{"ast":null,"code":"\"use strict\";\n\nvar _Reflect$construct = require(\"@babel/runtime-corejs2/core-js/reflect/construct\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/createClass\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/getPrototypeOf\"));\n\nvar _weakMap = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/weak-map\"));\n\nvar _events = require(\"events\");\n\nvar _readableStream = require(\"readable-stream\");\n\nvar _commonTimers = require(\"@webex/common-timers\");\n\nvar _constants = require(\"../constants\");\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2.default)(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;\n      result = _Reflect$construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0, _possibleConstructorReturn2.default)(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false;\n  if (_Reflect$construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar pcsByRTCRtpDirection = new _weakMap.default();\nvar emittersByRTCRtpDirection = new _weakMap.default();\nvar RTCRtpDirectionByEmitter = new _weakMap.default();\nvar emittersByStream = new _weakMap.default();\nvar timersByEmitter = new _weakMap.default();\n/**\n * Helper function that ensures no matter how many stats streams we create, we\n * don't poll the PeerConnection more than once per interval.\n * @param {EventEmitter} emitter\n * @param {Number} interval\n * @private\n * @returns {undefined}\n */\n\nvar schedule = function schedule(emitter, interval) {\n  var timer = (0, _commonTimers.safeSetTimeout)(function () {\n    var direction = RTCRtpDirectionByEmitter.get(emitter);\n    var pc = pcsByRTCRtpDirection.get(direction);\n\n    if (direction) {\n      direction.getStats().then(function (stats) {\n        emitter.emit(_constants.STATS.DATA, stats); // TODO: Remove on 1.0 spec adoption\n        // \"closed\" is supposed to be part of the {@link RTCPeerConnectionState}\n        // enum according to spec, but at time of writing, was still implemented\n        // in the {@link RTCSignalingState} enum.\n\n        if (!(pc.signalingState === _constants.STATS.CLOSED || pc.connectionState === _constants.STATS.CLOSED)) {\n          schedule(emitter, interval);\n        }\n      }).catch(function (err) {\n        emitter.emit(_constants.ERROR, err);\n      });\n    }\n  }, interval);\n  timersByEmitter.set(emitter, timer);\n};\n/**\n * Polls an {@link RTCPeerConnection} once per second and emits its {@link RTCStatsReport}\n * {@link RTCStatsReport}\n */\n\n\nvar StatsStream = /*#__PURE__*/function (_Readable) {\n  (0, _inherits2.default)(StatsStream, _Readable);\n\n  var _super = _createSuper(StatsStream);\n  /**\n   * @private\n   * @param {Object} config\n   * @param {RTCRtpSender|RTCRtpReceiver} config.rTCRtpDirection\n   * @param {RTCPeerConnection} config.peerConnection\n   * @param {Number} config.interval\n   */\n\n\n  function StatsStream() {\n    var _this;\n\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    (0, _classCallCheck2.default)(this, StatsStream);\n    _this = _super.call(this, {\n      objectMode: true\n    });\n    _this.interval = config.interval;\n\n    if (!emittersByRTCRtpDirection.has(config.rTCRtpDirection)) {\n      emittersByRTCRtpDirection.set(config.rTCRtpDirection, new _events.EventEmitter());\n    }\n\n    var emitter = emittersByRTCRtpDirection.get(config.rTCRtpDirection);\n\n    if (!emittersByStream.has((0, _assertThisInitialized2.default)(_this))) {\n      emittersByStream.set((0, _assertThisInitialized2.default)(_this), emitter);\n    }\n\n    if (!RTCRtpDirectionByEmitter.has(emitter)) {\n      RTCRtpDirectionByEmitter.set(emitter, config.rTCRtpDirection);\n    }\n\n    if (!pcsByRTCRtpDirection.has(config.rTCRtpDirection)) {\n      pcsByRTCRtpDirection.set(config.rTCRtpDirection, config.peerConnection);\n    }\n\n    emitter.once(_constants.ERROR, function (err) {\n      _this.emit(_constants.ERROR, err);\n    });\n    return _this;\n  }\n  /**\n   * See NodeJS Docs\n   * @private\n   * @returns {undefined}\n   */\n\n\n  (0, _createClass2.default)(StatsStream, [{\n    key: \"_read\",\n    value: function _read() {\n      var _this2 = this;\n\n      var emitter = emittersByStream.get(this);\n      emitter.once(_constants.STATS.DATA, function (data) {\n        if (!_this2.isPaused()) {\n          _this2.push(data);\n        }\n      });\n\n      if (!timersByEmitter.has(emitter)) {\n        schedule(emitter, this.interval);\n      }\n    }\n  }]);\n  return StatsStream;\n}(_readableStream.Readable);\n\nexports.default = StatsStream;","map":{"version":3,"mappings":"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","names":["pcsByRTCRtpDirection","emittersByRTCRtpDirection","RTCRtpDirectionByEmitter","emittersByStream","timersByEmitter","schedule","emitter","interval","timer","direction","get","pc","getStats","then","stats","emit","STATS","DATA","signalingState","CLOSED","connectionState","catch","err","ERROR","set","StatsStream","config","_this","objectMode","has","rTCRtpDirection","EventEmitter","peerConnection","once","data","_this2","isPaused","push","Readable"],"sources":["stream.js"],"sourcesContent":["import {EventEmitter} from 'events';\n\nimport {Readable} from 'readable-stream';\nimport {safeSetTimeout} from '@webex/common-timers';\n\nimport {\n  ERROR,\n  STATS\n} from '../constants';\n\nconst pcsByRTCRtpDirection = new WeakMap();\nconst emittersByRTCRtpDirection = new WeakMap();\nconst RTCRtpDirectionByEmitter = new WeakMap();\nconst emittersByStream = new WeakMap();\nconst timersByEmitter = new WeakMap();\n\n/**\n * Helper function that ensures no matter how many stats streams we create, we\n * don't poll the PeerConnection more than once per interval.\n * @param {EventEmitter} emitter\n * @param {Number} interval\n * @private\n * @returns {undefined}\n */\nconst schedule = (emitter, interval) => {\n  const timer = safeSetTimeout(() => {\n    const direction = RTCRtpDirectionByEmitter.get(emitter);\n    const pc = pcsByRTCRtpDirection.get(direction);\n\n    if (direction) {\n      direction.getStats()\n        .then((stats) => {\n          emitter.emit(STATS.DATA, stats);\n          // TODO: Remove on 1.0 spec adoption\n          // \"closed\" is supposed to be part of the {@link RTCPeerConnectionState}\n          // enum according to spec, but at time of writing, was still implemented\n          // in the {@link RTCSignalingState} enum.\n          if (!(pc.signalingState === STATS.CLOSED || pc.connectionState === STATS.CLOSED)) {\n            schedule(emitter, interval);\n          }\n        })\n        .catch((err) => {\n          emitter.emit(ERROR, err);\n        });\n    }\n  }, interval);\n\n  timersByEmitter.set(emitter, timer);\n};\n\n/**\n * Polls an {@link RTCPeerConnection} once per second and emits its {@link RTCStatsReport}\n * {@link RTCStatsReport}\n */\nexport default class StatsStream extends Readable {\n  /**\n   * @private\n   * @param {Object} config\n   * @param {RTCRtpSender|RTCRtpReceiver} config.rTCRtpDirection\n   * @param {RTCPeerConnection} config.peerConnection\n   * @param {Number} config.interval\n   */\n  constructor(config = {}) {\n    super({objectMode: true});\n\n    this.interval = config.interval;\n\n    if (!emittersByRTCRtpDirection.has(config.rTCRtpDirection)) {\n      emittersByRTCRtpDirection.set(config.rTCRtpDirection, new EventEmitter());\n    }\n    const emitter = emittersByRTCRtpDirection.get(config.rTCRtpDirection);\n\n    if (!emittersByStream.has(this)) {\n      emittersByStream.set(this, emitter);\n    }\n    if (!RTCRtpDirectionByEmitter.has(emitter)) {\n      RTCRtpDirectionByEmitter.set(emitter, config.rTCRtpDirection);\n    }\n\n    if (!pcsByRTCRtpDirection.has(config.rTCRtpDirection)) {\n      pcsByRTCRtpDirection.set(config.rTCRtpDirection, config.peerConnection);\n    }\n\n    emitter.once(ERROR, (err) => {\n      this.emit(ERROR, err);\n    });\n  }\n\n  /**\n   * See NodeJS Docs\n   * @private\n   * @returns {undefined}\n   */\n  _read() {\n    const emitter = emittersByStream.get(this);\n\n    emitter.once(STATS.DATA, (data) => {\n      if (!this.isPaused()) {\n        this.push(data);\n      }\n    });\n\n    if (!timersByEmitter.has(emitter)) {\n      schedule(emitter, this.interval);\n    }\n  }\n}\n\n"]},"metadata":{},"sourceType":"script"}