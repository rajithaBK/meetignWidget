{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/createClass\"));\n\nvar _loggerProxy = _interopRequireDefault(require(\"../common/logs/logger-proxy\"));\n\nvar _parameter = _interopRequireDefault(require(\"../common/errors/parameter\"));\n\nvar _permission = _interopRequireDefault(require(\"../common/errors/permission\"));\n\nvar _media = _interopRequireDefault(require(\"../media\"));\n\nvar _util = _interopRequireDefault(require(\"../meeting/util\"));\n\nvar _constants = require(\"../constants\");\n/* Certain aspects of server interaction for video muting are not implemented as we currently don't support remote muting of video.\n   If we ever need to support it, search for REMOTE_MUTE_VIDEO_MISSING_IMPLEMENTATION string to find the places that need updating\n*/\n\n\nvar createMuteState = function createMuteState(type, meeting, mediaDirection) {\n  if (type === _constants.AUDIO && !mediaDirection.sendAudio) {\n    return null;\n  }\n\n  if (type === _constants.VIDEO && !mediaDirection.sendVideo) {\n    return null;\n  }\n\n  _loggerProxy.default.logger.info(\"Meeting:muteState#createMuteState --> \".concat(type, \": creating MuteState for meeting id \").concat(meeting === null || meeting === void 0 ? void 0 : meeting.id));\n\n  return new MuteState(type, meeting);\n};\n/* The purpose of this class is to manage the local and remote mute state and make sure that the server state always matches\n   the last requested state by the client.\n\n   More info about Locus muting API: https://sqbu-github.cisco.com/pages/WebExSquared/locus/guides/mute.html#\n*/\n\n\nvar MuteState = /*#__PURE__*/function () {\n  function MuteState(type, meeting) {\n    (0, _classCallCheck2.default)(this, MuteState);\n\n    if (type !== _constants.AUDIO && type !== _constants.VIDEO) {\n      throw new _parameter.default('Mute state is designed for handling audio or video only');\n    }\n\n    this.type = type;\n    this.state = {\n      client: {\n        localMute: false\n      },\n      server: {\n        localMute: false,\n        // initial values available only for audio (REMOTE_MUTE_VIDEO_MISSING_IMPLEMENTATION)\n        remoteMute: type === _constants.AUDIO ? meeting.remoteMuted : false,\n        unmuteAllowed: type === _constants.AUDIO ? meeting.unmuteAllowed : true\n      },\n      syncToServerInProgress: false\n    }; // these 2 hold the resolve, reject methods for the promise we returned to the client in last handleClientRequest() call\n\n    this.pendingPromiseResolve = null;\n    this.pendingPromiseReject = null;\n  }\n  /**\n   * Handles mute/unmute request from the client/user. Returns a promise that's resolved once the server update is completed or\n   * at the point that this request becomese superseded by another client request.\n   *\n   * The client doesn't have to wait for the returned promise to resolve before calling handleClientRequest() again. If\n   * handleClientRequest() is called again before the previous one resolved, the MuteState class will make sure that eventually\n   * the server state will match the last requested state from the client.\n   *\n   * @public\n   * @memberof MuteState\n   * @param {Object} [meeting] the meeting object\n   * @param {Boolean} [mute] true for muting, false for unmuting request\n   * @returns {Promise}\n   */\n\n\n  (0, _createClass2.default)(MuteState, [{\n    key: \"handleClientRequest\",\n    value: function handleClientRequest(meeting, mute) {\n      var _this = this;\n\n      _loggerProxy.default.logger.info(\"Meeting:muteState#handleClientRequest --> \".concat(this.type, \": user requesting new mute state: \").concat(mute));\n\n      if (!mute && !this.state.server.unmuteAllowed) {\n        return _promise.default.reject(new _permission.default('User is not allowed to unmute self (hard mute feature is being used)'));\n      } // we don't check if we're already in the same state, because even if we were, we would still have to apply the mute state locally,\n      // because the client may have changed the audio/vidoe tracks\n\n\n      this.state.client.localMute = mute;\n      this.applyClientStateLocally(meeting);\n      return new _promise.default(function (resolve, reject) {\n        if (_this.pendingPromiseResolve) {\n          // resolve the last promise we returned to the client as the client has issued a new request that has superseded the previous one\n          _this.pendingPromiseResolve();\n        }\n\n        _this.pendingPromiseResolve = resolve;\n        _this.pendingPromiseReject = reject;\n\n        _this.applyClientStateToServer(meeting);\n      });\n    }\n    /**\n     * Applies the current mute state to the local track (by enabling or disabling it accordingly)\n     *\n     * @public\n     * @param {Object} [meeting] the meeting object\n     * @memberof MuteState\n     * @returns {void}\n     */\n\n  }, {\n    key: \"applyClientStateLocally\",\n    value: function applyClientStateLocally(meeting) {\n      _media.default.setLocalTrack(!this.state.client.localMute, this.type === _constants.AUDIO ? meeting.mediaProperties.audioTrack : meeting.mediaProperties.videoTrack);\n    }\n    /**\n     * Updates the server local and remote mute values so that they match the current client desired state.\n     *\n     * @private\n     * @param {Object} [meeting] the meeting object\n     * @memberof MuteState\n     * @returns {void}\n     */\n\n  }, {\n    key: \"applyClientStateToServer\",\n    value: function applyClientStateToServer(meeting) {\n      var _this2 = this;\n\n      if (this.state.syncToServerInProgress) {\n        _loggerProxy.default.logger.info(\"Meeting:muteState#applyClientStateToServer --> \".concat(this.type, \": request to server in progress, we need to wait for it to complete\"));\n\n        return;\n      }\n\n      var localMuteRequiresSync = this.state.client.localMute !== this.state.server.localMute;\n      var remoteMuteRequiresSync = !this.state.client.localMute && this.state.server.remoteMute;\n\n      _loggerProxy.default.logger.info(\"Meeting:muteState#applyClientStateToServer --> \".concat(this.type, \": localMuteRequiresSync: \").concat(localMuteRequiresSync, \" (\").concat(this.state.client.localMute, \" ?= \").concat(this.state.server.localMute, \")\"));\n\n      _loggerProxy.default.logger.info(\"Meeting:muteState#applyClientStateToServer --> \".concat(this.type, \": remoteMuteRequiresSync: \").concat(remoteMuteRequiresSync));\n\n      if (!localMuteRequiresSync && !remoteMuteRequiresSync) {\n        _loggerProxy.default.logger.info(\"Meeting:muteState#applyClientStateToServer --> \".concat(this.type, \": client state already matching server state, nothing to do\"));\n\n        if (this.pendingPromiseResolve) {\n          this.pendingPromiseResolve();\n        }\n\n        this.pendingPromiseResolve = null;\n        this.pendingPromiseReject = null;\n        return;\n      }\n\n      this.state.syncToServerInProgress = true; // first sync local mute with server\n\n      var localMuteSyncPromise = localMuteRequiresSync ? this.sendLocalMuteRequestToServer(meeting) : _promise.default.resolve();\n      localMuteSyncPromise.then(function () {\n        return remoteMuteRequiresSync ? _this2.sendRemoteMuteRequestToServer(meeting) : _promise.default.resolve();\n      }).then(function () {\n        _this2.state.syncToServerInProgress = false;\n\n        _loggerProxy.default.logger.info(\"Meeting:muteState#applyClientStateToServer --> \".concat(_this2.type, \": sync with server completed\")); // need to check if a new sync is required, because this.state.client may have changed while we were doing the current sync\n\n\n        _this2.applyClientStateToServer(meeting);\n      }).catch(function (e) {\n        _this2.state.syncToServerInProgress = false;\n\n        if (_this2.pendingPromiseReject) {\n          _this2.pendingPromiseReject(e);\n        }\n\n        _this2.pendingPromiseResolve = null;\n        _this2.pendingPromiseReject = null;\n      });\n    }\n    /**\n     * Sets the local mute value in the server\n     *\n     * @private\n     * @param {Object} [meeting] the meeting object\n     * @memberof MuteState\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"sendLocalMuteRequestToServer\",\n    value: function sendLocalMuteRequestToServer(meeting) {\n      var _meeting$audio,\n          _meeting$video,\n          _this3 = this;\n\n      var audioMuted = this.type === _constants.AUDIO ? this.state.client.localMute : (_meeting$audio = meeting.audio) === null || _meeting$audio === void 0 ? void 0 : _meeting$audio.state.client.localMute;\n      var videoMuted = this.type === _constants.VIDEO ? this.state.client.localMute : (_meeting$video = meeting.video) === null || _meeting$video === void 0 ? void 0 : _meeting$video.state.client.localMute;\n\n      _loggerProxy.default.logger.info(\"Meeting:muteState#sendLocalMuteRequestToServer --> \".concat(this.type, \": sending local mute (audio=\").concat(audioMuted, \", video=\").concat(videoMuted, \") to server\"));\n\n      return _util.default.remoteUpdateAudioVideo(audioMuted, videoMuted, meeting).then(function (locus) {\n        _loggerProxy.default.logger.info(\"Meeting:muteState#sendLocalMuteRequestToServer --> \".concat(_this3.type, \": local mute (audio=\").concat(audioMuted, \", video=\").concat(videoMuted, \") applied to server\"));\n\n        _this3.state.server.localMute = _this3.type === _constants.AUDIO ? audioMuted : videoMuted;\n        meeting.locusInfo.onFullLocus(locus);\n        return locus;\n      }).catch(function (remoteUpdateError) {\n        _loggerProxy.default.logger.warn(\"Meeting:muteState#sendLocalMuteRequestToServer --> \".concat(_this3.type, \": failed to apply local mute (audio=\").concat(audioMuted, \", video=\").concat(videoMuted, \") to server: \").concat(remoteUpdateError));\n\n        return _promise.default.reject(remoteUpdateError);\n      });\n    }\n    /**\n     * Sets the remote mute value in the server\n     *\n     * @private\n     * @param {Object} [meeting] the meeting object\n     * @memberof MuteState\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"sendRemoteMuteRequestToServer\",\n    value: function sendRemoteMuteRequestToServer(meeting) {\n      var _this4 = this;\n\n      if (this.type === _constants.AUDIO) {\n        var remoteMute = this.state.client.localMute;\n\n        _loggerProxy.default.logger.info(\"Meeting:muteState#sendRemoteMuteRequestToServer --> \".concat(this.type, \": sending remote mute:\").concat(remoteMute, \" to server\"));\n\n        return meeting.members.muteMember(meeting.members.selfId, remoteMute).then(function () {\n          _loggerProxy.default.logger.info(\"Meeting:muteState#sendRemoteMuteRequestToServer --> \".concat(_this4.type, \": remote mute:\").concat(remoteMute, \" applied to server\"));\n\n          _this4.state.server.remoteMute = remoteMute;\n        }).catch(function (remoteUpdateError) {\n          _loggerProxy.default.logger.warn(\"Meeting:muteState#sendRemoteMuteRequestToServer --> \".concat(_this4.type, \": failed to apply remote mute \").concat(remoteMute, \" to server: \").concat(remoteUpdateError));\n\n          return _promise.default.reject(remoteUpdateError);\n        });\n      } // for now we don't need to support remote muting of video (REMOTE_MUTE_VIDEO_MISSING_IMPLEMENTATION)\n\n\n      this.state.server.remoteMute = this.state.client.localMute;\n      return _promise.default.resolve();\n    }\n    /**\n     * This method should be called whenever the server remote mute state is changed\n     *\n     * @public\n     * @memberof MuteState\n     * @param {Boolean} [muted] true if user is remotely muted, false otherwise\n     * @param {Boolean} [unmuteAllowed] indicates if user is allowed to unmute self (false when \"hard mute\" feature is used)\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"handleServerRemoteMuteUpdate\",\n    value: function handleServerRemoteMuteUpdate(muted, unmuteAllowed) {\n      _loggerProxy.default.logger.info(\"Meeting:muteState#handleServerRemoteMuteUpdate --> \".concat(this.type, \": updating server remoteMute to (\").concat(muted, \")\"));\n\n      this.state.server.remoteMute = muted;\n      this.state.server.unmuteAllowed = unmuteAllowed;\n    }\n    /**\n     * This method should be called whenever we receive from the server a requirement to locally unmute\n     *\n     * @public\n     * @memberof MuteState\n     * @param {Object} [meeting] the meeting object\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"handleServerLocalUnmuteRequired\",\n    value: function handleServerLocalUnmuteRequired(meeting) {\n      _loggerProxy.default.logger.info(\"Meeting:muteState#handleServerLocalUnmuteRequired --> \".concat(this.type, \": localAudioUnmuteRequired received -> doing local unmute\"));\n\n      this.state.server.remoteMute = false;\n      this.state.client.localMute = false;\n\n      if (this.pendingPromiseReject) {\n        this.pendingPromiseReject(new Error('Server requested local unmute - this overrides any client request in progress'));\n        this.pendingPromiseResolve = null;\n        this.pendingPromiseReject = null;\n      }\n\n      this.applyClientStateLocally(meeting);\n      this.applyClientStateToServer(meeting);\n    }\n    /**\n     * Returns true if the user is locally or remotely muted\n     *\n     * @public\n     * @memberof MuteState\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isMuted\",\n    value: function isMuted() {\n      return this.state.client.localMute || this.state.server.localMute || this.state.server.remoteMute;\n    }\n    /**\n     * Returns true if the user is muted as a result of the client request (and not remotely muted)\n     *\n     * @public\n     * @memberof MuteState\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isSelf\",\n    value: function isSelf() {\n      return this.state.client.localMute && !this.state.server.remoteMute;\n    } // defined for backwards compatibility with the old AudioStateMachine/VideoStateMachine classes\n\n  }, {\n    key: \"muted\",\n    get: function get() {\n      return this.isMuted();\n    } // defined for backwards compatibility with the old AudioStateMachine/VideoStateMachine classes\n\n  }, {\n    key: \"self\",\n    get: function get() {\n      return this.isSelf();\n    }\n  }]);\n  return MuteState;\n}();\n\nvar _default = createMuteState;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["createMuteState","type","meeting","mediaDirection","AUDIO","sendAudio","VIDEO","sendVideo","LoggerProxy","logger","info","id","MuteState","ParameterError","state","client","localMute","server","remoteMute","remoteMuted","unmuteAllowed","syncToServerInProgress","pendingPromiseResolve","pendingPromiseReject","mute","_promise","reject","PermissionError","applyClientStateLocally","resolve","_this","applyClientStateToServer","Media","setLocalTrack","mediaProperties","audioTrack","videoTrack","localMuteRequiresSync","remoteMuteRequiresSync","localMuteSyncPromise","sendLocalMuteRequestToServer","then","_this2","sendRemoteMuteRequestToServer","catch","e","audioMuted","audio","_meeting$audio","videoMuted","video","_meeting$video","MeetingUtil","remoteUpdateAudioVideo","locus","_this3","locusInfo","onFullLocus","remoteUpdateError","warn","members","muteMember","selfId","_this4","muted","Error","isMuted","isSelf"],"sources":["muteState.js"],"sourcesContent":["\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport ParameterError from '../common/errors/parameter';\nimport PermissionError from '../common/errors/permission';\nimport Media from '../media';\nimport MeetingUtil from '../meeting/util';\nimport {AUDIO, VIDEO} from '../constants';\n\n\n/* Certain aspects of server interaction for video muting are not implemented as we currently don't support remote muting of video.\n   If we ever need to support it, search for REMOTE_MUTE_VIDEO_MISSING_IMPLEMENTATION string to find the places that need updating\n*/\n\nconst createMuteState = (type, meeting, mediaDirection) => {\n  if (type === AUDIO && !mediaDirection.sendAudio) {\n    return null;\n  }\n  if (type === VIDEO && !mediaDirection.sendVideo) {\n    return null;\n  }\n\n  LoggerProxy.logger.info(`Meeting:muteState#createMuteState --> ${type}: creating MuteState for meeting id ${meeting?.id}`);\n\n  return new MuteState(type, meeting);\n};\n\n/* The purpose of this class is to manage the local and remote mute state and make sure that the server state always matches\n   the last requested state by the client.\n\n   More info about Locus muting API: https://sqbu-github.cisco.com/pages/WebExSquared/locus/guides/mute.html#\n*/\nclass MuteState {\n  constructor(type, meeting) {\n    if ((type !== AUDIO) && (type !== VIDEO)) {\n      throw new ParameterError('Mute state is designed for handling audio or video only');\n    }\n    this.type = type;\n    this.state = {\n      client: {\n        localMute: false\n      },\n      server: {\n        localMute: false,\n        // initial values available only for audio (REMOTE_MUTE_VIDEO_MISSING_IMPLEMENTATION)\n        remoteMute: type === AUDIO ? meeting.remoteMuted : false,\n        unmuteAllowed: type === AUDIO ? meeting.unmuteAllowed : true\n      },\n      syncToServerInProgress: false\n    };\n    // these 2 hold the resolve, reject methods for the promise we returned to the client in last handleClientRequest() call\n    this.pendingPromiseResolve = null;\n    this.pendingPromiseReject = null;\n  }\n\n  /**\n   * Handles mute/unmute request from the client/user. Returns a promise that's resolved once the server update is completed or\n   * at the point that this request becomese superseded by another client request.\n   *\n   * The client doesn't have to wait for the returned promise to resolve before calling handleClientRequest() again. If\n   * handleClientRequest() is called again before the previous one resolved, the MuteState class will make sure that eventually\n   * the server state will match the last requested state from the client.\n   *\n   * @public\n   * @memberof MuteState\n   * @param {Object} [meeting] the meeting object\n   * @param {Boolean} [mute] true for muting, false for unmuting request\n   * @returns {Promise}\n   */\n  handleClientRequest(meeting, mute) {\n    LoggerProxy.logger.info(`Meeting:muteState#handleClientRequest --> ${this.type}: user requesting new mute state: ${mute}`);\n\n    if (!mute && !this.state.server.unmuteAllowed) {\n      return Promise.reject(new PermissionError('User is not allowed to unmute self (hard mute feature is being used)'));\n    }\n\n    // we don't check if we're already in the same state, because even if we were, we would still have to apply the mute state locally,\n    // because the client may have changed the audio/vidoe tracks\n    this.state.client.localMute = mute;\n    this.applyClientStateLocally(meeting);\n\n    return new Promise((resolve, reject) => {\n      if (this.pendingPromiseResolve) {\n        // resolve the last promise we returned to the client as the client has issued a new request that has superseded the previous one\n        this.pendingPromiseResolve();\n      }\n      this.pendingPromiseResolve = resolve;\n      this.pendingPromiseReject = reject;\n      this.applyClientStateToServer(meeting);\n    });\n  }\n\n  /**\n   * Applies the current mute state to the local track (by enabling or disabling it accordingly)\n   *\n   * @public\n   * @param {Object} [meeting] the meeting object\n   * @memberof MuteState\n   * @returns {void}\n   */\n  applyClientStateLocally(meeting) {\n    Media.setLocalTrack(\n      !this.state.client.localMute,\n      (this.type === AUDIO) ? meeting.mediaProperties.audioTrack : meeting.mediaProperties.videoTrack\n    );\n  }\n\n  /**\n   * Updates the server local and remote mute values so that they match the current client desired state.\n   *\n   * @private\n   * @param {Object} [meeting] the meeting object\n   * @memberof MuteState\n   * @returns {void}\n   */\n  applyClientStateToServer(meeting) {\n    if (this.state.syncToServerInProgress) {\n      LoggerProxy.logger.info(`Meeting:muteState#applyClientStateToServer --> ${this.type}: request to server in progress, we need to wait for it to complete`);\n\n      return;\n    }\n\n    const localMuteRequiresSync = (this.state.client.localMute !== this.state.server.localMute);\n    const remoteMuteRequiresSync = (!this.state.client.localMute && this.state.server.remoteMute);\n\n    LoggerProxy.logger.info(`Meeting:muteState#applyClientStateToServer --> ${this.type}: localMuteRequiresSync: ${localMuteRequiresSync} (${this.state.client.localMute} ?= ${this.state.server.localMute})`);\n    LoggerProxy.logger.info(`Meeting:muteState#applyClientStateToServer --> ${this.type}: remoteMuteRequiresSync: ${remoteMuteRequiresSync}`);\n\n    if (!localMuteRequiresSync && !remoteMuteRequiresSync) {\n      LoggerProxy.logger.info(`Meeting:muteState#applyClientStateToServer --> ${this.type}: client state already matching server state, nothing to do`);\n\n      if (this.pendingPromiseResolve) {\n        this.pendingPromiseResolve();\n      }\n      this.pendingPromiseResolve = null;\n      this.pendingPromiseReject = null;\n\n      return;\n    }\n\n    this.state.syncToServerInProgress = true;\n\n    // first sync local mute with server\n    const localMuteSyncPromise = (localMuteRequiresSync) ? this.sendLocalMuteRequestToServer(meeting) : Promise.resolve();\n\n    localMuteSyncPromise\n      .then(() =>\n        // then follow it up with remote mute sync\n        ((remoteMuteRequiresSync) ? this.sendRemoteMuteRequestToServer(meeting) : Promise.resolve()))\n      .then(() => {\n        this.state.syncToServerInProgress = false;\n        LoggerProxy.logger.info(`Meeting:muteState#applyClientStateToServer --> ${this.type}: sync with server completed`);\n\n        // need to check if a new sync is required, because this.state.client may have changed while we were doing the current sync\n        this.applyClientStateToServer(meeting);\n      })\n      .catch((e) => {\n        this.state.syncToServerInProgress = false;\n\n        if (this.pendingPromiseReject) {\n          this.pendingPromiseReject(e);\n        }\n        this.pendingPromiseResolve = null;\n        this.pendingPromiseReject = null;\n      });\n  }\n\n  /**\n   * Sets the local mute value in the server\n   *\n   * @private\n   * @param {Object} [meeting] the meeting object\n   * @memberof MuteState\n   * @returns {Promise}\n   */\n  sendLocalMuteRequestToServer(meeting) {\n    const audioMuted = (this.type === AUDIO) ? this.state.client.localMute : meeting.audio?.state.client.localMute;\n    const videoMuted = (this.type === VIDEO) ? this.state.client.localMute : meeting.video?.state.client.localMute;\n\n    LoggerProxy.logger.info(`Meeting:muteState#sendLocalMuteRequestToServer --> ${this.type}: sending local mute (audio=${audioMuted}, video=${videoMuted}) to server`);\n\n    return MeetingUtil.remoteUpdateAudioVideo(audioMuted, videoMuted, meeting)\n      .then((locus) => {\n        LoggerProxy.logger.info(\n          `Meeting:muteState#sendLocalMuteRequestToServer --> ${this.type}: local mute (audio=${audioMuted}, video=${videoMuted}) applied to server`\n        );\n\n        this.state.server.localMute = (this.type === AUDIO) ? audioMuted : videoMuted;\n\n        meeting.locusInfo.onFullLocus(locus);\n\n        return locus;\n      })\n      .catch((remoteUpdateError) => {\n        LoggerProxy.logger.warn(\n          `Meeting:muteState#sendLocalMuteRequestToServer --> ${this.type}: failed to apply local mute (audio=${audioMuted}, video=${videoMuted}) to server: ${remoteUpdateError}`\n        );\n\n        return Promise.reject(remoteUpdateError);\n      });\n  }\n\n\n  /**\n   * Sets the remote mute value in the server\n   *\n   * @private\n   * @param {Object} [meeting] the meeting object\n   * @memberof MuteState\n   * @returns {Promise}\n   */\n  sendRemoteMuteRequestToServer(meeting) {\n    if (this.type === AUDIO) {\n      const remoteMute = this.state.client.localMute;\n\n      LoggerProxy.logger.info(`Meeting:muteState#sendRemoteMuteRequestToServer --> ${this.type}: sending remote mute:${remoteMute} to server`);\n\n      return meeting.members.muteMember(meeting.members.selfId, remoteMute)\n        .then(() => {\n          LoggerProxy.logger.info(\n            `Meeting:muteState#sendRemoteMuteRequestToServer --> ${this.type}: remote mute:${remoteMute} applied to server`\n          );\n\n          this.state.server.remoteMute = remoteMute;\n        })\n        .catch((remoteUpdateError) => {\n          LoggerProxy.logger.warn(\n            `Meeting:muteState#sendRemoteMuteRequestToServer --> ${this.type}: failed to apply remote mute ${remoteMute} to server: ${remoteUpdateError}`\n          );\n\n          return Promise.reject(remoteUpdateError);\n        });\n    }\n\n    // for now we don't need to support remote muting of video (REMOTE_MUTE_VIDEO_MISSING_IMPLEMENTATION)\n    this.state.server.remoteMute = this.state.client.localMute;\n\n    return Promise.resolve();\n  }\n\n  /**\n   * This method should be called whenever the server remote mute state is changed\n   *\n   * @public\n   * @memberof MuteState\n   * @param {Boolean} [muted] true if user is remotely muted, false otherwise\n   * @param {Boolean} [unmuteAllowed] indicates if user is allowed to unmute self (false when \"hard mute\" feature is used)\n   * @returns {undefined}\n   */\n  handleServerRemoteMuteUpdate(muted, unmuteAllowed) {\n    LoggerProxy.logger.info(`Meeting:muteState#handleServerRemoteMuteUpdate --> ${this.type}: updating server remoteMute to (${muted})`);\n    this.state.server.remoteMute = muted;\n    this.state.server.unmuteAllowed = unmuteAllowed;\n  }\n\n  /**\n   * This method should be called whenever we receive from the server a requirement to locally unmute\n   *\n   * @public\n   * @memberof MuteState\n   * @param {Object} [meeting] the meeting object\n   * @returns {undefined}\n   */\n  handleServerLocalUnmuteRequired(meeting) {\n    LoggerProxy.logger.info(`Meeting:muteState#handleServerLocalUnmuteRequired --> ${this.type}: localAudioUnmuteRequired received -> doing local unmute`);\n\n    this.state.server.remoteMute = false;\n    this.state.client.localMute = false;\n\n    if (this.pendingPromiseReject) {\n      this.pendingPromiseReject(new Error('Server requested local unmute - this overrides any client request in progress'));\n      this.pendingPromiseResolve = null;\n      this.pendingPromiseReject = null;\n    }\n\n    this.applyClientStateLocally(meeting);\n    this.applyClientStateToServer(meeting);\n  }\n\n  /**\n   * Returns true if the user is locally or remotely muted\n   *\n   * @public\n   * @memberof MuteState\n   * @returns {Boolean}\n   */\n  isMuted() {\n    return this.state.client.localMute || this.state.server.localMute || this.state.server.remoteMute;\n  }\n\n  /**\n   * Returns true if the user is muted as a result of the client request (and not remotely muted)\n   *\n   * @public\n   * @memberof MuteState\n   * @returns {Boolean}\n   */\n  isSelf() {\n    return this.state.client.localMute && !this.state.server.remoteMute;\n  }\n\n  // defined for backwards compatibility with the old AudioStateMachine/VideoStateMachine classes\n  get muted() {\n    return this.isMuted();\n  }\n\n  // defined for backwards compatibility with the old AudioStateMachine/VideoStateMachine classes\n  get self() {\n    return this.isSelf();\n  }\n}\n\nexport default createMuteState;\n"]},"metadata":{},"sourceType":"script"}