{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _isFinite2 = _interopRequireDefault(require(\"lodash/isFinite\"));\n\nvar _keys2 = _interopRequireDefault(require(\"lodash/keys\"));\n\nvar _constants = require(\"../constants\");\n\nvar StatsCalculator = {};\n/**\n * Calculate an interval of values between 2 data points, using updated as the \"latest\" so updated - previous = interval\n * @param {WebRTCData} previous\n * @param {WebRTCData} updated\n * @returns {Object} interval: {StringKey: IntervalValue, ..., n}\n * @public\n */\n\nStatsCalculator.difference = function (previous, updated) {\n  // if there was no previous, just take the updated\n  if (!previous || !previous.data || !previous.data.getData || (0, _keys2.default)(previous.data.getData()).length === 0) {\n    return updated;\n  }\n\n  var interval = {}; // get inside the data from the filtered report\n\n  (0, _keys2.default)(updated.data.getData()).forEach(function (key) {\n    interval[key] = interval[key] ? interval[key] : {};\n    (0, _keys2.default)(updated.data.getData()[key]).forEach(function (stat) {\n      var value = updated.data.getData()[key][stat]; // only use some simple data points that are numbers and aren't silly things like timestamp\n\n      if ((0, _isFinite2.default)(value) && !(_constants.DEFAULT_EXCLUDED_STATS.includes(stat) && value !== 0)) {\n        // if there was nothing there before, just return the updated data\n        if (!previous.data.getData()[key] || !previous.data.getData()[key][stat]) {\n          interval[key][stat] = value;\n        } // subract and store\n        else {\n          value -= previous.data.getData()[key][stat];\n          interval[key][stat] = value;\n        }\n      }\n    });\n  });\n  return interval;\n};\n/**\n * Calculate an aggregate of values between an old summary and a new data point, using summary as the base to add to so aggregate = summary + data\n * @param {WebRTCData} data\n * @param {Object} summary\n * @returns {Object} aggregate {StringKey: SummedValue, ..., n}\n * @public\n */\n\n\nStatsCalculator.sum = function (data, summary) {\n  var aggregate = summary; // get inside the data from the filtered report\n\n  (0, _keys2.default)(data.data.getData()).forEach(function (key) {\n    (0, _keys2.default)(data.data.getData()[key]).forEach(function (stat) {\n      var value = data.data.getData()[key][stat]; // only use some simple data points that are numbers and aren't silly things like timestamp\n\n      if ((0, _isFinite2.default)(value) && !(_constants.DEFAULT_EXCLUDED_STATS.includes(stat) && value !== 0)) {\n        // if there was something there before, add to that value\n        if (aggregate[key][stat]) {\n          aggregate[key][stat] += value;\n        } // set up the value as the new data point\n        else {\n          aggregate[key][stat] = value;\n        }\n      }\n    });\n  });\n  return aggregate;\n};\n\nvar _default = StatsCalculator;\nexports.default = _default;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;AAEA;;AAEA,IAAMA,eAAe,GAAG,EAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,eAAe,CAACC,UAAhBD,GAA6B,UAACE,QAAD,EAAWC,OAAX,EAAuB;AAClD;AACA,MAAI,CAACD,QAAD,IAAa,CAACA,QAAQ,CAACE,IAAvB,IAA+B,CAACF,QAAQ,CAACE,IAATF,CAAcG,OAA9C,IAAyD,oBAAKH,QAAQ,CAACE,IAATF,CAAcG,OAAdH,EAAL,EAA8BI,MAA9B,KAAyC,CAAtG,EAAyG;AACvG,WAAOH,OAAP;AACD;;AACD,MAAMI,QAAQ,GAAG,EAAjB,CALkD,CAOlD;;AACA,sBAAKJ,OAAO,CAACC,IAARD,CAAaE,OAAbF,EAAL,EAA6BK,OAA7B,CAAqC,UAACC,GAAD,EAAS;AAC5CF,YAAQ,CAACE,GAAD,CAARF,GAAgBA,QAAQ,CAACE,GAAD,CAARF,GAAgBA,QAAQ,CAACE,GAAD,CAAxBF,GAAgC,EAAhDA;AACA,wBAAKJ,OAAO,CAACC,IAARD,CAAaE,OAAbF,GAAuBM,GAAvBN,CAAL,EAAkCK,OAAlC,CAA0C,UAACE,IAAD,EAAU;AAClD,UAAIC,KAAK,GAAGR,OAAO,CAACC,IAARD,CAAaE,OAAbF,GAAuBM,GAAvBN,EAA4BO,IAA5BP,CAAZ,CADkD,CAGlD;;AACA,UAAI,wBAASQ,KAAT,KAAmB,EAAEC,kCAAuBC,QAAvBD,CAAgCF,IAAhCE,KAAyCD,KAAK,KAAK,CAArD,CAAvB,EAAgF;AAC9E;AACA,YAAI,CAACT,QAAQ,CAACE,IAATF,CAAcG,OAAdH,GAAwBO,GAAxBP,CAAD,IAAiC,CAACA,QAAQ,CAACE,IAATF,CAAcG,OAAdH,GAAwBO,GAAxBP,EAA6BQ,IAA7BR,CAAtC,EAA0E;AACxEK,kBAAQ,CAACE,GAAD,CAARF,CAAcG,IAAdH,IAAsBI,KAAtBJ;AADF,UAGA;AAHA,aAIK;AACHI,eAAK,IAAIT,QAAQ,CAACE,IAATF,CAAcG,OAAdH,GAAwBO,GAAxBP,EAA6BQ,IAA7BR,CAATS;AACAJ,kBAAQ,CAACE,GAAD,CAARF,CAAcG,IAAdH,IAAsBI,KAAtBJ;AACD;AACF;AAdH;AAFF;AAoBA,SAAOA,QAAP;AA5BF;AA+BA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAP,eAAe,CAACc,GAAhBd,GAAsB,UAACI,IAAD,EAAOW,OAAP,EAAmB;AACvC,MAAMC,SAAS,GAAGD,OAAlB,CADuC,CAGvC;;AACA,sBAAKX,IAAI,CAACA,IAALA,CAAUC,OAAVD,EAAL,EAA0BI,OAA1B,CAAkC,UAACC,GAAD,EAAS;AACzC,wBAAKL,IAAI,CAACA,IAALA,CAAUC,OAAVD,GAAoBK,GAApBL,CAAL,EAA+BI,OAA/B,CAAuC,UAACE,IAAD,EAAU;AAC/C,UAAMC,KAAK,GAAGP,IAAI,CAACA,IAALA,CAAUC,OAAVD,GAAoBK,GAApBL,EAAyBM,IAAzBN,CAAd,CAD+C,CAG/C;;AACA,UAAI,wBAASO,KAAT,KAAmB,EAAEC,kCAAuBC,QAAvBD,CAAgCF,IAAhCE,KAAyCD,KAAK,KAAK,CAArD,CAAvB,EAAgF;AAC9E;AACA,YAAIK,SAAS,CAACP,GAAD,CAATO,CAAeN,IAAfM,CAAJ,EAA0B;AACxBA,mBAAS,CAACP,GAAD,CAATO,CAAeN,IAAfM,KAAwBL,KAAxBK;AADF,UAGA;AAHA,aAIK;AACHA,mBAAS,CAACP,GAAD,CAATO,CAAeN,IAAfM,IAAuBL,KAAvBK;AACD;AACF;AAbH;AADF;AAkBA,SAAOA,SAAP;AAtBF;;eAyBehB","names":["StatsCalculator","difference","previous","updated","data","getData","length","interval","forEach","key","stat","value","DEFAULT_EXCLUDED_STATS","includes","sum","summary","aggregate"],"sources":["calculator.js"],"sourcesContent":["import {keys, isFinite} from 'lodash';\n\nimport {DEFAULT_EXCLUDED_STATS} from '../constants';\n\nconst StatsCalculator = {};\n\n/**\n * Calculate an interval of values between 2 data points, using updated as the \"latest\" so updated - previous = interval\n * @param {WebRTCData} previous\n * @param {WebRTCData} updated\n * @returns {Object} interval: {StringKey: IntervalValue, ..., n}\n * @public\n */\nStatsCalculator.difference = (previous, updated) => {\n  // if there was no previous, just take the updated\n  if (!previous || !previous.data || !previous.data.getData || keys(previous.data.getData()).length === 0) {\n    return updated;\n  }\n  const interval = {};\n\n  // get inside the data from the filtered report\n  keys(updated.data.getData()).forEach((key) => {\n    interval[key] = interval[key] ? interval[key] : {};\n    keys(updated.data.getData()[key]).forEach((stat) => {\n      let value = updated.data.getData()[key][stat];\n\n      // only use some simple data points that are numbers and aren't silly things like timestamp\n      if (isFinite(value) && !(DEFAULT_EXCLUDED_STATS.includes(stat) && value !== 0)) {\n        // if there was nothing there before, just return the updated data\n        if (!previous.data.getData()[key] || !previous.data.getData()[key][stat]) {\n          interval[key][stat] = value;\n        }\n        // subract and store\n        else {\n          value -= previous.data.getData()[key][stat];\n          interval[key][stat] = value;\n        }\n      }\n    });\n  });\n\n  return interval;\n};\n\n/**\n * Calculate an aggregate of values between an old summary and a new data point, using summary as the base to add to so aggregate = summary + data\n * @param {WebRTCData} data\n * @param {Object} summary\n * @returns {Object} aggregate {StringKey: SummedValue, ..., n}\n * @public\n */\nStatsCalculator.sum = (data, summary) => {\n  const aggregate = summary;\n\n  // get inside the data from the filtered report\n  keys(data.data.getData()).forEach((key) => {\n    keys(data.data.getData()[key]).forEach((stat) => {\n      const value = data.data.getData()[key][stat];\n\n      // only use some simple data points that are numbers and aren't silly things like timestamp\n      if (isFinite(value) && !(DEFAULT_EXCLUDED_STATS.includes(stat) && value !== 0)) {\n        // if there was something there before, add to that value\n        if (aggregate[key][stat]) {\n          aggregate[key][stat] += value;\n        }\n        // set up the value as the new data point\n        else {\n          aggregate[key][stat] = value;\n        }\n      }\n    });\n  });\n\n  return aggregate;\n};\n\nexport default StatsCalculator;\n"]},"metadata":{},"sourceType":"script"}