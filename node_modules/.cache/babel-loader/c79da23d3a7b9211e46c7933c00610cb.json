{"ast":null,"code":"\"use strict\";\n\nvar _Reflect$construct = require(\"@babel/runtime-corejs2/core-js/reflect/construct\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/createClass\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/getPrototypeOf\"));\n\nvar _weakMap = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/weak-map\"));\n\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/map\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _httpCore = require(\"@webex/http-core\");\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2.default)(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;\n      result = _Reflect$construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0, _possibleConstructorReturn2.default)(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false;\n  if (_Reflect$construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n} // contains the system time in milliseconds at which the retry after associated with a 429 expires\n// mapped by the API name, e.g.: idbroker.webex.com/doStuff would be mapped as 'doStuff'\n\n\nvar rateLimitExpiryTime = new _weakMap.default(); // extracts the common identity API being called\n\nvar idBrokerRegex = /.*(idbroker|identity)(bts)?.ciscospark.com\\/([^/]+)/;\n/**\n * @class\n */\n\nvar RateLimitInterceptor = /*#__PURE__*/function (_Interceptor) {\n  (0, _inherits2.default)(RateLimitInterceptor, _Interceptor);\n\n  var _super = _createSuper(RateLimitInterceptor);\n  /**\n  * constructor\n  * @param {mixed} args\n  * @returns {Exception}\n  */\n\n\n  function RateLimitInterceptor() {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, RateLimitInterceptor);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    rateLimitExpiryTime.set((0, _assertThisInitialized2.default)(_this), new _map.default());\n    return _this;\n  }\n  /**\n   * @see {@link Interceptor#onRequest}\n   * @param {Object} options\n   * @returns {Object}\n   */\n\n\n  (0, _createClass2.default)(RateLimitInterceptor, [{\n    key: \"onRequest\",\n    value: function onRequest(options) {\n      if (this.isRateLimited(options.uri)) {\n        return _promise.default.reject(new Error(\"API rate limited \".concat(options.uri)));\n      }\n\n      return _promise.default.resolve(options);\n    }\n    /**\n     * @see {@link Interceptor#onResponseError}\n     * @param {Object} options\n     * @param {Error} reason\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"onResponseError\",\n    value: function onResponseError(options, reason) {\n      if (reason.statusCode === 429 && (options.uri.includes('idbroker') || options.uri.includes('identity'))) {\n        // set the retry after in the map, setting to milliseconds\n        this.setRateLimitExpiry(options.uri, this.extractRetryAfterTime(options));\n      }\n\n      return _promise.default.reject(reason);\n    }\n    /**\n     * @param {object} options associated with the request\n     * @returns {number} retry after time in milliseconds\n     */\n\n  }, {\n    key: \"extractRetryAfterTime\",\n    value: function extractRetryAfterTime(options) {\n      // 1S * 1K === 1MS\n      var milliMultiplier = 1000;\n      var retryAfter = options.headers['retry-after'] || null; // set 60 retry if no usable time defined\n\n      if (retryAfter === null || retryAfter <= 0) {\n        return 60 * milliMultiplier;\n      } // set max to 3600 S (1 hour) if greater than 1 hour\n\n\n      if (retryAfter > 3600) {\n        return 3600 * milliMultiplier;\n      }\n\n      return retryAfter * milliMultiplier;\n    }\n    /**\n     * Set the system time at which the rate limiting\n     * will expire in the rateLimitExpiryTime map.\n     * Assumes retryAfter is in milliseconds\n     * @param {string} uri API issuing the rate limiting\n     * @param {number} retryAfter milliseconds until rate limiting expires\n     * @returns {bool} true is value was successfully set\n     */\n\n  }, {\n    key: \"setRateLimitExpiry\",\n    value: function setRateLimitExpiry(uri, retryAfter) {\n      var apiName = this.getApiName(uri);\n\n      if (!apiName) {\n        return false;\n      }\n\n      var currTimeMilli = new Date().getTime();\n      var expiry = currTimeMilli + retryAfter;\n      var dict = rateLimitExpiryTime.get(this);\n      return dict.set(apiName, expiry);\n    }\n    /**\n     * returns true if the API is currently rate limited\n     * @param {string} uri\n     * @returns {Boolean} indicates whether or not the API is rate currently rate limited\n     */\n\n  }, {\n    key: \"getRateLimitStatus\",\n    value: function getRateLimitStatus(uri) {\n      var apiName = this.getApiName(uri);\n\n      if (!apiName) {\n        return false;\n      }\n\n      var currTimeMilli = new Date().getTime();\n      var dict = rateLimitExpiryTime.get(this);\n      var expiryTime = dict.get(apiName); // if no rate limit expiry has been registered in the map, return false.\n\n      if (expiryTime === undefined) {\n        return false;\n      } // return true, indicating rate limiting, if the system time is less than the expiry time\n\n\n      return currTimeMilli < dict.get(apiName);\n    }\n    /**\n     * split the URI and returns the API name of idBroker\n     * @param {string} uri\n     * @returns {string}\n     */\n\n  }, {\n    key: \"getApiName\",\n    value: function getApiName(uri) {\n      if (!uri) {\n        return null;\n      }\n\n      var results = uri.match(idBrokerRegex);\n\n      if (!results) {\n        return null;\n      } // group 0 = full match of URL, group 1 = identity or idbroker base\n      // group 2 = api name\n\n\n      return results[2];\n    }\n    /**\n     * check URI against list of currently rate limited\n     * URIs, and determines if retry-after\n     * @param {String} uri pattern to check\n     * @returns {bool}\n     */\n\n  }, {\n    key: \"isRateLimited\",\n    value: function isRateLimited(uri) {\n      // determine if the URI is associated with a common identity API\n      if (uri && (uri.includes('idbroker') || uri.includes('identity'))) {\n        return this.getRateLimitStatus(uri);\n      }\n\n      return false;\n    }\n  }], [{\n    key: \"create\",\n    value:\n    /**\n     * @returns {RateLimitInterceptor}\n     */\n    function create() {\n      return new RateLimitInterceptor({\n        webex: this\n      });\n    }\n  }]);\n  return RateLimitInterceptor;\n}(_httpCore.Interceptor);\n\nexports.default = RateLimitInterceptor;","map":{"version":3,"mappings":"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","names":["rateLimitExpiryTime","idBrokerRegex","RateLimitInterceptor","args","arguments","_this","set","options","isRateLimited","uri","_promise","reject","Error","resolve","reason","statusCode","includes","setRateLimitExpiry","extractRetryAfterTime","milliMultiplier","retryAfter","headers","apiName","getApiName","currTimeMilli","Date","getTime","expiry","dict","get","expiryTime","undefined","results","match","getRateLimitStatus","webex","Interceptor"],"sources":["rate-limit.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {Interceptor} from '@webex/http-core';\n\n// contains the system time in milliseconds at which the retry after associated with a 429 expires\n// mapped by the API name, e.g.: idbroker.webex.com/doStuff would be mapped as 'doStuff'\nconst rateLimitExpiryTime = new WeakMap();\n\n// extracts the common identity API being called\nconst idBrokerRegex = /.*(idbroker|identity)(bts)?.ciscospark.com\\/([^/]+)/;\n\n/**\n * @class\n */\nexport default class RateLimitInterceptor extends Interceptor {\n  /**\n   * @returns {RateLimitInterceptor}\n   */\n  static create() {\n    return new RateLimitInterceptor({webex: this});\n  }\n\n  /**\n  * constructor\n  * @param {mixed} args\n  * @returns {Exception}\n  */\n  constructor(...args) {\n    super(...args);\n    rateLimitExpiryTime.set(this, new Map());\n  }\n\n  /**\n   * @see {@link Interceptor#onRequest}\n   * @param {Object} options\n   * @returns {Object}\n   */\n  onRequest(options) {\n    if (this.isRateLimited(options.uri)) {\n      return Promise.reject(new Error(`API rate limited ${options.uri}`));\n    }\n\n    return Promise.resolve(options);\n  }\n\n  /**\n   * @see {@link Interceptor#onResponseError}\n   * @param {Object} options\n   * @param {Error} reason\n   * @returns {Object}\n   */\n  onResponseError(options, reason) {\n    if (reason.statusCode === 429 && (options.uri.includes('idbroker') || options.uri.includes('identity'))) {\n      // set the retry after in the map, setting to milliseconds\n      this.setRateLimitExpiry(options.uri, this.extractRetryAfterTime(options));\n    }\n\n    return Promise.reject(reason);\n  }\n\n  /**\n   * @param {object} options associated with the request\n   * @returns {number} retry after time in milliseconds\n   */\n  extractRetryAfterTime(options) {\n    // 1S * 1K === 1MS\n    const milliMultiplier = 1000;\n    const retryAfter = options.headers['retry-after'] || null;\n\n    // set 60 retry if no usable time defined\n    if (retryAfter === null || retryAfter <= 0) {\n      return 60 * milliMultiplier;\n    }\n    // set max to 3600 S (1 hour) if greater than 1 hour\n    if (retryAfter > 3600) {\n      return 3600 * milliMultiplier;\n    }\n\n    return retryAfter * milliMultiplier;\n  }\n\n  /**\n   * Set the system time at which the rate limiting\n   * will expire in the rateLimitExpiryTime map.\n   * Assumes retryAfter is in milliseconds\n   * @param {string} uri API issuing the rate limiting\n   * @param {number} retryAfter milliseconds until rate limiting expires\n   * @returns {bool} true is value was successfully set\n   */\n  setRateLimitExpiry(uri, retryAfter) {\n    const apiName = this.getApiName(uri);\n\n    if (!apiName) {\n      return false;\n    }\n\n    const currTimeMilli = new Date().getTime();\n    const expiry = currTimeMilli + retryAfter;\n    const dict = rateLimitExpiryTime.get(this);\n\n    return dict.set(apiName, expiry);\n  }\n\n  /**\n   * returns true if the API is currently rate limited\n   * @param {string} uri\n   * @returns {Boolean} indicates whether or not the API is rate currently rate limited\n   */\n  getRateLimitStatus(uri) {\n    const apiName = this.getApiName(uri);\n\n    if (!apiName) {\n      return false;\n    }\n\n    const currTimeMilli = new Date().getTime();\n    const dict = rateLimitExpiryTime.get(this);\n    const expiryTime = dict.get(apiName);\n\n    // if no rate limit expiry has been registered in the map, return false.\n    if (expiryTime === undefined) {\n      return false;\n    }\n\n    // return true, indicating rate limiting, if the system time is less than the expiry time\n    return currTimeMilli < dict.get(apiName);\n  }\n\n  /**\n   * split the URI and returns the API name of idBroker\n   * @param {string} uri\n   * @returns {string}\n   */\n  getApiName(uri) {\n    if (!uri) {\n      return null;\n    }\n\n    const results = uri.match(idBrokerRegex);\n\n    if (!results) {\n      return null;\n    }\n\n    // group 0 = full match of URL, group 1 = identity or idbroker base\n    // group 2 = api name\n    return results[2];\n  }\n\n  /**\n   * check URI against list of currently rate limited\n   * URIs, and determines if retry-after\n   * @param {String} uri pattern to check\n   * @returns {bool}\n   */\n  isRateLimited(uri) {\n    // determine if the URI is associated with a common identity API\n    if (uri && (uri.includes('idbroker') || uri.includes('identity'))) {\n      return this.getRateLimitStatus(uri);\n    }\n\n    return false;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}