{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StreamReader = exports.EndOfStreamError = void 0;\n\nconst EndOfFileStream_1 = require(\"./EndOfFileStream\");\n\nconst Deferred_1 = require(\"./Deferred\");\n\nvar EndOfFileStream_2 = require(\"./EndOfFileStream\");\n\nObject.defineProperty(exports, \"EndOfStreamError\", {\n  enumerable: true,\n  get: function () {\n    return EndOfFileStream_2.EndOfStreamError;\n  }\n});\nconst maxStreamReadSize = 1 * 1024 * 1024; // Maximum request length on read-stream operation\n\nclass StreamReader {\n  constructor(s) {\n    this.s = s;\n    /**\r\n     * Deferred used for postponed read request (as not data is yet available to read)\r\n     */\n\n    this.deferred = null;\n    this.endOfStream = false;\n    /**\r\n     * Store peeked data\r\n     * @type {Array}\r\n     */\n\n    this.peekQueue = [];\n\n    if (!s.read || !s.once) {\n      throw new Error('Expected an instance of stream.Readable');\n    }\n\n    this.s.once('end', () => this.reject(new EndOfFileStream_1.EndOfStreamError()));\n    this.s.once('error', err => this.reject(err));\n    this.s.once('close', () => this.reject(new Error('Stream closed')));\n  }\n  /**\r\n   * Read ahead (peek) from stream. Subsequent read or peeks will return the same data\r\n   * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in\r\n   * @param offset - Offset target\r\n   * @param length - Number of bytes to read\r\n   * @returns Number of bytes peeked\r\n   */\n\n\n  async peek(uint8Array, offset, length) {\n    const bytesRead = await this.read(uint8Array, offset, length);\n    this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead)); // Put read data back to peek buffer\n\n    return bytesRead;\n  }\n  /**\r\n   * Read chunk from stream\r\n   * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in\r\n   * @param offset - Offset target\r\n   * @param length - Number of bytes to read\r\n   * @returns Number of bytes read\r\n   */\n\n\n  async read(buffer, offset, length) {\n    if (length === 0) {\n      return 0;\n    }\n\n    if (this.peekQueue.length === 0 && this.endOfStream) {\n      throw new EndOfFileStream_1.EndOfStreamError();\n    }\n\n    let remaining = length;\n    let bytesRead = 0; // consume peeked data first\n\n    while (this.peekQueue.length > 0 && remaining > 0) {\n      const peekData = this.peekQueue.pop(); // Front of queue\n\n      if (!peekData) throw new Error('peekData should be defined');\n      const lenCopy = Math.min(peekData.length, remaining);\n      buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);\n      bytesRead += lenCopy;\n      remaining -= lenCopy;\n\n      if (lenCopy < peekData.length) {\n        // remainder back to queue\n        this.peekQueue.push(peekData.subarray(lenCopy));\n      }\n    } // continue reading from stream if required\n\n\n    while (remaining > 0 && !this.endOfStream) {\n      const reqLen = Math.min(remaining, maxStreamReadSize);\n      const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);\n      bytesRead += chunkLen;\n      if (chunkLen < reqLen) break;\n      remaining -= chunkLen;\n    }\n\n    return bytesRead;\n  }\n  /**\r\n   * Read chunk from stream\r\n   * @param buffer Target Uint8Array (or Buffer) to store data read from stream in\r\n   * @param offset Offset target\r\n   * @param length Number of bytes to read\r\n   * @returns Number of bytes read\r\n   */\n\n\n  async readFromStream(buffer, offset, length) {\n    const readBuffer = this.s.read(length);\n\n    if (readBuffer) {\n      buffer.set(readBuffer, offset);\n      return readBuffer.length;\n    } else {\n      const request = {\n        buffer,\n        offset,\n        length,\n        deferred: new Deferred_1.Deferred()\n      };\n      this.deferred = request.deferred;\n      this.s.once('readable', () => {\n        this.readDeferred(request);\n      });\n      return request.deferred.promise;\n    }\n  }\n  /**\r\n   * Process deferred read request\r\n   * @param request Deferred read request\r\n   */\n\n\n  readDeferred(request) {\n    const readBuffer = this.s.read(request.length);\n\n    if (readBuffer) {\n      request.buffer.set(readBuffer, request.offset);\n      request.deferred.resolve(readBuffer.length);\n      this.deferred = null;\n    } else {\n      this.s.once('readable', () => {\n        this.readDeferred(request);\n      });\n    }\n  }\n\n  reject(err) {\n    this.endOfStream = true;\n\n    if (this.deferred) {\n      this.deferred.reject(err);\n      this.deferred = null;\n    }\n  }\n\n}\n\nexports.StreamReader = StreamReader;","map":{"version":3,"sources":["C:/Users/rkanthet/Documents/test_window_object/node_modules/peek-readable/lib/StreamReader.js"],"names":["Object","defineProperty","exports","value","StreamReader","EndOfStreamError","EndOfFileStream_1","require","Deferred_1","EndOfFileStream_2","enumerable","get","maxStreamReadSize","constructor","s","deferred","endOfStream","peekQueue","read","once","Error","reject","err","peek","uint8Array","offset","length","bytesRead","push","subarray","buffer","remaining","peekData","pop","lenCopy","Math","min","set","reqLen","chunkLen","readFromStream","readBuffer","request","Deferred","readDeferred","promise","resolve"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.StreamReader = exports.EndOfStreamError = void 0;\r\nconst EndOfFileStream_1 = require(\"./EndOfFileStream\");\r\nconst Deferred_1 = require(\"./Deferred\");\r\nvar EndOfFileStream_2 = require(\"./EndOfFileStream\");\r\nObject.defineProperty(exports, \"EndOfStreamError\", { enumerable: true, get: function () { return EndOfFileStream_2.EndOfStreamError; } });\r\nconst maxStreamReadSize = 1 * 1024 * 1024; // Maximum request length on read-stream operation\r\nclass StreamReader {\r\n    constructor(s) {\r\n        this.s = s;\r\n        /**\r\n         * Deferred used for postponed read request (as not data is yet available to read)\r\n         */\r\n        this.deferred = null;\r\n        this.endOfStream = false;\r\n        /**\r\n         * Store peeked data\r\n         * @type {Array}\r\n         */\r\n        this.peekQueue = [];\r\n        if (!s.read || !s.once) {\r\n            throw new Error('Expected an instance of stream.Readable');\r\n        }\r\n        this.s.once('end', () => this.reject(new EndOfFileStream_1.EndOfStreamError()));\r\n        this.s.once('error', err => this.reject(err));\r\n        this.s.once('close', () => this.reject(new Error('Stream closed')));\r\n    }\r\n    /**\r\n     * Read ahead (peek) from stream. Subsequent read or peeks will return the same data\r\n     * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in\r\n     * @param offset - Offset target\r\n     * @param length - Number of bytes to read\r\n     * @returns Number of bytes peeked\r\n     */\r\n    async peek(uint8Array, offset, length) {\r\n        const bytesRead = await this.read(uint8Array, offset, length);\r\n        this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead)); // Put read data back to peek buffer\r\n        return bytesRead;\r\n    }\r\n    /**\r\n     * Read chunk from stream\r\n     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in\r\n     * @param offset - Offset target\r\n     * @param length - Number of bytes to read\r\n     * @returns Number of bytes read\r\n     */\r\n    async read(buffer, offset, length) {\r\n        if (length === 0) {\r\n            return 0;\r\n        }\r\n        if (this.peekQueue.length === 0 && this.endOfStream) {\r\n            throw new EndOfFileStream_1.EndOfStreamError();\r\n        }\r\n        let remaining = length;\r\n        let bytesRead = 0;\r\n        // consume peeked data first\r\n        while (this.peekQueue.length > 0 && remaining > 0) {\r\n            const peekData = this.peekQueue.pop(); // Front of queue\r\n            if (!peekData)\r\n                throw new Error('peekData should be defined');\r\n            const lenCopy = Math.min(peekData.length, remaining);\r\n            buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);\r\n            bytesRead += lenCopy;\r\n            remaining -= lenCopy;\r\n            if (lenCopy < peekData.length) {\r\n                // remainder back to queue\r\n                this.peekQueue.push(peekData.subarray(lenCopy));\r\n            }\r\n        }\r\n        // continue reading from stream if required\r\n        while (remaining > 0 && !this.endOfStream) {\r\n            const reqLen = Math.min(remaining, maxStreamReadSize);\r\n            const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);\r\n            bytesRead += chunkLen;\r\n            if (chunkLen < reqLen)\r\n                break;\r\n            remaining -= chunkLen;\r\n        }\r\n        return bytesRead;\r\n    }\r\n    /**\r\n     * Read chunk from stream\r\n     * @param buffer Target Uint8Array (or Buffer) to store data read from stream in\r\n     * @param offset Offset target\r\n     * @param length Number of bytes to read\r\n     * @returns Number of bytes read\r\n     */\r\n    async readFromStream(buffer, offset, length) {\r\n        const readBuffer = this.s.read(length);\r\n        if (readBuffer) {\r\n            buffer.set(readBuffer, offset);\r\n            return readBuffer.length;\r\n        }\r\n        else {\r\n            const request = {\r\n                buffer,\r\n                offset,\r\n                length,\r\n                deferred: new Deferred_1.Deferred()\r\n            };\r\n            this.deferred = request.deferred;\r\n            this.s.once('readable', () => {\r\n                this.readDeferred(request);\r\n            });\r\n            return request.deferred.promise;\r\n        }\r\n    }\r\n    /**\r\n     * Process deferred read request\r\n     * @param request Deferred read request\r\n     */\r\n    readDeferred(request) {\r\n        const readBuffer = this.s.read(request.length);\r\n        if (readBuffer) {\r\n            request.buffer.set(readBuffer, request.offset);\r\n            request.deferred.resolve(readBuffer.length);\r\n            this.deferred = null;\r\n        }\r\n        else {\r\n            this.s.once('readable', () => {\r\n                this.readDeferred(request);\r\n            });\r\n        }\r\n    }\r\n    reject(err) {\r\n        this.endOfStream = true;\r\n        if (this.deferred) {\r\n            this.deferred.reject(err);\r\n            this.deferred = null;\r\n        }\r\n    }\r\n}\r\nexports.StreamReader = StreamReader;\r\n"]},"metadata":{},"sourceType":"script"}