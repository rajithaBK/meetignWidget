{"ast":null,"code":"\"use strict\";\n\nvar _Reflect$construct = require(\"@babel/runtime-corejs2/core-js/reflect/construct\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _weakMap = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/weak-map\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/keys\"));\n\nvar _defineProperty = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/reflect/define-property\"));\n\nvar _parseInt2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/parse-int\"));\n\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/json/stringify\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/createClass\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/getPrototypeOf\"));\n\nvar _isObject2 = _interopRequireDefault(require(\"lodash/isObject\"));\n\nvar _has2 = _interopRequireDefault(require(\"lodash/has\"));\n\nvar _defaults2 = _interopRequireDefault(require(\"lodash/defaults\"));\n\nvar _events = require(\"events\");\n\nvar _common = require(\"@webex/common\");\n\nvar _commonTimers = require(\"@webex/common-timers\");\n\nvar _uuid = _interopRequireDefault(require(\"uuid\"));\n\nvar _errors = require(\"../errors\");\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2.default)(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;\n      result = _Reflect$construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0, _possibleConstructorReturn2.default)(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false;\n  if (_Reflect$construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar sockets = new _weakMap.default();\n/**\n * Generalized socket abstraction\n */\n\nvar Socket = /*#__PURE__*/function (_EventEmitter) {\n  (0, _inherits2.default)(Socket, _EventEmitter);\n\n  var _super = _createSuper(Socket);\n  /**\n   * constructor\n   * @returns {Socket}\n   */\n\n\n  function Socket() {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, Socket);\n    _this = _super.call(this);\n    _this.onmessage = _this.onmessage.bind((0, _assertThisInitialized2.default)(_this));\n    _this.onclose = _this.onclose.bind((0, _assertThisInitialized2.default)(_this));\n    return _this;\n  }\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n   * @returns {string}\n   */\n\n\n  (0, _createClass2.default)(Socket, [{\n    key: \"binaryType\",\n    get: function get() {\n      return sockets.get(this).binaryType;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n     * @returns {number}\n     */\n\n  }, {\n    key: \"bufferedAmount\",\n    get: function get() {\n      return sockets.get(this).bufferedAmount;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n     * @returns {string}\n     */\n\n  }, {\n    key: \"extensions\",\n    get: function get() {\n      return sockets.get(this).extensions;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n     * @returns {string}\n     */\n\n  }, {\n    key: \"protocol\",\n    get: function get() {\n      return sockets.get(this).protocol;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n     * @returns {number}\n     */\n\n  }, {\n    key: \"readyState\",\n    get: function get() {\n      return sockets.get(this).readyState;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n     * @returns {string}\n     */\n\n  }, {\n    key: \"url\",\n    get: function get() {\n      return sockets.get(this).url;\n    }\n    /**\n     * Provides the environmentally appropriate constructor (ws in NodeJS,\n     * WebSocket in browsers)\n     * @returns {WebSocket}\n     */\n\n  }, {\n    key: \"close\",\n    value:\n    /**\n     * Closes the socket\n     * @param {Object} options\n     * @param {string} options.reason\n     * @param {number} options.code\n     * @returns {Promise}\n     */\n    function close(options) {\n      var _this2 = this;\n\n      return new _promise.default(function (resolve, reject) {\n        var socket = sockets.get(_this2);\n\n        if (!socket) {\n          // Open has not been called yet so there is no socket to close\n          resolve();\n          return;\n        } // logger is defined once open is called\n\n\n        _this2.logger.info('socket: closing');\n\n        if (socket.readyState === 2 || socket.readyState === 3) {\n          _this2.logger.info('socket: already closed');\n\n          resolve();\n          return;\n        }\n\n        options = options || {};\n\n        if (options.code && options.code !== 1000 && (options.code < 3000 || options.code > 4999)) {\n          reject(new Error('`options.code` must be 1000 or between 3000 and 4999 (inclusive)'));\n          return;\n        }\n\n        options = (0, _defaults2.default)(options, {\n          code: 1000,\n          reason: 'Done'\n        });\n        var closeTimer = (0, _commonTimers.safeSetTimeout)(function () {\n          try {\n            _this2.logger.info('socket: no close event received, forcing closure');\n\n            resolve(_this2.onclose({\n              code: 1000,\n              reason: 'Done (forced)'\n            }));\n          } catch (error) {\n            _this2.logger.warn('socket: force-close failed', error);\n          }\n        }, _this2.forceCloseDelay);\n\n        socket.onclose = function (event) {\n          _this2.logger.info('socket: close event fired', event.code, event.reason);\n\n          clearTimeout(closeTimer);\n\n          _this2.onclose(event);\n\n          resolve(event);\n        };\n\n        socket.close(options.code, options.reason);\n      });\n    }\n    /**\n     * Opens a WebSocket\n     * @param {string} url\n     * @param {options} options\n     * @param {number} options.forceCloseDelay (required)\n     * @param {number} options.pingInterval (required)\n     * @param {number} options.pongTimeout (required)\n     * @param {string} options.token (required)\n     * @param {string} options.trackingId (required)\n     * @param {Logger} options.logger (required)\n     * @param {string} options.logLevelToken\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"open\",\n    value: function open(url, options) {\n      var _this3 = this;\n\n      return new _promise.default(function (resolve, reject) {\n        /* eslint complexity: [0] */\n        if (!url) {\n          reject(new Error('`url` is required'));\n          return;\n        }\n\n        if (sockets.get(_this3)) {\n          reject(new Error('Socket#open() can only be called once per instance'));\n          return;\n        }\n\n        options = options || {};\n        (0, _common.checkRequired)(['forceCloseDelay', 'pingInterval', 'pongTimeout', 'token', 'trackingId', 'logger'], options);\n        (0, _keys.default)(options).forEach(function (key) {\n          (0, _defineProperty.default)(_this3, key, {\n            enumerable: false,\n            value: options[key]\n          });\n        });\n        var WebSocket = Socket.getWebSocketConstructor();\n\n        _this3.logger.info('socket: creating WebSocket');\n\n        var socket = new WebSocket(url, [], options);\n        socket.binaryType = 'arraybuffer';\n        socket.onmessage = _this3.onmessage;\n\n        socket.onclose = function (event) {\n          event = _this3._fixCloseCode(event);\n\n          _this3.logger.info('socket: closed before open', event.code, event.reason);\n\n          switch (event.code) {\n            case 1005:\n              // IE 11 doesn't seem to allow 4XXX codes, so if we get a 1005, assume\n              // it's a bad websocket url. That'll trigger a device refresh; if it\n              // turns out we had a bad token, the device refresh should 401 and\n              // trigger a token refresh.\n              return reject(new _errors.UnknownResponse(event));\n\n            case 4400:\n              return reject(new _errors.BadRequest(event));\n\n            case 4401:\n              return reject(new _errors.NotAuthorized(event));\n\n            case 4403:\n              return reject(new _errors.Forbidden(event));\n            // case 4404:\n            //   return reject(new NotFound(event));\n\n            default:\n              return reject(new _errors.ConnectionError(event));\n          }\n        };\n\n        socket.onopen = function () {\n          _this3.logger.info('socket: connected');\n\n          _this3._authorize().then(function () {\n            _this3.logger.info('socket: authorized');\n\n            socket.onclose = _this3.onclose;\n            resolve();\n          }).catch(reject);\n        };\n\n        socket.onerror = function (event) {\n          _this3.logger.warn('socket: error event fired', event);\n        };\n\n        sockets.set(_this3, socket);\n\n        _this3.logger.info('socket: waiting for server');\n      });\n    }\n    /**\n     * Handles incoming CloseEvents\n     * @param {CloseEvent} event\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"onclose\",\n    value: function onclose(event) {\n      this.logger.info('socket: closed', event.code, event.reason);\n      clearTimeout(this.pongTimer);\n      clearTimeout(this.pingTimer);\n      event = this._fixCloseCode(event);\n      this.emit('close', event); // Remove all listeners to (a) avoid reacting to late pongs and (b) ensure\n      // we don't have a retain cycle.\n\n      this.removeAllListeners();\n    }\n    /**\n     * Handles incoming message events\n     * @param {MessageEvent} event\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"onmessage\",\n    value: function onmessage(event) {\n      try {\n        var data = JSON.parse(event.data);\n        var sequenceNumber = (0, _parseInt2.default)(data.sequenceNumber, 10);\n        this.logger.debug('socket: sequence number: ', sequenceNumber);\n\n        if (this.expectedSequenceNumber && sequenceNumber !== this.expectedSequenceNumber) {\n          this.logger.debug(\"socket: sequence number mismatch indicates lost mercury message. expected: \".concat(this.expectedSequenceNumber, \", actual: \").concat(sequenceNumber));\n          this.emit('sequence-mismatch', sequenceNumber, this.expectedSequenceNumber);\n        }\n\n        this.expectedSequenceNumber = sequenceNumber + 1; // Yes, it's a little weird looking; we want to emit message events that\n        // look like normal socket message events, but event.data cannot be\n        // modified and we don't actually care about anything but the data property\n\n        var processedEvent = {\n          data: data\n        };\n\n        this._acknowledge(processedEvent);\n\n        if (data.type === 'pong') {\n          this.emit('pong', processedEvent);\n        } else {\n          this.emit('message', processedEvent);\n        }\n      } catch (error) {\n        // The above code should only be able to throw if we receive an unparsable\n        // message from Mercury. At this time, the only action we have is to\n        // ignore it and move on.\n\n        /* istanbul ignore next */\n        this.logger.warn('socket: error while receiving WebSocket message', error);\n      }\n    }\n    /**\n     * Sends a message up the socket\n     * @param {mixed} data\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(data) {\n      var _this4 = this;\n\n      return new _promise.default(function (resolve, reject) {\n        if (_this4.readyState !== 1) {\n          return reject(new Error('INVALID_STATE_ERROR'));\n        }\n\n        if ((0, _isObject2.default)(data)) {\n          data = (0, _stringify.default)(data);\n        }\n\n        var socket = sockets.get(_this4);\n        socket.send(data);\n        return resolve();\n      });\n    }\n    /**\n     * Sends an acknowledgment for a specific event\n     * @param {MessageEvent} event\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"_acknowledge\",\n    value: function _acknowledge(event) {\n      if (!event) {\n        return _promise.default.reject(new Error('`event` is required'));\n      }\n\n      if (!(0, _has2.default)(event, 'data.id')) {\n        return _promise.default.reject(new Error('`event.data.id` is required'));\n      }\n\n      return this.send({\n        messageId: event.data.id,\n        type: 'ack'\n      });\n    }\n    /**\n     * Sends an auth message up the socket\n     * @private\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"_authorize\",\n    value: function _authorize() {\n      var _this5 = this;\n\n      return new _promise.default(function (resolve) {\n        _this5.logger.info('socket: authorizing');\n\n        _this5.send({\n          id: _uuid.default.v4(),\n          type: 'authorization',\n          data: {\n            token: _this5.token\n          },\n          trackingId: _this5.trackingId,\n          logLevelToken: _this5.logLevelToken\n        });\n\n        var waitForBufferState = function waitForBufferState(event) {\n          if (!event.data.type && (event.data.data.eventType === 'mercury.buffer_state' || event.data.data.eventType === 'mercury.registration_status')) {\n            _this5.removeListener('message', waitForBufferState);\n\n            _this5._ping();\n\n            resolve();\n          }\n        };\n\n        _this5.once('message', waitForBufferState);\n      });\n    }\n    /**\n     * Deals with the fact that some browsers drop some close codes (but not\n     * close reasons).\n     * @param {CloseEvent} event\n     * @private\n     * @returns {CloseEvent}\n     */\n\n  }, {\n    key: \"_fixCloseCode\",\n    value: function _fixCloseCode(event) {\n      if (event.code === 1005 && event.reason) {\n        switch (event.reason.toLowerCase()) {\n          case 'replaced':\n            this.logger.info('socket: fixing CloseEvent code for reason: ', event.reason);\n            event.code = 4000;\n            break;\n\n          case 'authentication failed':\n          case 'authentication did not happen within the timeout window of 30000 seconds.':\n            this.logger.info('socket: fixing CloseEvent code for reason: ', event.reason);\n            event.code = 1008;\n            break;\n\n          default: // do nothing\n\n        }\n      }\n\n      return event;\n    }\n    /**\n     * Sends a ping up the socket and confirms we get it back\n     * @param {[type]} id\n     * @private\n     * @returns {[type]}\n     */\n\n  }, {\n    key: \"_ping\",\n    value: function _ping(id) {\n      var _this6 = this;\n\n      var confirmPongId = function confirmPongId(event) {\n        try {\n          _this6.logger.debug('socket: pong', event.data.id);\n\n          if (event.data && event.data.id !== id) {\n            _this6.logger.info('socket: received pong for wrong ping id, closing socket');\n\n            _this6.logger.debug('socket: expected', id, 'received', event.data.id);\n\n            _this6.close({\n              code: 1000,\n              reason: 'Pong mismatch'\n            });\n          }\n        } catch (error) {\n          // This try/catch block was added as a debugging step; to the best of my\n          // knowledge, the above can never throw.\n\n          /* istanbul ignore next */\n          _this6.logger.error('socket: error occurred in confirmPongId', error);\n        }\n      };\n\n      var onPongNotReceived = function onPongNotReceived() {\n        try {\n          _this6.logger.info('socket: pong not receive in expected period, closing socket');\n\n          _this6.close({\n            code: 1000,\n            reason: 'Pong not received'\n          }).catch(function (reason) {\n            _this6.logger.warn('socket: failed to close socket after missed pong', reason);\n          });\n        } catch (error) {\n          // This try/catch block was added as a debugging step; to the best of my\n          // knowledge, the above can never throw.\n\n          /* istanbul ignore next */\n          _this6.logger.error('socket: error occurred in onPongNotReceived', error);\n        }\n      };\n\n      var scheduleNextPingAndCancelPongTimer = function scheduleNextPingAndCancelPongTimer() {\n        try {\n          clearTimeout(_this6.pongTimer);\n          _this6.pingTimer = (0, _commonTimers.safeSetTimeout)(function () {\n            return _this6._ping();\n          }, _this6.pingInterval);\n        } catch (error) {\n          // This try/catch block was added as a debugging step; to the best of my\n          // knowledge, the above can never throw.\n\n          /* istanbul ignore next */\n          _this6.logger.error('socket: error occurred in scheduleNextPingAndCancelPongTimer', error);\n        }\n      };\n\n      id = id || _uuid.default.v4();\n      this.pongTimer = (0, _commonTimers.safeSetTimeout)(onPongNotReceived, this.pongTimeout);\n      this.once('pong', scheduleNextPingAndCancelPongTimer);\n      this.once('pong', confirmPongId);\n      this.logger.debug(\"socket: ping \".concat(id));\n      return this.send({\n        id: id,\n        type: 'ping'\n      });\n    }\n  }], [{\n    key: \"getWebSocketConstructor\",\n    value: function getWebSocketConstructor() {\n      throw new Error('Socket.getWebSocketConstructor() must be implemented in an environmentally appropriate way');\n    }\n  }]);\n  return Socket;\n}(_events.EventEmitter);\n\nexports.default = Socket;","map":{"version":3,"mappings":"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","names":["sockets","Socket","_this","onmessage","bind","onclose","get","binaryType","bufferedAmount","extensions","protocol","readyState","url","options","resolve","reject","socket","_this2","logger","info","code","Error","reason","closeTimer","error","warn","forceCloseDelay","event","clearTimeout","close","_this3","forEach","key","enumerable","value","WebSocket","getWebSocketConstructor","_fixCloseCode","UnknownResponse","BadRequest","NotAuthorized","Forbidden","ConnectionError","onopen","_authorize","then","catch","onerror","set","pongTimer","pingTimer","emit","removeAllListeners","data","JSON","parse","sequenceNumber","debug","expectedSequenceNumber","processedEvent","_acknowledge","type","_this4","send","_promise","messageId","id","_this5","uuid","v4","token","trackingId","logLevelToken","waitForBufferState","eventType","removeListener","_ping","once","toLowerCase","confirmPongId","_this6","onPongNotReceived","scheduleNextPingAndCancelPongTimer","pingInterval","pongTimeout","EventEmitter"],"sources":["socket-base.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {EventEmitter} from 'events';\n\nimport {checkRequired} from '@webex/common';\nimport {safeSetTimeout} from '@webex/common-timers';\nimport {defaults, has, isObject} from 'lodash';\nimport uuid from 'uuid';\n\nimport {\n  BadRequest,\n  ConnectionError,\n  Forbidden,\n  NotAuthorized,\n  UnknownResponse\n  // NotFound\n} from '../errors';\n\nconst sockets = new WeakMap();\n\n/**\n * Generalized socket abstraction\n */\nexport default class Socket extends EventEmitter {\n  /**\n   * constructor\n   * @returns {Socket}\n   */\n  constructor() {\n    super();\n    this.onmessage = this.onmessage.bind(this);\n    this.onclose = this.onclose.bind(this);\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n   * @returns {string}\n   */\n  get binaryType() {\n    return sockets.get(this).binaryType;\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n   * @returns {number}\n   */\n  get bufferedAmount() {\n    return sockets.get(this).bufferedAmount;\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n   * @returns {string}\n   */\n  get extensions() {\n    return sockets.get(this).extensions;\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n   * @returns {string}\n   */\n  get protocol() {\n    return sockets.get(this).protocol;\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n   * @returns {number}\n   */\n  get readyState() {\n    return sockets.get(this).readyState;\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n   * @returns {string}\n   */\n  get url() {\n    return sockets.get(this).url;\n  }\n\n  /**\n   * Provides the environmentally appropriate constructor (ws in NodeJS,\n   * WebSocket in browsers)\n   * @returns {WebSocket}\n   */\n  static getWebSocketConstructor() {\n    throw new Error('Socket.getWebSocketConstructor() must be implemented in an environmentally appropriate way');\n  }\n\n  /**\n   * Closes the socket\n   * @param {Object} options\n   * @param {string} options.reason\n   * @param {number} options.code\n   * @returns {Promise}\n   */\n  close(options) {\n    return new Promise((resolve, reject) => {\n      const socket = sockets.get(this);\n\n      if (!socket) {\n        // Open has not been called yet so there is no socket to close\n        resolve();\n\n        return;\n      }\n      // logger is defined once open is called\n      this.logger.info('socket: closing');\n\n      if (socket.readyState === 2 || socket.readyState === 3) {\n        this.logger.info('socket: already closed');\n        resolve();\n\n        return;\n      }\n\n      options = options || {};\n      if (options.code && options.code !== 1000 && (options.code < 3000 || options.code > 4999)) {\n        reject(new Error('`options.code` must be 1000 or between 3000 and 4999 (inclusive)'));\n\n        return;\n      }\n\n      options = defaults(options, {\n        code: 1000,\n        reason: 'Done'\n      });\n\n      const closeTimer = safeSetTimeout(() => {\n        try {\n          this.logger.info('socket: no close event received, forcing closure');\n          resolve(this.onclose({\n            code: 1000,\n            reason: 'Done (forced)'\n          }));\n        }\n        catch (error) {\n          this.logger.warn('socket: force-close failed', error);\n        }\n      }, this.forceCloseDelay);\n\n      socket.onclose = (event) => {\n        this.logger.info('socket: close event fired', event.code, event.reason);\n        clearTimeout(closeTimer);\n        this.onclose(event);\n        resolve(event);\n      };\n\n      socket.close(options.code, options.reason);\n    });\n  }\n\n  /**\n   * Opens a WebSocket\n   * @param {string} url\n   * @param {options} options\n   * @param {number} options.forceCloseDelay (required)\n   * @param {number} options.pingInterval (required)\n   * @param {number} options.pongTimeout (required)\n   * @param {string} options.token (required)\n   * @param {string} options.trackingId (required)\n   * @param {Logger} options.logger (required)\n   * @param {string} options.logLevelToken\n   * @returns {Promise}\n   */\n  open(url, options) {\n    return new Promise((resolve, reject) => {\n      /* eslint complexity: [0] */\n      if (!url) {\n        reject(new Error('`url` is required'));\n\n        return;\n      }\n\n      if (sockets.get(this)) {\n        reject(new Error('Socket#open() can only be called once per instance'));\n\n        return;\n      }\n\n      options = options || {};\n\n      checkRequired([\n        'forceCloseDelay',\n        'pingInterval',\n        'pongTimeout',\n        'token',\n        'trackingId',\n        'logger'\n      ], options);\n\n      Object.keys(options).forEach((key) => {\n        Reflect.defineProperty(this, key, {\n          enumerable: false,\n          value: options[key]\n        });\n      });\n\n      const WebSocket = Socket.getWebSocketConstructor();\n\n      this.logger.info('socket: creating WebSocket');\n      const socket = new WebSocket(url, [], options);\n\n      socket.binaryType = 'arraybuffer';\n      socket.onmessage = this.onmessage;\n\n      socket.onclose = (event) => {\n        event = this._fixCloseCode(event);\n        this.logger.info('socket: closed before open', event.code, event.reason);\n        switch (event.code) {\n          case 1005:\n          // IE 11 doesn't seem to allow 4XXX codes, so if we get a 1005, assume\n          // it's a bad websocket url. That'll trigger a device refresh; if it\n          // turns out we had a bad token, the device refresh should 401 and\n          // trigger a token refresh.\n            return reject(new UnknownResponse(event));\n          case 4400:\n            return reject(new BadRequest(event));\n          case 4401:\n            return reject(new NotAuthorized(event));\n          case 4403:\n            return reject(new Forbidden(event));\n            // case 4404:\n            //   return reject(new NotFound(event));\n          default:\n            return reject(new ConnectionError(event));\n        }\n      };\n\n      socket.onopen = () => {\n        this.logger.info('socket: connected');\n        this._authorize()\n          .then(() => {\n            this.logger.info('socket: authorized');\n            socket.onclose = this.onclose;\n            resolve();\n          })\n          .catch(reject);\n      };\n\n      socket.onerror = (event) => {\n        this.logger.warn('socket: error event fired', event);\n      };\n\n      sockets.set(this, socket);\n      this.logger.info('socket: waiting for server');\n    });\n  }\n\n  /**\n   * Handles incoming CloseEvents\n   * @param {CloseEvent} event\n   * @returns {undefined}\n   */\n  onclose(event) {\n    this.logger.info('socket: closed', event.code, event.reason);\n    clearTimeout(this.pongTimer);\n    clearTimeout(this.pingTimer);\n\n    event = this._fixCloseCode(event);\n    this.emit('close', event);\n\n    // Remove all listeners to (a) avoid reacting to late pongs and (b) ensure\n    // we don't have a retain cycle.\n    this.removeAllListeners();\n  }\n\n  /**\n   * Handles incoming message events\n   * @param {MessageEvent} event\n   * @returns {undefined}\n   */\n  onmessage(event) {\n    try {\n      const data = JSON.parse(event.data);\n      const sequenceNumber = parseInt(data.sequenceNumber, 10);\n\n      this.logger.debug('socket: sequence number: ', sequenceNumber);\n      if (this.expectedSequenceNumber && sequenceNumber !== this.expectedSequenceNumber) {\n        this.logger.debug(`socket: sequence number mismatch indicates lost mercury message. expected: ${this.expectedSequenceNumber}, actual: ${sequenceNumber}`);\n        this.emit('sequence-mismatch', sequenceNumber, this.expectedSequenceNumber);\n      }\n      this.expectedSequenceNumber = sequenceNumber + 1;\n\n      // Yes, it's a little weird looking; we want to emit message events that\n      // look like normal socket message events, but event.data cannot be\n      // modified and we don't actually care about anything but the data property\n      const processedEvent = {data};\n\n      this._acknowledge(processedEvent);\n      if (data.type === 'pong') {\n        this.emit('pong', processedEvent);\n      }\n      else {\n        this.emit('message', processedEvent);\n      }\n    }\n    catch (error) {\n      // The above code should only be able to throw if we receive an unparsable\n      // message from Mercury. At this time, the only action we have is to\n      // ignore it and move on.\n      /* istanbul ignore next */\n      this.logger.warn('socket: error while receiving WebSocket message', error);\n    }\n  }\n\n  /**\n   * Sends a message up the socket\n   * @param {mixed} data\n   * @returns {Promise}\n   */\n  send(data) {\n    return new Promise((resolve, reject) => {\n      if (this.readyState !== 1) {\n        return reject(new Error('INVALID_STATE_ERROR'));\n      }\n\n      if (isObject(data)) {\n        data = JSON.stringify(data);\n      }\n\n      const socket = sockets.get(this);\n\n      socket.send(data);\n\n      return resolve();\n    });\n  }\n\n  /**\n   * Sends an acknowledgment for a specific event\n   * @param {MessageEvent} event\n   * @returns {Promise}\n   */\n  _acknowledge(event) {\n    if (!event) {\n      return Promise.reject(new Error('`event` is required'));\n    }\n\n    if (!has(event, 'data.id')) {\n      return Promise.reject(new Error('`event.data.id` is required'));\n    }\n\n    return this.send({\n      messageId: event.data.id,\n      type: 'ack'\n    });\n  }\n\n  /**\n   * Sends an auth message up the socket\n   * @private\n   * @returns {Promise}\n   */\n  _authorize() {\n    return new Promise((resolve) => {\n      this.logger.info('socket: authorizing');\n      this.send({\n        id: uuid.v4(),\n        type: 'authorization',\n        data: {\n          token: this.token\n        },\n        trackingId: this.trackingId,\n        logLevelToken: this.logLevelToken\n      });\n\n      const waitForBufferState = (event) => {\n        if (!event.data.type && (event.data.data.eventType === 'mercury.buffer_state' || event.data.data.eventType === 'mercury.registration_status')) {\n          this.removeListener('message', waitForBufferState);\n          this._ping();\n          resolve();\n        }\n      };\n\n      this.once('message', waitForBufferState);\n    });\n  }\n\n  /**\n   * Deals with the fact that some browsers drop some close codes (but not\n   * close reasons).\n   * @param {CloseEvent} event\n   * @private\n   * @returns {CloseEvent}\n   */\n  _fixCloseCode(event) {\n    if (event.code === 1005 && event.reason) {\n      switch (event.reason.toLowerCase()) {\n        case 'replaced':\n          this.logger.info('socket: fixing CloseEvent code for reason: ', event.reason);\n          event.code = 4000;\n          break;\n        case 'authentication failed':\n        case 'authentication did not happen within the timeout window of 30000 seconds.':\n          this.logger.info('socket: fixing CloseEvent code for reason: ', event.reason);\n          event.code = 1008;\n          break;\n        default:\n        // do nothing\n      }\n    }\n\n    return event;\n  }\n\n  /**\n   * Sends a ping up the socket and confirms we get it back\n   * @param {[type]} id\n   * @private\n   * @returns {[type]}\n   */\n  _ping(id) {\n    const confirmPongId = (event) => {\n      try {\n        this.logger.debug('socket: pong', event.data.id);\n        if (event.data && event.data.id !== id) {\n          this.logger.info('socket: received pong for wrong ping id, closing socket');\n          this.logger.debug('socket: expected', id, 'received', event.data.id);\n          this.close({\n            code: 1000,\n            reason: 'Pong mismatch'\n          });\n        }\n      }\n      catch (error) {\n        // This try/catch block was added as a debugging step; to the best of my\n        // knowledge, the above can never throw.\n        /* istanbul ignore next */\n        this.logger.error('socket: error occurred in confirmPongId', error);\n      }\n    };\n\n    const onPongNotReceived = () => {\n      try {\n        this.logger.info('socket: pong not receive in expected period, closing socket');\n        this.close({\n          code: 1000,\n          reason: 'Pong not received'\n        })\n          .catch((reason) => {\n            this.logger.warn('socket: failed to close socket after missed pong', reason);\n          });\n      }\n      catch (error) {\n        // This try/catch block was added as a debugging step; to the best of my\n        // knowledge, the above can never throw.\n        /* istanbul ignore next */\n        this.logger.error('socket: error occurred in onPongNotReceived', error);\n      }\n    };\n\n    const scheduleNextPingAndCancelPongTimer = () => {\n      try {\n        clearTimeout(this.pongTimer);\n        this.pingTimer = safeSetTimeout(() => this._ping(), this.pingInterval);\n      }\n      catch (error) {\n        // This try/catch block was added as a debugging step; to the best of my\n        // knowledge, the above can never throw.\n        /* istanbul ignore next */\n        this.logger.error('socket: error occurred in scheduleNextPingAndCancelPongTimer', error);\n      }\n    };\n\n    id = id || uuid.v4();\n    this.pongTimer = safeSetTimeout(onPongNotReceived, this.pongTimeout);\n    this.once('pong', scheduleNextPingAndCancelPongTimer);\n    this.once('pong', confirmPongId);\n\n    this.logger.debug(`socket: ping ${id}`);\n\n    return this.send({\n      id,\n      type: 'ping'\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}