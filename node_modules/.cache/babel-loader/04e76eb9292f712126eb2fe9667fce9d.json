{"ast":null,"code":"\"use strict\";\n\nvar _Reflect$construct = require(\"@babel/runtime-corejs2/core-js/reflect/construct\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime-corejs2/regenerator\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/asyncToGenerator\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/createClass\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/getPrototypeOf\"));\n\nvar _wrapNativeSuper2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/wrapNativeSuper\"));\n\nvar _loggerProxy = _interopRequireDefault(require(\"../common/logs/logger-proxy\"));\n\nvar _triggerProxy = _interopRequireDefault(require(\"../common/events/trigger-proxy\"));\n\nvar _constants = require(\"../constants\");\n\nvar _reconnection = _interopRequireDefault(require(\"../common/errors/reconnection\"));\n\nvar _reconnectionInProgress = _interopRequireDefault(require(\"../common/errors/reconnection-in-progress\"));\n\nvar _peerConnectionManager = _interopRequireDefault(require(\"../peer-connection-manager\"));\n\nvar _config = require(\"../metrics/config\");\n\nvar _media = _interopRequireDefault(require(\"../media\"));\n\nvar _metrics = _interopRequireDefault(require(\"../metrics\"));\n\nvar _collection = _interopRequireDefault(require(\"../roap/collection\"));\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2.default)(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;\n      result = _Reflect$construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0, _possibleConstructorReturn2.default)(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false;\n  if (_Reflect$construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * Used to indicate that the reconnect logic needs to be retried.\n *\n * @class NeedsRetryError\n * @extends {Error}\n */\n\n\nvar NeedsRetryError = /*#__PURE__*/function (_Error) {\n  (0, _inherits2.default)(NeedsRetryError, _Error);\n\n  var _super = _createSuper(NeedsRetryError);\n\n  function NeedsRetryError() {\n    (0, _classCallCheck2.default)(this, NeedsRetryError);\n    return _super.apply(this, arguments);\n  }\n\n  return NeedsRetryError;\n}( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Error));\n/**\n * Used to indicate that the meeting needs to be rejoined, not just media reconnected\n *\n * @class NeedsRejoinError\n * @extends {Error}\n */\n\n\nvar NeedsRejoinError = /*#__PURE__*/function (_Error2) {\n  (0, _inherits2.default)(NeedsRejoinError, _Error2);\n\n  var _super2 = _createSuper(NeedsRejoinError);\n  /**\n   * Creates an instance of NeedsRejoinError.\n   * @param {Object} params\n   * @param {boolean} params.wasSharing\n   * @param {Error} params.error\n   * @memberof NeedsRejoinError\n   */\n\n\n  function NeedsRejoinError(_ref) {\n    var _this;\n\n    var wasSharing = _ref.wasSharing,\n        _ref$error = _ref.error,\n        error = _ref$error === void 0 ? new Error('Meeting needs to be rejoined') : _ref$error;\n    (0, _classCallCheck2.default)(this, NeedsRejoinError);\n    _this = _super2.call(this, error);\n    _this.wasSharing = wasSharing;\n    return _this;\n  }\n\n  return NeedsRejoinError;\n}( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Error));\n/**\n * @export\n * @class ReconnectionManager\n*/\n\n\nvar ReconnectionManager = /*#__PURE__*/function () {\n  /**\n   * @param {Meeting} meeting\n   */\n  function ReconnectionManager(meeting) {\n    (0, _classCallCheck2.default)(this, ReconnectionManager);\n    /**\n     * Stores ICE reconnection state data.\n     *\n     * @instance\n     * @type {Object}\n     * @private\n     * @memberof ReconnectionManager\n     */\n\n    this.iceState = {\n      disconnected: false,\n      resolve: function resolve() {},\n      timer: undefined,\n      timeoutDuration: meeting.config.reconnection.iceReconnectionTimeout\n    };\n    /**\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof ReconnectionManager\n    */\n\n    this.status = _constants.RECONNECTION.STATE.DEFAULT_STATUS;\n    /**\n     * @instance\n     * @type {Number}\n     * @private\n     * @memberof ReconnectionManager\n    */\n\n    this.tryCount = _constants.RECONNECTION.STATE.DEFAULT_TRY_COUNT;\n    /**\n     * @instance\n     * @type {Object}\n     * @private\n     * @memberof ReconnectionManager\n    */\n    // TODO : change this logic to not save the meeting instance\n    // It gets complicated when meeting ends on remote side , We have a old meeting instance which is not up to date\n\n    this.webex = meeting.webex;\n    /**\n     * @instance\n     * @type {Meeting}\n     * @private\n     * @memberof ReconnectionManager\n     */\n    // TODO: try removing the circular dependency for meeting and reconnection manager\n    // try moving this to meetings collection\n\n    this.meeting = meeting;\n    this.maxRejoinAttempts = meeting.config.reconnection.maxRejoinAttempts;\n    this.rejoinAttempts = _constants.RECONNECTION.STATE.DEFAULT_TRY_COUNT;\n    this.autoRejoinEnabled = meeting.config.reconnection.autoRejoin; // Make sure reconnection state is in default\n\n    this.reset();\n  }\n  /**\n   * Sets the iceState to connected and clears any disconnect timeouts and\n   * related timeout data within the iceState.\n   *\n   * @returns {undefined}\n   * @public\n   * @memberof ReconnectionManager\n   */\n\n\n  (0, _createClass2.default)(ReconnectionManager, [{\n    key: \"iceReconnected\",\n    value: function iceReconnected() {\n      if (this.iceState.disconnected) {\n        _loggerProxy.default.logger.log('ReconnectionManager:index#iceReconnected --> ice has reconnected');\n\n        this.iceState.resolve();\n\n        this.iceState.resolve = function () {};\n\n        if (this.iceState.timer) {\n          clearTimeout(this.iceState.timer);\n          delete this.iceState.timer;\n        }\n\n        this.iceState.disconnected = false;\n      }\n    }\n    /**\n     * Set the iceState to disconnected and generates a timeout that waits for the\n     * iceState to reconnect and then resolves. If the ice state is already\n     * processing a reconnect, it immediately resolves. Rejects if the timeout\n     * duration is reached.\n     *\n     * @returns {Promise<undefined>}\n     * @public\n     * @memberof ReconnectionManager\n     */\n\n  }, {\n    key: \"waitForIceReconnect\",\n    value: function waitForIceReconnect() {\n      var _this2 = this;\n\n      if (!this.iceState.disconnected) {\n        _loggerProxy.default.logger.log('ReconnectionManager:index#waitForIceReconnect --> waiting for ice reconnect');\n\n        this.iceState.disconnected = true;\n        return new _promise.default(function (resolve, reject) {\n          _this2.iceState.timer = setTimeout(function () {\n            if (_this2.iceState.disconnected === false) {\n              resolve();\n            } else {\n              _this2.iceState.disconnected = false;\n              reject(new Error(\"ice reconnection did not occur in \".concat(_this2.iceState.timeoutDuration, \"ms\")));\n            }\n          }, _this2.iceState.timeoutDuration);\n          _this2.iceState.resolve = resolve;\n        });\n      } // return a resolved promise to prevent multiple catch executions of reconnect\n\n\n      return _promise.default.resolve();\n    }\n    /**\n     * @returns {undefined}\n     * @public\n     * @memberof ReconnectionManager\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.status = _constants.RECONNECTION.STATE.DEFAULT_STATUS;\n      this.tryCount = _constants.RECONNECTION.STATE.DEFAULT_TRY_COUNT;\n      this.rejoinAttempts = _constants.RECONNECTION.STATE.DEFAULT_TRY_COUNT;\n    }\n    /**\n     * @returns {undefined}\n     * @public\n     * @memberof ReconnectionManager\n     */\n\n  }, {\n    key: \"cleanUp\",\n    value: function cleanUp() {\n      this.reset();\n      this.meeting = null;\n    }\n    /**\n     * @returns {Boolean}\n     * @throws {ReconnectionError}\n     * @private\n     * @memberof ReconnectionManager\n     */\n\n  }, {\n    key: \"validate\",\n    value: function validate() {\n      if (this.meeting.config.reconnection.enabled) {\n        if (this.status === _constants.RECONNECTION.STATE.DEFAULT_STATUS || this.status === _constants.RECONNECTION.STATE.COMPLETE) {\n          return true;\n        }\n\n        _loggerProxy.default.logger.info('ReconnectionManager:index#validate --> Reconnection already in progress.');\n\n        throw new _reconnectionInProgress.default('Reconnection already in progress.');\n      }\n\n      _loggerProxy.default.logger.info('ReconnectionManager:index#validate --> Reconnection is not enabled.');\n\n      throw new _reconnection.default('Reconnection is not enabled.');\n    }\n    /**\n     * Initiates a media reconnect for the active meeting\n     * @param {Object} reconnectOptions\n     * @param {boolean} [reconnectOptions.networkDisconnect=false] indicates if a network disconnect event happened\n     * @param {boolean} [reconnectOptions.networkRetry=false] indicates if we are retrying the reconnect\n     * @returns {Promise}\n     * @public\n     * @memberof ReconnectionManager\n     */\n\n  }, {\n    key: \"reconnect\",\n    value: function () {\n      var _reconnect = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {\n        var _this3 = this;\n\n        var _ref2,\n            _ref2$networkDisconne,\n            networkDisconnect,\n            _ref2$networkRetry,\n            networkRetry,\n            _args = arguments;\n\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _ref2 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, _ref2$networkDisconne = _ref2.networkDisconnect, networkDisconnect = _ref2$networkDisconne === void 0 ? false : _ref2$networkDisconne, _ref2$networkRetry = _ref2.networkRetry, networkRetry = _ref2$networkRetry === void 0 ? false : _ref2$networkRetry;\n\n                _loggerProxy.default.logger.info(\"ReconnectionManager:index#reconnect --> Reconnection start for meeting \".concat(this.meeting.id, \".\")); // First, validate that we can reconnect, if not, it will throw an error\n\n\n                _context.prev = 2;\n                this.validate();\n                _context.next = 10;\n                break;\n\n              case 6:\n                _context.prev = 6;\n                _context.t0 = _context[\"catch\"](2);\n\n                _loggerProxy.default.logger.info('ReconnectionManager:index#reconnect --> Reconnection unable to begin.', _context.t0);\n\n                throw _context.t0;\n\n              case 10:\n                if (!networkRetry) {\n                  // Only log START metrics on the initial reconnect\n                  _loggerProxy.default.logger.info('ReconnectionManager:index#reconnect --> Sending reconnect start metric.');\n\n                  _metrics.default.postEvent({\n                    event: _config.eventType.MEDIA_RECONNECTING,\n                    meeting: this.meeting\n                  });\n                }\n\n                return _context.abrupt(\"return\", this.executeReconnection({\n                  networkDisconnect: networkDisconnect\n                }).then(function () {\n                  _loggerProxy.default.logger.info('ReconnectionManager:index#reconnect --> Reconnection successful.');\n\n                  _loggerProxy.default.logger.info('ReconnectionManager:index#reconnect --> Sending reconnect success metric.');\n\n                  _metrics.default.postEvent({\n                    event: _config.eventType.MEDIA_RECOVERED,\n                    meeting: _this3.meeting,\n                    data: {\n                      recoveredBy: _config.reconnection.RECOVERED_BY_NEW\n                    }\n                  });\n                }).catch(function (reconnectError) {\n                  if (reconnectError instanceof NeedsRetryError) {\n                    _loggerProxy.default.logger.info('ReconnectionManager:index#reconnect --> Reconnection not successful, retrying.'); // Reset our reconnect status since we are looping back to the beginning\n                    // Reset our reconnect status since we are looping back to the beginning\n\n\n                    _this3.status = _constants.RECONNECTION.STATE.DEFAULT_STATUS; // This is a network retry, so we should not log START metrics again\n                    // This is a network retry, so we should not log START metrics again\n\n                    return _this3.reconnect({\n                      networkDisconnect: true,\n                      networkRetry: true\n                    });\n                  } // Reconnect has failed\n                  // Reconnect has failed\n\n\n                  _loggerProxy.default.logger.error('ReconnectionManager:index#reconnect --> Reconnection failed.', reconnectError.message);\n\n                  _loggerProxy.default.logger.info('ReconnectionManager:index#reconnect --> Sending reconnect abort metric.');\n\n                  var reconnectMetric = {\n                    event: _config.eventType.CALL_ABORTED,\n                    meeting: _this3.meeting,\n                    data: {\n                      errors: [{\n                        category: _config.errorObjects.category.expected,\n                        errorCode: 2008,\n                        fatal: true,\n                        name: _config.errorObjects.name.mediaEngine,\n                        shownToUser: false\n                      }]\n                    }\n                  };\n\n                  _metrics.default.postEvent(reconnectMetric);\n\n                  if (reconnectError instanceof NeedsRejoinError) {\n                    // send call aborded event with catogery as expected as we are trying to rejoin\n                    if (_this3.autoRejoinEnabled) {\n                      return _this3.rejoinMeeting(reconnectError.wasSharing);\n                    }\n                  }\n\n                  throw reconnectError;\n                }));\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2, 6]]);\n      }));\n\n      function reconnect() {\n        return _reconnect.apply(this, arguments);\n      }\n\n      return reconnect;\n    }()\n    /**\n     * @param {Object} reconnectOptions\n     * @param {boolean} [reconnectOptions.networkDisconnect=false] indicates if a network disconnect event happened\n     * @returns {Promise}\n     * @throws {NeedsRetryError}\n     * @private\n     * @memberof ReconnectionManager\n     */\n\n  }, {\n    key: \"executeReconnection\",\n    value: function () {\n      var _executeReconnection = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(_ref3) {\n        var _ref3$networkDisconne, networkDisconnect, wasSharing, media;\n\n        return _regenerator.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _ref3$networkDisconne = _ref3.networkDisconnect, networkDisconnect = _ref3$networkDisconne === void 0 ? false : _ref3$networkDisconne;\n                this.status = _constants.RECONNECTION.STATE.IN_PROGRESS;\n\n                _loggerProxy.default.logger.info('ReconnectionManager:index#executeReconnection --> Attempting to reconnect to meeting.');\n\n                if (!networkDisconnect) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                _context2.prev = 4;\n                _context2.next = 7;\n                return this.reconnectMercuryWebSocket();\n\n              case 7:\n                _loggerProxy.default.logger.error('ReconnectionManager:index#executeReconnection --> Websocket reconnected.', this.webex.internal.device.url);\n\n                _context2.next = 15;\n                break;\n\n              case 10:\n                _context2.prev = 10;\n                _context2.t0 = _context2[\"catch\"](4);\n\n                _loggerProxy.default.logger.error('ReconnectionManager:index#executeReconnection --> Unable to reconnect to websocket, giving up.');\n\n                this.status = _constants.RECONNECTION.STATE.FAILURE;\n                throw _context2.t0;\n\n              case 15:\n                wasSharing = this.meeting.shareStatus === _constants.SHARE_STATUS.LOCAL_SHARE_ACTIVE;\n                _context2.prev = 16;\n\n                _loggerProxy.default.logger.info('ReconnectionManager:index#executeReconnection --> Updating meeting data from server.');\n\n                _context2.next = 20;\n                return this.webex.meetings.syncMeetings();\n\n              case 20:\n                _context2.next = 26;\n                break;\n\n              case 22:\n                _context2.prev = 22;\n                _context2.t1 = _context2[\"catch\"](16);\n\n                _loggerProxy.default.logger.info('ReconnectionManager:index#executeReconnection --> Unable to sync meetings, reconnecting.', _context2.t1);\n\n                throw new NeedsRetryError(_context2.t1);\n\n              case 26:\n                if (!(!this.meeting || !this.webex.meetings.getMeetingByType(_constants._ID_, this.meeting.id))) {\n                  _context2.next = 29;\n                  break;\n                }\n\n                _loggerProxy.default.logger.info('ReconnectionManager:index#executeReconnection --> Meeting got deleted due to inactivity or ended remotely ');\n\n                throw new Error('Unable to rejoin a meeting already ended or inactive .');\n\n              case 29:\n                _loggerProxy.default.logger.info(\"ReconnectionManager:index#executeReconnection --> Current state of meeting is \".concat(this.meeting.state)); // If the meeting state was left, no longer reconnect media\n\n\n                if (!(this.meeting.state === _constants._LEFT_)) {\n                  _context2.next = 34;\n                  break;\n                }\n\n                if (!(this.meeting.type === _constants._CALL_)) {\n                  _context2.next = 33;\n                  break;\n                }\n\n                throw new Error('Unable to rejoin a call in LEFT state.');\n\n              case 33:\n                throw new NeedsRejoinError({\n                  wasSharing: wasSharing\n                });\n\n              case 34:\n                _context2.prev = 34;\n                _context2.next = 37;\n                return this.reconnectMedia();\n\n              case 37:\n                media = _context2.sent;\n\n                _loggerProxy.default.logger.log('ReconnectionManager:index#executeReconnection --> Media reestablished');\n\n                this.status = _constants.RECONNECTION.STATE.COMPLETE;\n                return _context2.abrupt(\"return\", media);\n\n              case 43:\n                _context2.prev = 43;\n                _context2.t2 = _context2[\"catch\"](34);\n\n                _loggerProxy.default.logger.error('ReconnectionManager:index#executeReconnection --> Media reestablishment failed');\n\n                this.status = _constants.RECONNECTION.STATE.FAILURE;\n                throw _context2.t2;\n\n              case 48:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[4, 10], [16, 22], [34, 43]]);\n      }));\n\n      function executeReconnection(_x) {\n        return _executeReconnection.apply(this, arguments);\n      }\n\n      return executeReconnection;\n    }()\n    /**\n     * Rejoins a meeting after detecting the member was in a LEFT state\n     *\n     * @async\n     * @param {boolean} wasSharing\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"rejoinMeeting\",\n    value: function () {\n      var _rejoinMeeting = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {\n        var wasSharing,\n            previousCorrelationId,\n            _args3 = arguments;\n        return _regenerator.default.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                wasSharing = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : false;\n                _context3.prev = 1;\n\n                _loggerProxy.default.logger.info('ReconnectionManager:index#rejoinMeeting --> attemping meeting rejoin');\n\n                previousCorrelationId = this.meeting.correlationId;\n                _context3.next = 6;\n                return this.meeting.join({\n                  rejoin: true\n                });\n\n              case 6:\n                _loggerProxy.default.logger.info('ReconnectionManager:index#rejoinMeeting --> meeting rejoined');\n\n                _collection.default.deleteSession(previousCorrelationId);\n\n                if (wasSharing) {\n                  // Stop the share streams if user tried to rejoin\n                  _media.default.stopTracks(this.meeting.mediaProperties.shareTrack);\n\n                  this.meeting.isSharing = false;\n\n                  if (this.shareStatus === _constants.SHARE_STATUS.LOCAL_SHARE_ACTIVE) {\n                    this.meeting.shareStatus = _constants.SHARE_STATUS.NO_SHARE;\n                  }\n\n                  this.meeting.mediaProperties.mediaDirection.sendShare = false;\n\n                  _triggerProxy.default.trigger(this.meeting, {\n                    file: 'reconnection-manager/index',\n                    function: 'rejoinMeeting'\n                  }, _constants.EVENT_TRIGGERS.MEETING_STOPPED_SHARING_LOCAL, {\n                    reason: _constants.SHARE_STOPPED_REASON.MEETING_REJOIN\n                  });\n                }\n\n                _context3.next = 23;\n                break;\n\n              case 11:\n                _context3.prev = 11;\n                _context3.t0 = _context3[\"catch\"](1);\n                this.rejoinAttempts += 1;\n\n                if (!(this.rejoinAttempts <= this.maxRejoinAttempts)) {\n                  _context3.next = 19;\n                  break;\n                }\n\n                _loggerProxy.default.logger.info(\"ReconnectionManager:index#rejoinMeeting --> Unable to rejoin meeting, attempt #\".concat(this.rejoinAttempts, \", retrying.\"), _context3.t0);\n\n                this.rejoinMeeting();\n                _context3.next = 23;\n                break;\n\n              case 19:\n                _loggerProxy.default.logger.error('ReconnectionManager:index#rejoinMeeting --> Unable to rejoin meeting after max attempts.', _context3.t0);\n\n                _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.MEETING_MAX_REJOIN_FAILURE, {\n                  locus_id: this.meeting.locusUrl.split('/').pop(),\n                  reason: _context3.t0.message,\n                  stack: _context3.t0.stack\n                });\n\n                this.status = _constants.RECONNECTION.STATE.FAILURE;\n                throw _context3.t0;\n\n              case 23:\n                _context3.prev = 23;\n                _context3.next = 26;\n                return this.reconnectMedia();\n\n              case 26:\n                _context3.next = 32;\n                break;\n\n              case 28:\n                _context3.prev = 28;\n                _context3.t1 = _context3[\"catch\"](23);\n\n                _loggerProxy.default.logger.error('ReconnectionManager:index#rejoinMeeting --> Unable to reestablish media after rejoining.', _context3.t1);\n\n                throw _context3.t1;\n\n              case 32:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[1, 11], [23, 28]]);\n      }));\n\n      function rejoinMeeting() {\n        return _rejoinMeeting.apply(this, arguments);\n      }\n\n      return rejoinMeeting;\n    }()\n    /**\n     * @returns {Promise}\n     * @private\n     * @memberof ReconnectionManager\n     */\n\n  }, {\n    key: \"reconnectMedia\",\n    value: function reconnectMedia() {\n      var _this4 = this;\n\n      _loggerProxy.default.logger.log('ReconnectionManager:index#reconnectMedia --> Begin reestablishment of media');\n\n      ReconnectionManager.setupPeerConnection(this.meeting);\n      return _media.default.attachMedia(this.meeting.mediaProperties, {\n        meetingId: this.meeting.id,\n        remoteQualityLevel: this.meeting.mediaProperties.remoteQualityLevel,\n        enableRtx: this.meeting.config.enableRtx,\n        enableExtmap: this.meeting.config.enableExtmap\n      }).then(function (peerConnection) {\n        return _this4.meeting.setRemoteStream(peerConnection);\n      }).then(function () {\n        _loggerProxy.default.logger.log('ReconnectionManager:index#reconnectMedia --> Sending ROAP media request');\n\n        return _this4.meeting.roap.sendRoapMediaRequest({\n          sdp: _this4.meeting.mediaProperties.peerConnection.sdp,\n          roapSeq: _this4.meeting.roapSeq,\n          meeting: _this4.meeting,\n          reconnect: true\n        });\n      });\n    }\n    /**\n     * Attempt to Reconnect Mercury Websocket\n     * @returns {Promise}\n     * @private\n     * @memberof ReconnectionManager\n     */\n\n  }, {\n    key: \"reconnectMercuryWebSocket\",\n    value: function () {\n      var _reconnectMercuryWebSocket = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {\n        return _regenerator.default.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _loggerProxy.default.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Reconnecting websocket.'); // First, attempt to disconnect if we think we are already connected.\n\n\n                if (!this.webex.internal.mercury.connected) {\n                  _context4.next = 13;\n                  break;\n                }\n\n                _loggerProxy.default.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Disconnecting existing websocket.');\n\n                _context4.prev = 3;\n                _context4.next = 6;\n                return this.webex.internal.mercury.disconnect();\n\n              case 6:\n                _loggerProxy.default.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Websocket disconnected successfully.');\n\n                _context4.next = 13;\n                break;\n\n              case 9:\n                _context4.prev = 9;\n                _context4.t0 = _context4[\"catch\"](3); // If we can't disconnect, the sdk is in such a bad state that reconnecting is not going to happen.\n\n                _loggerProxy.default.logger.error('ReconnectionManager:index#reconnectMercuryWebSocket --> Unable to disconnect from websocket, giving up.', _context4.t0);\n\n                throw _context4.t0;\n\n              case 13:\n                _context4.prev = 13;\n\n                _loggerProxy.default.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Connecting websocket.');\n\n                _context4.next = 17;\n                return this.webex.internal.mercury.connect();\n\n              case 17:\n                _loggerProxy.default.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Websocket connected successfully.');\n\n                _context4.next = 24;\n                break;\n\n              case 20:\n                _context4.prev = 20;\n                _context4.t1 = _context4[\"catch\"](13);\n\n                _loggerProxy.default.logger.error('ReconnectionManager:index#reconnectMercuryWebSocket --> Unable to connect to websocket, giving up.', _context4.t1);\n\n                throw _context4.t1;\n\n              case 24:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[3, 9], [13, 20]]);\n      }));\n\n      function reconnectMercuryWebSocket() {\n        return _reconnectMercuryWebSocket.apply(this, arguments);\n      }\n\n      return reconnectMercuryWebSocket;\n    }()\n    /**\n     * @param {Meeting} meeting\n     * @returns {undefined}\n     * @private\n     * @memberof ReconnectionManager\n     */\n\n  }], [{\n    key: \"setupPeerConnection\",\n    value: function setupPeerConnection(meeting) {\n      _loggerProxy.default.logger.log('ReconnectionManager:index#setupPeerConnection --> Begin resetting peer connection'); // close pcs, unset to null and create a new one with out closing any streams\n\n\n      _peerConnectionManager.default.close(meeting.mediaProperties.peerConnection);\n\n      meeting.mediaProperties.unsetPeerConnection();\n      meeting.mediaProperties.reInitiatePeerconnection();\n\n      _peerConnectionManager.default.setPeerConnectionEvents(meeting); // update the peerconnection in the stats manager when ever we reconnect\n\n\n      meeting.statsAnalyzer.updatePeerconnection(meeting.mediaProperties.peerConnection);\n    }\n  }]);\n  return ReconnectionManager;\n}();\n\nexports.default = ReconnectionManager;","map":{"version":3,"mappings":"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","names":["NeedsRetryError","Error","NeedsRejoinError","wasSharing","error","_this","ReconnectionManager","meeting","iceState","disconnected","resolve","timer","undefined","timeoutDuration","config","reconnection","iceReconnectionTimeout","status","RECONNECTION","STATE","DEFAULT_STATUS","tryCount","DEFAULT_TRY_COUNT","webex","maxRejoinAttempts","rejoinAttempts","autoRejoinEnabled","autoRejoin","reset","LoggerProxy","logger","log","clearTimeout","reject","_this2","setTimeout","_promise","enabled","COMPLETE","info","ReconnectInProgress","ReconnectionError","_ref2","networkDisconnect","networkRetry","id","_context","validate","Metrics","postEvent","event","eventType","MEDIA_RECONNECTING","executeReconnection","then","MEDIA_RECOVERED","_this3","data","recoveredBy","RECOVERED_BY_NEW","catch","reconnectError","reconnect","message","reconnectMetric","CALL_ABORTED","errors","category","errorObjects","expected","errorCode","fatal","name","mediaEngine","shownToUser","rejoinMeeting","_ref3$networkDisconne","IN_PROGRESS","_context2","reconnectMercuryWebSocket","internal","device","url","FAILURE","shareStatus","SHARE_STATUS","LOCAL_SHARE_ACTIVE","meetings","syncMeetings","getMeetingByType","_ID_","state","_LEFT_","type","_CALL_","reconnectMedia","media","_context3","previousCorrelationId","correlationId","join","rejoin","RoapCollection","deleteSession","Media","stopTracks","mediaProperties","shareTrack","isSharing","NO_SHARE","mediaDirection","sendShare","Trigger","trigger","file","function","EVENT_TRIGGERS","MEETING_STOPPED_SHARING_LOCAL","reason","SHARE_STOPPED_REASON","MEETING_REJOIN","sendBehavioralMetric","BEHAVIORAL_METRICS","MEETING_MAX_REJOIN_FAILURE","locus_id","locusUrl","split","pop","stack","setupPeerConnection","attachMedia","meetingId","remoteQualityLevel","enableRtx","enableExtmap","peerConnection","_this4","setRemoteStream","roap","sendRoapMediaRequest","sdp","roapSeq","mercury","connected","_context4","disconnect","connect","PeerConnectionManager","close","unsetPeerConnection","reInitiatePeerconnection","setPeerConnectionEvents","statsAnalyzer","updatePeerconnection"],"sources":["index.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\n/* eslint-disable no-warning-comments */\n\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport Trigger from '../common/events/trigger-proxy';\nimport {\n  EVENT_TRIGGERS,\n  BEHAVIORAL_METRICS,\n  RECONNECTION,\n  SHARE_STATUS,\n  SHARE_STOPPED_REASON,\n  _CALL_,\n  _LEFT_,\n  _ID_\n} from '../constants';\nimport ReconnectionError from '../common/errors/reconnection';\nimport ReconnectInProgress from '../common/errors/reconnection-in-progress';\nimport PeerConnectionManager from '../peer-connection-manager';\nimport {eventType, reconnection, errorObjects} from '../metrics/config';\nimport Media from '../media';\nimport Metrics from '../metrics';\nimport RoapCollection from '../roap/collection';\n\n/**\n * Used to indicate that the reconnect logic needs to be retried.\n *\n * @class NeedsRetryError\n * @extends {Error}\n */\nclass NeedsRetryError extends Error {}\n\n/**\n * Used to indicate that the meeting needs to be rejoined, not just media reconnected\n *\n * @class NeedsRejoinError\n * @extends {Error}\n */\nclass NeedsRejoinError extends Error {\n  /**\n   * Creates an instance of NeedsRejoinError.\n   * @param {Object} params\n   * @param {boolean} params.wasSharing\n   * @param {Error} params.error\n   * @memberof NeedsRejoinError\n   */\n  constructor({wasSharing, error = new Error('Meeting needs to be rejoined')}) {\n    super(error);\n\n    this.wasSharing = wasSharing;\n  }\n}\n\n/**\n * @export\n * @class ReconnectionManager\n*/\nexport default class ReconnectionManager {\n  /**\n   * @param {Meeting} meeting\n   */\n  constructor(meeting) {\n    /**\n     * Stores ICE reconnection state data.\n     *\n     * @instance\n     * @type {Object}\n     * @private\n     * @memberof ReconnectionManager\n     */\n    this.iceState = {\n      disconnected: false,\n      resolve: () => {},\n      timer: undefined,\n      timeoutDuration: meeting.config.reconnection.iceReconnectionTimeout\n    };\n\n    /**\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof ReconnectionManager\n    */\n    this.status = RECONNECTION.STATE.DEFAULT_STATUS;\n    /**\n     * @instance\n     * @type {Number}\n     * @private\n     * @memberof ReconnectionManager\n    */\n    this.tryCount = RECONNECTION.STATE.DEFAULT_TRY_COUNT;\n    /**\n     * @instance\n     * @type {Object}\n     * @private\n     * @memberof ReconnectionManager\n    */\n    // TODO : change this logic to not save the meeting instance\n    // It gets complicated when meeting ends on remote side , We have a old meeting instance which is not up to date\n    this.webex = meeting.webex;\n    /**\n     * @instance\n     * @type {Meeting}\n     * @private\n     * @memberof ReconnectionManager\n     */\n    // TODO: try removing the circular dependency for meeting and reconnection manager\n    // try moving this to meetings collection\n    this.meeting = meeting;\n\n    this.maxRejoinAttempts = meeting.config.reconnection.maxRejoinAttempts;\n    this.rejoinAttempts = RECONNECTION.STATE.DEFAULT_TRY_COUNT;\n    this.autoRejoinEnabled = meeting.config.reconnection.autoRejoin;\n\n\n    // Make sure reconnection state is in default\n    this.reset();\n  }\n\n  /**\n   * Sets the iceState to connected and clears any disconnect timeouts and\n   * related timeout data within the iceState.\n   *\n   * @returns {undefined}\n   * @public\n   * @memberof ReconnectionManager\n   */\n  iceReconnected() {\n    if (this.iceState.disconnected) {\n      LoggerProxy.logger.log('ReconnectionManager:index#iceReconnected --> ice has reconnected');\n\n      this.iceState.resolve();\n      this.iceState.resolve = () => {};\n\n      if (this.iceState.timer) {\n        clearTimeout(this.iceState.timer);\n        delete this.iceState.timer;\n      }\n\n      this.iceState.disconnected = false;\n    }\n  }\n\n  /**\n   * Set the iceState to disconnected and generates a timeout that waits for the\n   * iceState to reconnect and then resolves. If the ice state is already\n   * processing a reconnect, it immediately resolves. Rejects if the timeout\n   * duration is reached.\n   *\n   * @returns {Promise<undefined>}\n   * @public\n   * @memberof ReconnectionManager\n   */\n  waitForIceReconnect() {\n    if (!this.iceState.disconnected) {\n      LoggerProxy.logger.log('ReconnectionManager:index#waitForIceReconnect --> waiting for ice reconnect');\n\n      this.iceState.disconnected = true;\n\n      return new Promise((resolve, reject) => {\n        this.iceState.timer = setTimeout(() => {\n          if (this.iceState.disconnected === false) {\n            resolve();\n          }\n          else {\n            this.iceState.disconnected = false;\n            reject(new Error(`ice reconnection did not occur in ${this.iceState.timeoutDuration}ms`));\n          }\n        }, this.iceState.timeoutDuration);\n\n        this.iceState.resolve = resolve;\n      });\n    }\n\n    // return a resolved promise to prevent multiple catch executions of reconnect\n    return Promise.resolve();\n  }\n\n  /**\n   * @returns {undefined}\n   * @public\n   * @memberof ReconnectionManager\n   */\n  reset() {\n    this.status = RECONNECTION.STATE.DEFAULT_STATUS;\n    this.tryCount = RECONNECTION.STATE.DEFAULT_TRY_COUNT;\n    this.rejoinAttempts = RECONNECTION.STATE.DEFAULT_TRY_COUNT;\n  }\n\n  /**\n   * @returns {undefined}\n   * @public\n   * @memberof ReconnectionManager\n   */\n  cleanUp() {\n    this.reset();\n    this.meeting = null;\n  }\n\n  /**\n   * @returns {Boolean}\n   * @throws {ReconnectionError}\n   * @private\n   * @memberof ReconnectionManager\n   */\n  validate() {\n    if (this.meeting.config.reconnection.enabled) {\n      if (\n        this.status === RECONNECTION.STATE.DEFAULT_STATUS ||\n        this.status === RECONNECTION.STATE.COMPLETE\n      ) {\n        return true;\n      }\n\n      LoggerProxy.logger.info('ReconnectionManager:index#validate --> Reconnection already in progress.');\n\n      throw new ReconnectInProgress('Reconnection already in progress.');\n    }\n\n    LoggerProxy.logger.info('ReconnectionManager:index#validate --> Reconnection is not enabled.');\n\n    throw new ReconnectionError('Reconnection is not enabled.');\n  }\n\n  /**\n   * Initiates a media reconnect for the active meeting\n   * @param {Object} reconnectOptions\n   * @param {boolean} [reconnectOptions.networkDisconnect=false] indicates if a network disconnect event happened\n   * @param {boolean} [reconnectOptions.networkRetry=false] indicates if we are retrying the reconnect\n   * @returns {Promise}\n   * @public\n   * @memberof ReconnectionManager\n   */\n  async reconnect({networkDisconnect = false, networkRetry = false} = {}) {\n    LoggerProxy.logger.info(`ReconnectionManager:index#reconnect --> Reconnection start for meeting ${this.meeting.id}.`);\n    // First, validate that we can reconnect, if not, it will throw an error\n    try {\n      this.validate();\n    }\n    catch (error) {\n      LoggerProxy.logger.info('ReconnectionManager:index#reconnect --> Reconnection unable to begin.', error);\n      throw error;\n    }\n\n    if (!networkRetry) {\n      // Only log START metrics on the initial reconnect\n      LoggerProxy.logger.info('ReconnectionManager:index#reconnect --> Sending reconnect start metric.');\n      Metrics.postEvent({\n        event: eventType.MEDIA_RECONNECTING,\n        meeting: this.meeting\n      });\n    }\n\n    return this.executeReconnection({networkDisconnect})\n      .then(() => {\n        LoggerProxy.logger.info('ReconnectionManager:index#reconnect --> Reconnection successful.');\n        LoggerProxy.logger.info('ReconnectionManager:index#reconnect --> Sending reconnect success metric.');\n        Metrics.postEvent({\n          event: eventType.MEDIA_RECOVERED,\n          meeting: this.meeting,\n          data: {recoveredBy: reconnection.RECOVERED_BY_NEW}\n        });\n      })\n      .catch((reconnectError) => {\n        if (reconnectError instanceof NeedsRetryError) {\n          LoggerProxy.logger.info('ReconnectionManager:index#reconnect --> Reconnection not successful, retrying.');\n          // Reset our reconnect status since we are looping back to the beginning\n          this.status = RECONNECTION.STATE.DEFAULT_STATUS;\n\n          // This is a network retry, so we should not log START metrics again\n          return this.reconnect({networkDisconnect: true, networkRetry: true});\n        }\n\n        // Reconnect has failed\n        LoggerProxy.logger.error('ReconnectionManager:index#reconnect --> Reconnection failed.', reconnectError.message);\n        LoggerProxy.logger.info('ReconnectionManager:index#reconnect --> Sending reconnect abort metric.');\n\n        const reconnectMetric = {\n          event: eventType.CALL_ABORTED,\n          meeting: this.meeting,\n          data: {\n            errors: [\n              {\n                category: errorObjects.category.expected,\n                errorCode: 2008,\n                fatal: true,\n                name: errorObjects.name.mediaEngine,\n                shownToUser: false\n              }\n            ]\n          }\n        };\n\n        Metrics.postEvent(reconnectMetric);\n        if (reconnectError instanceof NeedsRejoinError) {\n          // send call aborded event with catogery as expected as we are trying to rejoin\n\n          if (this.autoRejoinEnabled) {\n            return this.rejoinMeeting(reconnectError.wasSharing);\n          }\n        }\n\n\n        throw reconnectError;\n      });\n  }\n\n  /**\n   * @param {Object} reconnectOptions\n   * @param {boolean} [reconnectOptions.networkDisconnect=false] indicates if a network disconnect event happened\n   * @returns {Promise}\n   * @throws {NeedsRetryError}\n   * @private\n   * @memberof ReconnectionManager\n   */\n  async executeReconnection({networkDisconnect = false}) {\n    this.status = RECONNECTION.STATE.IN_PROGRESS;\n\n    LoggerProxy.logger.info('ReconnectionManager:index#executeReconnection --> Attempting to reconnect to meeting.');\n\n    if (networkDisconnect) {\n      try {\n        await this.reconnectMercuryWebSocket();\n        LoggerProxy.logger.error('ReconnectionManager:index#executeReconnection --> Websocket reconnected.', this.webex.internal.device.url);\n      }\n      catch (error) {\n        LoggerProxy.logger.error('ReconnectionManager:index#executeReconnection --> Unable to reconnect to websocket, giving up.');\n        this.status = RECONNECTION.STATE.FAILURE;\n        throw (error);\n      }\n    }\n\n    const wasSharing = this.meeting.shareStatus === SHARE_STATUS.LOCAL_SHARE_ACTIVE;\n\n    try {\n      LoggerProxy.logger.info('ReconnectionManager:index#executeReconnection --> Updating meeting data from server.');\n      await this.webex.meetings.syncMeetings();\n    }\n    catch (syncError) {\n      LoggerProxy.logger.info('ReconnectionManager:index#executeReconnection --> Unable to sync meetings, reconnecting.', syncError);\n      throw (new NeedsRetryError(syncError));\n    }\n\n    // TODO: try to improve this logic as the reconnection manager saves the instance of deleted meeting object\n    // So that on rejoin it known what parametrs it was using\n    if (!this.meeting || !this.webex.meetings.getMeetingByType(_ID_, this.meeting.id)) {\n      LoggerProxy.logger.info('ReconnectionManager:index#executeReconnection --> Meeting got deleted due to inactivity or ended remotely ');\n\n      throw new Error('Unable to rejoin a meeting already ended or inactive .');\n    }\n\n    LoggerProxy.logger.info(`ReconnectionManager:index#executeReconnection --> Current state of meeting is ${this.meeting.state}`);\n\n    // If the meeting state was left, no longer reconnect media\n    if (this.meeting.state === _LEFT_) {\n      if (this.meeting.type === _CALL_) {\n        throw new Error('Unable to rejoin a call in LEFT state.');\n      }\n\n      throw (new NeedsRejoinError({wasSharing}));\n    }\n\n    try {\n      const media = await this.reconnectMedia();\n\n      LoggerProxy.logger.log('ReconnectionManager:index#executeReconnection --> Media reestablished');\n      this.status = RECONNECTION.STATE.COMPLETE;\n\n      return media;\n    }\n    catch (error) {\n      LoggerProxy.logger.error('ReconnectionManager:index#executeReconnection --> Media reestablishment failed');\n      this.status = RECONNECTION.STATE.FAILURE;\n\n      throw (error);\n    }\n  }\n\n  /**\n   * Rejoins a meeting after detecting the member was in a LEFT state\n   *\n   * @async\n   * @param {boolean} wasSharing\n   * @returns {Promise}\n   */\n  async rejoinMeeting(wasSharing = false) {\n    try {\n      LoggerProxy.logger.info('ReconnectionManager:index#rejoinMeeting --> attemping meeting rejoin');\n      const previousCorrelationId = this.meeting.correlationId;\n\n      await this.meeting.join({rejoin: true});\n      LoggerProxy.logger.info('ReconnectionManager:index#rejoinMeeting --> meeting rejoined');\n\n      RoapCollection.deleteSession(previousCorrelationId);\n\n      if (wasSharing) {\n        // Stop the share streams if user tried to rejoin\n        Media.stopTracks(this.meeting.mediaProperties.shareTrack);\n        this.meeting.isSharing = false;\n        if (this.shareStatus === SHARE_STATUS.LOCAL_SHARE_ACTIVE) {\n          this.meeting.shareStatus = SHARE_STATUS.NO_SHARE;\n        }\n        this.meeting.mediaProperties.mediaDirection.sendShare = false;\n        Trigger.trigger(\n          this.meeting,\n          {\n            file: 'reconnection-manager/index',\n            function: 'rejoinMeeting'\n          },\n          EVENT_TRIGGERS.MEETING_STOPPED_SHARING_LOCAL,\n          {\n            reason: SHARE_STOPPED_REASON.MEETING_REJOIN\n          }\n        );\n      }\n    }\n    catch (joinError) {\n      this.rejoinAttempts += 1;\n      if (this.rejoinAttempts <= this.maxRejoinAttempts) {\n        LoggerProxy.logger.info(`ReconnectionManager:index#rejoinMeeting --> Unable to rejoin meeting, attempt #${this.rejoinAttempts}, retrying.`, joinError);\n        this.rejoinMeeting();\n      }\n      else {\n        LoggerProxy.logger.error('ReconnectionManager:index#rejoinMeeting --> Unable to rejoin meeting after max attempts.', joinError);\n        Metrics.sendBehavioralMetric(\n          BEHAVIORAL_METRICS.MEETING_MAX_REJOIN_FAILURE,\n          {\n            locus_id: this.meeting.locusUrl.split('/').pop(),\n            reason: joinError.message,\n            stack: joinError.stack\n          }\n        );\n        this.status = RECONNECTION.STATE.FAILURE;\n        throw joinError;\n      }\n    }\n\n    try {\n      await this.reconnectMedia();\n    }\n    catch (mediaError) {\n      LoggerProxy.logger.error('ReconnectionManager:index#rejoinMeeting --> Unable to reestablish media after rejoining.', mediaError);\n      throw mediaError;\n    }\n  }\n\n  /**\n   * @returns {Promise}\n   * @private\n   * @memberof ReconnectionManager\n   */\n  reconnectMedia() {\n    LoggerProxy.logger.log('ReconnectionManager:index#reconnectMedia --> Begin reestablishment of media');\n\n    ReconnectionManager.setupPeerConnection(this.meeting);\n\n    return Media.attachMedia(this.meeting.mediaProperties, {\n      meetingId: this.meeting.id,\n      remoteQualityLevel: this.meeting.mediaProperties.remoteQualityLevel,\n      enableRtx: this.meeting.config.enableRtx,\n      enableExtmap: this.meeting.config.enableExtmap\n    })\n      .then((peerConnection) => this.meeting.setRemoteStream(peerConnection))\n      .then(() => {\n        LoggerProxy.logger.log('ReconnectionManager:index#reconnectMedia --> Sending ROAP media request');\n\n        return this.meeting.roap\n          .sendRoapMediaRequest({\n            sdp: this.meeting.mediaProperties.peerConnection.sdp,\n            roapSeq: this.meeting.roapSeq,\n            meeting: this.meeting,\n            reconnect: true\n          });\n      });\n  }\n\n  /**\n   * Attempt to Reconnect Mercury Websocket\n   * @returns {Promise}\n   * @private\n   * @memberof ReconnectionManager\n   */\n  async reconnectMercuryWebSocket() {\n    LoggerProxy.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Reconnecting websocket.');\n    // First, attempt to disconnect if we think we are already connected.\n    if (this.webex.internal.mercury.connected) {\n      LoggerProxy.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Disconnecting existing websocket.');\n      try {\n        await this.webex.internal.mercury.disconnect();\n        LoggerProxy.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Websocket disconnected successfully.');\n      }\n      catch (disconnectError) {\n        // If we can't disconnect, the sdk is in such a bad state that reconnecting is not going to happen.\n        LoggerProxy.logger.error('ReconnectionManager:index#reconnectMercuryWebSocket --> Unable to disconnect from websocket, giving up.', disconnectError);\n        throw disconnectError;\n      }\n    }\n\n    try {\n      LoggerProxy.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Connecting websocket.');\n      await this.webex.internal.mercury.connect();\n      LoggerProxy.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Websocket connected successfully.');\n    }\n    catch (connectError) {\n      LoggerProxy.logger.error('ReconnectionManager:index#reconnectMercuryWebSocket --> Unable to connect to websocket, giving up.', connectError);\n\n      throw (connectError);\n    }\n  }\n\n  /**\n   * @param {Meeting} meeting\n   * @returns {undefined}\n   * @private\n   * @memberof ReconnectionManager\n   */\n  static setupPeerConnection(meeting) {\n    LoggerProxy.logger.log('ReconnectionManager:index#setupPeerConnection --> Begin resetting peer connection');\n    // close pcs, unset to null and create a new one with out closing any streams\n    PeerConnectionManager.close(meeting.mediaProperties.peerConnection);\n    meeting.mediaProperties.unsetPeerConnection();\n    meeting.mediaProperties.reInitiatePeerconnection();\n    PeerConnectionManager.setPeerConnectionEvents(meeting);\n    // update the peerconnection in the stats manager when ever we reconnect\n    meeting.statsAnalyzer.updatePeerconnection(meeting.mediaProperties.peerConnection);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}