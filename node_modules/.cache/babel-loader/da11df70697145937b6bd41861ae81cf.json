{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime-corejs2/regenerator\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/asyncToGenerator\"));\n\nvar _url = _interopRequireDefault(require(\"url\"));\n\nvar _common = require(\"@webex/common\");\n\nvar _constants = require(\"../constants\");\n\nvar _parameter = _interopRequireDefault(require(\"../common/errors/parameter\"));\n\nvar _loggerProxy = _interopRequireDefault(require(\"../common/logs/logger-proxy\"));\n\nvar MeetingInfoUtil = {};\n\nMeetingInfoUtil.getParsedUrl = function (link) {\n  try {\n    var parsedUrl = _url.default.parse(link);\n\n    if (!parsedUrl) {\n      return false;\n    } // hack for links such as <company>.webex.com/meet/<user> without a protocol\n\n\n    if (!parsedUrl.protocol) {\n      parsedUrl = _url.default.parse(\"\".concat(_constants.HTTPS_PROTOCOL).concat(link));\n    }\n\n    return parsedUrl;\n  } catch (error) {\n    _loggerProxy.default.logger.warn(\"Meeting-info:util#getParsedUrl --> unable to parse the URL, error: \".concat(error));\n\n    return null;\n  }\n};\n/**\n * Helper function to check if a string matches a known meeting link pattern\n * @param {String} value  string to parse and see if it matches a meeting link\n * @returns {Boolean}\n */\n\n\nMeetingInfoUtil.isMeetingLink = function (value) {\n  var parsedUrl = MeetingInfoUtil.getParsedUrl(value);\n  var hostNameBool = parsedUrl.hostname && parsedUrl.hostname.includes(_constants.WEBEX_DOT_COM);\n  var pathNameBool = parsedUrl.pathname && (parsedUrl.pathname.includes(\"/\".concat(_constants.MEET)) || parsedUrl.pathname.includes(\"/\".concat(_constants.MEET_M)) || parsedUrl.pathname.includes(\"/\".concat(_constants.JOIN)));\n  return hostNameBool && pathNameBool;\n};\n\nMeetingInfoUtil.isConversationUrl = function (value, webex) {\n  var clusterId = webex.internal.services.getClusterId(value);\n\n  if (clusterId) {\n    return clusterId.endsWith(_constants.CONVERSATION_SERVICE);\n  }\n\n  return false;\n};\n\nMeetingInfoUtil.isSipUri = function (sipString) {\n  // TODO: lets remove regex from this equation and user URI matchers and such\n  // have not found a great sip uri parser library as of now\n  var sipUri = _constants.DIALER_REGEX.SIP_ADDRESS.exec(sipString);\n\n  return sipUri;\n};\n\nMeetingInfoUtil.isPhoneNumber = function (phoneNumber) {\n  var isValidNumber = _constants.DIALER_REGEX.PHONE_NUMBER.test(phoneNumber);\n\n  return isValidNumber;\n};\n\nMeetingInfoUtil.getHydraId = function (destination) {\n  var _deconstructHydraId = (0, _common.deconstructHydraId)(destination),\n      type = _deconstructHydraId.type,\n      id = _deconstructHydraId.id,\n      cluster = _deconstructHydraId.cluster;\n\n  if (id && _constants.UUID_REG.test(id)) {\n    if (type === _constants._ROOM_) {\n      return {\n        room: true,\n        destination: id,\n        cluster: cluster\n      };\n    }\n\n    if (type === _constants._PEOPLE_) {\n      return {\n        people: true,\n        destination: id,\n        cluster: cluster\n      };\n    }\n\n    return {};\n  }\n\n  return {};\n};\n\nMeetingInfoUtil.getSipUriFromHydraPersonId = function (destination, webex) {\n  return webex.people.get(destination).then(function (res) {\n    if (res.emails && res.emails.length) {\n      return res.emails[0];\n    }\n\n    throw new _parameter.default('Hydra Id Lookup was an invalid hydra person id.');\n  }).catch(function (err) {\n    _loggerProxy.default.logger.error(\"Meeting-info:util#MeetingInfoUtil.getSipUriFromHydraPersonId --> getSipUriFromHydraPersonId \".concat(err, \" \"));\n\n    throw err;\n  });\n};\n\nMeetingInfoUtil.getDestinationType = /*#__PURE__*/function () {\n  var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(from) {\n    var type, webex, destination, _options, res, _res$items$, orgId, userId, options, hydraId, conversationUrl;\n\n    return _regenerator.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            type = from.type, webex = from.webex;\n            destination = from.destination;\n\n            if (!(type === _constants._PERSONAL_ROOM_)) {\n              _context.next = 15;\n              break;\n            }\n\n            if (destination) {\n              _context.next = 7;\n              break;\n            } // if we are not getting anything in desination we fetch org and user ids from webex instance\n\n\n            destination = {\n              userId: webex.internal.device.userId,\n              orgId: webex.internal.device.orgId\n            };\n            _context.next = 15;\n            break;\n\n          case 7:\n            _options = _constants.VALID_EMAIL_ADDRESS.test(destination) ? {\n              email: destination\n            } : {\n              id: destination\n            }; // we are assuming userId as default\n\n            _context.next = 10;\n            return webex.people.list(_options);\n\n          case 10:\n            res = _context.sent;\n            _res$items$ = res.items[0], orgId = _res$items$.orgId, userId = _res$items$.id;\n            userId = (0, _common.deconstructHydraId)(userId).id;\n            orgId = (0, _common.deconstructHydraId)(orgId).id;\n            destination = {\n              userId: userId,\n              orgId: orgId\n            };\n\n          case 15:\n            if (!type) {\n              _context.next = 17;\n              break;\n            }\n\n            return _context.abrupt(\"return\", {\n              destination: destination,\n              type: type\n            });\n\n          case 17:\n            options = {};\n            hydraId = MeetingInfoUtil.getHydraId(destination);\n\n            if (!MeetingInfoUtil.isMeetingLink(destination)) {\n              _context.next = 25;\n              break;\n            }\n\n            _loggerProxy.default.logger.warn('Meeting-info:util#generateOptions --> WARN, use of Meeting Link is deprecated, please use a SIP URI instead');\n\n            options.type = _constants._MEETING_LINK_;\n            options.destination = destination;\n            _context.next = 62;\n            break;\n\n          case 25:\n            if (!MeetingInfoUtil.isSipUri(destination)) {\n              _context.next = 30;\n              break;\n            }\n\n            options.type = _constants._SIP_URI_;\n            options.destination = destination;\n            _context.next = 62;\n            break;\n\n          case 30:\n            if (!MeetingInfoUtil.isPhoneNumber(destination)) {\n              _context.next = 35;\n              break;\n            }\n\n            options.type = _constants._SIP_URI_;\n            options.destination = destination;\n            _context.next = 62;\n            break;\n\n          case 35:\n            if (!MeetingInfoUtil.isConversationUrl(destination, webex)) {\n              _context.next = 40;\n              break;\n            }\n\n            options.type = _constants._CONVERSATION_URL_;\n            options.destination = destination;\n            _context.next = 62;\n            break;\n\n          case 40:\n            if (!hydraId.people) {\n              _context.next = 45;\n              break;\n            }\n\n            options.type = _constants._SIP_URI_;\n            return _context.abrupt(\"return\", MeetingInfoUtil.getSipUriFromHydraPersonId(hydraId.destination, webex).then(function (res) {\n              options.destination = res; // Since hydra person ids require a unique case in which they are\n              // entirely converted to a SIP URI, we need to set a flag for detecting\n              // this type of destination.\n              // Since hydra person ids require a unique case in which they are\n              // entirely converted to a SIP URI, we need to set a flag for detecting\n              // this type of destination.\n\n              options.wasHydraPerson = true;\n              return _promise.default.resolve(options);\n            }));\n\n          case 45:\n            if (!hydraId.room) {\n              _context.next = 60;\n              break;\n            }\n\n            options.type = _constants._CONVERSATION_URL_;\n            _context.prev = 47;\n            _context.next = 50;\n            return webex.internal.services.waitForCatalog('postauth');\n\n          case 50:\n            conversationUrl = webex.internal.conversation.getUrlFromClusterId({\n              cluster: hydraId.cluster,\n              id: hydraId.destination\n            });\n            options.destination = conversationUrl;\n            _context.next = 58;\n            break;\n\n          case 54:\n            _context.prev = 54;\n            _context.t0 = _context[\"catch\"](47);\n\n            _loggerProxy.default.logger.error(\"Meeting-info:util#getDestinationType --> \".concat(_context.t0));\n\n            throw _context.t0;\n\n          case 58:\n            _context.next = 62;\n            break;\n\n          case 60:\n            _loggerProxy.default.logger.warn('Meeting-info:util#getDestinationType --> (\\'MeetingInfo is fetched with meeting link, sip uri, phone number, hydra room id, hydra people id, or a conversation url.');\n\n            throw new _parameter.default('MeetingInfo is fetched with meeting link, sip uri, phone number, hydra room id, hydra people id, or a conversation url.');\n\n          case 62:\n            return _context.abrupt(\"return\", _promise.default.resolve(options));\n\n          case 63:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[47, 54]]);\n  }));\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Helper function to build up a correct locus url depending on the value passed\n * @param {Object} options type and value to fetch meeting info\n * @param {String} options.type One of [SIP_URI, PERSONAL_ROOM, MEETING_ID, CONVERSATION_URL, LOCUS_ID, MEETING_LINK]\n * @param {Object} options.destination ?? value.value\n * @returns {Object} returns an object with {resource, method}\n */\n\n\nMeetingInfoUtil.getRequestBody = function (options) {\n  var _destination$info, _destination$info2;\n\n  var type = options.type,\n      destination = options.destination,\n      password = options.password,\n      captchaInfo = options.captchaInfo;\n  var body = {\n    supportHostKey: true\n  };\n\n  switch (type) {\n    case _constants._SIP_URI_:\n      body.sipUrl = destination;\n      break;\n\n    case _constants._PERSONAL_ROOM_:\n      body.userId = destination.userId;\n      body.orgId = destination.orgId;\n      break;\n\n    case _constants._MEETING_ID_:\n      body.meetingKey = destination;\n      break;\n\n    case _constants._CONVERSATION_URL_:\n      body.conversationUrl = destination;\n      break;\n\n    case _constants._LOCUS_ID_:\n      // use meetingID for the completer meeting info for the already started meeting\n      if ((_destination$info = destination.info) !== null && _destination$info !== void 0 && _destination$info.webExMeetingId) {\n        body.meetingKey = destination.info.webExMeetingId;\n      } else if ((_destination$info2 = destination.info) !== null && _destination$info2 !== void 0 && _destination$info2.sipUri) {\n        body.sipUrl = destination.info.sipUri;\n      }\n\n      break;\n\n    case _constants._MEETING_LINK_:\n      body.meetingUrl = destination;\n      break;\n\n    case _constants._MEETING_UUID_:\n      {\n        body.meetingUUID = destination;\n        break;\n      }\n\n    default:\n  }\n\n  if (password) {\n    body.password = password;\n  }\n\n  if (captchaInfo) {\n    body.captchaID = captchaInfo.id;\n    body.captchaVerifyCode = captchaInfo.code;\n  }\n\n  return body;\n};\n\nvar _default = MeetingInfoUtil;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["MeetingInfoUtil","getParsedUrl","link","parsedUrl","url","parse","protocol","HTTPS_PROTOCOL","error","LoggerProxy","logger","warn","isMeetingLink","value","hostNameBool","hostname","includes","WEBEX_DOT_COM","pathNameBool","pathname","MEET","MEET_M","JOIN","isConversationUrl","webex","clusterId","internal","services","getClusterId","endsWith","CONVERSATION_SERVICE","isSipUri","sipString","sipUri","DIALER_REGEX","SIP_ADDRESS","exec","isPhoneNumber","phoneNumber","isValidNumber","PHONE_NUMBER","test","getHydraId","destination","type","id","cluster","UUID_REG","_ROOM_","room","_PEOPLE_","people","getSipUriFromHydraPersonId","get","then","res","emails","length","ParameterError","catch","err","getDestinationType","from","_PERSONAL_ROOM_","_context","userId","device","orgId","options","VALID_EMAIL_ADDRESS","email","list","_res$items$","items","hydraId","_MEETING_LINK_","_SIP_URI_","_CONVERSATION_URL_","wasHydraPerson","_promise","resolve","waitForCatalog","conversationUrl","conversation","getUrlFromClusterId","getRequestBody","password","captchaInfo","body","supportHostKey","sipUrl","_MEETING_ID_","meetingKey","_LOCUS_ID_","info","_destination$info","webExMeetingId","_destination$info2","meetingUrl","_MEETING_UUID_","meetingUUID","captchaID","captchaVerifyCode","code"],"sources":["utilv2.js"],"sourcesContent":["import url from 'url';\n\nimport {\n  deconstructHydraId\n} from '@webex/common';\n\nimport {\n  _SIP_URI_,\n  _PERSONAL_ROOM_,\n  _MEETING_ID_,\n  _CONVERSATION_URL_,\n  _LOCUS_ID_,\n  _MEETING_LINK_,\n  _PEOPLE_,\n  _ROOM_,\n  _MEETING_UUID_,\n  DIALER_REGEX,\n  WEBEX_DOT_COM,\n  CONVERSATION_SERVICE,\n  JOIN,\n  MEET,\n  MEET_M,\n  HTTPS_PROTOCOL,\n  UUID_REG,\n  VALID_EMAIL_ADDRESS\n} from '../constants';\nimport ParameterError from '../common/errors/parameter';\nimport LoggerProxy from '../common/logs/logger-proxy';\n\nconst MeetingInfoUtil = {};\n\nMeetingInfoUtil.getParsedUrl = (link) => {\n  try {\n    let parsedUrl = url.parse(link);\n\n    if (!parsedUrl) {\n      return false;\n    }\n    // hack for links such as <company>.webex.com/meet/<user> without a protocol\n    if (!parsedUrl.protocol) {\n      parsedUrl = url.parse(`${HTTPS_PROTOCOL}${link}`);\n    }\n\n    return parsedUrl;\n  }\n  catch (error) {\n    LoggerProxy.logger.warn(`Meeting-info:util#getParsedUrl --> unable to parse the URL, error: ${error}`);\n\n    return null;\n  }\n};\n\n/**\n * Helper function to check if a string matches a known meeting link pattern\n * @param {String} value  string to parse and see if it matches a meeting link\n * @returns {Boolean}\n */\nMeetingInfoUtil.isMeetingLink = (value) => {\n  const parsedUrl = MeetingInfoUtil.getParsedUrl(value);\n  const hostNameBool = parsedUrl.hostname && parsedUrl.hostname.includes(WEBEX_DOT_COM);\n  const pathNameBool = parsedUrl.pathname && (parsedUrl.pathname.includes(`/${MEET}`) || parsedUrl.pathname.includes(`/${MEET_M}`) || parsedUrl.pathname.includes(`/${JOIN}`));\n\n  return hostNameBool && pathNameBool;\n};\n\nMeetingInfoUtil.isConversationUrl = (value, webex) => {\n  const clusterId = webex.internal.services.getClusterId(value);\n\n  if (clusterId) {\n    return clusterId.endsWith(CONVERSATION_SERVICE);\n  }\n\n  return false;\n};\n\n\nMeetingInfoUtil.isSipUri = (sipString) => {\n  // TODO: lets remove regex from this equation and user URI matchers and such\n  // have not found a great sip uri parser library as of now\n  const sipUri = DIALER_REGEX.SIP_ADDRESS.exec(sipString);\n\n  return sipUri;\n};\n\nMeetingInfoUtil.isPhoneNumber = (phoneNumber) => {\n  const isValidNumber = DIALER_REGEX.PHONE_NUMBER.test(phoneNumber);\n\n  return isValidNumber;\n};\n\nMeetingInfoUtil.getHydraId = (destination) => {\n  const {type, id, cluster} = deconstructHydraId(destination);\n\n  if (id && UUID_REG.test(id)) {\n    if (type === _ROOM_) {\n      return {room: true, destination: id, cluster};\n    }\n    if (type === _PEOPLE_) {\n      return {people: true, destination: id, cluster};\n    }\n\n    return {};\n  }\n\n  return {};\n};\n\nMeetingInfoUtil.getSipUriFromHydraPersonId = (destination, webex) => webex.people.get(destination).then((res) => {\n  if (res.emails && res.emails.length) {\n    return res.emails[0];\n  }\n  throw new ParameterError('Hydra Id Lookup was an invalid hydra person id.');\n}).catch((err) => {\n  LoggerProxy.logger.error(`Meeting-info:util#MeetingInfoUtil.getSipUriFromHydraPersonId --> getSipUriFromHydraPersonId ${err} `);\n  throw err;\n});\n\n\nMeetingInfoUtil.getDestinationType = async (from) => {\n  const {type, webex} = from;\n  let {destination} = from;\n\n  if (type === _PERSONAL_ROOM_) { // this case checks if your type is personal room\n    if (!destination) { // if we are not getting anything in desination we fetch org and user ids from webex instance\n      destination = {\n        userId: webex.internal.device.userId,\n        orgId: webex.internal.device.orgId\n      };\n    }\n    else {\n      const options = VALID_EMAIL_ADDRESS.test(destination) ? {email: destination} : {id: destination};// we are assuming userId as default\n      const res = await webex.people.list(options);\n\n      let {orgId, id: userId} = res.items[0];\n\n      userId = deconstructHydraId(userId).id;\n      orgId = deconstructHydraId(orgId).id;\n      destination = {userId, orgId};\n    }\n  }\n  if (type) {\n    return {\n      destination,\n      type\n    };\n  }\n  const options = {};\n  const hydraId = MeetingInfoUtil.getHydraId(destination);\n\n  if (MeetingInfoUtil.isMeetingLink(destination)) {\n    LoggerProxy.logger.warn('Meeting-info:util#generateOptions --> WARN, use of Meeting Link is deprecated, please use a SIP URI instead');\n\n    options.type = _MEETING_LINK_;\n    options.destination = destination;\n  }\n  else if (MeetingInfoUtil.isSipUri(destination)) {\n    options.type = _SIP_URI_;\n    options.destination = destination;\n  }\n  else if (MeetingInfoUtil.isPhoneNumber(destination)) {\n    options.type = _SIP_URI_;\n    options.destination = destination;\n  }\n  else if (MeetingInfoUtil.isConversationUrl(destination, webex)) {\n    options.type = _CONVERSATION_URL_;\n    options.destination = destination;\n  }\n  else if (hydraId.people) {\n    options.type = _SIP_URI_;\n\n    return MeetingInfoUtil.getSipUriFromHydraPersonId(hydraId.destination, webex).then((res) => {\n      options.destination = res;\n\n      // Since hydra person ids require a unique case in which they are\n      // entirely converted to a SIP URI, we need to set a flag for detecting\n      // this type of destination.\n      options.wasHydraPerson = true;\n\n      return Promise.resolve(options);\n    });\n  }\n  else if (hydraId.room) {\n    options.type = _CONVERSATION_URL_;\n    try {\n      await webex.internal.services.waitForCatalog('postauth');\n\n      const conversationUrl = webex.internal.conversation.getUrlFromClusterId({\n        cluster: hydraId.cluster,\n        id: hydraId.destination\n      });\n\n      options.destination = conversationUrl;\n    }\n    catch (e) {\n      LoggerProxy.logger.error(`Meeting-info:util#getDestinationType --> ${e}`);\n      throw (e);\n    }\n  }\n  else {\n    LoggerProxy.logger.warn('Meeting-info:util#getDestinationType --> (\\'MeetingInfo is fetched with meeting link, sip uri, phone number, hydra room id, hydra people id, or a conversation url.');\n    throw new ParameterError('MeetingInfo is fetched with meeting link, sip uri, phone number, hydra room id, hydra people id, or a conversation url.');\n  }\n\n  return Promise.resolve(options);\n};\n\n/**\n * Helper function to build up a correct locus url depending on the value passed\n * @param {Object} options type and value to fetch meeting info\n * @param {String} options.type One of [SIP_URI, PERSONAL_ROOM, MEETING_ID, CONVERSATION_URL, LOCUS_ID, MEETING_LINK]\n * @param {Object} options.destination ?? value.value\n * @returns {Object} returns an object with {resource, method}\n */\nMeetingInfoUtil.getRequestBody = (options) => {\n  const {\n    type, destination, password, captchaInfo\n  } = options;\n  const body = {\n    supportHostKey: true\n  };\n\n  switch (type) {\n    case _SIP_URI_:\n      body.sipUrl = destination;\n      break;\n    case _PERSONAL_ROOM_:\n      body.userId = destination.userId;\n      body.orgId = destination.orgId;\n      break;\n    case _MEETING_ID_:\n      body.meetingKey = destination;\n      break;\n    case _CONVERSATION_URL_:\n      body.conversationUrl = destination;\n      break;\n    case _LOCUS_ID_:\n      // use meetingID for the completer meeting info for the already started meeting\n      if (destination.info?.webExMeetingId) {\n        body.meetingKey = destination.info.webExMeetingId;\n      }\n      else if (destination.info?.sipUri) {\n        body.sipUrl = destination.info.sipUri;\n      }\n      break;\n    case _MEETING_LINK_:\n      body.meetingUrl = destination;\n      break;\n    case _MEETING_UUID_: {\n      body.meetingUUID = destination;\n      break;\n    }\n    default:\n  }\n\n  if (password) {\n    body.password = password;\n  }\n\n  if (captchaInfo) {\n    body.captchaID = captchaInfo.id;\n    body.captchaVerifyCode = captchaInfo.code;\n  }\n\n  return body;\n};\n\nexport default MeetingInfoUtil;\n"]},"metadata":{},"sourceType":"script"}