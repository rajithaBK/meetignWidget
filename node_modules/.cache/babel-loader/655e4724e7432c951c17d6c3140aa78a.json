{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime-corejs2/regenerator\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/asyncToGenerator\"));\n\nvar _url = _interopRequireDefault(require(\"url\"));\n\nvar _btoa = _interopRequireDefault(require(\"btoa\"));\n\nvar _common = require(\"@webex/common\");\n\nvar _parameter = _interopRequireDefault(require(\"../common/errors/parameter\"));\n\nvar _loggerProxy = _interopRequireDefault(require(\"../common/logs/logger-proxy\"));\n\nvar _constants = require(\"../constants\");\n\nvar MeetingInfoUtil = {};\n\nMeetingInfoUtil.extractDestination = function (destination, type) {\n  var dest = destination;\n\n  if (type === _constants._LOCUS_ID_) {\n    if (!(destination && destination.url)) {\n      throw new _parameter.default('You cannot create a meeting by locus without a locus.url defined');\n    }\n\n    dest = destination.url;\n  }\n\n  return dest;\n};\n\nMeetingInfoUtil.getParsedUrl = function (link) {\n  try {\n    var parsedUrl = _url.default.parse(link);\n\n    if (!parsedUrl) {\n      return false;\n    } // hack for links such as <company>.webex.com/meet/<user> without a protocol\n\n\n    if (!parsedUrl.protocol) {\n      parsedUrl = _url.default.parse(\"\".concat(_constants.HTTPS_PROTOCOL).concat(link));\n    }\n\n    return parsedUrl;\n  } catch (error) {\n    _loggerProxy.default.logger.warn(\"Meeting-info:util#getParsedUrl --> unable to parse the URL, error: \".concat(error));\n\n    return null;\n  }\n};\n/**\n * Helper function to check if a string matches a known meeting link pattern\n * @param {String} value  string to parse and see if it matches a meeting link\n * @returns {Boolean}\n */\n\n\nMeetingInfoUtil.isMeetingLink = function (value) {\n  var parsedUrl = MeetingInfoUtil.getParsedUrl(value);\n  var hostNameBool = parsedUrl.hostname && parsedUrl.hostname.includes(_constants.WEBEX_DOT_COM);\n  var pathNameBool = parsedUrl.pathname && (parsedUrl.pathname.includes(\"/\".concat(_constants.MEET)) || parsedUrl.pathname.includes(\"/\".concat(_constants.MEET_M)) || parsedUrl.pathname.includes(\"/\".concat(_constants.JOIN)));\n  return hostNameBool && pathNameBool;\n};\n\nMeetingInfoUtil.isConversationUrl = function (value, webex) {\n  var clusterId = webex.internal.services.getClusterId(value);\n\n  if (clusterId) {\n    return clusterId.endsWith(_constants.CONVERSATION_SERVICE);\n  }\n\n  return false;\n};\n\nMeetingInfoUtil.convertLinkToSip = function (value) {\n  var parsedUrl = MeetingInfoUtil.getParsedUrl(value);\n\n  if (!parsedUrl) {\n    return null;\n  }\n\n  var user;\n\n  if (parsedUrl.pathname) {\n    var userIndex = parsedUrl.pathname.lastIndexOf('/');\n    user = parsedUrl.pathname.substring(userIndex + 1);\n  }\n\n  if (!user) {\n    return null;\n  }\n\n  var company;\n\n  if (parsedUrl.hostname) {\n    var companyIndex = parsedUrl.hostname.lastIndexOf(\".\".concat(_constants.WEBEX_DOT_COM));\n    company = parsedUrl.hostname.substring(0, companyIndex).replace(_constants.WWW_DOT, '');\n  }\n\n  if (!company) {\n    return null;\n  }\n\n  return \"\".concat(user, \"@\").concat(company, \".\").concat(_constants.WEBEX_DOT_COM);\n};\n\nMeetingInfoUtil.isSipUri = function (sipString) {\n  // TODO: lets remove regex from this equation and user URI matchers and such\n  // have not found a great sip uri parser library as of now\n  var sipUri = _constants.DIALER_REGEX.SIP_ADDRESS.exec(sipString);\n\n  return sipUri;\n};\n\nMeetingInfoUtil.isPhoneNumber = function (phoneNumber) {\n  var isValidNumber = _constants.DIALER_REGEX.PHONE_NUMBER.test(phoneNumber);\n\n  return isValidNumber;\n};\n\nMeetingInfoUtil.getHydraId = function (destination) {\n  var _deconstructHydraId = (0, _common.deconstructHydraId)(destination),\n      type = _deconstructHydraId.type,\n      id = _deconstructHydraId.id,\n      cluster = _deconstructHydraId.cluster;\n\n  if (id && _constants.UUID_REG.test(id)) {\n    if (type === _constants._ROOM_) {\n      return {\n        room: true,\n        destination: id,\n        cluster: cluster\n      };\n    }\n\n    if (type === _constants._PEOPLE_) {\n      return {\n        people: true,\n        destination: id,\n        cluster: cluster\n      };\n    }\n\n    return {};\n  }\n\n  return {};\n};\n\nMeetingInfoUtil.getSipUriFromHydraPersonId = function (destination, webex) {\n  return webex.people.get(destination).then(function (res) {\n    if (res.emails && res.emails.length) {\n      return res.emails[0];\n    }\n\n    throw new _parameter.default('Hydra Id Lookup was an invalid hydra person id.');\n  }).catch(function (err) {\n    _loggerProxy.default.logger.error(\"Meeting-info:util#MeetingInfoUtil.getSipUriFromHydraPersonId --> getSipUriFromHydraPersonId \".concat(err, \" \"));\n\n    throw err;\n  });\n};\n\nMeetingInfoUtil.generateOptions = /*#__PURE__*/function () {\n  var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(from) {\n    var destination, type, webex, options, hydraId, conversationUrl;\n    return _regenerator.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            destination = from.destination, type = from.type, webex = from.webex;\n\n            if (!type) {\n              _context.next = 3;\n              break;\n            }\n\n            return _context.abrupt(\"return\", {\n              destination: destination,\n              type: type\n            });\n\n          case 3:\n            options = {};\n            hydraId = MeetingInfoUtil.getHydraId(destination);\n\n            if (!MeetingInfoUtil.isMeetingLink(destination)) {\n              _context.next = 11;\n              break;\n            }\n\n            _loggerProxy.default.logger.warn('Meeting-info:util#generateOptions --> WARN, use of Meeting Link is deprecated, please use a SIP URI instead');\n\n            options.type = _constants._MEETING_LINK_;\n            options.destination = destination;\n            _context.next = 47;\n            break;\n\n          case 11:\n            if (!MeetingInfoUtil.isSipUri(destination)) {\n              _context.next = 16;\n              break;\n            }\n\n            options.type = _constants._SIP_URI_;\n            options.destination = destination;\n            _context.next = 47;\n            break;\n\n          case 16:\n            if (!MeetingInfoUtil.isPhoneNumber(destination)) {\n              _context.next = 21;\n              break;\n            }\n\n            options.type = _constants._SIP_URI_;\n            options.destination = destination;\n            _context.next = 47;\n            break;\n\n          case 21:\n            if (!MeetingInfoUtil.isConversationUrl(destination, webex)) {\n              _context.next = 26;\n              break;\n            }\n\n            options.type = _constants._CONVERSATION_URL_;\n            options.destination = destination;\n            _context.next = 47;\n            break;\n\n          case 26:\n            if (!hydraId.people) {\n              _context.next = 31;\n              break;\n            }\n\n            options.type = _constants._SIP_URI_;\n            return _context.abrupt(\"return\", MeetingInfoUtil.getSipUriFromHydraPersonId(hydraId.destination, webex).then(function (res) {\n              options.destination = res; // Since hydra person ids require a unique case in which they are\n              // entirely converted to a SIP URI, we need to set a flag for detecting\n              // this type of destination.\n              // Since hydra person ids require a unique case in which they are\n              // entirely converted to a SIP URI, we need to set a flag for detecting\n              // this type of destination.\n\n              options.wasHydraPerson = true;\n              return _promise.default.resolve(options);\n            }));\n\n          case 31:\n            if (!hydraId.room) {\n              _context.next = 46;\n              break;\n            }\n\n            options.type = _constants._CONVERSATION_URL_;\n            _context.prev = 33;\n            _context.next = 36;\n            return webex.internal.services.waitForCatalog('postauth');\n\n          case 36:\n            conversationUrl = webex.internal.conversation.getUrlFromClusterId({\n              cluster: hydraId.cluster,\n              id: hydraId.destination\n            });\n            options.destination = conversationUrl;\n            _context.next = 44;\n            break;\n\n          case 40:\n            _context.prev = 40;\n            _context.t0 = _context[\"catch\"](33);\n\n            _loggerProxy.default.logger.error(\"Meeting-info:util#generateOptions --> \".concat(_context.t0));\n\n            throw _context.t0;\n\n          case 44:\n            _context.next = 47;\n            break;\n\n          case 46:\n            throw new _parameter.default('MeetingInfo is fetched with meeting link, sip uri, phone number, hydra room id, hydra people id, or a conversation url.');\n\n          case 47:\n            return _context.abrupt(\"return\", _promise.default.resolve(options));\n\n          case 48:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[33, 40]]);\n  }));\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Helper function to build up a correct locus url depending on the value passed\n * @param {String} type One of [SIP_URI, PERSONAL_ROOM, MEETING_ID, CONVERSATION_URL, LOCUS_ID, MEETING_LINK]\n * @param {Object} value ?? value.value\n * @returns {Object} returns an object with {resource, method}\n */\n\n\nMeetingInfoUtil.getResourceUrl = function (type, value) {\n  var resource = \"/\".concat(_constants.LOCI, \"/\").concat(_constants.MEETINGINFO);\n  var method = _constants.HTTP_VERBS.GET;\n  var uri = null;\n\n  switch (type) {\n    case _constants._SIP_URI_:\n    case _constants._PERSONAL_ROOM_:\n    case _constants._MEETING_ID_:\n      resource = \"/\".concat(_constants.LOCI, \"/\").concat(_constants.MEETINGINFO, \"/\").concat(encodeURIComponent(value), \"?\").concat(_constants.TYPE, \"=\").concat(type, \"&\").concat(_constants.USE_URI_LOOKUP_FALSE);\n      break;\n\n    case _constants._CONVERSATION_URL_:\n      method = _constants.HTTP_VERBS.PUT;\n      break;\n\n    case _constants._LOCUS_ID_:\n      uri = \"\".concat(value, \"/\").concat(_constants.MEETINGINFO);\n      method = _constants.HTTP_VERBS.PUT;\n      break;\n\n    case _constants._MEETING_LINK_:\n      resource = \"$/\".concat(_constants.LOCI, \"/\").concat(_constants.MEETINGINFO, \"/\").concat((0, _btoa.default)(value), \"?\").concat(_constants.TYPE, \"=\").concat(_constants._MEETING_LINK_, \"&\").concat(_constants.USE_URI_LOOKUP_FALSE);\n      break;\n\n    default:\n  }\n\n  return {\n    uri: uri,\n    resource: resource,\n    method: method\n  };\n};\n\nMeetingInfoUtil.getRequestParams = function (resourceOptions, type, value, api) {\n  var requestParams = {\n    method: resourceOptions.method,\n    api: api,\n    resource: resourceOptions.resource\n  };\n\n  if (resourceOptions.method === _constants.HTTP_VERBS.GET) {\n    // for handling URL redirections\n    requestParams.resource = requestParams.resource.concat(\"&\".concat(_constants.ALTERNATE_REDIRECT_TRUE));\n  } else if (type !== _constants._LOCUS_ID_) {\n    // locus id check is a PUT not sure why\n    requestParams.resource = requestParams.resource.concat(\"?\".concat(_constants.ALTERNATE_REDIRECT_TRUE));\n    requestParams.body = {\n      value: value,\n      lookupType: type\n    };\n  } else if (type === _constants._LOCUS_ID_) {\n    requestParams = {\n      method: resourceOptions.method,\n      uri: resourceOptions.uri\n    };\n  }\n\n  return requestParams;\n};\n\nvar _default = MeetingInfoUtil;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["MeetingInfoUtil","extractDestination","destination","type","dest","_LOCUS_ID_","url","ParameterError","getParsedUrl","link","parsedUrl","parse","protocol","HTTPS_PROTOCOL","error","LoggerProxy","logger","warn","isMeetingLink","value","hostNameBool","hostname","includes","WEBEX_DOT_COM","pathNameBool","pathname","MEET","MEET_M","JOIN","isConversationUrl","webex","clusterId","internal","services","getClusterId","endsWith","CONVERSATION_SERVICE","convertLinkToSip","user","userIndex","lastIndexOf","substring","company","companyIndex","replace","WWW_DOT","isSipUri","sipString","sipUri","DIALER_REGEX","SIP_ADDRESS","exec","isPhoneNumber","phoneNumber","isValidNumber","PHONE_NUMBER","test","getHydraId","id","cluster","UUID_REG","_ROOM_","room","_PEOPLE_","people","getSipUriFromHydraPersonId","get","then","res","emails","length","catch","err","generateOptions","from","_context","options","hydraId","_MEETING_LINK_","_SIP_URI_","_CONVERSATION_URL_","wasHydraPerson","_promise","resolve","waitForCatalog","conversationUrl","conversation","getUrlFromClusterId","getResourceUrl","resource","LOCI","MEETINGINFO","method","HTTP_VERBS","GET","uri","_PERSONAL_ROOM_","_MEETING_ID_","encodeURIComponent","TYPE","USE_URI_LOOKUP_FALSE","PUT","getRequestParams","resourceOptions","api","requestParams","concat","ALTERNATE_REDIRECT_TRUE","body","lookupType"],"sources":["util.js"],"sourcesContent":["import url from 'url';\n\nimport btoa from 'btoa';\nimport {\n  deconstructHydraId\n} from '@webex/common';\n\nimport ParameterError from '../common/errors/parameter';\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport {\n  _SIP_URI_,\n  _PERSONAL_ROOM_,\n  _MEETING_ID_,\n  _CONVERSATION_URL_,\n  _LOCUS_ID_,\n  _MEETING_LINK_,\n  _PEOPLE_,\n  _ROOM_,\n  HTTP_VERBS,\n  USE_URI_LOOKUP_FALSE,\n  TYPE,\n  LOCI,\n  MEETINGINFO,\n  ALTERNATE_REDIRECT_TRUE,\n  DIALER_REGEX,\n  WEBEX_DOT_COM,\n  CONVERSATION_SERVICE,\n  WWW_DOT,\n  JOIN,\n  MEET,\n  MEET_M,\n  HTTPS_PROTOCOL,\n  UUID_REG\n} from '../constants';\n\nconst MeetingInfoUtil = {};\n\nMeetingInfoUtil.extractDestination = (destination, type) => {\n  let dest = destination;\n\n  if (type === _LOCUS_ID_) {\n    if (!(destination && destination.url)) {\n      throw new ParameterError('You cannot create a meeting by locus without a locus.url defined');\n    }\n    dest = destination.url;\n  }\n\n  return dest;\n};\n\nMeetingInfoUtil.getParsedUrl = (link) => {\n  try {\n    let parsedUrl = url.parse(link);\n\n    if (!parsedUrl) {\n      return false;\n    }\n    // hack for links such as <company>.webex.com/meet/<user> without a protocol\n    if (!parsedUrl.protocol) {\n      parsedUrl = url.parse(`${HTTPS_PROTOCOL}${link}`);\n    }\n\n    return parsedUrl;\n  }\n  catch (error) {\n    LoggerProxy.logger.warn(`Meeting-info:util#getParsedUrl --> unable to parse the URL, error: ${error}`);\n\n    return null;\n  }\n};\n\n/**\n * Helper function to check if a string matches a known meeting link pattern\n * @param {String} value  string to parse and see if it matches a meeting link\n * @returns {Boolean}\n */\nMeetingInfoUtil.isMeetingLink = (value) => {\n  const parsedUrl = MeetingInfoUtil.getParsedUrl(value);\n  const hostNameBool = parsedUrl.hostname && parsedUrl.hostname.includes(WEBEX_DOT_COM);\n  const pathNameBool = parsedUrl.pathname && (parsedUrl.pathname.includes(`/${MEET}`) || parsedUrl.pathname.includes(`/${MEET_M}`) || parsedUrl.pathname.includes(`/${JOIN}`));\n\n  return hostNameBool && pathNameBool;\n};\n\nMeetingInfoUtil.isConversationUrl = (value, webex) => {\n  const clusterId = webex.internal.services.getClusterId(value);\n\n  if (clusterId) {\n    return clusterId.endsWith(CONVERSATION_SERVICE);\n  }\n\n  return false;\n};\n\nMeetingInfoUtil.convertLinkToSip = (value) => {\n  const parsedUrl = MeetingInfoUtil.getParsedUrl(value);\n\n  if (!parsedUrl) {\n    return null;\n  }\n  let user;\n\n  if (parsedUrl.pathname) {\n    const userIndex = parsedUrl.pathname.lastIndexOf('/');\n\n    user = parsedUrl.pathname.substring(userIndex + 1);\n  }\n  if (!user) {\n    return null;\n  }\n  let company;\n\n  if (parsedUrl.hostname) {\n    const companyIndex = parsedUrl.hostname.lastIndexOf(`.${WEBEX_DOT_COM}`);\n\n    company = parsedUrl.hostname.substring(0, companyIndex).replace(WWW_DOT, '');\n  }\n  if (!company) {\n    return null;\n  }\n\n  return `${user}@${company}.${WEBEX_DOT_COM}`;\n};\n\n\nMeetingInfoUtil.isSipUri = (sipString) => {\n  // TODO: lets remove regex from this equation and user URI matchers and such\n  // have not found a great sip uri parser library as of now\n  const sipUri = DIALER_REGEX.SIP_ADDRESS.exec(sipString);\n\n  return sipUri;\n};\n\nMeetingInfoUtil.isPhoneNumber = (phoneNumber) => {\n  const isValidNumber = DIALER_REGEX.PHONE_NUMBER.test(phoneNumber);\n\n  return isValidNumber;\n};\n\nMeetingInfoUtil.getHydraId = (destination) => {\n  const {type, id, cluster} = deconstructHydraId(destination);\n\n  if (id && UUID_REG.test(id)) {\n    if (type === _ROOM_) {\n      return {room: true, destination: id, cluster};\n    }\n    if (type === _PEOPLE_) {\n      return {people: true, destination: id, cluster};\n    }\n\n    return {};\n  }\n\n  return {};\n};\n\nMeetingInfoUtil.getSipUriFromHydraPersonId = (destination, webex) => webex.people.get(destination).then((res) => {\n  if (res.emails && res.emails.length) {\n    return res.emails[0];\n  }\n  throw new ParameterError('Hydra Id Lookup was an invalid hydra person id.');\n}).catch((err) => {\n  LoggerProxy.logger.error(`Meeting-info:util#MeetingInfoUtil.getSipUriFromHydraPersonId --> getSipUriFromHydraPersonId ${err} `);\n  throw err;\n});\n\nMeetingInfoUtil.generateOptions = async (from) => {\n  const {destination, type, webex} = from;\n\n  if (type) {\n    return {\n      destination,\n      type\n    };\n  }\n  const options = {};\n  const hydraId = MeetingInfoUtil.getHydraId(destination);\n\n  if (MeetingInfoUtil.isMeetingLink(destination)) {\n    LoggerProxy.logger.warn('Meeting-info:util#generateOptions --> WARN, use of Meeting Link is deprecated, please use a SIP URI instead');\n\n    options.type = _MEETING_LINK_;\n    options.destination = destination;\n  }\n  else if (MeetingInfoUtil.isSipUri(destination)) {\n    options.type = _SIP_URI_;\n    options.destination = destination;\n  }\n  else if (MeetingInfoUtil.isPhoneNumber(destination)) {\n    options.type = _SIP_URI_;\n    options.destination = destination;\n  }\n  else if (MeetingInfoUtil.isConversationUrl(destination, webex)) {\n    options.type = _CONVERSATION_URL_;\n    options.destination = destination;\n  }\n  else if (hydraId.people) {\n    options.type = _SIP_URI_;\n\n    return MeetingInfoUtil.getSipUriFromHydraPersonId(hydraId.destination, webex).then((res) => {\n      options.destination = res;\n\n      // Since hydra person ids require a unique case in which they are\n      // entirely converted to a SIP URI, we need to set a flag for detecting\n      // this type of destination.\n      options.wasHydraPerson = true;\n\n      return Promise.resolve(options);\n    });\n  }\n  else if (hydraId.room) {\n    options.type = _CONVERSATION_URL_;\n    try {\n      await webex.internal.services.waitForCatalog('postauth');\n\n      const conversationUrl = webex.internal.conversation.getUrlFromClusterId({\n        cluster: hydraId.cluster,\n        id: hydraId.destination\n      });\n\n      options.destination = conversationUrl;\n    }\n    catch (e) {\n      LoggerProxy.logger.error(`Meeting-info:util#generateOptions --> ${e}`);\n      throw (e);\n    }\n  }\n  else {\n    throw new ParameterError('MeetingInfo is fetched with meeting link, sip uri, phone number, hydra room id, hydra people id, or a conversation url.');\n  }\n\n  return Promise.resolve(options);\n};\n\n/**\n * Helper function to build up a correct locus url depending on the value passed\n * @param {String} type One of [SIP_URI, PERSONAL_ROOM, MEETING_ID, CONVERSATION_URL, LOCUS_ID, MEETING_LINK]\n * @param {Object} value ?? value.value\n * @returns {Object} returns an object with {resource, method}\n */\nMeetingInfoUtil.getResourceUrl = (type, value) => {\n  let resource = `/${LOCI}/${MEETINGINFO}`;\n  let method = HTTP_VERBS.GET;\n  let uri = null;\n\n  switch (type) {\n    case _SIP_URI_:\n    case _PERSONAL_ROOM_:\n    case _MEETING_ID_:\n      resource = `/${LOCI}/${MEETINGINFO}/${encodeURIComponent(value)}?${TYPE}=${type}&${USE_URI_LOOKUP_FALSE}`;\n      break;\n    case _CONVERSATION_URL_:\n      method = HTTP_VERBS.PUT;\n      break;\n    case _LOCUS_ID_:\n      uri = `${value}/${MEETINGINFO}`;\n      method = HTTP_VERBS.PUT;\n      break;\n    case _MEETING_LINK_:\n      resource = `$/${LOCI}/${MEETINGINFO}/${btoa(value)}?${TYPE}=${_MEETING_LINK_}&${USE_URI_LOOKUP_FALSE}`;\n      break;\n    default:\n  }\n\n  return {\n    uri,\n    resource,\n    method\n  };\n};\n\nMeetingInfoUtil.getRequestParams = (resourceOptions, type, value, api) => {\n  let requestParams = {\n    method: resourceOptions.method,\n    api,\n    resource: resourceOptions.resource\n  };\n\n  if (resourceOptions.method === HTTP_VERBS.GET) {\n    // for handling URL redirections\n    requestParams.resource = requestParams.resource.concat(`&${ALTERNATE_REDIRECT_TRUE}`);\n  }\n  else\n  if (type !== _LOCUS_ID_) {\n    // locus id check is a PUT not sure why\n    requestParams.resource = requestParams.resource.concat(`?${ALTERNATE_REDIRECT_TRUE}`);\n    requestParams.body = {\n      value,\n      lookupType: type\n    };\n  }\n  else if (type === _LOCUS_ID_) {\n    requestParams = {\n      method: resourceOptions.method,\n      uri: resourceOptions.uri\n    };\n  }\n\n  return requestParams;\n};\n\nexport default MeetingInfoUtil;\n"]},"metadata":{},"sourceType":"script"}