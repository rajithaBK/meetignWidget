{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _assign = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/assign\"));\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/keys\"));\n\nvar _entries = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/entries\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/toConsumableArray\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/defineProperty\"));\n\nvar _debounce2 = _interopRequireDefault(require(\"lodash/debounce\"));\n\nvar _constants = require(\"./constants\");\n/**\n * Presence Worker\n * Manages fetches and subscriptions for presence\n * @class\n */\n\n\nvar PresenceWorker = /*#__PURE__*/function () {\n  /**\n   * Constructs a presence worker to execute and\n   * maintain tasks related to presence upkeep.\n   * @returns {undefined}\n   */\n  function PresenceWorker() {\n    (0, _classCallCheck2.default)(this, PresenceWorker);\n    (0, _defineProperty2.default)(this, \"debouncedFetch\", (0, _debounce2.default)(this.checkFetchers, _constants.FETCH_DELAY));\n    this.presences = {}; // current presence objects; updated time\n\n    this.watchers = {}; // counter of visible presence-required objects\n\n    this.fetchers = {}; // waiting to get presence object\n\n    this.flights = {}; // in flight to get presence object\n\n    this.campers = {}; // waiting to subscribe; updated time\n\n    this.subscribers = {}; // current subscriptions; expiration time\n  }\n  /**\n   * Connect to the mercury for presence and starts worker.\n   * @param {object} webex\n   * @returns {undefined}\n   */\n\n\n  (0, _createClass2.default)(PresenceWorker, [{\n    key: \"initialize\",\n    value: function initialize(webex) {\n      var _this = this;\n\n      if (!webex || !webex.internal) {\n        throw new Error('Must initialize Presence Worker with webex!');\n      }\n\n      this.webex = webex;\n      var mercury = this.webex.internal.mercury.connected ? _promise.default.resolve() : this.webex.internal.mercury.connect();\n      mercury.then(function () {\n        _this.webex.internal.mercury.on(_constants.APHELEIA_SUBSCRIPTION_UPDATE, _this.subscriptionUpdate.bind(_this));\n      });\n      setInterval(this.groundskeeper.bind(this), _constants.GROUNDSKEEPER_INTERVAL);\n    }\n    /**\n     * Trigger a subscription update event.\n     * @param {string} event\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"subscriptionUpdate\",\n    value: function subscriptionUpdate(event) {\n      this.presences[event.data.subject] = new Date().getTime();\n      this.webex.internal.presence.emitEvent(_constants.PRESENCE_UPDATE, {\n        type: _constants.ENVELOPE_TYPE.SUBSCRIPTION,\n        payload: event.data\n      });\n    }\n    /**\n     * Retrieves and subscribes to a user's presence.\n     * @param {string} id\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"enqueue\",\n    value: function enqueue(id) {\n      var now = new Date().getTime();\n\n      if (this.watchers[id]) {\n        this.watchers[id] += 1;\n      } else {\n        this.watchers[id] = 1;\n      }\n\n      if (this.subscribers[id]) {\n        return;\n      }\n\n      if (!this.campers[id]) {\n        this.campers[id] = now;\n      } // Retrieve presence if:\n      // not in flight or\n      // don't already have the presence or\n      // presence has gone stale\n\n\n      if (!this.flights[id] && (!this.presences[id] || this.presences[id] < now - _constants.UPDATE_PRESENCE_DELAY)) {\n        this.fetchers[id] = id;\n        this.debouncedFetch();\n      }\n    }\n    /**\n     * Retract from subscribing to a user's presence.\n     * @param {string} id\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"dequeue\",\n    value: function dequeue(id) {\n      if (this.watchers[id]) {\n        this.watchers[id] -= 1;\n\n        if (this.watchers[id] <= 0) {\n          delete this.watchers[id];\n          delete this.fetchers[id];\n          delete this.campers[id];\n        }\n      }\n    }\n    /**\n     * Retrieve users' presences.\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"checkFetchers\",\n    value: function checkFetchers() {\n      var _this2 = this;\n\n      var boarding = this.fetchers;\n      (0, _assign.default)(this.flights, boarding);\n      this.fetchers = {};\n      this.webex.internal.presence.list((0, _keys.default)(boarding)).then(function (response) {\n        var now = new Date().getTime();\n        response.statusList.forEach(function (presence) {\n          var id = presence.subject;\n          delete _this2.flights[id];\n          _this2.presences[id] = now;\n        });\n\n        _this2.webex.internal.presence.emitEvent(_constants.PRESENCE_UPDATE, {\n          type: _constants.ENVELOPE_TYPE.PRESENCE,\n          payload: response\n        });\n      });\n    }\n  }, {\n    key: \"checkCampers\",\n    value:\n    /**\n     * Determine if we should subscribe to users' presences.\n     * @returns {Array}: User ids to subscribe.\n     */\n    function checkCampers() {\n      var _this3 = this;\n\n      var now = new Date().getTime();\n      var subscribers = [];\n      (0, _entries.default)(this.campers).forEach(function (camper) {\n        var id = camper[0];\n        var time = camper[1]; // Subscribe if they've been camping for a minute\n\n        if (time < now - _constants.SUBSCRIPTION_DELAY) {\n          delete _this3.campers[id];\n          _this3.subscribers[id] = null;\n          subscribers.push(id);\n        }\n      });\n      return subscribers;\n    }\n    /**\n     * Determine if we should re-subscribe or remove users' subscriptions.\n     * @returns {Array}: User ids to re-subscribe.\n     */\n\n  }, {\n    key: \"checkSubscriptions\",\n    value: function checkSubscriptions() {\n      var _this4 = this;\n\n      var now = new Date().getTime();\n      var renewIds = [];\n      (0, _entries.default)(this.subscribers).forEach(function (subscription) {\n        var id = subscription[0];\n        var expiration = subscription[1];\n\n        if (expiration) {\n          // Renew subscription if they're about to expire\n          if (_this4.watchers[id] && now > expiration - _constants.PREMATURE_EXPIRATION_SUBSCRIPTION_TIME) {\n            renewIds.push(id);\n          } else if (now > expiration) {\n            delete _this4.subscribers[id];\n          }\n        }\n      });\n      return renewIds;\n    }\n    /**\n     * Remove expired presence objects.\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"cleanPresences\",\n    value: function cleanPresences() {\n      var _this5 = this;\n\n      var trash = [];\n\n      var tenMinutesAgo = new Date().getTime() - _constants.EXPIRED_PRESENCE_TIME;\n\n      (0, _entries.default)(this.presences).forEach(function (presence) {\n        var id = presence[0];\n        var lastUpdated = presence[1]; // Delete the object if it is stale\n\n        if (lastUpdated < tenMinutesAgo) {\n          delete _this5.presences[id];\n          trash.push(id);\n        }\n      }); // Tells client to delete it too\n\n      if (trash.length) {\n        this.webex.internal.presence.emitEvent(_constants.PRESENCE_UPDATE, {\n          type: _constants.ENVELOPE_TYPE.DELETE,\n          payload: trash\n        });\n      }\n    }\n    /**\n     * Execute chores on an interval.\n     * Checks if we should make new subscribe,\n     * checks if we should re-subscribe,\n     * removes expired subscriptions,\n     * removes expired presence objects.\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"groundskeeper\",\n    value: function groundskeeper() {\n      var _this6 = this;\n\n      var campers = this.checkCampers();\n      var renewSubscriptions = this.checkSubscriptions();\n      var ids = [].concat((0, _toConsumableArray2.default)(campers), (0, _toConsumableArray2.default)(renewSubscriptions));\n\n      if (ids.length) {\n        this.webex.internal.presence.subscribe(ids).then(function (body) {\n          var now = new Date().getTime();\n          body.responses.forEach(function (response) {\n            if (response.responseCode === 200) {\n              var ttl = response.subscriptionTtl * 1000;\n              _this6.subscribers[response.subject] = now + ttl;\n              _this6.presences[response.status.subject] = now;\n            } else {\n              // If it errored for any reason, set the ttl so we clean it out eventually\n              _this6.subscribers[response.subject] = now + _constants.DEFAULT_SUBSCRIPTION_TTL;\n            }\n          });\n        });\n      }\n\n      this.cleanPresences();\n    }\n  }]);\n  return PresenceWorker;\n}();\n\nexports.default = PresenceWorker;","map":{"version":3,"mappings":"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","names":["PresenceWorker","checkFetchers","FETCH_DELAY","presences","watchers","fetchers","flights","campers","subscribers","webex","internal","Error","mercury","connected","_promise","resolve","connect","then","_this","on","APHELEIA_SUBSCRIPTION_UPDATE","subscriptionUpdate","bind","setInterval","groundskeeper","GROUNDSKEEPER_INTERVAL","event","data","subject","Date","getTime","presence","emitEvent","PRESENCE_UPDATE","type","ENVELOPE_TYPE","SUBSCRIPTION","payload","id","now","UPDATE_PRESENCE_DELAY","debouncedFetch","boarding","list","response","statusList","forEach","_this2","PRESENCE","camper","time","SUBSCRIPTION_DELAY","_this3","push","renewIds","subscription","expiration","_this4","PREMATURE_EXPIRATION_SUBSCRIPTION_TIME","trash","tenMinutesAgo","EXPIRED_PRESENCE_TIME","lastUpdated","_this5","length","DELETE","checkCampers","renewSubscriptions","checkSubscriptions","ids","subscribe","body","responses","responseCode","ttl","subscriptionTtl","_this6","status","DEFAULT_SUBSCRIPTION_TTL","cleanPresences"],"sources":["presence-worker.js"],"sourcesContent":["\nimport {debounce} from 'lodash';\n\nimport {\n  FETCH_DELAY,\n  GROUNDSKEEPER_INTERVAL,\n  SUBSCRIPTION_DELAY,\n  UPDATE_PRESENCE_DELAY,\n  EXPIRED_PRESENCE_TIME,\n  PREMATURE_EXPIRATION_SUBSCRIPTION_TIME,\n  DEFAULT_SUBSCRIPTION_TTL,\n  APHELEIA_SUBSCRIPTION_UPDATE,\n  PRESENCE_UPDATE,\n  ENVELOPE_TYPE\n} from './constants';\n\n/**\n * Presence Worker\n * Manages fetches and subscriptions for presence\n * @class\n */\nexport default class PresenceWorker {\n  /**\n   * Constructs a presence worker to execute and\n   * maintain tasks related to presence upkeep.\n   * @returns {undefined}\n   */\n  constructor() {\n    this.presences = {}; // current presence objects; updated time\n    this.watchers = {}; // counter of visible presence-required objects\n    this.fetchers = {}; // waiting to get presence object\n    this.flights = {}; // in flight to get presence object\n    this.campers = {}; // waiting to subscribe; updated time\n    this.subscribers = {}; // current subscriptions; expiration time\n  }\n\n  /**\n   * Connect to the mercury for presence and starts worker.\n   * @param {object} webex\n   * @returns {undefined}\n   */\n  initialize(webex) {\n    if (!webex || !webex.internal) {\n      throw new Error('Must initialize Presence Worker with webex!');\n    }\n\n    this.webex = webex;\n\n    const mercury = this.webex.internal.mercury.connected ?\n      Promise.resolve() : this.webex.internal.mercury.connect();\n\n    mercury.then(() => {\n      this.webex.internal.mercury.on(APHELEIA_SUBSCRIPTION_UPDATE,\n        this.subscriptionUpdate.bind(this));\n    });\n\n    setInterval(this.groundskeeper.bind(this), GROUNDSKEEPER_INTERVAL);\n  }\n\n  /**\n   * Trigger a subscription update event.\n   * @param {string} event\n   * @returns {undefined}\n   */\n  subscriptionUpdate(event) {\n    this.presences[event.data.subject] = new Date().getTime();\n\n    this.webex.internal.presence.emitEvent(PRESENCE_UPDATE, {\n      type: ENVELOPE_TYPE.SUBSCRIPTION,\n      payload: event.data\n    });\n  }\n\n  /**\n   * Retrieves and subscribes to a user's presence.\n   * @param {string} id\n   * @returns {undefined}\n   */\n  enqueue(id) {\n    const now = new Date().getTime();\n\n    if (this.watchers[id]) {\n      this.watchers[id] += 1;\n    }\n    else {\n      this.watchers[id] = 1;\n    }\n\n    if (this.subscribers[id]) {\n      return;\n    }\n\n    if (!this.campers[id]) {\n      this.campers[id] = now;\n    }\n\n    // Retrieve presence if:\n    // not in flight or\n    // don't already have the presence or\n    // presence has gone stale\n    if (!this.flights[id] &&\n        (!this.presences[id] ||\n        this.presences[id] < now - UPDATE_PRESENCE_DELAY)) {\n      this.fetchers[id] = id;\n      this.debouncedFetch();\n    }\n  }\n\n  /**\n   * Retract from subscribing to a user's presence.\n   * @param {string} id\n   * @returns {undefined}\n   */\n  dequeue(id) {\n    if (this.watchers[id]) {\n      this.watchers[id] -= 1;\n\n      if (this.watchers[id] <= 0) {\n        delete this.watchers[id];\n        delete this.fetchers[id];\n        delete this.campers[id];\n      }\n    }\n  }\n\n  /**\n   * Retrieve users' presences.\n   * @returns {undefined}\n   */\n  checkFetchers() {\n    const boarding = this.fetchers;\n\n    Object.assign(this.flights, boarding);\n    this.fetchers = {};\n\n\n    this.webex.internal.presence.list(Object.keys(boarding))\n      .then((response) => {\n        const now = new Date().getTime();\n\n        response.statusList.forEach((presence) => {\n          const id = presence.subject;\n\n          delete this.flights[id];\n          this.presences[id] = now;\n        });\n\n        this.webex.internal.presence.emitEvent(PRESENCE_UPDATE, {\n          type: ENVELOPE_TYPE.PRESENCE,\n          payload: response\n        });\n      });\n  }\n\n  debouncedFetch = debounce(this.checkFetchers, FETCH_DELAY)\n\n  /**\n   * Determine if we should subscribe to users' presences.\n   * @returns {Array}: User ids to subscribe.\n   */\n  checkCampers() {\n    const now = new Date().getTime();\n    const subscribers = [];\n\n    Object.entries(this.campers).forEach((camper) => {\n      const id = camper[0];\n      const time = camper[1];\n\n      // Subscribe if they've been camping for a minute\n      if (time < now - SUBSCRIPTION_DELAY) {\n        delete this.campers[id];\n        this.subscribers[id] = null;\n        subscribers.push(id);\n      }\n    });\n\n    return subscribers;\n  }\n\n  /**\n   * Determine if we should re-subscribe or remove users' subscriptions.\n   * @returns {Array}: User ids to re-subscribe.\n   */\n  checkSubscriptions() {\n    const now = new Date().getTime();\n\n    const renewIds = [];\n\n    Object.entries(this.subscribers).forEach((subscription) => {\n      const id = subscription[0];\n      const expiration = subscription[1];\n\n      if (expiration) {\n        // Renew subscription if they're about to expire\n        if (this.watchers[id] &&\n            now > expiration - PREMATURE_EXPIRATION_SUBSCRIPTION_TIME) {\n          renewIds.push(id);\n        }\n        else if (now > expiration) {\n          delete this.subscribers[id];\n        }\n      }\n    });\n\n    return renewIds;\n  }\n\n  /**\n   * Remove expired presence objects.\n   * @returns {undefined}\n   */\n  cleanPresences() {\n    const trash = [];\n    const tenMinutesAgo = new Date().getTime() - EXPIRED_PRESENCE_TIME;\n\n    Object.entries(this.presences).forEach((presence) => {\n      const id = presence[0];\n      const lastUpdated = presence[1];\n\n      // Delete the object if it is stale\n      if (lastUpdated < tenMinutesAgo) {\n        delete this.presences[id];\n        trash.push(id);\n      }\n    });\n\n    // Tells client to delete it too\n    if (trash.length) {\n      this.webex.internal.presence.emitEvent(PRESENCE_UPDATE, {\n        type: ENVELOPE_TYPE.DELETE,\n        payload: trash\n      });\n    }\n  }\n\n  /**\n   * Execute chores on an interval.\n   * Checks if we should make new subscribe,\n   * checks if we should re-subscribe,\n   * removes expired subscriptions,\n   * removes expired presence objects.\n   * @returns {undefined}\n   */\n  groundskeeper() {\n    const campers = this.checkCampers();\n    const renewSubscriptions = this.checkSubscriptions();\n\n    const ids = [\n      ...campers,\n      ...renewSubscriptions\n    ];\n\n    if (ids.length) {\n      this.webex.internal.presence.subscribe(ids)\n        .then((body) => {\n          const now = new Date().getTime();\n\n          body.responses.forEach((response) => {\n            if (response.responseCode === 200) {\n              const ttl = response.subscriptionTtl * 1000;\n\n              this.subscribers[response.subject] = now + ttl;\n              this.presences[response.status.subject] = now;\n            }\n            else {\n              // If it errored for any reason, set the ttl so we clean it out eventually\n              this.subscribers[response.subject] = now + DEFAULT_SUBSCRIPTION_TTL;\n            }\n          });\n        });\n    }\n\n    this.cleanPresences();\n  }\n}\n\n"]},"metadata":{},"sourceType":"script"}