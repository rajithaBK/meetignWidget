{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _now = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/date/now\"));\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime-corejs2/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/asyncToGenerator\"));\n\nvar _constants = require(\"../constants\");\n\nvar _loggerProxy = _interopRequireDefault(require(\"../common/logs/logger-proxy\"));\n\nvar _triggerProxy = _interopRequireDefault(require(\"../common/events/trigger-proxy\"));\n/* globals window */\n\n/**\n  * Meetings Media Codec Missing Event\n  * Emitted when H.264 codec is not\n  * found in the browser.\n  * @event media:codec:missing\n  * @instance\n  * @memberof MeetingsUtil\n  */\n\n/**\n  * Meetings Media Codec Loaded Event\n  * Emitted when H.264 codec has been\n  * loaded in the browser.\n  * @event media:codec:loaded\n  * @instance\n  * @memberof MeetingsUtil\n  */\n\n\nvar MeetingsUtil = {};\n\nMeetingsUtil.getMeetingAddedType = function (type) {\n  return type === _constants._LOCUS_ID_ ? _constants._INCOMING_ : _constants._CREATED_;\n};\n\nMeetingsUtil.handleRoapMercury = function (envelope, meetingCollection) {\n  var data = envelope.data;\n  var eventType = data.eventType;\n\n  if (eventType === _constants.LOCUSEVENT.MESSAGE_ROAP) {\n    var meeting = meetingCollection.getByKey(_constants.CORRELATION_ID, data.correlationId);\n\n    if (meeting) {\n      meeting.roap.roapEvent(data);\n    }\n  }\n};\n\nMeetingsUtil.checkForCorrelationId = function (deviceUrl, locus) {\n  var devices = [];\n\n  if (locus) {\n    if (locus && locus.self && locus.self.devices) {\n      devices = locus.self.devices;\n    }\n\n    var foundDevice = devices.find(function (device) {\n      return device.url === deviceUrl;\n    });\n\n    if (foundDevice && foundDevice.correlationId) {\n      return foundDevice.correlationId;\n    }\n  }\n\n  return false;\n};\n/**\n * Will check to see if the H.264 media codec is supported.\n * @async\n * @private\n * @returns {Promise<boolean>}\n */\n\n\nMeetingsUtil.hasH264Codec = /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {\n  var hasCodec, pc, offer;\n  return _regenerator.default.wrap(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          hasCodec = false;\n          _context.prev = 1;\n          pc = new window.RTCPeerConnection();\n          _context.next = 5;\n          return pc.createOffer({\n            offerToReceiveVideo: true\n          });\n\n        case 5:\n          offer = _context.sent;\n\n          if (offer.sdp.match(/^a=rtpmap:\\d+\\s+H264\\/\\d+/m)) {\n            hasCodec = true;\n          }\n\n          pc.close();\n          _context.next = 13;\n          break;\n\n        case 10:\n          _context.prev = 10;\n          _context.t0 = _context[\"catch\"](1);\n\n          _loggerProxy.default.logger.error('Meetings:util#hasH264Codec --> Error creating peerConnection for H.264 test.');\n\n        case 13:\n          return _context.abrupt(\"return\", hasCodec);\n\n        case 14:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _callee, null, [[1, 10]]);\n}));\n/**\n * Notifies the user whether or not the H.264\n * codec is present. Will continuously check\n * until max duration.\n * @async\n * @private\n * @param {object} options\n * @param {Number} options.firstChecked Timestamp in milliseconds\n * @param {boolean} options.disableNotifications Default is false. Boolean to enable/disable notification and events\n * @returns {undefined}\n */\n\nMeetingsUtil.checkH264Support = /*#__PURE__*/function () {\n  var _checkH264Support = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(options) {\n    var _this = this;\n\n    var hasH264Codec, _ref2, firstChecked, disableNotifications, delay, maxDuration, shouldTrigger, shouldStopChecking;\n\n    return _regenerator.default.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            hasH264Codec = MeetingsUtil.hasH264Codec;\n            _ref2 = options || {}, firstChecked = _ref2.firstChecked, disableNotifications = _ref2.disableNotifications;\n            delay = 5e3; // ms\n\n            maxDuration = 3e5; // ms\n\n            shouldTrigger = firstChecked === undefined;\n            shouldStopChecking = firstChecked && (0, _now.default)() - firstChecked >= maxDuration; // Disable notifications and start H.264 download only\n\n            if (!disableNotifications) {\n              _context2.next = 9;\n              break;\n            }\n\n            hasH264Codec();\n            return _context2.abrupt(\"return\");\n\n          case 9:\n            _context2.next = 11;\n            return hasH264Codec();\n\n          case 11:\n            if (!_context2.sent) {\n              _context2.next = 15;\n              break;\n            }\n\n            _triggerProxy.default.trigger(this, {\n              file: 'meetings/util',\n              function: 'checkH264Support'\n            }, _constants.EVENT_TRIGGERS.MEDIA_CODEC_LOADED);\n\n            _loggerProxy.default.logger.log('Meetings:util#checkH264Support --> H264 codec loaded successfully.');\n\n            return _context2.abrupt(\"return\");\n\n          case 15:\n            if (!shouldStopChecking) {\n              _context2.next = 18;\n              break;\n            }\n\n            _loggerProxy.default.logger.error('Meetings:util#checkH264Support --> Timed out waiting for H264 codec to load.');\n\n            return _context2.abrupt(\"return\");\n\n          case 18:\n            // Trigger only once\n            if (shouldTrigger) {\n              _triggerProxy.default.trigger(this, {\n                file: 'meetings/util',\n                function: 'checkH264Support'\n              }, _constants.EVENT_TRIGGERS.MEDIA_CODEC_MISSING);\n\n              _loggerProxy.default.logger.log('Meetings:util#checkH264Support --> H264 codec is missing.');\n            } // Keep checking in intervals to see if codec loaded\n\n\n            window.setTimeout(function () {\n              var timestamp = firstChecked || (0, _now.default)();\n              MeetingsUtil.checkH264Support.call(_this, {\n                firstChecked: timestamp\n              });\n            }, delay);\n\n          case 20:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, this);\n  }));\n\n  function checkH264Support(_x) {\n    return _checkH264Support.apply(this, arguments);\n  }\n\n  return checkH264Support;\n}();\n\nvar _default = MeetingsUtil;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["MeetingsUtil","getMeetingAddedType","type","_LOCUS_ID_","_INCOMING_","_CREATED_","handleRoapMercury","envelope","meetingCollection","data","eventType","LOCUSEVENT","MESSAGE_ROAP","meeting","getByKey","CORRELATION_ID","correlationId","roap","roapEvent","checkForCorrelationId","deviceUrl","locus","devices","self","foundDevice","find","device","url","hasH264Codec","hasCodec","_context","pc","window","RTCPeerConnection","createOffer","offerToReceiveVideo","offer","sdp","match","close","LoggerProxy","logger","error","checkH264Support","options","_ref2","firstChecked","disableNotifications","delay","maxDuration","shouldTrigger","undefined","shouldStopChecking","_context2","Trigger","trigger","file","function","EVENT_TRIGGERS","MEDIA_CODEC_LOADED","log","MEDIA_CODEC_MISSING","setTimeout","timestamp","call","_this"],"sources":["util.js"],"sourcesContent":["/* globals window */\n\nimport {\n  _LOCUS_ID_,\n  _INCOMING_,\n  _CREATED_,\n  LOCUSEVENT,\n  CORRELATION_ID,\n  EVENT_TRIGGERS\n} from '../constants';\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport Trigger from '../common/events/trigger-proxy';\n\n/**\n  * Meetings Media Codec Missing Event\n  * Emitted when H.264 codec is not\n  * found in the browser.\n  * @event media:codec:missing\n  * @instance\n  * @memberof MeetingsUtil\n  */\n\n/**\n  * Meetings Media Codec Loaded Event\n  * Emitted when H.264 codec has been\n  * loaded in the browser.\n  * @event media:codec:loaded\n  * @instance\n  * @memberof MeetingsUtil\n  */\n\nconst MeetingsUtil = {};\n\nMeetingsUtil.getMeetingAddedType = (type) => (type === _LOCUS_ID_ ? _INCOMING_ : _CREATED_);\n\nMeetingsUtil.handleRoapMercury = (envelope, meetingCollection) => {\n  const {data} = envelope;\n  const {eventType} = data;\n\n  if (eventType === LOCUSEVENT.MESSAGE_ROAP) {\n    const meeting = meetingCollection.getByKey(CORRELATION_ID, data.correlationId);\n\n    if (meeting) {\n      meeting.roap.roapEvent(data);\n    }\n  }\n};\n\nMeetingsUtil.checkForCorrelationId = (deviceUrl, locus) => {\n  let devices = [];\n\n  if (locus) {\n    if (locus && locus.self && locus.self.devices) {\n      devices = locus.self.devices;\n    }\n\n    const foundDevice = devices.find((device) => device.url === deviceUrl);\n\n    if (foundDevice && foundDevice.correlationId) {\n      return foundDevice.correlationId;\n    }\n  }\n\n  return false;\n};\n\n\n/**\n * Will check to see if the H.264 media codec is supported.\n * @async\n * @private\n * @returns {Promise<boolean>}\n */\nMeetingsUtil.hasH264Codec = async () => {\n  let hasCodec = false;\n\n  try {\n    const pc = new window.RTCPeerConnection();\n    const offer = await pc.createOffer({offerToReceiveVideo: true});\n\n    if (offer.sdp.match(/^a=rtpmap:\\d+\\s+H264\\/\\d+/m)) {\n      hasCodec = true;\n    }\n    pc.close();\n  }\n  catch (error) {\n    LoggerProxy.logger.error('Meetings:util#hasH264Codec --> Error creating peerConnection for H.264 test.');\n  }\n\n  return hasCodec;\n};\n\n\n/**\n * Notifies the user whether or not the H.264\n * codec is present. Will continuously check\n * until max duration.\n * @async\n * @private\n * @param {object} options\n * @param {Number} options.firstChecked Timestamp in milliseconds\n * @param {boolean} options.disableNotifications Default is false. Boolean to enable/disable notification and events\n * @returns {undefined}\n */\nMeetingsUtil.checkH264Support = async function checkH264Support(options) {\n  const {hasH264Codec} = MeetingsUtil;\n  const {firstChecked, disableNotifications} = options || {};\n  const delay = 5e3; // ms\n  const maxDuration = 3e5; // ms\n  const shouldTrigger = (firstChecked === undefined);\n  const shouldStopChecking = firstChecked && (Date.now() - firstChecked) >= maxDuration;\n\n  // Disable notifications and start H.264 download only\n  if (disableNotifications) {\n    hasH264Codec();\n\n    return;\n  }\n\n  // Codec loaded trigger event notification\n  if (await hasH264Codec()) {\n    Trigger.trigger(\n      this,\n      {\n        file: 'meetings/util',\n        function: 'checkH264Support'\n      },\n      EVENT_TRIGGERS.MEDIA_CODEC_LOADED\n    );\n    LoggerProxy.logger.log('Meetings:util#checkH264Support --> H264 codec loaded successfully.');\n\n    return;\n  }\n\n  // Stop checking if past the timelimit\n  if (shouldStopChecking) {\n    LoggerProxy.logger.error('Meetings:util#checkH264Support --> Timed out waiting for H264 codec to load.');\n\n    return;\n  }\n\n  // Trigger only once\n  if (shouldTrigger) {\n    Trigger.trigger(\n      this,\n      {\n        file: 'meetings/util',\n        function: 'checkH264Support'\n      },\n      EVENT_TRIGGERS.MEDIA_CODEC_MISSING\n    );\n    LoggerProxy.logger.log('Meetings:util#checkH264Support --> H264 codec is missing.');\n  }\n\n  // Keep checking in intervals to see if codec loaded\n  window.setTimeout(() => {\n    const timestamp = firstChecked || Date.now();\n\n    MeetingsUtil.checkH264Support.call(this, {firstChecked: timestamp});\n  }, delay);\n};\n\nexport default MeetingsUtil;\n"]},"metadata":{},"sourceType":"script"}