{"ast":null,"code":"\"use strict\";\n\nvar _Reflect$construct = require(\"@babel/runtime-corejs2/core-js/reflect/construct\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _deleteProperty = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/reflect/delete-property\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/createClass\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/getPrototypeOf\"));\n\nvar _httpCore = require(\"@webex/http-core\");\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2.default)(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;\n      result = _Reflect$construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0, _possibleConstructorReturn2.default)(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false;\n  if (_Reflect$construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * @class\n */\n\n\nvar AuthInterceptor = /*#__PURE__*/function (_Interceptor) {\n  (0, _inherits2.default)(AuthInterceptor, _Interceptor);\n\n  var _super = _createSuper(AuthInterceptor);\n\n  function AuthInterceptor() {\n    (0, _classCallCheck2.default)(this, AuthInterceptor);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(AuthInterceptor, [{\n    key: \"onRequest\",\n    value:\n    /**\n     * @see {@link Interceptor#onRequest}\n     * @param {Object} options\n     * @returns {Object}\n     */\n    function onRequest(options) {\n      var _this = this;\n\n      options.headers = options.headers || {}; // If Authorizations is already set, don't overwrite it\n\n      if ('authorization' in options.headers || 'auth' in options) {\n        // If Authorization is set to null, false, or undefined, delete it to\n        // prevent a CORS preflight.\n        if (!options.headers.authorization) {\n          (0, _deleteProperty.default)(options.headers, 'authorization');\n        }\n\n        return _promise.default.resolve(options);\n      }\n\n      return this.requiresCredentials(options).then(function (requires) {\n        if (!requires) {\n          return options;\n        }\n\n        return _this.webex.credentials.getUserToken().then(function (token) {\n          options.headers.authorization = token.toString();\n          return options;\n        });\n      });\n    }\n    /**\n     * Determines if the provided options object needs an authorization header.\n     *\n     * @param {Object} options\n     * @returns {Promise<boolean>}\n     */\n\n  }, {\n    key: \"requiresCredentials\",\n    value: function requiresCredentials(options) {\n      var _this2 = this; // Validate that authorization is necessary.\n\n\n      if (options.addAuthHeader === false) {\n        return _promise.default.resolve(false);\n      } // Validate that the services plugin has been loaded before proceeding.\n\n\n      if (!this.webex.internal.services) {\n        return _promise.default.resolve(false);\n      } // Destructure webex instance to isolate services plugin.\n\n\n      var services = this.webex.internal.services; // Store the current service details if available and destructure details.\n\n      var details = services.getServiceFromUrl(options.uri || '');\n\n      var _ref = details || {},\n          name = _ref.name;\n\n      var resource = options.resource,\n          uri = options.uri;\n      var service = options.service || options.api; // Unique validation for the u2c service.\n\n      if (service && service === 'u2c' || name && name === 'u2c') {\n        if (resource && resource.includes('limited') || uri && uri.includes('limited')) {\n          return _promise.default.resolve(false);\n        }\n\n        return _promise.default.resolve(true);\n      } // Validate that the allowed domains can be utilized.\n\n\n      if (services.validateDomains && services.hasAllowedDomains() && uri && services.isAllowedDomainUrl(uri)) {\n        return _promise.default.resolve(true);\n      } // Perform an additional validation in case the service does not exist yet.\n\n\n      return services.waitForService({\n        name: service,\n        url: uri\n      }).then(function (detectedUrl) {\n        // Validate that the url exists in the catalog.\n        if (services.getServiceFromUrl(detectedUrl)) {\n          return true;\n        } // Return false to indicate authentication is not required.\n\n\n        return false;\n      }).catch(function (error) {\n        _this2.webex.logger.warn('auth-interceptor: failed to validate service exists in catalog', error);\n\n        return false;\n      });\n    }\n    /**\n     * @see {@link Interceptor#onResponseError}\n     * @param {Object} options\n     * @param {Error} reason\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"onResponseError\",\n    value: function onResponseError(options, reason) {\n      var _this3 = this;\n\n      return this.shouldAttemptReauth(reason, options).then(function (shouldAttemptReauth) {\n        if (shouldAttemptReauth) {\n          _this3.webex.logger.info('auth: received 401, attempting to reauthenticate');\n\n          if (reason.options.headers) {\n            (0, _deleteProperty.default)(reason.options.headers, 'authorization');\n          }\n\n          if (_this3.webex.credentials.canRefresh) {\n            return _this3.webex.credentials.refresh().then(function () {\n              return _this3.replay(options);\n            });\n          }\n        }\n\n        return _promise.default.reject(reason);\n      });\n    }\n    /**\n     * Replays the request\n     * @param {Object} options\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"replay\",\n    value: function replay(options) {\n      if (options.replayCount) {\n        options.replayCount += 1;\n      } else {\n        options.replayCount = 1;\n      }\n\n      if (options.replayCount > this.webex.config.maxAuthenticationReplays) {\n        this.webex.logger.error(\"auth: failed after \".concat(this.webex.config.maxAuthenticationReplays, \" replay attempts\"));\n        return _promise.default.reject(new Error(\"Failed after \".concat(this.webex.config.maxAuthenticationReplays, \" replay attempts\")));\n      }\n\n      this.webex.logger.info(\"auth: replaying request \".concat(options.replayCount, \" time\"));\n      return this.webex.request(options);\n    }\n    /**\n     * Indicates whether or not the current request should refresh its access\n     * token in event of a 401\n     * @param {Error} reason\n     * @param {Object} options\n     * @returns {Promise<boolean>}\n     */\n\n  }, {\n    key: \"shouldAttemptReauth\",\n    value: function shouldAttemptReauth(reason, options) {\n      if (options && options.shouldRefreshAccessToken === false) {\n        return _promise.default.resolve(false);\n      }\n\n      if (reason.statusCode === 401) {\n        return _promise.default.resolve(true);\n      }\n\n      return _promise.default.resolve(false);\n    }\n  }], [{\n    key: \"create\",\n    value:\n    /**\n     * @returns {AuthInterceptor}\n     */\n    function create() {\n      return new AuthInterceptor({\n        webex: this\n      });\n    }\n  }]);\n  return AuthInterceptor;\n}(_httpCore.Interceptor);\n\nexports.default = AuthInterceptor;","map":{"version":3,"mappings":"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","names":["AuthInterceptor","options","headers","authorization","_promise","resolve","requiresCredentials","then","requires","_this","webex","credentials","getUserToken","token","toString","addAuthHeader","internal","services","details","getServiceFromUrl","uri","name","resource","service","api","includes","validateDomains","hasAllowedDomains","isAllowedDomainUrl","waitForService","url","detectedUrl","catch","error","_this2","logger","warn","reason","shouldAttemptReauth","_this3","info","canRefresh","refresh","replay","reject","replayCount","config","maxAuthenticationReplays","Error","request","shouldRefreshAccessToken","statusCode","Interceptor"],"sources":["auth.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {Interceptor} from '@webex/http-core';\n\n/**\n * @class\n */\nexport default class AuthInterceptor extends Interceptor {\n  /**\n   * @returns {AuthInterceptor}\n   */\n  static create() {\n    return new AuthInterceptor({webex: this});\n  }\n\n  /**\n   * @see {@link Interceptor#onRequest}\n   * @param {Object} options\n   * @returns {Object}\n   */\n  onRequest(options) {\n    options.headers = options.headers || {};\n\n    // If Authorizations is already set, don't overwrite it\n    if ('authorization' in options.headers || 'auth' in options) {\n      // If Authorization is set to null, false, or undefined, delete it to\n      // prevent a CORS preflight.\n      if (!options.headers.authorization) {\n        Reflect.deleteProperty(options.headers, 'authorization');\n      }\n\n      return Promise.resolve(options);\n    }\n\n    return this.requiresCredentials(options)\n      .then((requires) => {\n        if (!requires) {\n          return options;\n        }\n\n        return this.webex.credentials.getUserToken()\n          .then((token) => {\n            options.headers.authorization = token.toString();\n\n            return options;\n          });\n      });\n  }\n\n  /**\n   * Determines if the provided options object needs an authorization header.\n   *\n   * @param {Object} options\n   * @returns {Promise<boolean>}\n   */\n  requiresCredentials(options) {\n    // Validate that authorization is necessary.\n    if (options.addAuthHeader === false) {\n      return Promise.resolve(false);\n    }\n\n    // Validate that the services plugin has been loaded before proceeding.\n    if (!this.webex.internal.services) {\n      return Promise.resolve(false);\n    }\n\n    // Destructure webex instance to isolate services plugin.\n    const {services} = this.webex.internal;\n\n    // Store the current service details if available and destructure details.\n    const details = services.getServiceFromUrl(options.uri || '');\n    const {name} = details || {};\n    const {resource, uri} = options;\n    const service = options.service || options.api;\n\n    // Unique validation for the u2c service.\n    if ((service && service === 'u2c') || (name && name === 'u2c')) {\n      if (\n        (resource && resource.includes('limited')) ||\n        (uri && uri.includes('limited'))\n      ) {\n        return Promise.resolve(false);\n      }\n\n      return Promise.resolve(true);\n    }\n\n\n    // Validate that the allowed domains can be utilized.\n    if (services.validateDomains &&\n      services.hasAllowedDomains() &&\n      (uri && services.isAllowedDomainUrl(uri))) {\n      return Promise.resolve(true);\n    }\n\n    // Perform an additional validation in case the service does not exist yet.\n    return services.waitForService({name: service, url: uri})\n      .then((detectedUrl) => {\n        // Validate that the url exists in the catalog.\n        if (services.getServiceFromUrl(detectedUrl)) {\n          return true;\n        }\n\n        // Return false to indicate authentication is not required.\n        return false;\n      })\n      .catch((error) => {\n        this.webex.logger.warn(\n          'auth-interceptor: failed to validate service exists in catalog',\n          error\n        );\n\n        return false;\n      });\n  }\n\n  /**\n   * @see {@link Interceptor#onResponseError}\n   * @param {Object} options\n   * @param {Error} reason\n   * @returns {Object}\n   */\n  onResponseError(options, reason) {\n    return this.shouldAttemptReauth(reason, options)\n      .then((shouldAttemptReauth) => {\n        if (shouldAttemptReauth) {\n          this.webex.logger.info('auth: received 401, attempting to reauthenticate');\n\n          if (reason.options.headers) {\n            Reflect.deleteProperty(reason.options.headers, 'authorization');\n          }\n\n          if (this.webex.credentials.canRefresh) {\n            return this.webex.credentials.refresh()\n              .then(() => this.replay(options));\n          }\n        }\n\n        return Promise.reject(reason);\n      });\n  }\n\n  /**\n   * Replays the request\n   * @param {Object} options\n   * @returns {Object}\n   */\n  replay(options) {\n    if (options.replayCount) {\n      options.replayCount += 1;\n    }\n    else {\n      options.replayCount = 1;\n    }\n\n    if (options.replayCount > this.webex.config.maxAuthenticationReplays) {\n      this.webex.logger.error(`auth: failed after ${this.webex.config.maxAuthenticationReplays} replay attempts`);\n\n      return Promise.reject(new Error(`Failed after ${this.webex.config.maxAuthenticationReplays} replay attempts`));\n    }\n\n    this.webex.logger.info(`auth: replaying request ${options.replayCount} time`);\n\n    return this.webex.request(options);\n  }\n\n  /**\n   * Indicates whether or not the current request should refresh its access\n   * token in event of a 401\n   * @param {Error} reason\n   * @param {Object} options\n   * @returns {Promise<boolean>}\n   */\n  shouldAttemptReauth(reason, options) {\n    if (options && options.shouldRefreshAccessToken === false) {\n      return Promise.resolve(false);\n    }\n\n    if (reason.statusCode === 401) {\n      return Promise.resolve(true);\n    }\n\n    return Promise.resolve(false);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}