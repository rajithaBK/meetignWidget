{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _applyDecoratedDescriptor2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/applyDecoratedDescriptor\"));\n\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/json/stringify\"));\n\nvar _apply = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/reflect/apply\"));\n\nvar _assign = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/assign\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _deleteProperty = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/reflect/delete-property\"));\n\nvar _parseInt2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/parse-int\"));\n\nvar _getOwnPropertyDescriptor = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\"));\n\nvar _omit2 = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _isEmpty2 = _interopRequireDefault(require(\"lodash/isEmpty\"));\n\nvar _cloneDeep2 = _interopRequireDefault(require(\"lodash/cloneDeep\"));\n\nvar _querystring = _interopRequireDefault(require(\"querystring\"));\n\nvar _url = _interopRequireDefault(require(\"url\"));\n\nvar _common = require(\"@webex/common\");\n\nvar _webexCore = require(\"@webex/webex-core\");\n\nvar _uuid = _interopRequireDefault(require(\"uuid\"));\n\nvar _dec, _dec2, _obj;\n\nvar OAUTH2_CSRF_TOKEN = 'oauth2-csrf-token';\n\nvar EMPTY_OBJECT_STRING = _common.base64.encode((0, _stringify.default)({}));\n/**\n * Browser support for OAuth2. Automatically parses the URL hash for an access\n * token\n * @class\n * @name AuthorizationBrowser\n */\n\n\nvar Authorization = _webexCore.WebexPlugin.extend((_dec = (0, _common.whileInFlight)('isAuthorizing'), _dec2 = (0, _common.whileInFlight)('isAuthorizing'), (_obj = {\n  derived: {\n    /**\n     * Alias of {@link AuthorizationBrowser#isAuthorizing}\n     * @instance\n     * @memberof AuthorizationBrowser\n     * @type {boolean}\n     */\n    isAuthenticating: {\n      deps: ['isAuthorizing'],\n      fn: function fn() {\n        return this.isAuthorizing;\n      }\n    }\n  },\n  session: {\n    /**\n     * Indicates if an Authorization Code exchange is inflight\n     * @instance\n     * @memberof AuthorizationBrowser\n     * @type {boolean}\n     */\n    isAuthorizing: {\n      default: false,\n      type: 'boolean'\n    },\n    ready: {\n      default: false,\n      type: 'boolean'\n    }\n  },\n  namespace: 'Credentials',\n\n  /**\n   * Initializer\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} attrs {@link AmpersandState}\n   * @param {boolean} attrs.parse Controls whether or not the the url should get\n   * parsed for an access token\n   * @private\n   * @returns {Authorization}\n   */\n  // eslint-disable-next-line complexity\n  initialize: function initialize(attrs, options) {\n    var _this = this;\n\n    var ret = (0, _apply.default)(_webexCore.WebexPlugin.prototype.initialize, this, [attrs, options]); // Reminder, we can't do parse based on config, because config is not\n    // available until nextTick and we want to be able to throw errors found in\n    // the url.\n\n    if (attrs.parse === false) {\n      this.ready = true;\n      return ret;\n    }\n\n    var location = _url.default.parse(this.webex.getWindow().location.href, true);\n\n    this._checkForErrors(location);\n\n    var hash = location.hash;\n\n    if (!hash) {\n      this.ready = true;\n      return ret;\n    }\n\n    if (hash.includes('#')) {\n      hash = hash.substr(1);\n    }\n\n    location.hash = _querystring.default.parse(hash);\n\n    if (location.hash.state) {\n      location.hash.state = JSON.parse(_common.base64.decode(location.hash.state));\n    }\n\n    var tokenData = this._parseHash(location);\n\n    if (!tokenData) {\n      return ret;\n    }\n\n    this._cleanUrl(location); // Wait until nextTick in case `credentials` hasn't initialized yet\n\n\n    process.nextTick(function () {\n      _this.webex.credentials.set({\n        supertoken: tokenData\n      });\n\n      _this.ready = true;\n    });\n    return ret;\n  },\n\n  /**\n   * Kicks off an oauth flow\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @returns {Promise}\n   */\n  initiateLogin: function initiateLogin() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options.state = options.state || {};\n    options.state.csrf_token = this._generateSecurityToken(); // If we're not explicitly a confidential client, assume we're a public\n    // client\n\n    if (this.config.clientType === 'confidential') {\n      return this.initiateAuthorizationCodeGrant(options);\n    }\n\n    return this.initiateImplicitGrant(options);\n  },\n\n  /**\n   * Kicks off the Authorization Code grant flow. Typically called via\n   * {@link AuthorizationBrowser#initiateLogin}\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @returns {Promise}\n   */\n  initiateImplicitGrant: function initiateImplicitGrant(options) {\n    this.logger.info('authorization: initiating implicit grant flow');\n    this.webex.getWindow().location = this.webex.credentials.buildLoginUrl((0, _assign.default)({\n      response_type: 'token'\n    }, options));\n    return _promise.default.resolve();\n  },\n\n  /**\n   * Kicks off the Implicit Code grant flow. Typically called via\n   * {@link AuthorizationBrowser#initiateLogin}\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @returns {Promise}\n   */\n  initiateAuthorizationCodeGrant: function initiateAuthorizationCodeGrant(options) {\n    this.logger.info('authorization: initiating authorization code grant flow');\n    this.webex.getWindow().location = this.webex.credentials.buildLoginUrl((0, _assign.default)({\n      response_type: 'code'\n    }, options));\n    return _promise.default.resolve();\n  },\n\n  /**\n   * Requests a Webex access token for a user already authenticated into\n   * your product.\n   *\n   * Note: You'll need to supply a jwtRefreshCallback of the form\n   * `Promise<jwt> = jwtRefreshCallback(webex)` for automatic token refresh to\n   * work.\n   *\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @param {Object} options.jwt This is a jwt generated by your backend that\n   * identifies a user in your system\n   * @returns {Promise}\n   */\n  requestAccessTokenFromJwt: function requestAccessTokenFromJwt(_ref) {\n    var _this2 = this;\n\n    var jwt = _ref.jwt;\n    var hydraUri = this.webex.internal.services.get('hydra', true);\n\n    if (hydraUri && hydraUri.slice(-1) !== '/') {\n      // add a `/` to hydra's uri from the services catalog so that\n      // it matches the current env service format.\n      hydraUri += '/';\n    }\n\n    hydraUri = hydraUri || process.env.HYDRA_SERVICE_URL || 'https://api.ciscospark.com/v1/';\n    return this.webex.request({\n      method: 'POST',\n      uri: \"\".concat(hydraUri, \"jwt/login\"),\n      headers: {\n        authorization: jwt\n      }\n    }).then(function (_ref2) {\n      var body = _ref2.body;\n      return {\n        access_token: body.token,\n        token_type: 'Bearer',\n        expires_in: body.expiresIn\n      };\n    }).then(function (token) {\n      _this2.webex.credentials.set({\n        supertoken: token\n      });\n    }).then(function () {\n      return _this2.webex.internal.services.initServiceCatalogs();\n    });\n  },\n\n  /**\n   * Called by {@link WebexCore#logout()}. Redirects to the logout page\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @param {boolean} options.noRedirect if true, does not redirect\n   * @returns {Promise}\n   */\n  logout: function logout() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!options.noRedirect) {\n      this.webex.getWindow().location = this.webex.credentials.buildLogoutUrl(options);\n    }\n  },\n\n  /**\n   * Checks if the result of the login redirect contains an error string\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} location\n   * @private\n   * @returns {Promise}\n   */\n  _checkForErrors: function _checkForErrors(location) {\n    var query = location.query;\n\n    if (query && query.error) {\n      var ErrorConstructor = _webexCore.grantErrors.select(query.error);\n\n      throw new ErrorConstructor(query);\n    }\n  },\n\n  /**\n   * Removes no-longer needed values from the url (access token, csrf token, etc)\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} location\n   * @private\n   * @returns {Promise}\n   */\n  _cleanUrl: function _cleanUrl(location) {\n    location = (0, _cloneDeep2.default)(location);\n\n    if (this.webex.getWindow().history && this.webex.getWindow().history.replaceState) {\n      ['access_token', 'token_type', 'expires_in', 'refresh_token', 'refresh_token_expires_in'].forEach(function (key) {\n        return (0, _deleteProperty.default)(location.hash, key);\n      });\n\n      if (!(0, _isEmpty2.default)(location.hash.state)) {\n        location.hash.state = _common.base64.encode((0, _stringify.default)((0, _omit2.default)(location.hash.state, 'csrf_token')));\n\n        if (location.hash.state === EMPTY_OBJECT_STRING) {\n          (0, _deleteProperty.default)(location.hash, 'state');\n        }\n      } else {\n        (0, _deleteProperty.default)(location.hash, 'state');\n      }\n\n      location.hash = _querystring.default.stringify(location.hash);\n      this.webex.getWindow().history.replaceState({}, null, _url.default.format(location));\n    }\n  },\n\n  /**\n   * Generates a CSRF token and sticks in in sessionStorage\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @private\n   * @returns {Promise}\n   */\n  _generateSecurityToken: function _generateSecurityToken() {\n    this.logger.info('authorization: generating csrf token');\n\n    var token = _uuid.default.v4();\n\n    this.webex.getWindow().sessionStorage.setItem('oauth2-csrf-token', token);\n    return token;\n  },\n\n  /**\n   * Parses the url hash into an access token object\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} location\n   * @private\n   * @returns {Object}\n   */\n  _parseHash: function _parseHash(location) {\n    var hash = (0, _cloneDeep2.default)(location.hash);\n\n    if (hash) {\n      this._verifySecurityToken(hash);\n    }\n\n    if (!hash.access_token) {\n      this.ready = true;\n      return undefined;\n    }\n\n    if (hash.expires_in) {\n      hash.expires_in = (0, _parseInt2.default)(hash.expires_in, 10);\n    }\n\n    if (hash.refresh_token_expires_in) {\n      hash.refresh_token_expires_in = (0, _parseInt2.default)(hash.refresh_token_expires_in, 10);\n    }\n\n    return hash;\n  },\n\n  /**\n   * Checks if the CSRF token in sessionStorage is the same as the one returned\n   * in the url.\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} hash\n   * @private\n   * @returns {Promise}\n   */\n  _verifySecurityToken: function _verifySecurityToken(hash) {\n    var sessionToken = this.webex.getWindow().sessionStorage.getItem(OAUTH2_CSRF_TOKEN);\n    this.webex.getWindow().sessionStorage.removeItem(OAUTH2_CSRF_TOKEN);\n\n    if (!sessionToken) {\n      return;\n    }\n\n    if (!hash.state) {\n      throw new Error(\"Expected CSRF token \".concat(sessionToken, \", but not found in redirect hash\"));\n    }\n\n    if (!hash.state.csrf_token) {\n      throw new Error(\"Expected CSRF token \".concat(sessionToken, \", but not found in redirect hash\"));\n    }\n\n    var token = hash.state.csrf_token;\n\n    if (token !== sessionToken) {\n      throw new Error(\"CSRF token \".concat(token, \" does not match stored token \").concat(sessionToken));\n    }\n  },\n  version: \"1.154.2\"\n}, ((0, _applyDecoratedDescriptor2.default)(_obj, \"initiateImplicitGrant\", [_dec], (0, _getOwnPropertyDescriptor.default)(_obj, \"initiateImplicitGrant\"), _obj), (0, _applyDecoratedDescriptor2.default)(_obj, \"initiateAuthorizationCodeGrant\", [_dec2], (0, _getOwnPropertyDescriptor.default)(_obj, \"initiateAuthorizationCodeGrant\"), _obj), (0, _applyDecoratedDescriptor2.default)(_obj, \"requestAccessTokenFromJwt\", [_common.oneFlight], (0, _getOwnPropertyDescriptor.default)(_obj, \"requestAccessTokenFromJwt\"), _obj)), _obj)));\n\nvar _default = Authorization;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["OAUTH2_CSRF_TOKEN","EMPTY_OBJECT_STRING","base64","encode","Authorization","WebexPlugin","extend","derived","isAuthenticating","deps","fn","isAuthorizing","session","default","type","ready","namespace","initialize","attrs","options","ret","prototype","parse","location","url","webex","getWindow","href","_checkForErrors","hash","includes","substr","querystring","state","JSON","decode","tokenData","_parseHash","_cleanUrl","process","nextTick","_this","credentials","set","supertoken","initiateLogin","csrf_token","_generateSecurityToken","config","clientType","initiateAuthorizationCodeGrant","initiateImplicitGrant","logger","info","buildLoginUrl","response_type","_promise","resolve","requestAccessTokenFromJwt","jwt","hydraUri","internal","services","get","slice","env","HYDRA_SERVICE_URL","request","method","uri","headers","authorization","then","body","access_token","token","token_type","expires_in","expiresIn","_this2","initServiceCatalogs","logout","noRedirect","buildLogoutUrl","query","error","ErrorConstructor","grantErrors","select","history","replaceState","forEach","key","stringify","format","uuid","v4","sessionStorage","setItem","_verifySecurityToken","undefined","refresh_token_expires_in","sessionToken","getItem","removeItem","Error","version","oneFlight"],"sources":["authorization.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\n/* eslint camelcase: [0] */\n\nimport querystring from 'querystring';\nimport url from 'url';\n\nimport {base64, oneFlight, whileInFlight} from '@webex/common';\nimport {grantErrors, WebexPlugin} from '@webex/webex-core';\nimport {cloneDeep, isEmpty, omit} from 'lodash';\nimport uuid from 'uuid';\n\nconst OAUTH2_CSRF_TOKEN = 'oauth2-csrf-token';\nconst EMPTY_OBJECT_STRING = base64.encode(JSON.stringify({}));\n\n/**\n * Browser support for OAuth2. Automatically parses the URL hash for an access\n * token\n * @class\n * @name AuthorizationBrowser\n */\nconst Authorization = WebexPlugin.extend({\n  derived: {\n    /**\n     * Alias of {@link AuthorizationBrowser#isAuthorizing}\n     * @instance\n     * @memberof AuthorizationBrowser\n     * @type {boolean}\n     */\n    isAuthenticating: {\n      deps: ['isAuthorizing'],\n      fn() {\n        return this.isAuthorizing;\n      }\n    }\n  },\n\n  session: {\n    /**\n     * Indicates if an Authorization Code exchange is inflight\n     * @instance\n     * @memberof AuthorizationBrowser\n     * @type {boolean}\n     */\n    isAuthorizing: {\n      default: false,\n      type: 'boolean'\n    },\n    ready: {\n      default: false,\n      type: 'boolean'\n    }\n  },\n\n  namespace: 'Credentials',\n\n  /**\n   * Initializer\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} attrs {@link AmpersandState}\n   * @param {boolean} attrs.parse Controls whether or not the the url should get\n   * parsed for an access token\n   * @private\n   * @returns {Authorization}\n   */\n  // eslint-disable-next-line complexity\n  initialize(attrs, options) {\n    const ret = Reflect.apply(WebexPlugin.prototype.initialize, this, [attrs, options]);\n\n    // Reminder, we can't do parse based on config, because config is not\n    // available until nextTick and we want to be able to throw errors found in\n    // the url.\n    if (attrs.parse === false) {\n      this.ready = true;\n\n      return ret;\n    }\n    const location = url.parse(this.webex.getWindow().location.href, true);\n\n    this._checkForErrors(location);\n\n    let {hash} = location;\n\n    if (!hash) {\n      this.ready = true;\n\n      return ret;\n    }\n    if (hash.includes('#')) {\n      hash = hash.substr(1);\n    }\n    location.hash = querystring.parse(hash);\n    if (location.hash.state) {\n      location.hash.state = JSON.parse(base64.decode(location.hash.state));\n    }\n    const tokenData = this._parseHash(location);\n\n    if (!tokenData) {\n      return ret;\n    }\n    this._cleanUrl(location);\n\n    // Wait until nextTick in case `credentials` hasn't initialized yet\n    process.nextTick(() => {\n      this.webex.credentials.set({supertoken: tokenData});\n      this.ready = true;\n    });\n\n    return ret;\n  },\n\n  /**\n   * Kicks off an oauth flow\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @returns {Promise}\n   */\n  initiateLogin(options = {}) {\n    options.state = options.state || {};\n    options.state.csrf_token = this._generateSecurityToken();\n\n    // If we're not explicitly a confidential client, assume we're a public\n    // client\n    if (this.config.clientType === 'confidential') {\n      return this.initiateAuthorizationCodeGrant(options);\n    }\n\n    return this.initiateImplicitGrant(options);\n  },\n\n  @whileInFlight('isAuthorizing')\n  /**\n   * Kicks off the Authorization Code grant flow. Typically called via\n   * {@link AuthorizationBrowser#initiateLogin}\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @returns {Promise}\n   */\n  initiateImplicitGrant(options) {\n    this.logger.info('authorization: initiating implicit grant flow');\n    this.webex.getWindow().location = this.webex.credentials.buildLoginUrl(Object.assign({response_type: 'token'}, options));\n\n    return Promise.resolve();\n  },\n\n  @whileInFlight('isAuthorizing')\n  /**\n   * Kicks off the Implicit Code grant flow. Typically called via\n   * {@link AuthorizationBrowser#initiateLogin}\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @returns {Promise}\n   */\n  initiateAuthorizationCodeGrant(options) {\n    this.logger.info('authorization: initiating authorization code grant flow');\n    this.webex.getWindow().location = this.webex.credentials.buildLoginUrl(Object.assign({response_type: 'code'}, options));\n\n    return Promise.resolve();\n  },\n\n  @oneFlight\n  /**\n   * Requests a Webex access token for a user already authenticated into\n   * your product.\n   *\n   * Note: You'll need to supply a jwtRefreshCallback of the form\n   * `Promise<jwt> = jwtRefreshCallback(webex)` for automatic token refresh to\n   * work.\n   *\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @param {Object} options.jwt This is a jwt generated by your backend that\n   * identifies a user in your system\n   * @returns {Promise}\n   */\n  requestAccessTokenFromJwt({jwt}) {\n    let hydraUri = this.webex.internal.services.get('hydra', true);\n\n    if (hydraUri && hydraUri.slice(-1) !== '/') {\n      // add a `/` to hydra's uri from the services catalog so that\n      // it matches the current env service format.\n      hydraUri += '/';\n    }\n\n    hydraUri = hydraUri ||\n      process.env.HYDRA_SERVICE_URL ||\n      'https://api.ciscospark.com/v1/';\n\n    return this.webex.request({\n      method: 'POST',\n      uri: `${hydraUri}jwt/login`,\n      headers: {\n        authorization: jwt\n      }\n    })\n      .then(({body}) => ({\n        access_token: body.token,\n        token_type: 'Bearer',\n        expires_in: body.expiresIn\n      }))\n      .then((token) => {\n        this.webex.credentials.set({\n          supertoken: token\n        });\n      })\n      .then(() => this.webex.internal.services.initServiceCatalogs());\n  },\n\n  /**\n   * Called by {@link WebexCore#logout()}. Redirects to the logout page\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @param {boolean} options.noRedirect if true, does not redirect\n   * @returns {Promise}\n   */\n  logout(options = {}) {\n    if (!options.noRedirect) {\n      this.webex.getWindow().location = this.webex.credentials.buildLogoutUrl(options);\n    }\n  },\n\n  /**\n   * Checks if the result of the login redirect contains an error string\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} location\n   * @private\n   * @returns {Promise}\n   */\n  _checkForErrors(location) {\n    const {query} = location;\n\n    if (query && query.error) {\n      const ErrorConstructor = grantErrors.select(query.error);\n\n      throw new ErrorConstructor(query);\n    }\n  },\n\n  /**\n   * Removes no-longer needed values from the url (access token, csrf token, etc)\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} location\n   * @private\n   * @returns {Promise}\n   */\n  _cleanUrl(location) {\n    location = cloneDeep(location);\n    if (this.webex.getWindow().history && this.webex.getWindow().history.replaceState) {\n      [\n        'access_token',\n        'token_type',\n        'expires_in',\n        'refresh_token',\n        'refresh_token_expires_in'\n      ].forEach((key) => Reflect.deleteProperty(location.hash, key));\n      if (!isEmpty(location.hash.state)) {\n        location.hash.state = base64.encode(JSON.stringify(omit(location.hash.state, 'csrf_token')));\n        if (location.hash.state === EMPTY_OBJECT_STRING) {\n          Reflect.deleteProperty(location.hash, 'state');\n        }\n      }\n      else {\n        Reflect.deleteProperty(location.hash, 'state');\n      }\n      location.hash = querystring.stringify(location.hash);\n      this.webex.getWindow().history.replaceState({}, null, url.format(location));\n    }\n  },\n\n  /**\n   * Generates a CSRF token and sticks in in sessionStorage\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @private\n   * @returns {Promise}\n   */\n  _generateSecurityToken() {\n    this.logger.info('authorization: generating csrf token');\n\n    const token = uuid.v4();\n\n    this.webex.getWindow().sessionStorage.setItem('oauth2-csrf-token', token);\n\n    return token;\n  },\n\n  /**\n   * Parses the url hash into an access token object\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} location\n   * @private\n   * @returns {Object}\n   */\n  _parseHash(location) {\n    const hash = cloneDeep(location.hash);\n\n    if (hash) {\n      this._verifySecurityToken(hash);\n    }\n    if (!hash.access_token) {\n      this.ready = true;\n\n      return undefined;\n    }\n    if (hash.expires_in) {\n      hash.expires_in = parseInt(hash.expires_in, 10);\n    }\n    if (hash.refresh_token_expires_in) {\n      hash.refresh_token_expires_in = parseInt(hash.refresh_token_expires_in, 10);\n    }\n\n    return hash;\n  },\n\n  /**\n   * Checks if the CSRF token in sessionStorage is the same as the one returned\n   * in the url.\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} hash\n   * @private\n   * @returns {Promise}\n   */\n  _verifySecurityToken(hash) {\n    const sessionToken = this.webex.getWindow().sessionStorage.getItem(OAUTH2_CSRF_TOKEN);\n\n    this.webex.getWindow().sessionStorage.removeItem(OAUTH2_CSRF_TOKEN);\n    if (!sessionToken) {\n      return;\n    }\n\n    if (!hash.state) {\n      throw new Error(`Expected CSRF token ${sessionToken}, but not found in redirect hash`);\n    }\n\n    if (!hash.state.csrf_token) {\n      throw new Error(`Expected CSRF token ${sessionToken}, but not found in redirect hash`);\n    }\n\n    const token = hash.state.csrf_token;\n\n    if (token !== sessionToken) {\n      throw new Error(`CSRF token ${token} does not match stored token ${sessionToken}`);\n    }\n  }\n});\n\nexport default Authorization;\n"]},"metadata":{},"sourceType":"script"}