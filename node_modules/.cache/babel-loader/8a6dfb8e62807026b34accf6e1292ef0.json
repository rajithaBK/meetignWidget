{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _assign = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/assign\"));\n\nvar _apply = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/reflect/apply\"));\n\nvar _getOwnPropertyDescriptor = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\"));\n\nvar _applyDecoratedDescriptor2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/applyDecoratedDescriptor\"));\n\nvar _isArray2 = _interopRequireDefault(require(\"lodash/isArray\"));\n\nvar _common = require(\"@webex/common\");\n\nvar _webexCore = require(\"@webex/webex-core\");\n\nvar _userUuidBatcher = _interopRequireDefault(require(\"./user-uuid-batcher\"));\n\nvar _userUuidStore = _interopRequireDefault(require(\"./user-uuid-store\"));\n\nvar _dec, _dec2, _dec3, _dec4, _obj;\n/**\n * @class\n */\n\n\nvar User = _webexCore.WebexPlugin.extend((_dec = (0, _webexCore.waitForValue)('@'), _dec2 = (0, _common.oneFlight)({\n  keyFactory: function keyFactory(email, options) {\n    return email + String(options && options.create);\n  }\n}), _dec3 = (0, _webexCore.persist)('@'), _dec4 = (0, _common.deprecated)('Use User#verify()'), (_obj = {\n  namespace: 'User',\n  children: {\n    batcher: _userUuidBatcher.default\n  },\n  props: {\n    /**\n     * Indicates if the current user is known to have a password.\n     * @instance\n     * @memberof User\n     * @type {boolean}\n     */\n    hasPassword: {\n      default: false,\n      type: 'boolean'\n    }\n  },\n  session: {\n    store: {\n      default: function _default() {\n        return new _userUuidStore.default();\n      },\n      type: 'any'\n    }\n  },\n\n  /**\n   * Activates a Webex user account and exchanges for user token.\n   * @instance\n   * @memberof User\n   * @param {Object} options\n   * @param {Object} options.confirmationCode (required -- optional if verification token is provided)\n   * @param {Object} options.id (required -- optional if verification token is provided)\n   * @param {Object} options.verificationToken (required -- optional if uuid and verification token provided)\n   * @param {Object} options.email (required with verificationToken for Federation/global user)\n   * @returns {Promise} Resolves with a userSession\n   */\n  activate: function activate() {\n    var _this = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!(options.verificationToken || options.confirmationCode && options.id)) {\n      return _promise.default.reject(new Error('either options.verificationToken is required or both options.confirmationCode and options.id are required'));\n    }\n\n    options.scope = this.webex.config.credentials.scope; // if we have options.email and options.verificationToken\n    // and Federation flag is enabled, flag that we need to\n    // lookup user's CI.\n\n    var activateOptions = (0, _assign.default)({}, options);\n    delete activateOptions.email;\n    return this.request({\n      uri: this.webex.config.credentials.activationUrl,\n      method: 'POST',\n      body: activateOptions,\n      auth: {\n        user: this.webex.config.credentials.client_id,\n        pass: this.webex.config.credentials.client_secret,\n        sendImmediately: true\n      }\n    }).then(function (res) {\n      _this.webex.credentials.set({\n        supertoken: res.body.tokenData\n      });\n\n      return res.body;\n    });\n  },\n\n  /**\n   * Converts a user-identifying object to a uuid, perhaps by doing a network\n   * lookup\n   * @param {string|Object} user\n   * @param {Object} options\n   * @param {boolean} options.create if true, ensures the return UUID refers to\n   * an existing user (rather than creating one deterministically based on email\n   * address), even if that user must be created\n   * @returns {Promise<string>}\n   */\n  asUUID: function asUUID(user, options) {\n    var _this2 = this;\n\n    if (!user) {\n      return _promise.default.reject(new Error('`user` is required'));\n    }\n\n    if ((0, _isArray2.default)(user)) {\n      return _promise.default.all(user.map(function (u) {\n        return _this2.asUUID(u, options);\n      }));\n    }\n\n    var id = this._extractUUID(user);\n\n    if (!(options && options.force) && _common.patterns.uuid.test(id)) {\n      return _promise.default.resolve(id);\n    }\n\n    var email = this._extractEmailAddress(user);\n\n    if (!_common.patterns.email.test(email)) {\n      return _promise.default.reject(new Error('Provided user object does not appear to identify a user'));\n    }\n\n    return this.getUUID(email, options);\n  },\n\n  /**\n   * Requests a uuid from the api\n   * @param {string} email\n   * @param {Object} options\n   * @param {boolean} options.create\n   * @returns {Promise<string>}\n   */\n  fetchUUID: function fetchUUID(email, options) {\n    var _this3 = this;\n\n    return this.batcher.request({\n      email: email,\n      create: options && options.create\n    }).then(function (user) {\n      return _this3.recordUUID((0, _assign.default)({\n        emailAddress: email\n      }, user)).then(function () {\n        return user.id;\n      });\n    });\n  },\n\n  /**\n   * Generates One Time Password.\n   * @instance\n   * @param {Object} options\n   * @param {string} options.email\n   * @param {string} options.id\n   * @returns {Promise}\n   */\n  generateOTP: function generateOTP() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!(options.email || options.id)) {\n      return _promise.default.reject(new Error('One of `options.email` or `options.id` is required'));\n    }\n\n    return this.request({\n      uri: this.webex.config.credentials.generateOtpUrl,\n      method: 'POST',\n      body: options,\n      auth: {\n        user: this.webex.config.credentials.client_id,\n        pass: this.webex.config.credentials.client_secret\n      }\n    }).then(function (res) {\n      return res.body;\n    });\n  },\n\n  /**\n   * Fetches details about the current user\n   * @returns {Promise<Object>}\n   */\n  get: function get() {\n    var _this4 = this;\n\n    return this.request({\n      service: 'conversation',\n      resource: 'users'\n    }).then(function (res) {\n      return res.body;\n    }).then((0, _common.tap)(function (user) {\n      return _this4.recordUUID({\n        id: user.id,\n        // CI endpoints don't use the same user format as actors, so, email may\n        // be in one of a few fields\n        emailAddress: user.email || user.emailAddress\n      });\n    }));\n  },\n  getUUID: function getUUID(email, options) {\n    var _this5 = this;\n\n    return this.store.getByEmail(email).then(function (user) {\n      if (options && options.create && !user.userExists) {\n        return _promise.default.reject(new Error('User for specified email cannot be confirmed to exist'));\n      }\n\n      if (!user.id) {\n        return _promise.default.reject(new Error('No id recorded for specified user'));\n      }\n\n      return user.id;\n    }).catch(function () {\n      return _this5.fetchUUID(email, options);\n    });\n  },\n  initialize: function initialize() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return (0, _apply.default)(_webexCore.WebexPlugin.prototype.initialize, this, args);\n  },\n\n  /**\n   * Caches the uuid for the specified email address\n   * @param {Object} user\n   * @param {string} user.id\n   * @param {string} user.emailAddress\n   * @returns {Promise}\n   */\n  recordUUID: function recordUUID(user) {\n    if (!user) {\n      return _promise.default.reject(new Error('`user` is required'));\n    }\n\n    if (!user.id) {\n      return _promise.default.reject(new Error('`user.id` is required'));\n    }\n\n    if (!_common.patterns.uuid.test(user.id)) {\n      return _promise.default.reject(new Error('`user.id` must be a uuid'));\n    }\n\n    if (!user.emailAddress) {\n      return _promise.default.reject(new Error('`user.emailAddress` is required'));\n    }\n\n    if (!_common.patterns.email.test(user.emailAddress)) {\n      return _promise.default.reject(new Error('`user.emailAddress` must be an email address'));\n    }\n\n    return this.store.add(user);\n  },\n  register: function register() {\n    return this.verify.apply(this, arguments);\n  },\n\n  /**\n   * Updates a user with webex.\n   * @param {Object} body\n   * @private\n   * @returns {Promise} Resolves with a response from PATCH request\n   */\n  _setUser: function _setUser(body) {\n    var _this6 = this;\n\n    return this.webex.credentials.getUserToken().then(function (token) {\n      return _this6.request({\n        uri: \"\".concat(_this6.webex.config.credentials.setPasswordUrl, \"/\").concat(_this6.webex.internal.device.userId),\n        method: 'PATCH',\n        headers: {\n          authorization: token.toString()\n        },\n        body: body\n      });\n    });\n  },\n\n  /**\n   * Updates a user's password with webex.\n   * @instance\n   * @memberof User\n   * @param {Object} options\n   * @param {string} options.password (required)\n   * @param {string} options.email (required when federation enabled)\n   * @returns {Promise} Resolves with complete user object containing new password\n   */\n  setPassword: function setPassword(options) {\n    var _this7 = this;\n\n    options = options || {};\n\n    if (!options.password) {\n      return _promise.default.reject(new Error('`options.password` is required'));\n    }\n\n    return this._setUser({\n      schemas: ['urn:scim:schemas:core:1.0', 'urn:scim:schemas:extension:cisco:commonidentity:1.0'],\n      password: options.password\n    }).then(function (res) {\n      _this7.hasPassword = true;\n      return res.body;\n    });\n  },\n\n  /**\n   * Updates a user's name with webex.\n   * @instance\n   * @memberof User\n   * @param {string} givenName\n   * @param {string} familyName\n   * @param {string} displayName\n   * @returns {Promise<Object>}\n   */\n  updateName: function updateName() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        givenName = _ref.givenName,\n        familyName = _ref.familyName,\n        displayName = _ref.displayName;\n\n    if (!(givenName || familyName || displayName)) {\n      return _promise.default.reject(new Error('One of `givenName` and `familyName` or `displayName` is required'));\n    }\n\n    return this._setUser({\n      schemas: ['urn:scim:schemas:core:1.0', 'urn:scim:schemas:extension:cisco:commonidentity:1.0'],\n      name: {\n        givenName: givenName,\n        familyName: familyName\n      },\n      displayName: displayName\n    }).then(function (res) {\n      return res.body;\n    });\n  },\n\n  /**\n   * Updates the current user's display name\n   * @param {Object} options\n   * @param {string} options.displayName\n   * @returns {Promise<Object>}\n   */\n  update: function update(options) {\n    options = options || {};\n\n    if (!options.displayName) {\n      return _promise.default.reject(new Error('`options.displayName` is required'));\n    }\n\n    return this.request({\n      method: 'PATCH',\n      service: 'conversation',\n      resource: 'users/user',\n      body: options\n    }).then(function (res) {\n      return res.body;\n    });\n  },\n\n  /**\n   * Validated One Time Password.\n   * @instance\n   * @param {Object} options\n   * @param {string} options.email\n   * @param {string} options.id\n   * @param {string} options.oneTimePassword\n   * @returns {Promise}\n   */\n  validateOTP: function validateOTP() {\n    var _this8 = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!(options.email || options.id) || !options.oneTimePassword) {\n      return _promise.default.reject(new Error('One of `options.email` or `options.id` and `options.oneTimePassword` are required'));\n    }\n\n    options.scope = this.webex.config.credentials.scope;\n    return this.request({\n      uri: this.webex.config.credentials.validateOtpUrl,\n      method: 'POST',\n      body: options,\n      auth: {\n        user: this.webex.config.credentials.client_id,\n        pass: this.webex.config.credentials.client_secret\n      }\n    }).then(function (res) {\n      _this8.webex.credentials.set({\n        supertoken: res.body.tokenData\n      });\n\n      return res.body;\n    });\n  },\n\n  /**\n   * Determines if the specified user needs to signup or can signin.\n   * Triggers activation email if client credentials are used\n   * @param {Object} options\n   * @param {string} options.email (required)\n   * @param {string} options.reqId required if need to check email status\n   * @param {string} options.preloginId\n   * @returns {Promise<Object>}\n   */\n  verify: function verify(options) {\n    var _this9 = this;\n\n    options = (0, _assign.default)({}, this.config.verifyDefaults, options);\n    var _options = options,\n        email = _options.email;\n\n    if (!email) {\n      return _promise.default.reject(new Error('`options.email` is required'));\n    }\n\n    return this.webex.internal.services.collectPreauthCatalog({\n      email: email\n    }).then(function () {\n      return _this9.webex.credentials.getUserToken();\n    }).catch(function () {\n      return _this9.webex.credentials.getClientToken();\n    }).then(function (token) {\n      return _this9.request({\n        service: 'atlas',\n        resource: 'users/activations',\n        method: 'POST',\n        headers: {\n          authorization: token.toString(),\n          'x-prelogin-userid': options.preloginId\n        },\n        body: options,\n        shouldRefreshAccessToken: false\n      });\n    }).then(function (res) {\n      if (res.body.hasPassword || res.body.sso) {\n        _this9.hasPassword = true;\n      }\n\n      return res.body;\n    });\n  },\n\n  /**\n   * If the passed-in lookupCI is true, retrieve the user's\n   * CI from Atlas and return the URL's via a Promise.\n   * Otherwise, return current CI in config via a Promise.\n   * Useful in a Promise chain to retrieve the CI based on\n   * conditions like Federation enabled, and suppresses sending\n   * an additional email to the user, since this is just a\n   * look-up.\n   * @param {string} email (required)\n   * @param {boolean} lookupCI (required)\n   * @returns {Promise<Object>}\n   */\n  getUserCI: function getUserCI(email, lookupCI) {\n    if (lookupCI) {\n      // call verify first to get the user's CI, but suppress sending another email\n      var verifyOptions = {\n        email: email,\n        suppressEmail: true\n      };\n      return this.verify(verifyOptions).then(function (res) {\n        return _promise.default.resolve(res.userEntities);\n      });\n    }\n\n    return _promise.default.resolve({\n      idBrokerUrl: this.webex.config.credentials.idbroker.url,\n      identityUrl: this.webex.config.credentials.identity.url\n    });\n  },\n\n  /**\n   * Extracts the uuid from a user identifying object\n   * @param {string|Object} user\n   * @private\n   * @returns {string}\n   */\n  _extractUUID: function _extractUUID(user) {\n    return user.entryUUID || user.id || user;\n  },\n\n  /**\n   * Extracts the email address from a user identifying object\n   * @param {string|Object} user\n   * @private\n   * @returns {string}\n   */\n  _extractEmailAddress: function _extractEmailAddress(user) {\n    return user.email || user.emailAddress || user.entryEmail || user;\n  },\n  version: \"1.154.2\"\n}, ((0, _applyDecoratedDescriptor2.default)(_obj, \"activate\", [_dec], (0, _getOwnPropertyDescriptor.default)(_obj, \"activate\"), _obj), (0, _applyDecoratedDescriptor2.default)(_obj, \"getUUID\", [_dec2], (0, _getOwnPropertyDescriptor.default)(_obj, \"getUUID\"), _obj), (0, _applyDecoratedDescriptor2.default)(_obj, \"initialize\", [_dec3], (0, _getOwnPropertyDescriptor.default)(_obj, \"initialize\"), _obj), (0, _applyDecoratedDescriptor2.default)(_obj, \"register\", [_dec4], (0, _getOwnPropertyDescriptor.default)(_obj, \"register\"), _obj)), _obj)));\n\nvar _default2 = User;\nexports.default = _default2;","map":{"version":3,"mappings":"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","names":["User","WebexPlugin","extend","keyFactory","email","options","String","create","namespace","children","batcher","UserUUIDBatcher","props","hasPassword","default","type","session","store","UserUUIDStore","activate","verificationToken","confirmationCode","id","_promise","reject","Error","scope","webex","config","credentials","activateOptions","request","uri","activationUrl","method","body","auth","user","client_id","pass","client_secret","sendImmediately","then","res","_this","set","supertoken","tokenData","asUUID","all","map","u","_this2","_extractUUID","force","patterns","uuid","test","resolve","_extractEmailAddress","getUUID","fetchUUID","_this3","recordUUID","emailAddress","generateOTP","generateOtpUrl","get","service","resource","_this4","getByEmail","userExists","catch","_this5","initialize","args","arguments","prototype","add","register","verify","_setUser","getUserToken","token","_this6","setPasswordUrl","internal","device","userId","headers","authorization","toString","setPassword","password","schemas","_this7","updateName","givenName","familyName","displayName","name","update","validateOTP","oneTimePassword","validateOtpUrl","_this8","verifyDefaults","services","collectPreauthCatalog","_this9","getClientToken","preloginId","shouldRefreshAccessToken","sso","getUserCI","lookupCI","verifyOptions","suppressEmail","userEntities","idBrokerUrl","idbroker","url","identityUrl","identity","entryUUID","entryEmail","version"],"sources":["user.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {isArray} from 'lodash';\nimport {deprecated, oneFlight, patterns, tap} from '@webex/common';\nimport {persist, WebexPlugin, waitForValue} from '@webex/webex-core';\n\nimport UserUUIDBatcher from './user-uuid-batcher';\nimport UserUUIDStore from './user-uuid-store';\n\n/**\n * @class\n */\nconst User = WebexPlugin.extend({\n  namespace: 'User',\n\n  children: {\n    batcher: UserUUIDBatcher\n  },\n\n  props: {\n    /**\n     * Indicates if the current user is known to have a password.\n     * @instance\n     * @memberof User\n     * @type {boolean}\n     */\n    hasPassword: {\n      default: false,\n      type: 'boolean'\n    }\n  },\n\n  session: {\n    store: {\n      default() {\n        return new UserUUIDStore();\n      },\n      type: 'any'\n    }\n  },\n\n  @waitForValue('@')\n  /**\n   * Activates a Webex user account and exchanges for user token.\n   * @instance\n   * @memberof User\n   * @param {Object} options\n   * @param {Object} options.confirmationCode (required -- optional if verification token is provided)\n   * @param {Object} options.id (required -- optional if verification token is provided)\n   * @param {Object} options.verificationToken (required -- optional if uuid and verification token provided)\n   * @param {Object} options.email (required with verificationToken for Federation/global user)\n   * @returns {Promise} Resolves with a userSession\n   */\n  activate(options = {}) {\n    if (!(options.verificationToken || (options.confirmationCode && options.id))) {\n      return Promise.reject(new Error('either options.verificationToken is required or both options.confirmationCode and options.id are required'));\n    }\n\n    options.scope = this.webex.config.credentials.scope;\n\n    // if we have options.email and options.verificationToken\n    // and Federation flag is enabled, flag that we need to\n    // lookup user's CI.\n    const activateOptions = Object.assign({}, options);\n\n    delete activateOptions.email;\n\n    return this.request({\n      uri: this.webex.config.credentials.activationUrl,\n      method: 'POST',\n      body: activateOptions,\n      auth: {\n        user: this.webex.config.credentials.client_id,\n        pass: this.webex.config.credentials.client_secret,\n        sendImmediately: true\n      }\n    })\n      .then((res) => {\n        this.webex.credentials.set({supertoken: res.body.tokenData});\n\n        return res.body;\n      });\n  },\n\n  /**\n   * Converts a user-identifying object to a uuid, perhaps by doing a network\n   * lookup\n   * @param {string|Object} user\n   * @param {Object} options\n   * @param {boolean} options.create if true, ensures the return UUID refers to\n   * an existing user (rather than creating one deterministically based on email\n   * address), even if that user must be created\n   * @returns {Promise<string>}\n   */\n  asUUID(user, options) {\n    if (!user) {\n      return Promise.reject(new Error('`user` is required'));\n    }\n\n    if (isArray(user)) {\n      return Promise.all(user.map((u) => this.asUUID(u, options)));\n    }\n\n    const id = this._extractUUID(user);\n\n    if (!(options && options.force) && patterns.uuid.test(id)) {\n      return Promise.resolve(id);\n    }\n\n    const email = this._extractEmailAddress(user);\n\n    if (!patterns.email.test(email)) {\n      return Promise.reject(new Error('Provided user object does not appear to identify a user'));\n    }\n\n    return this.getUUID(email, options);\n  },\n\n  /**\n   * Requests a uuid from the api\n   * @param {string} email\n   * @param {Object} options\n   * @param {boolean} options.create\n   * @returns {Promise<string>}\n   */\n  fetchUUID(email, options) {\n    return this.batcher.request({\n      email,\n      create: options && options.create\n    })\n      .then((user) => this.recordUUID(Object.assign({emailAddress: email}, user))\n        .then(() => user.id));\n  },\n  /**\n   * Generates One Time Password.\n   * @instance\n   * @param {Object} options\n   * @param {string} options.email\n   * @param {string} options.id\n   * @returns {Promise}\n   */\n  generateOTP(options = {}) {\n    if (!(options.email || options.id)) {\n      return Promise.reject(new Error('One of `options.email` or `options.id` is required'));\n    }\n\n    return this.request({\n      uri: this.webex.config.credentials.generateOtpUrl,\n      method: 'POST',\n      body: options,\n      auth: {\n        user: this.webex.config.credentials.client_id,\n        pass: this.webex.config.credentials.client_secret\n      }\n    })\n      .then((res) => res.body);\n  },\n\n  /**\n   * Fetches details about the current user\n   * @returns {Promise<Object>}\n   */\n  get() {\n    return this.request({\n      service: 'conversation',\n      resource: 'users'\n    })\n      .then((res) => res.body)\n      .then(tap((user) => this.recordUUID({\n        id: user.id,\n        // CI endpoints don't use the same user format as actors, so, email may\n        // be in one of a few fields\n        emailAddress: user.email || user.emailAddress\n      })));\n  },\n\n  /**\n   * Converts an email address to a uuid, perhaps by doing a network lookup\n   * @param {string} email\n   * @param {Object} options\n   * @param {boolean} options.create\n   * @returns {Promise<string>}\n   */\n  @oneFlight({keyFactory: (email, options) => email + String(options && options.create)})\n  getUUID(email, options) {\n    return this.store.getByEmail(email)\n      .then((user) => {\n        if (options && options.create && !user.userExists) {\n          return Promise.reject(new Error('User for specified email cannot be confirmed to exist'));\n        }\n\n        if (!user.id) {\n          return Promise.reject(new Error('No id recorded for specified user'));\n        }\n\n        return user.id;\n      })\n      .catch(() => this.fetchUUID(email, options));\n  },\n\n  @persist('@')\n  initialize(...args) {\n    return Reflect.apply(WebexPlugin.prototype.initialize, this, args);\n  },\n\n  /**\n   * Caches the uuid for the specified email address\n   * @param {Object} user\n   * @param {string} user.id\n   * @param {string} user.emailAddress\n   * @returns {Promise}\n   */\n  recordUUID(user) {\n    if (!user) {\n      return Promise.reject(new Error('`user` is required'));\n    }\n\n    if (!user.id) {\n      return Promise.reject(new Error('`user.id` is required'));\n    }\n\n    if (!patterns.uuid.test(user.id)) {\n      return Promise.reject(new Error('`user.id` must be a uuid'));\n    }\n\n    if (!user.emailAddress) {\n      return Promise.reject(new Error('`user.emailAddress` is required'));\n    }\n\n    if (!patterns.email.test(user.emailAddress)) {\n      return Promise.reject(new Error('`user.emailAddress` must be an email address'));\n    }\n\n    return this.store.add(user);\n  },\n\n  @deprecated('Use User#verify()')\n  register(...args) {\n    return this.verify(...args);\n  },\n\n  /**\n   * Updates a user with webex.\n   * @param {Object} body\n   * @private\n   * @returns {Promise} Resolves with a response from PATCH request\n   */\n  _setUser(body) {\n    return this.webex.credentials.getUserToken()\n      .then((token) => this.request({\n        uri: `${this.webex.config.credentials.setPasswordUrl}/${this.webex.internal.device.userId}`,\n        method: 'PATCH',\n        headers: {\n          authorization: token.toString()\n        },\n        body\n      }));\n  },\n\n  /**\n   * Updates a user's password with webex.\n   * @instance\n   * @memberof User\n   * @param {Object} options\n   * @param {string} options.password (required)\n   * @param {string} options.email (required when federation enabled)\n   * @returns {Promise} Resolves with complete user object containing new password\n   */\n  setPassword(options) {\n    options = options || {};\n    if (!options.password) {\n      return Promise.reject(new Error('`options.password` is required'));\n    }\n\n    return this._setUser({\n      schemas: ['urn:scim:schemas:core:1.0', 'urn:scim:schemas:extension:cisco:commonidentity:1.0'],\n      password: options.password\n    })\n      .then((res) => {\n        this.hasPassword = true;\n\n        return res.body;\n      });\n  },\n\n  /**\n   * Updates a user's name with webex.\n   * @instance\n   * @memberof User\n   * @param {string} givenName\n   * @param {string} familyName\n   * @param {string} displayName\n   * @returns {Promise<Object>}\n   */\n  updateName({givenName, familyName, displayName} = {}) {\n    if (!(givenName || familyName || displayName)) {\n      return Promise.reject(new Error('One of `givenName` and `familyName` or `displayName` is required'));\n    }\n\n    return this._setUser({\n      schemas: ['urn:scim:schemas:core:1.0', 'urn:scim:schemas:extension:cisco:commonidentity:1.0'],\n      name: {givenName, familyName},\n      displayName\n    })\n      .then((res) => res.body);\n  },\n\n  /**\n   * Updates the current user's display name\n   * @param {Object} options\n   * @param {string} options.displayName\n   * @returns {Promise<Object>}\n   */\n  update(options) {\n    options = options || {};\n    if (!options.displayName) {\n      return Promise.reject(new Error('`options.displayName` is required'));\n    }\n\n    return this.request({\n      method: 'PATCH',\n      service: 'conversation',\n      resource: 'users/user',\n      body: options\n    })\n      .then((res) => res.body);\n  },\n\n  /**\n   * Validated One Time Password.\n   * @instance\n   * @param {Object} options\n   * @param {string} options.email\n   * @param {string} options.id\n   * @param {string} options.oneTimePassword\n   * @returns {Promise}\n   */\n  validateOTP(options = {}) {\n    if (!(options.email || options.id) || !options.oneTimePassword) {\n      return Promise.reject(new Error('One of `options.email` or `options.id` and `options.oneTimePassword` are required'));\n    }\n\n    options.scope = this.webex.config.credentials.scope;\n\n    return this.request({\n      uri: this.webex.config.credentials.validateOtpUrl,\n      method: 'POST',\n      body: options,\n      auth: {\n        user: this.webex.config.credentials.client_id,\n        pass: this.webex.config.credentials.client_secret\n      }\n    })\n      .then((res) => {\n        this.webex.credentials.set({supertoken: res.body.tokenData});\n\n        return res.body;\n      });\n  },\n\n  /**\n   * Determines if the specified user needs to signup or can signin.\n   * Triggers activation email if client credentials are used\n   * @param {Object} options\n   * @param {string} options.email (required)\n   * @param {string} options.reqId required if need to check email status\n   * @param {string} options.preloginId\n   * @returns {Promise<Object>}\n   */\n  verify(options) {\n    options = Object.assign({}, this.config.verifyDefaults, options);\n    const {email} = options;\n\n    if (!email) {\n      return Promise.reject(new Error('`options.email` is required'));\n    }\n\n    return this.webex.internal.services.collectPreauthCatalog({email})\n      .then(() => this.webex.credentials.getUserToken())\n      .catch(() => this.webex.credentials.getClientToken())\n      .then((token) => this.request({\n        service: 'atlas',\n        resource: 'users/activations',\n        method: 'POST',\n        headers: {\n          authorization: token.toString(),\n          'x-prelogin-userid': options.preloginId\n        },\n        body: options,\n        shouldRefreshAccessToken: false\n      }))\n      .then((res) => {\n        if (res.body.hasPassword || res.body.sso) {\n          this.hasPassword = true;\n        }\n\n        return res.body;\n      });\n  },\n\n\n  /**\n   * If the passed-in lookupCI is true, retrieve the user's\n   * CI from Atlas and return the URL's via a Promise.\n   * Otherwise, return current CI in config via a Promise.\n   * Useful in a Promise chain to retrieve the CI based on\n   * conditions like Federation enabled, and suppresses sending\n   * an additional email to the user, since this is just a\n   * look-up.\n   * @param {string} email (required)\n   * @param {boolean} lookupCI (required)\n   * @returns {Promise<Object>}\n   */\n  getUserCI(email, lookupCI) {\n    if (lookupCI) {\n      // call verify first to get the user's CI, but suppress sending another email\n      const verifyOptions = {\n        email,\n        suppressEmail: true\n      };\n\n      return this.verify(verifyOptions).then((res) => Promise.resolve(res.userEntities));\n    }\n\n    return Promise.resolve(\n      {\n        idBrokerUrl: this.webex.config.credentials.idbroker.url,\n        identityUrl: this.webex.config.credentials.identity.url\n      }\n    );\n  },\n\n  /**\n   * Extracts the uuid from a user identifying object\n   * @param {string|Object} user\n   * @private\n   * @returns {string}\n   */\n  _extractUUID(user) {\n    return user.entryUUID || user.id || user;\n  },\n\n  /**\n   * Extracts the email address from a user identifying object\n   * @param {string|Object} user\n   * @private\n   * @returns {string}\n   */\n  _extractEmailAddress(user) {\n    return user.email || user.emailAddress || user.entryEmail || user;\n  }\n\n});\n\nexport default User;\n"]},"metadata":{},"sourceType":"script"}