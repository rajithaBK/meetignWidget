{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _cloneDeep2 = _interopRequireDefault(require(\"lodash/cloneDeep\"));\n\nrequire(\"@webex/internal-plugin-lyra\");\n\nrequire(\"@webex/internal-plugin-search\");\n\nvar _webexCore = require(\"@webex/webex-core\");\n\nvar _uuid = _interopRequireDefault(require(\"uuid\"));\n\nvar _constants = require(\"./constants\");\n\nvar _collection = _interopRequireDefault(require(\"./collection\"));\n\nvar DeviceManager = _webexCore.WebexPlugin.extend({\n  namespace: 'DeviceManager',\n  _devicePendingPinChallenge: null,\n  _pairedDevice: null,\n  _boundSpace: null,\n  initialize: function initialize() {\n    var _this = this; // Lyra mercury events listener\n\n\n    this.webex.internal.mercury.on('event:lyra.space_updated', function (_ref) {\n      var data = _ref.data;\n\n      _this._receiveDeviceUpdates(data);\n    });\n  },\n\n  /**\n  * Gets a list of all recent devices associated with the user\n  * the device list gets populated from Redis\n  * @returns {Promise<Device>}\n  */\n  getAll: function getAll() {\n    return _collection.default.getAll();\n  },\n\n  /**\n  * Gets a list of all recent devices associated with the user\n  * the device list gets populated from Redis\n  * @returns {Promise<Device>}\n  */\n  refresh: function refresh() {\n    var _this2 = this;\n\n    _collection.default.reset();\n\n    return this.webex.request({\n      api: 'wdm',\n      resource: 'devices/auxiliary'\n    }).then(function (res) {\n      if (!res.body) {\n        return _promise.default.reject();\n      }\n\n      return _this2._updateDeviceMetadata(res.body.items).then(function (devices) {\n        /* eslint-disable consistent-return */\n        devices.forEach(function (device) {\n          if (device.deviceInfo && device.deviceInfo.machineType === _constants.LYRA_SPACE) {\n            return _this2.webex.internal.lyra.space.get(device.deviceInfo).catch(function (err) {\n              _this2.logger.error('DeviceManager#refresh: failed to receive device info', err);\n            });\n          }\n        });\n        /* eslint-enable consistent-return */\n\n        res.body.items.forEach(function (device) {\n          _collection.default.set(device);\n        });\n        return _this2.getAll();\n      });\n    }).catch(function (err) {\n      _this2.logger.error('DeviceManager#refresh: failed to fetch recent devices', err);\n    });\n  },\n\n  /**\n  * Search for a device by name\n  * @param {Object} options\n  * @param {string} options.searchQuery\n  * @returns {Promise<Device>}\n  */\n  search: function search(options) {\n    var _this3 = this;\n\n    if (!options || !options.searchQuery) {\n      this.logger.error('DeviceManager#search: options.searchQuery is required');\n      return _promise.default.reject(new Error('DeviceManager#search: options.searchQuery is required'));\n    }\n\n    return this.webex.internal.search.people({\n      searchId: _uuid.default.v4(),\n      searchType: 'DEVICE_SEARCH',\n      searchEntity: 'device',\n      includePeople: false,\n      includeRooms: true,\n      queryString: options.searchQuery\n    }).catch(function (err) {\n      _this3.logger.error('DeviceManager#search: failed to search a device', err);\n\n      throw err;\n    });\n  },\n\n  /**\n  * Caches the device info and also registers to Redis for subsequent fetches\n  * @param {Object} device\n  * @param {string} device.id\n  * @returns {deviceInfo}\n  */\n  upsert: function upsert(device) {\n    var _this4 = this;\n\n    var deviceId = device.id || device.identity && device.identity.id;\n\n    if (!deviceId) {\n      this.logger.error('DeviceManager#upsert: device.id is required');\n      return _promise.default.reject(new Error('DeviceManager#upsert: device.id is required'));\n    }\n\n    this._pairedDevice = this._devicePendingPinChallenge;\n    this._devicePendingPinChallenge = null; // check if the device is already existing, if so then merge else add\n\n    var existingDevice = _collection.default.get(deviceId);\n\n    if (existingDevice) {\n      _collection.default.set(device);\n\n      return _promise.default.resolve(_collection.default.get(deviceId));\n    } // new device requested, add to wdm for subsequent retreivals\n\n\n    return this.webex.request({\n      api: 'wdm',\n      method: 'PUT',\n      resource: \"devices/auxiliary/Room/\".concat(deviceId)\n    }).then(function (res) {\n      var auxDevice = res.body;\n      return _this4._decryptDeviceName(auxDevice);\n    }).then(function (device) {\n      _collection.default.set(device);\n\n      return _promise.default.resolve(_collection.default.get(deviceId));\n    }).catch(function (err) {\n      _this4.logger.error('DeviceManager#upsert: failed to add/update a device', err);\n\n      return _promise.default.reject(err);\n    });\n  },\n\n  /**\n  * Retreives device info of a particular device\n  * @param {string} token\n  * @returns {Promise<deviceInfo>}\n  */\n  get: function get(token) {\n    var _this5 = this;\n\n    if (!token) {\n      this.logger.error('DeviceManager#get: token is required');\n      return _promise.default.reject(new Error('DeviceManager#get: token is required'));\n    }\n\n    var deviceInfo;\n    return this.webex.internal.lyra.getAdvertisedEndpoint(token).then(function (res) {\n      deviceInfo = res;\n      return _this5.webex.internal.lyra.space.get({\n        id: res.advertiser.id\n      });\n    }).then(function (result) {\n      // the deviceInfo doesn't have proper displayName, hence update\n      // displayName on deviceInfo for search to work\n      if (result && result.identity && result.identity.displayName) {\n        deviceInfo.advertiser.displayName = result.identity.displayName;\n      }\n\n      return deviceInfo;\n    }).catch(function (err) {\n      _this5.logger.error('DeviceManager#get: failed to get device info', err);\n\n      return _promise.default.reject(err);\n    });\n  },\n\n  /**\n  * Unregisters the device from Redis, will not fetch in subsequent loads,\n  * similar to space.deleteBinding()\n  * @param {string} deviceId\n  * @returns {Promise<deviceInfo>}\n  */\n  remove: function remove(deviceId) {\n    var _this6 = this;\n\n    if (!deviceId) {\n      this.logger.error('DeviceManager#remove: deviceId is required');\n      return _promise.default.reject(new Error('DeviceManager#remove: deviceId is required'));\n    }\n\n    return this.webex.request({\n      method: 'delete',\n      api: 'wdm',\n      resource: \"devices/auxiliary/\".concat(deviceId)\n    }).catch(function (error) {\n      _this6.logger.error('DeviceManager#remove: failed to remove the device', error);\n\n      return _promise.default.reject(error);\n    });\n  },\n\n  /**\n  * Requests to display PIN on the device\n  * @param {object} device\n  * @param {object} options\n  * @param {object} options.data\n  * @returns {Promise<deviceInfo>}\n  */\n  requestPin: function requestPin(device) {\n    var _this7 = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var deviceId = device.id || device.identity && device.identity.id;\n\n    if (!deviceId) {\n      this.logger.error('DeviceManager#requestPin: device.id is required');\n      return _promise.default.reject(new Error('DeviceManager#requestPin: device.id is required'));\n    }\n\n    var space = {\n      id: deviceId,\n      url: \"/spaces/\".concat(deviceId)\n    };\n    return this.webex.internal.lyra.space.get(space).then(function (dev) {\n      // check if the space is pinChallenge capable\n      if (dev && dev.occupants && dev.occupants.pinChallenge) {\n        _this7.logger.info('DeviceManager#requestPin: space is PIN challenge capable');\n\n        return _this7.webex.internal.lyra.space.join(space, {\n          passType: 'MANUAL',\n          verificationInitiation: 'PIN',\n          data: options.data\n        }).then(function () {\n          _this7._devicePendingPinChallenge = dev; // return the actual device so that it can be upserted on successful\n          // PIN exchange\n\n          return dev;\n        });\n      } // pairs with the space if it's not PIN challenge capable\n\n\n      _this7.logger.info('DeviceManager#requestPin: space is not PIN challenge capable, probably already occupied, will still return device info');\n\n      return _this7.webex.internal.lyra.space.get(space).then(function () {\n        return _promise.default.resolve(dev);\n      });\n    }).catch(function (err) {\n      _this7.logger.error('DeviceManager#requestPin: device failed PIN challenge request', err);\n\n      return _promise.default.reject(err);\n    });\n  },\n\n  /**\n  * pairs the device with the user (manual pairing), also adds it to\n  * user's recents list for subsequent fetches.\n  * similar to space.join()\n  * @param {object} options\n  * @param {number} options.pin\n  * @returns {Promise<deviceInfo>}\n  */\n  pair: function pair() {\n    var _this8 = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!options.pin) {\n      this.logger.error('DeviceManager#pair: options.pin is required');\n      return _promise.default.reject(new Error('DeviceManager#pair: options.pin is required'));\n    }\n\n    if (this._devicePendingPinChallenge) {\n      var space = {\n        id: this._devicePendingPinChallenge.identity.id,\n        url: \"/spaces/\".concat(this._devicePendingPinChallenge.identity.id)\n      };\n      return this.webex.internal.lyra.space.join(space, {\n        passType: 'PIN_ANSWER',\n        data: options.pin\n      }).catch(function (err) {\n        _this8.logger.error('DeviceManager#pair: incorrect PIN, unable to pair ', err);\n\n        return _promise.default.reject(err);\n      }).then(function () {\n        return _this8.upsert(_this8._devicePendingPinChallenge);\n      });\n    }\n\n    this.logger.error('DeviceManager#pair: no device to pair');\n    return _promise.default.reject(new Error('DeviceManager#pair: no device to pair'));\n  },\n\n  /**\n  * unpairs the device with the user (manual/ultrasonic pairing), but still\n  * keeps in the recents list/does not remove from Redis\n  * options.removeAllDevices will remove all associated devices to user\n  * similar to space.leave()\n  * @param {object} options\n  * @param {boolean} options.removeAllDevices\n  * @returns {Promise<deviceInfo>}\n  */\n  unpair: function unpair() {\n    var _this9 = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#unpair: no device to unpair');\n      return _promise.default.reject(new Error('DeviceManager#unpair: no device to unpair'));\n    }\n\n    var space = {\n      url: \"/spaces/\".concat(this._pairedDevice.identity.id)\n    };\n    return this.webex.internal.lyra.space.leave(space, options).catch(function (err) {\n      _this9.logger.error('DeviceManager#unpair: failed to remove device from Lyra', err);\n\n      return _promise.default.reject(err);\n    });\n  },\n\n  /**\n  * binds the space to the paired device (if supported)\n  * similar to space.bindConversation()\n  * @param {object} options\n  * @param {boolean} options.url, conversation url\n  * @param {boolean} options.kmsResourceObjectUrl of the convo\n  * @returns {Promise<deviceInfo>}\n  */\n  bindSpace: function bindSpace() {\n    var _this10 = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!options.url) {\n      this.logger.error('DeviceManager#pair: options.url is required');\n      return _promise.default.reject(new Error('DeviceManager#bindSpace: options.url is required'));\n    }\n\n    if (!options.kmsResourceObjectUrl) {\n      this.logger.error('DeviceManager#bindSpace: options.kmsResourceObjectUrl is required');\n      return _promise.default.reject(new Error('DeviceManager#bindSpace: options.kmsResourceObjectUrl is required'));\n    }\n\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#bindSpace: No device paired currently');\n      return _promise.default.reject(new Error('DeviceManager#bindSpace: No device paired currently'));\n    }\n\n    var space = {\n      url: \"/spaces/\".concat(this._pairedDevice.identity.id),\n      id: this._pairedDevice.identity.id\n    };\n    this._boundSpace = {\n      kmsResourceObjectUrl: options.kmsResourceObjectUrl,\n      url: options.url\n    };\n    return this.webex.internal.lyra.space.bindConversation(space, this._boundSpace).catch(function (err) {\n      _this10.logger.error('DeviceManager#bindSpace: failed to bind device to Space');\n\n      return _promise.default.reject(err);\n    });\n  },\n\n  /**\n  * unbinds the space to the paired device (if supported)\n  * similar to space.unbindConversation()\n  * @returns {Promise<deviceInfo>}\n  */\n  unbindSpace: function unbindSpace() {\n    var _this11 = this;\n\n    if (!this._pairedDevice || !this._boundSpace) {\n      this.logger.error('DeviceManager#unbindSpace: No space currently bound to the device');\n      return _promise.default.reject(new Error('DeviceManager#unbindSpace: No space currently bound to the device'));\n    }\n\n    var space = {\n      url: \"/spaces/\".concat(this._pairedDevice.identity.id),\n      id: this._pairedDevice.identity.id\n    };\n    return this.webex.internal.lyra.space.unbindConversation(space, this._boundSpace).then(function (res) {\n      _this11._boundSpace = null;\n      return _promise.default.resolve(res);\n    }).catch(function (err) {\n      _this11.logger.error('DeviceManager#unbindSpace: failed to unbind Space to device');\n\n      return _promise.default.reject(err);\n    });\n  },\n\n  /**\n  * Gets the audio state of the paired device\n  * similar to device.getAudioState()\n  * @returns {Promise<audioState>}\n  */\n  getAudioState: function getAudioState() {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#getAudioState: Currently no device is paired');\n      return _promise.default.reject(new Error('DeviceManager#getAudioState: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.getAudioState(this._pairedDevice);\n  },\n\n  /**\n  * Updates audio state of the paired device, should be called every 10 minutes\n  * or when mic or volume state is changed\n  * similar to device.putAudioState()\n  * @param {object} space\n  * @param {object} audioState\n  * @returns {Promise<audioState>}\n  */\n  putAudioState: function putAudioState(space) {\n    var audioState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.webex.internal.lyra.device.putAudioState(space, audioState);\n  },\n\n  /**\n  * Mutes paired device\n  * similar to device.mute()\n  * @returns {Promise<audioState>}\n  */\n  mute: function mute() {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#mute: Currently no device is paired');\n      return _promise.default.reject(new Error('DeviceManager#mute: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.mute(this._pairedDevice);\n  },\n\n  /**\n  * Unmutes paired device\n  * similar to device.unmute()\n  * @returns {Promise<audioState>}\n  */\n  unmute: function unmute() {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#unmute: Currently no device is paired');\n      return _promise.default.reject(new Error('DeviceManager#unmute: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.unmute(this._pairedDevice);\n  },\n\n  /**\n  * Increases paired device's volume\n  * similar to device.increaseVolume()\n  * @returns {Promise<audioState>}\n  */\n  increaseVolume: function increaseVolume() {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#increaseVolume: Currently no device is paired');\n      return _promise.default.reject(new Error('DeviceManager#increaseVolume: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.increaseVolume(this._pairedDevice);\n  },\n\n  /**\n  * Decreases paired device's volume\n  * similar to device.decreaseVolume()\n  * @returns {Promise<audioState>}\n  */\n  decreaseVolume: function decreaseVolume() {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#decreaseVolume: Currently no device is paired');\n      return _promise.default.reject(new Error('DeviceManager#decreaseVolume: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.decreaseVolume(this._pairedDevice);\n  },\n\n  /**\n  * Sets paired device's volume but should use increase and decrease api instead\n  * similar to device.setVolume()\n  * @param {number} level\n  * @returns {Promise<audioState>}\n  */\n  setVolume: function setVolume() {\n    var level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#setVolume: Currently no device is paired');\n      return _promise.default.reject(new Error('DeviceManager#setVolume: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.setVolume(this._pairedDevice, level);\n  },\n\n  /**\n  * Utility function to update decrypted device name on device object\n  * @param {Array} deviceArray\n  * @returns {device}\n  */\n  _updateDeviceMetadata: function _updateDeviceMetadata() {\n    var _this12 = this;\n\n    var deviceArray = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    if (!deviceArray.length) {\n      return _promise.default.resolve(deviceArray);\n    }\n\n    var devices = (0, _cloneDeep2.default)(deviceArray);\n    return _promise.default.all(devices.map(function (device, index) {\n      return _this12.webex.internal.services.waitForCatalog('postauth').then(function () {\n        if (device.deviceClass === _constants.UC_CLOUD) {\n          device.id = \"\".concat(_this12.webex.internal.services.get('wdm'), \"/\").concat(device.id);\n        }\n\n        return _this12._decryptDeviceName(device);\n      }).then(function (updatedDevice) {\n        devices[index] = updatedDevice;\n        return _promise.default.resolve();\n      });\n    })).then(function () {\n      return _promise.default.resolve(devices);\n    });\n  },\n\n  /**\n  * Utility function to update decrypted device name on device object\n  * @param {object} inDevice\n  * @returns {device}\n  */\n  _decryptDeviceName: function _decryptDeviceName() {\n    var _this13 = this;\n\n    var inDevice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var device = (0, _cloneDeep2.default)(inDevice);\n\n    if (device.metadata && device.metadata.encryptedUserAssignedName && device.metadata.encryptionKeyUrl) {\n      return this.webex.internal.encryption.decryptText(device.metadata.encryptionKeyUrl, device.metadata.encryptedUserAssignedName).then(function (decryptedDeviceName) {\n        // set userAssignedName as the decypted value, unset encryptedUserAssignedName since it's not needed\n        device.metadata.encryptedUserAssignedName = undefined;\n        device.metadata.userAssignedName = decryptedDeviceName;\n        return _promise.default.resolve(device);\n      }).catch(function (err) {\n        // unset encryptedUserAssignedName if failed to decrypt\n        device.metadata.encryptedUserAssignedName = undefined;\n\n        _this13.logger.error('DeviceCollection#_decryptDeviceName: failed to decrypt device name', err);\n      });\n    }\n\n    return _promise.default.resolve(device);\n  },\n\n  /**\n  * Utility function to update device info on mercury updates\n  * @param {object} device\n  * @returns {device}\n  */\n  _receiveDeviceUpdates: function _receiveDeviceUpdates(device) {\n    var _this14 = this; // we care only the updates are for the registered devices\n\n\n    if (device && device.spaceUrl) {\n      var deviceId = device.spaceUrl.substring(device.spaceUrl.lastIndexOf('/') + 1);\n\n      var existingDevice = _collection.default.get(deviceId);\n\n      if (existingDevice) {\n        return this.webex.internal.lyra.space.get({\n          id: deviceId\n        }).then(function (space) {\n          var device = _collection.default.get(deviceId);\n\n          if (device && space.occupants && (!space.occupants.self || !space.occupants.self.verified)) {\n            device.productName = space.devices && space.devices[0] && space.devices[0].productName || _constants.DEFAULT_PRODUCT_NAME; // pin challenge is not verified reset _pairedDevice if ids\n            // match\n\n            var pairedDeviceId = _this14._pairedDevice && (_this14._pairedDevice.id || _this14._pairedDevice.identity.id);\n\n            if (pairedDeviceId === deviceId) {\n              _this14._pairedDevice = null;\n\n              _this14.logger.info(\"DeviceManager#_receiveDeviceUpdates: device \".concat(deviceId, \" lost pairing\"));\n\n              return _promise.default.resolve();\n            } // we do not want to reset the device pending PIN challenge\n\n\n            if (_this14._devicePendingPinChallenge.identity.id !== deviceId) {\n              return _this14.upsert(device);\n            }\n\n            return _promise.default.resolve();\n          }\n\n          return _promise.default.resolve();\n        }).catch(function (err) {\n          _this14.logger.error('DeviceManager#_receiveDeviceUpdates: failed to receive updates for Lyra space', err);\n        });\n      }\n    }\n\n    return _promise.default.resolve();\n  },\n  version: \"1.154.2\"\n});\n\nvar _default = DeviceManager;\nexports.default = _default;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;AAIAA;;AACAA;;AACA;;AACA;;AAEA;;AACA;;AAEA,IAAMC,aAAa,GAAGC,uBAAYC,MAAZD,CAAmB;AACvCE,WAAS,EAAE,eAD4B;AAEvCC,4BAA0B,EAAE,IAFW;AAGvCC,eAAa,EAAE,IAHwB;AAIvCC,aAAW,EAAE,IAJ0B;AAMvCC,YANuC,wBAM1B;AAAA,sBACX;;;AACA,SAAKC,KAAL,CAAWC,QAAX,CAAoBC,OAApB,CAA4BC,EAA5B,CAA+B,0BAA/B,EAA2D,gBAAY;AAAA,UAAVC,IAAU,QAAVA,IAAU;;AACrEC,WAAI,CAACC,qBAAL,CAA2BF,IAA3B;AADF;AARqC;;AAavC;AACF;AACA;AACA;AACA;AACEG,QAlBuC,oBAkB9B;AACP,WAAOC,oBAAiBD,MAAjBC,EAAP;AAnBqC;;AAsBvC;AACF;AACA;AACA;AACA;AACEC,SA3BuC,qBA2B7B;AAAA;;AACRD,wBAAiBE,KAAjBF;;AAEA,WAAO,KAAKR,KAAL,CAAWW,OAAX,CAAmB;AACxBC,SAAG,EAAE,KADmB;AAExBC,cAAQ,EAAE;AAFc,KAAnB,EAIJC,IAJI,CAIC,UAACC,GAAD,EAAS;AACb,UAAI,CAACA,GAAG,CAACC,IAAT,EAAe;AACb,eAAOC,iBAAQC,MAAR,EAAP;AACD;;AAED,aAAOC,MAAI,CAACC,qBAAL,CAA2BL,GAAG,CAACC,IAAJD,CAASM,KAApC,EACJP,IADI,CACC,UAACQ,OAAD,EAAa;AACjB;AACAA,eAAO,CAACC,OAARD,CAAgB,UAACE,MAAD,EAAY;AAC1B,cAAIA,MAAM,CAACC,UAAPD,IACFA,MAAM,CAACC,UAAPD,CAAkBE,WAAlBF,KAAkCG,qBADpC,EACgD;AAC9C,mBAAOR,MAAI,CAACnB,KAAL,CAAWC,QAAX,CAAoB2B,IAApB,CAAyBC,KAAzB,CAA+BC,GAA/B,CAAmCN,MAAM,CAACC,UAA1C,EACJM,KADI,CACE,UAACC,GAAD,EAAS;AACdb,oBAAI,CAACc,MAAL,CAAYC,KAAZ,CAAkB,sDAAlB,EAA0EF,GAA1E;AAFG,cAAP;AAID;AAPH;AASA;;AACAjB,WAAG,CAACC,IAAJD,CAASM,KAATN,CAAeQ,OAAfR,CAAuB,UAACS,MAAD,EAAY;AACjChB,8BAAiB2B,GAAjB3B,CAAqBgB,MAArBhB;AADF;AAIA,eAAOW,MAAI,CAACZ,MAAL,EAAP;AAjBG,QAAP;AATG,OA6BJwB,KA7BI,CA6BE,UAACC,GAAD,EAAS;AACdb,YAAI,CAACc,MAAL,CAAYC,KAAZ,CAAkB,uDAAlB,EAA2EF,GAA3E;AA9BG,MAAP;AA9BqC;;AAgEvC;AACF;AACA;AACA;AACA;AACA;AACEI,QAtEuC,kBAsEhCC,OAtEgC,EAsEvB;AAAA;;AACd,QAAI,CAACA,OAAD,IAAY,CAACA,OAAO,CAACC,WAAzB,EAAsC;AACpC,WAAKL,MAAL,CAAYC,KAAZ,CAAkB,uDAAlB;AAEA,aAAOjB,iBAAQC,MAAR,CAAe,IAAIqB,KAAJ,CAAU,uDAAV,CAAf,CAAP;AACD;;AAED,WAAO,KAAKvC,KAAL,CAAWC,QAAX,CAAoBmC,MAApB,CAA2BI,MAA3B,CAAkC;AACvCC,cAAQ,EAAEC,cAAKC,EAALD,EAD6B;AAEvCE,gBAAU,EAAE,eAF2B;AAGvCC,kBAAY,EAAE,QAHyB;AAIvCC,mBAAa,EAAE,KAJwB;AAKvCC,kBAAY,EAAE,IALyB;AAMvCC,iBAAW,EAAEX,OAAO,CAACC;AANkB,KAAlC,EAQJP,KARI,CAQE,UAACC,GAAD,EAAS;AACdiB,YAAI,CAAChB,MAAL,CAAYC,KAAZ,CAAkB,iDAAlB,EAAqEF,GAArE;;AAEA,YAAMA,GAAN;AAXG,MAAP;AA7EqC;;AA4FvC;AACF;AACA;AACA;AACA;AACA;AACEkB,QAlGuC,kBAkGhC1B,MAlGgC,EAkGxB;AAAA;;AACb,QAAM2B,QAAQ,GAAG3B,MAAM,CAAC4B,EAAP5B,IAAaA,MAAM,CAAC6B,QAAP7B,IAAmBA,MAAM,CAAC6B,QAAP7B,CAAgB4B,EAAjE;;AAEA,QAAI,CAACD,QAAL,EAAe;AACb,WAAKlB,MAAL,CAAYC,KAAZ,CAAkB,6CAAlB;AAEA,aAAOjB,iBAAQC,MAAR,CAAe,IAAIqB,KAAJ,CAAU,6CAAV,CAAf,CAAP;AACD;;AACD,SAAK1C,aAAL,GAAqB,KAAKD,0BAA1B;AACA,SAAKA,0BAAL,GAAkC,IAAlC,CATa,CAUb;;AACA,QAAM0D,cAAc,GAAG9C,oBAAiBsB,GAAjBtB,CAAqB2C,QAArB3C,CAAvB;;AAEA,QAAI8C,cAAJ,EAAoB;AAClB9C,0BAAiB2B,GAAjB3B,CAAqBgB,MAArBhB;;AAEA,aAAOS,iBAAQsC,OAAR,CAAgB/C,oBAAiBsB,GAAjBtB,CAAqB2C,QAArB3C,CAAhB,CAAP;AAhBW,MAmBb;;;AACA,WAAO,KAAKR,KAAL,CAAWW,OAAX,CAAmB;AACxBC,SAAG,EAAE,KADmB;AAExB4C,YAAM,EAAE,KAFgB;AAGxB3C,cAAQ,mCAA4BsC,QAA5B;AAHgB,KAAnB,EAKJrC,IALI,CAKC,UAACC,GAAD,EAAS;AACb,UAAM0C,SAAS,GAAG1C,GAAG,CAACC,IAAtB;AAEA,aAAO0C,MAAI,CAACC,kBAAL,CAAwBF,SAAxB,CAAP;AARG,OAUJ3C,IAVI,CAUC,UAACU,MAAD,EAAY;AAChBhB,0BAAiB2B,GAAjB3B,CAAqBgB,MAArBhB;;AAEA,aAAOS,iBAAQsC,OAAR,CAAgB/C,oBAAiBsB,GAAjBtB,CAAqB2C,QAArB3C,CAAhB,CAAP;AAbG,OAeJuB,KAfI,CAeE,UAACC,GAAD,EAAS;AACd0B,YAAI,CAACzB,MAAL,CAAYC,KAAZ,CAAkB,qDAAlB,EAAyEF,GAAzE;;AAEA,aAAOf,iBAAQC,MAAR,CAAec,GAAf,CAAP;AAlBG,MAAP;AAtHqC;;AA4IvC;AACF;AACA;AACA;AACA;AACEF,KAjJuC,eAiJnC8B,KAjJmC,EAiJ5B;AAAA;;AACT,QAAI,CAACA,KAAL,EAAY;AACV,WAAK3B,MAAL,CAAYC,KAAZ,CAAkB,sCAAlB;AAEA,aAAOjB,iBAAQC,MAAR,CAAe,IAAIqB,KAAJ,CAAU,sCAAV,CAAf,CAAP;AACD;;AACD,QAAId,UAAJ;AAEA,WAAO,KAAKzB,KAAL,CAAWC,QAAX,CAAoB2B,IAApB,CAAyBiC,qBAAzB,CAA+CD,KAA/C,EACJ9C,IADI,CACC,UAACC,GAAD,EAAS;AACbU,gBAAU,GAAGV,GAAbU;AAEA,aAAOqC,MAAI,CAAC9D,KAAL,CAAWC,QAAX,CAAoB2B,IAApB,CAAyBC,KAAzB,CAA+BC,GAA/B,CAAmC;AAACsB,UAAE,EAAErC,GAAG,CAACgD,UAAJhD,CAAeqC;AAApB,OAAnC,CAAP;AAJG,OAMJtC,IANI,CAMC,UAACkD,MAAD,EAAY;AAChB;AACA;AACA,UAAIA,MAAM,IAAIA,MAAM,CAACX,QAAjBW,IAA6BA,MAAM,CAACX,QAAPW,CAAgBC,WAAjD,EAA8D;AAC5DxC,kBAAU,CAACsC,UAAXtC,CAAsBwC,WAAtBxC,GAAoCuC,MAAM,CAACX,QAAPW,CAAgBC,WAApDxC;AACD;;AAED,aAAOA,UAAP;AAbG,OAeJM,KAfI,CAeE,UAACC,GAAD,EAAS;AACd8B,YAAI,CAAC7B,MAAL,CAAYC,KAAZ,CAAkB,8CAAlB,EAAkEF,GAAlE;;AAEA,aAAOf,iBAAQC,MAAR,CAAec,GAAf,CAAP;AAlBG,MAAP;AAzJqC;;AA+KvC;AACF;AACA;AACA;AACA;AACA;AACEkC,QArLuC,kBAqLhCf,QArLgC,EAqLtB;AAAA;;AACf,QAAI,CAACA,QAAL,EAAe;AACb,WAAKlB,MAAL,CAAYC,KAAZ,CAAkB,4CAAlB;AAEA,aAAOjB,iBAAQC,MAAR,CAAe,IAAIqB,KAAJ,CAAU,4CAAV,CAAf,CAAP;AACD;;AAED,WAAO,KAAKvC,KAAL,CAAWW,OAAX,CAAmB;AACxB6C,YAAM,EAAE,QADgB;AAExB5C,SAAG,EAAE,KAFmB;AAGxBC,cAAQ,8BAAuBsC,QAAvB;AAHgB,KAAnB,EAKJpB,KALI,CAKE,UAACG,KAAD,EAAW;AAChBiC,YAAI,CAAClC,MAAL,CAAYC,KAAZ,CAAkB,mDAAlB,EAAuEA,KAAvE;;AAEA,aAAOjB,iBAAQC,MAAR,CAAegB,KAAf,CAAP;AARG,MAAP;AA5LqC;;AAwMvC;AACF;AACA;AACA;AACA;AACA;AACA;AACEkC,YA/MuC,sBA+M5B5C,MA/M4B,EA+MN;AAAA;;AAAA,QAAda,OAAc,uEAAJ,EAAI;AAC/B,QAAMc,QAAQ,GAAG3B,MAAM,CAAC4B,EAAP5B,IAAaA,MAAM,CAAC6B,QAAP7B,IAAmBA,MAAM,CAAC6B,QAAP7B,CAAgB4B,EAAjE;;AAEA,QAAI,CAACD,QAAL,EAAe;AACb,WAAKlB,MAAL,CAAYC,KAAZ,CAAkB,iDAAlB;AAEA,aAAOjB,iBAAQC,MAAR,CAAe,IAAIqB,KAAJ,CAAU,iDAAV,CAAf,CAAP;AACD;;AACD,QAAMV,KAAK,GAAG;AAACuB,QAAE,EAAED,QAAL;AAAekB,SAAG,oBAAalB,QAAb;AAAlB,KAAd;AAEA,WAAO,KAAKnD,KAAL,CAAWC,QAAX,CAAoB2B,IAApB,CAAyBC,KAAzB,CAA+BC,GAA/B,CAAmCD,KAAnC,EACJf,IADI,CACC,UAACwD,GAAD,EAAS;AAAE;AACf,UAAIA,GAAG,IAAIA,GAAG,CAACC,SAAXD,IAAwBA,GAAG,CAACC,SAAJD,CAAcE,YAA1C,EAAwD;AACtDC,cAAI,CAACxC,MAAL,CAAYyC,IAAZ,CAAiB,0DAAjB;;AAEA,eAAOD,MAAI,CAACzE,KAAL,CAAWC,QAAX,CAAoB2B,IAApB,CAAyBC,KAAzB,CAA+B8C,IAA/B,CAAoC9C,KAApC,EAA2C;AAChD+C,kBAAQ,EAAE,QADsC;AAEhDC,gCAAsB,EAAE,KAFwB;AAGhDzE,cAAI,EAAEiC,OAAO,CAACjC;AAHkC,SAA3C,EAKJU,IALI,CAKC,YAAM;AACV2D,gBAAI,CAAC7E,0BAAL,GAAkC0E,GAAlC,CADU,CAGV;AACA;;AACA,iBAAOA,GAAP;AAVG,UAAP;AAJW,QAiBb;;;AACAG,YAAI,CAACxC,MAAL,CAAYyC,IAAZ,CAAiB,wHAAjB;;AAEA,aAAOD,MAAI,CAACzE,KAAL,CAAWC,QAAX,CAAoB2B,IAApB,CAAyBC,KAAzB,CAA+BC,GAA/B,CAAmCD,KAAnC,EACJf,IADI,CACC;AAAA,eAAMG,iBAAQsC,OAAR,CAAgBe,GAAhB,CAAN;AADD,QAAP;AArBG,OAwBJvC,KAxBI,CAwBE,UAACC,GAAD,EAAS;AACdyC,YAAI,CAACxC,MAAL,CAAYC,KAAZ,CAAkB,+DAAlB,EAAmFF,GAAnF;;AAEA,aAAOf,iBAAQC,MAAR,CAAec,GAAf,CAAP;AA3BG,MAAP;AAzNqC;;AAwPvC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACE8C,MAhQuC,kBAgQpB;AAAA;;AAAA,QAAdzC,OAAc,uEAAJ,EAAI;;AACjB,QAAI,CAACA,OAAO,CAAC0C,GAAb,EAAkB;AAChB,WAAK9C,MAAL,CAAYC,KAAZ,CAAkB,6CAAlB;AAEA,aAAOjB,iBAAQC,MAAR,CAAe,IAAIqB,KAAJ,CAAU,6CAAV,CAAf,CAAP;AACD;;AACD,QAAI,KAAK3C,0BAAT,EAAqC;AACnC,UAAMiC,KAAK,GAAG;AAACuB,UAAE,EAAE,KAAKxD,0BAAL,CAAgCyD,QAAhC,CAAyCD,EAA9C;AAAkDiB,WAAG,oBAAa,KAAKzE,0BAAL,CAAgCyD,QAAhC,CAAyCD,EAAtD;AAArD,OAAd;AAEA,aAAO,KAAKpD,KAAL,CAAWC,QAAX,CAAoB2B,IAApB,CAAyBC,KAAzB,CAA+B8C,IAA/B,CAAoC9C,KAApC,EAA2C;AAChD+C,gBAAQ,EAAE,YADsC;AAEhDxE,YAAI,EAAEiC,OAAO,CAAC0C;AAFkC,OAA3C,EAIJhD,KAJI,CAIE,UAACC,GAAD,EAAS;AACdgD,cAAI,CAAC/C,MAAL,CAAYC,KAAZ,CAAkB,oDAAlB,EAAwEF,GAAxE;;AAEA,eAAOf,iBAAQC,MAAR,CAAec,GAAf,CAAP;AAPG,SASJlB,IATI,CASC;AAAA,eAAMkE,MAAI,CAAC9B,MAAL,CAAY8B,MAAI,CAACpF,0BAAjB,CAAN;AATD,QAAP;AAUD;;AACD,SAAKqC,MAAL,CAAYC,KAAZ,CAAkB,uCAAlB;AAEA,WAAOjB,iBAAQC,MAAR,CAAe,IAAIqB,KAAJ,CAAU,uCAAV,CAAf,CAAP;AAtRqC;;AAyRvC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE0C,QAlSuC,oBAkSlB;AAAA;;AAAA,QAAd5C,OAAc,uEAAJ,EAAI;;AACnB,QAAI,CAAC,KAAKxC,aAAV,EAAyB;AACvB,WAAKoC,MAAL,CAAYC,KAAZ,CAAkB,2CAAlB;AAEA,aAAOjB,iBAAQC,MAAR,CAAe,IAAIqB,KAAJ,CAAU,2CAAV,CAAf,CAAP;AACD;;AACD,QAAMV,KAAK,GAAG;AAACwC,SAAG,oBAAa,KAAKxE,aAAL,CAAmBwD,QAAnB,CAA4BD,EAAzC;AAAJ,KAAd;AAEA,WAAO,KAAKpD,KAAL,CAAWC,QAAX,CAAoB2B,IAApB,CAAyBC,KAAzB,CAA+BqD,KAA/B,CAAqCrD,KAArC,EAA4CQ,OAA5C,EACJN,KADI,CACE,UAACC,GAAD,EAAS;AACdmD,YAAI,CAAClD,MAAL,CAAYC,KAAZ,CAAkB,yDAAlB,EAA6EF,GAA7E;;AAEA,aAAOf,iBAAQC,MAAR,CAAec,GAAf,CAAP;AAJG,MAAP;AA1SqC;;AAkTvC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACEoD,WA1TuC,uBA0Tf;AAAA;;AAAA,QAAd/C,OAAc,uEAAJ,EAAI;;AACtB,QAAI,CAACA,OAAO,CAACgC,GAAb,EAAkB;AAChB,WAAKpC,MAAL,CAAYC,KAAZ,CAAkB,6CAAlB;AAEA,aAAOjB,iBAAQC,MAAR,CAAe,IAAIqB,KAAJ,CAAU,kDAAV,CAAf,CAAP;AACD;;AACD,QAAI,CAACF,OAAO,CAACgD,oBAAb,EAAmC;AACjC,WAAKpD,MAAL,CAAYC,KAAZ,CAAkB,mEAAlB;AAEA,aAAOjB,iBAAQC,MAAR,CAAe,IAAIqB,KAAJ,CAAU,mEAAV,CAAf,CAAP;AACD;;AACD,QAAI,CAAC,KAAK1C,aAAV,EAAyB;AACvB,WAAKoC,MAAL,CAAYC,KAAZ,CAAkB,qDAAlB;AAEA,aAAOjB,iBAAQC,MAAR,CAAe,IAAIqB,KAAJ,CAAU,qDAAV,CAAf,CAAP;AACD;;AACD,QAAMV,KAAK,GAAG;AAACwC,SAAG,oBAAa,KAAKxE,aAAL,CAAmBwD,QAAnB,CAA4BD,EAAzC,CAAJ;AAAmDA,QAAE,EAAE,KAAKvD,aAAL,CAAmBwD,QAAnB,CAA4BD;AAAnF,KAAd;AAEA,SAAKtD,WAAL,GAAmB;AACjBuF,0BAAoB,EAAEhD,OAAO,CAACgD,oBADb;AAEjBhB,SAAG,EAAEhC,OAAO,CAACgC;AAFI,KAAnB;AAKA,WAAO,KAAKrE,KAAL,CAAWC,QAAX,CAAoB2B,IAApB,CAAyBC,KAAzB,CAA+ByD,gBAA/B,CAAgDzD,KAAhD,EAAuD,KAAK/B,WAA5D,EACJiC,KADI,CACE,UAACC,GAAD,EAAS;AACduD,aAAI,CAACtD,MAAL,CAAYC,KAAZ,CAAkB,yDAAlB;;AAEA,aAAOjB,iBAAQC,MAAR,CAAec,GAAf,CAAP;AAJG,MAAP;AAjVqC;;AAyVvC;AACF;AACA;AACA;AACA;AACEwD,aA9VuC,yBA8VzB;AAAA;;AACZ,QAAI,CAAC,KAAK3F,aAAN,IAAuB,CAAC,KAAKC,WAAjC,EAA8C;AAC5C,WAAKmC,MAAL,CAAYC,KAAZ,CAAkB,mEAAlB;AAEA,aAAOjB,iBAAQC,MAAR,CAAe,IAAIqB,KAAJ,CAAU,mEAAV,CAAf,CAAP;AACD;;AACD,QAAMV,KAAK,GAAG;AAACwC,SAAG,oBAAa,KAAKxE,aAAL,CAAmBwD,QAAnB,CAA4BD,EAAzC,CAAJ;AAAmDA,QAAE,EAAE,KAAKvD,aAAL,CAAmBwD,QAAnB,CAA4BD;AAAnF,KAAd;AAEA,WAAO,KAAKpD,KAAL,CAAWC,QAAX,CAAoB2B,IAApB,CAAyBC,KAAzB,CAA+B4D,kBAA/B,CAAkD5D,KAAlD,EAAyD,KAAK/B,WAA9D,EACJgB,IADI,CACC,UAACC,GAAD,EAAS;AACb2E,aAAI,CAAC5F,WAAL,GAAmB,IAAnB;AAEA,aAAOmB,iBAAQsC,OAAR,CAAgBxC,GAAhB,CAAP;AAJG,OAMJgB,KANI,CAME,UAACC,GAAD,EAAS;AACd0D,aAAI,CAACzD,MAAL,CAAYC,KAAZ,CAAkB,6DAAlB;;AAEA,aAAOjB,iBAAQC,MAAR,CAAec,GAAf,CAAP;AATG,MAAP;AAtWqC;;AAmXvC;AACF;AACA;AACA;AACA;AACE2D,eAxXuC,2BAwXvB;AACd,QAAI,CAAC,KAAK9F,aAAV,EAAyB;AACvB,WAAKoC,MAAL,CAAYC,KAAZ,CAAkB,4DAAlB;AAEA,aAAOjB,iBAAQC,MAAR,CAAe,IAAIqB,KAAJ,CAAU,4DAAV,CAAf,CAAP;AACD;;AAED,WAAO,KAAKvC,KAAL,CAAWC,QAAX,CAAoB2B,IAApB,CAAyBJ,MAAzB,CAAgCmE,aAAhC,CAA8C,KAAK9F,aAAnD,CAAP;AA/XqC;;AAkYvC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACE+F,eA1YuC,yBA0YzB/D,KA1YyB,EA0YD;AAAA,QAAjBgE,UAAiB,uEAAJ,EAAI;AACpC,WAAO,KAAK7F,KAAL,CAAWC,QAAX,CAAoB2B,IAApB,CAAyBJ,MAAzB,CAAgCoE,aAAhC,CAA8C/D,KAA9C,EAAqDgE,UAArD,CAAP;AA3YqC;;AA8YvC;AACF;AACA;AACA;AACA;AACEC,MAnZuC,kBAmZhC;AACL,QAAI,CAAC,KAAKjG,aAAV,EAAyB;AACvB,WAAKoC,MAAL,CAAYC,KAAZ,CAAkB,mDAAlB;AAEA,aAAOjB,iBAAQC,MAAR,CAAe,IAAIqB,KAAJ,CAAU,mDAAV,CAAf,CAAP;AACD;;AAED,WAAO,KAAKvC,KAAL,CAAWC,QAAX,CAAoB2B,IAApB,CAAyBJ,MAAzB,CAAgCsE,IAAhC,CAAqC,KAAKjG,aAA1C,CAAP;AA1ZqC;;AA6ZvC;AACF;AACA;AACA;AACA;AACEkG,QAlauC,oBAka9B;AACP,QAAI,CAAC,KAAKlG,aAAV,EAAyB;AACvB,WAAKoC,MAAL,CAAYC,KAAZ,CAAkB,qDAAlB;AAEA,aAAOjB,iBAAQC,MAAR,CAAe,IAAIqB,KAAJ,CAAU,qDAAV,CAAf,CAAP;AACD;;AAED,WAAO,KAAKvC,KAAL,CAAWC,QAAX,CAAoB2B,IAApB,CAAyBJ,MAAzB,CAAgCuE,MAAhC,CAAuC,KAAKlG,aAA5C,CAAP;AAzaqC;;AA4avC;AACF;AACA;AACA;AACA;AACEmG,gBAjbuC,4BAibtB;AACf,QAAI,CAAC,KAAKnG,aAAV,EAAyB;AACvB,WAAKoC,MAAL,CAAYC,KAAZ,CAAkB,6DAAlB;AAEA,aAAOjB,iBAAQC,MAAR,CAAe,IAAIqB,KAAJ,CAAU,6DAAV,CAAf,CAAP;AACD;;AAED,WAAO,KAAKvC,KAAL,CAAWC,QAAX,CAAoB2B,IAApB,CAAyBJ,MAAzB,CAAgCwE,cAAhC,CAA+C,KAAKnG,aAApD,CAAP;AAxbqC;;AA2bvC;AACF;AACA;AACA;AACA;AACEoG,gBAhcuC,4BAgctB;AACf,QAAI,CAAC,KAAKpG,aAAV,EAAyB;AACvB,WAAKoC,MAAL,CAAYC,KAAZ,CAAkB,6DAAlB;AAEA,aAAOjB,iBAAQC,MAAR,CAAe,IAAIqB,KAAJ,CAAU,6DAAV,CAAf,CAAP;AACD;;AAED,WAAO,KAAKvC,KAAL,CAAWC,QAAX,CAAoB2B,IAApB,CAAyBJ,MAAzB,CAAgCyE,cAAhC,CAA+C,KAAKpG,aAApD,CAAP;AAvcqC;;AA0cvC;AACF;AACA;AACA;AACA;AACA;AACEqG,WAhduC,uBAgdlB;AAAA,QAAXC,KAAW,uEAAH,CAAG;;AACnB,QAAI,CAAC,KAAKtG,aAAV,EAAyB;AACvB,WAAKoC,MAAL,CAAYC,KAAZ,CAAkB,wDAAlB;AAEA,aAAOjB,iBAAQC,MAAR,CAAe,IAAIqB,KAAJ,CAAU,wDAAV,CAAf,CAAP;AACD;;AAED,WAAO,KAAKvC,KAAL,CAAWC,QAAX,CAAoB2B,IAApB,CAAyBJ,MAAzB,CAAgC0E,SAAhC,CAA0C,KAAKrG,aAA/C,EAA8DsG,KAA9D,CAAP;AAvdqC;;AA0dvC;AACF;AACA;AACA;AACA;AACE/E,uBA/duC,mCA+dC;AAAA;;AAAA,QAAlBgF,WAAkB,uEAAJ,EAAI;;AACtC,QAAI,CAACA,WAAW,CAACC,MAAjB,EAAyB;AACvB,aAAOpF,iBAAQsC,OAAR,CAAgB6C,WAAhB,CAAP;AACD;;AACD,QAAM9E,OAAO,GAAG,yBAAU8E,WAAV,CAAhB;AAEA,WAAOnF,iBAAQqF,GAAR,CAAYhF,OAAO,CAACiF,GAARjF,CACjB,UAACE,MAAD,EAASgF,KAAT;AAAA,aAAmBC,OAAI,CAACzG,KAAL,CAAWC,QAAX,CAAoByG,QAApB,CAA6BC,cAA7B,CAA4C,UAA5C,EAChB7F,IADgB,CACX,YAAM;AACV,YAAIU,MAAM,CAACoF,WAAPpF,KAAuBqF,mBAA3B,EAAqC;AACnCrF,gBAAM,CAAC4B,EAAP5B,aAAeiF,OAAI,CAACzG,KAAL,CAAWC,QAAX,CAAoByG,QAApB,CAA6B5E,GAA7B,CAAiC,KAAjC,CAAf,cAA0DN,MAAM,CAAC4B,EAAjE;AACD;;AAED,eAAOqD,OAAI,CAAC9C,kBAAL,CAAwBnC,MAAxB,CAAP;AANe,SAQhBV,IARgB,CAQX,UAACgG,aAAD,EAAmB;AACvBxF,eAAO,CAACkF,KAAD,CAAPlF,GAAiBwF,aAAjBxF;AAEA,eAAOL,iBAAQsC,OAAR,EAAP;AAXe,QAAnB;AADiB,MAAZ,EAeJzC,IAfI,CAeC;AAAA,aAAMG,iBAAQsC,OAAR,CAAgBjC,OAAhB,CAAN;AAfD,MAAP;AAreqC;;AAufvC;AACF;AACA;AACA;AACA;AACEqC,oBA5fuC,gCA4fL;AAAA;;AAAA,QAAfoD,QAAe,uEAAJ,EAAI;AAChC,QAAMvF,MAAM,GAAG,yBAAUuF,QAAV,CAAf;;AAEA,QAAIvF,MAAM,CAACwF,QAAPxF,IACFA,MAAM,CAACwF,QAAPxF,CAAgByF,yBADdzF,IAEFA,MAAM,CAACwF,QAAPxF,CAAgB0F,gBAFlB,EAEoC;AAClC,aAAO,KAAKlH,KAAL,CAAWC,QAAX,CAAoBkH,UAApB,CAA+BC,WAA/B,CACL5F,MAAM,CAACwF,QAAPxF,CAAgB0F,gBADX,EAC6B1F,MAAM,CAACwF,QAAPxF,CAAgByF,yBAD7C,EAGJnG,IAHI,CAGC,UAACuG,mBAAD,EAAyB;AAC7B;AACA7F,cAAM,CAACwF,QAAPxF,CAAgByF,yBAAhBzF,GAA4C8F,SAA5C9F;AACAA,cAAM,CAACwF,QAAPxF,CAAgB+F,gBAAhB/F,GAAmC6F,mBAAnC7F;AAEA,eAAOP,iBAAQsC,OAAR,CAAgB/B,MAAhB,CAAP;AARG,SAUJO,KAVI,CAUE,UAACC,GAAD,EAAS;AACd;AACAR,cAAM,CAACwF,QAAPxF,CAAgByF,yBAAhBzF,GAA4C8F,SAA5C9F;;AACAgG,eAAI,CAACvF,MAAL,CAAYC,KAAZ,CAAkB,oEAAlB,EAAwFF,GAAxF;AAbG,QAAP;AAeD;;AAED,WAAOf,iBAAQsC,OAAR,CAAgB/B,MAAhB,CAAP;AAnhBqC;;AAshBvC;AACF;AACA;AACA;AACA;AACElB,uBA3hBuC,iCA2hBjBkB,MA3hBiB,EA2hBT;AAAA,wBAC5B;;;AACA,QAAIA,MAAM,IAAIA,MAAM,CAACiG,QAArB,EAA+B;AAC7B,UAAMtE,QAAQ,GAAG3B,MAAM,CAACiG,QAAPjG,CAAgBkG,SAAhBlG,CAA0BA,MAAM,CAACiG,QAAPjG,CAAgBmG,WAAhBnG,CAA4B,GAA5BA,IAAmC,CAA7DA,CAAjB;;AACA,UAAM8B,cAAc,GAAG9C,oBAAiBsB,GAAjBtB,CAAqB2C,QAArB3C,CAAvB;;AAEA,UAAI8C,cAAJ,EAAoB;AAClB,eAAO,KAAKtD,KAAL,CAAWC,QAAX,CAAoB2B,IAApB,CAAyBC,KAAzB,CAA+BC,GAA/B,CAAmC;AAACsB,YAAE,EAAED;AAAL,SAAnC,EACJrC,IADI,CACC,UAACe,KAAD,EAAW;AACf,cAAML,MAAM,GAAGhB,oBAAiBsB,GAAjBtB,CAAqB2C,QAArB3C,CAAf;;AAEA,cAAIgB,MAAM,IACRK,KAAK,CAAC0C,SADJ/C,KAED,CAACK,KAAK,CAAC0C,SAAN1C,CAAgB+F,IAAjB,IAAyB,CAAC/F,KAAK,CAAC0C,SAAN1C,CAAgB+F,IAAhB/F,CAAqBgG,QAF9CrG,CAAJ,EAE6D;AAC3DA,kBAAM,CAACsG,WAAPtG,GAAqBK,KAAK,CAACP,OAANO,IAAiBA,KAAK,CAACP,OAANO,CAAc,CAAdA,CAAjBA,IAAqCA,KAAK,CAACP,OAANO,CAAc,CAAdA,EAAiBiG,WAAtDjG,IACrBkG,+BADAvG,CAD2D,CAG3D;AACA;;AACA,gBAAMwG,cAAc,GAAGC,OAAI,CAACpI,aAAL,KAAuBoI,OAAI,CAACpI,aAAL,CAAmBuD,EAAnB,IAAyB6E,OAAI,CAACpI,aAAL,CAAmBwD,QAAnB,CAA4BD,EAA5E,CAAvB;;AAEA,gBAAI4E,cAAc,KAAK7E,QAAvB,EAAiC;AAC/B8E,qBAAI,CAACpI,aAAL,GAAqB,IAArB;;AACAoI,qBAAI,CAAChG,MAAL,CAAYyC,IAAZ,uDAAgEvB,QAAhE;;AAEA,qBAAOlC,iBAAQsC,OAAR,EAAP;AAXyD,cAa3D;;;AACA,gBAAI0E,OAAI,CAACrI,0BAAL,CAAgCyD,QAAhC,CAAyCD,EAAzC,KAAgDD,QAApD,EAA8D;AAC5D,qBAAO8E,OAAI,CAAC/E,MAAL,CAAY1B,MAAZ,CAAP;AACD;;AAED,mBAAOP,iBAAQsC,OAAR,EAAP;AACD;;AAED,iBAAOtC,iBAAQsC,OAAR,EAAP;AA3BG,WA6BJxB,KA7BI,CA6BE,UAACC,GAAD,EAAS;AACdiG,iBAAI,CAAChG,MAAL,CAAYC,KAAZ,CAAkB,+EAAlB,EAAmGF,GAAnG;AA9BG,UAAP;AAgCD;AACF;;AAED,WAAOf,iBAAQsC,OAAR,EAAP;AArkBqC;AAAA2E;AAAA,CAAnBzI,CAAtB;;eA2kBeD","names":["require","DeviceManager","WebexPlugin","extend","namespace","_devicePendingPinChallenge","_pairedDevice","_boundSpace","initialize","webex","internal","mercury","on","data","_this","_receiveDeviceUpdates","getAll","DeviceCollection","refresh","reset","request","api","resource","then","res","body","_promise","reject","_this2","_updateDeviceMetadata","items","devices","forEach","device","deviceInfo","machineType","LYRA_SPACE","lyra","space","get","catch","err","logger","error","set","search","options","searchQuery","Error","people","searchId","uuid","v4","searchType","searchEntity","includePeople","includeRooms","queryString","_this3","upsert","deviceId","id","identity","existingDevice","resolve","method","auxDevice","_this4","_decryptDeviceName","token","getAdvertisedEndpoint","_this5","advertiser","result","displayName","remove","_this6","requestPin","url","dev","occupants","pinChallenge","_this7","info","join","passType","verificationInitiation","pair","pin","_this8","unpair","leave","_this9","bindSpace","kmsResourceObjectUrl","bindConversation","_this10","unbindSpace","unbindConversation","_this11","getAudioState","putAudioState","audioState","mute","unmute","increaseVolume","decreaseVolume","setVolume","level","deviceArray","length","all","map","index","_this12","services","waitForCatalog","deviceClass","UC_CLOUD","updatedDevice","inDevice","metadata","encryptedUserAssignedName","encryptionKeyUrl","encryption","decryptText","decryptedDeviceName","undefined","userAssignedName","_this13","spaceUrl","substring","lastIndexOf","self","verified","productName","DEFAULT_PRODUCT_NAME","pairedDeviceId","_this14","version"],"sources":["device-manager.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\nimport {cloneDeep} from 'lodash';\nimport '@webex/internal-plugin-lyra';\nimport '@webex/internal-plugin-search';\nimport {WebexPlugin} from '@webex/webex-core';\nimport uuid from 'uuid';\n\nimport {LYRA_SPACE, UC_CLOUD, DEFAULT_PRODUCT_NAME} from './constants';\nimport DeviceCollection from './collection';\n\nconst DeviceManager = WebexPlugin.extend({\n  namespace: 'DeviceManager',\n  _devicePendingPinChallenge: null,\n  _pairedDevice: null,\n  _boundSpace: null,\n\n  initialize() {\n    // Lyra mercury events listener\n    this.webex.internal.mercury.on('event:lyra.space_updated', ({data}) => {\n      this._receiveDeviceUpdates(data);\n    });\n  },\n\n  /**\n  * Gets a list of all recent devices associated with the user\n  * the device list gets populated from Redis\n  * @returns {Promise<Device>}\n  */\n  getAll() {\n    return DeviceCollection.getAll();\n  },\n\n  /**\n  * Gets a list of all recent devices associated with the user\n  * the device list gets populated from Redis\n  * @returns {Promise<Device>}\n  */\n  refresh() {\n    DeviceCollection.reset();\n\n    return this.webex.request({\n      api: 'wdm',\n      resource: 'devices/auxiliary'\n    })\n      .then((res) => {\n        if (!res.body) {\n          return Promise.reject();\n        }\n\n        return this._updateDeviceMetadata(res.body.items)\n          .then((devices) => {\n            /* eslint-disable consistent-return */\n            devices.forEach((device) => {\n              if (device.deviceInfo &&\n                device.deviceInfo.machineType === LYRA_SPACE) {\n                return this.webex.internal.lyra.space.get(device.deviceInfo)\n                  .catch((err) => {\n                    this.logger.error('DeviceManager#refresh: failed to receive device info', err);\n                  });\n              }\n            });\n            /* eslint-enable consistent-return */\n            res.body.items.forEach((device) => {\n              DeviceCollection.set(device);\n            });\n\n            return this.getAll();\n          });\n      })\n      .catch((err) => {\n        this.logger.error('DeviceManager#refresh: failed to fetch recent devices', err);\n      });\n  },\n\n  /**\n  * Search for a device by name\n  * @param {Object} options\n  * @param {string} options.searchQuery\n  * @returns {Promise<Device>}\n  */\n  search(options) {\n    if (!options || !options.searchQuery) {\n      this.logger.error('DeviceManager#search: options.searchQuery is required');\n\n      return Promise.reject(new Error('DeviceManager#search: options.searchQuery is required'));\n    }\n\n    return this.webex.internal.search.people({\n      searchId: uuid.v4(),\n      searchType: 'DEVICE_SEARCH',\n      searchEntity: 'device',\n      includePeople: false,\n      includeRooms: true,\n      queryString: options.searchQuery\n    })\n      .catch((err) => {\n        this.logger.error('DeviceManager#search: failed to search a device', err);\n\n        throw err;\n      });\n  },\n\n  /**\n  * Caches the device info and also registers to Redis for subsequent fetches\n  * @param {Object} device\n  * @param {string} device.id\n  * @returns {deviceInfo}\n  */\n  upsert(device) {\n    const deviceId = device.id || device.identity && device.identity.id;\n\n    if (!deviceId) {\n      this.logger.error('DeviceManager#upsert: device.id is required');\n\n      return Promise.reject(new Error('DeviceManager#upsert: device.id is required'));\n    }\n    this._pairedDevice = this._devicePendingPinChallenge;\n    this._devicePendingPinChallenge = null;\n    // check if the device is already existing, if so then merge else add\n    const existingDevice = DeviceCollection.get(deviceId);\n\n    if (existingDevice) {\n      DeviceCollection.set(device);\n\n      return Promise.resolve(DeviceCollection.get(deviceId));\n    }\n\n    // new device requested, add to wdm for subsequent retreivals\n    return this.webex.request({\n      api: 'wdm',\n      method: 'PUT',\n      resource: `devices/auxiliary/Room/${deviceId}`\n    })\n      .then((res) => {\n        const auxDevice = res.body;\n\n        return this._decryptDeviceName(auxDevice);\n      })\n      .then((device) => {\n        DeviceCollection.set(device);\n\n        return Promise.resolve(DeviceCollection.get(deviceId));\n      })\n      .catch((err) => {\n        this.logger.error('DeviceManager#upsert: failed to add/update a device', err);\n\n        return Promise.reject(err);\n      });\n  },\n\n  /**\n  * Retreives device info of a particular device\n  * @param {string} token\n  * @returns {Promise<deviceInfo>}\n  */\n  get(token) {\n    if (!token) {\n      this.logger.error('DeviceManager#get: token is required');\n\n      return Promise.reject(new Error('DeviceManager#get: token is required'));\n    }\n    let deviceInfo;\n\n    return this.webex.internal.lyra.getAdvertisedEndpoint(token)\n      .then((res) => {\n        deviceInfo = res;\n\n        return this.webex.internal.lyra.space.get({id: res.advertiser.id});\n      })\n      .then((result) => {\n        // the deviceInfo doesn't have proper displayName, hence update\n        // displayName on deviceInfo for search to work\n        if (result && result.identity && result.identity.displayName) {\n          deviceInfo.advertiser.displayName = result.identity.displayName;\n        }\n\n        return deviceInfo;\n      })\n      .catch((err) => {\n        this.logger.error('DeviceManager#get: failed to get device info', err);\n\n        return Promise.reject(err);\n      });\n  },\n\n  /**\n  * Unregisters the device from Redis, will not fetch in subsequent loads,\n  * similar to space.deleteBinding()\n  * @param {string} deviceId\n  * @returns {Promise<deviceInfo>}\n  */\n  remove(deviceId) {\n    if (!deviceId) {\n      this.logger.error('DeviceManager#remove: deviceId is required');\n\n      return Promise.reject(new Error('DeviceManager#remove: deviceId is required'));\n    }\n\n    return this.webex.request({\n      method: 'delete',\n      api: 'wdm',\n      resource: `devices/auxiliary/${deviceId}`\n    })\n      .catch((error) => {\n        this.logger.error('DeviceManager#remove: failed to remove the device', error);\n\n        return Promise.reject(error);\n      });\n  },\n\n  /**\n  * Requests to display PIN on the device\n  * @param {object} device\n  * @param {object} options\n  * @param {object} options.data\n  * @returns {Promise<deviceInfo>}\n  */\n  requestPin(device, options = {}) {\n    const deviceId = device.id || device.identity && device.identity.id;\n\n    if (!deviceId) {\n      this.logger.error('DeviceManager#requestPin: device.id is required');\n\n      return Promise.reject(new Error('DeviceManager#requestPin: device.id is required'));\n    }\n    const space = {id: deviceId, url: `/spaces/${deviceId}`};\n\n    return this.webex.internal.lyra.space.get(space)\n      .then((dev) => { // check if the space is pinChallenge capable\n        if (dev && dev.occupants && dev.occupants.pinChallenge) {\n          this.logger.info('DeviceManager#requestPin: space is PIN challenge capable');\n\n          return this.webex.internal.lyra.space.join(space, {\n            passType: 'MANUAL',\n            verificationInitiation: 'PIN',\n            data: options.data\n          })\n            .then(() => {\n              this._devicePendingPinChallenge = dev;\n\n              // return the actual device so that it can be upserted on successful\n              // PIN exchange\n              return dev;\n            });\n        }\n        // pairs with the space if it's not PIN challenge capable\n        this.logger.info('DeviceManager#requestPin: space is not PIN challenge capable, probably already occupied, will still return device info');\n\n        return this.webex.internal.lyra.space.get(space)\n          .then(() => Promise.resolve(dev));\n      })\n      .catch((err) => {\n        this.logger.error('DeviceManager#requestPin: device failed PIN challenge request', err);\n\n        return Promise.reject(err);\n      });\n  },\n\n  /**\n  * pairs the device with the user (manual pairing), also adds it to\n  * user's recents list for subsequent fetches.\n  * similar to space.join()\n  * @param {object} options\n  * @param {number} options.pin\n  * @returns {Promise<deviceInfo>}\n  */\n  pair(options = {}) {\n    if (!options.pin) {\n      this.logger.error('DeviceManager#pair: options.pin is required');\n\n      return Promise.reject(new Error('DeviceManager#pair: options.pin is required'));\n    }\n    if (this._devicePendingPinChallenge) {\n      const space = {id: this._devicePendingPinChallenge.identity.id, url: `/spaces/${this._devicePendingPinChallenge.identity.id}`};\n\n      return this.webex.internal.lyra.space.join(space, {\n        passType: 'PIN_ANSWER',\n        data: options.pin\n      })\n        .catch((err) => {\n          this.logger.error('DeviceManager#pair: incorrect PIN, unable to pair ', err);\n\n          return Promise.reject(err);\n        })\n        .then(() => this.upsert(this._devicePendingPinChallenge));\n    }\n    this.logger.error('DeviceManager#pair: no device to pair');\n\n    return Promise.reject(new Error('DeviceManager#pair: no device to pair'));\n  },\n\n  /**\n  * unpairs the device with the user (manual/ultrasonic pairing), but still\n  * keeps in the recents list/does not remove from Redis\n  * options.removeAllDevices will remove all associated devices to user\n  * similar to space.leave()\n  * @param {object} options\n  * @param {boolean} options.removeAllDevices\n  * @returns {Promise<deviceInfo>}\n  */\n  unpair(options = {}) {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#unpair: no device to unpair');\n\n      return Promise.reject(new Error('DeviceManager#unpair: no device to unpair'));\n    }\n    const space = {url: `/spaces/${this._pairedDevice.identity.id}`};\n\n    return this.webex.internal.lyra.space.leave(space, options)\n      .catch((err) => {\n        this.logger.error('DeviceManager#unpair: failed to remove device from Lyra', err);\n\n        return Promise.reject(err);\n      });\n  },\n\n  /**\n  * binds the space to the paired device (if supported)\n  * similar to space.bindConversation()\n  * @param {object} options\n  * @param {boolean} options.url, conversation url\n  * @param {boolean} options.kmsResourceObjectUrl of the convo\n  * @returns {Promise<deviceInfo>}\n  */\n  bindSpace(options = {}) {\n    if (!options.url) {\n      this.logger.error('DeviceManager#pair: options.url is required');\n\n      return Promise.reject(new Error('DeviceManager#bindSpace: options.url is required'));\n    }\n    if (!options.kmsResourceObjectUrl) {\n      this.logger.error('DeviceManager#bindSpace: options.kmsResourceObjectUrl is required');\n\n      return Promise.reject(new Error('DeviceManager#bindSpace: options.kmsResourceObjectUrl is required'));\n    }\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#bindSpace: No device paired currently');\n\n      return Promise.reject(new Error('DeviceManager#bindSpace: No device paired currently'));\n    }\n    const space = {url: `/spaces/${this._pairedDevice.identity.id}`, id: this._pairedDevice.identity.id};\n\n    this._boundSpace = {\n      kmsResourceObjectUrl: options.kmsResourceObjectUrl,\n      url: options.url\n    };\n\n    return this.webex.internal.lyra.space.bindConversation(space, this._boundSpace)\n      .catch((err) => {\n        this.logger.error('DeviceManager#bindSpace: failed to bind device to Space');\n\n        return Promise.reject(err);\n      });\n  },\n\n  /**\n  * unbinds the space to the paired device (if supported)\n  * similar to space.unbindConversation()\n  * @returns {Promise<deviceInfo>}\n  */\n  unbindSpace() {\n    if (!this._pairedDevice || !this._boundSpace) {\n      this.logger.error('DeviceManager#unbindSpace: No space currently bound to the device');\n\n      return Promise.reject(new Error('DeviceManager#unbindSpace: No space currently bound to the device'));\n    }\n    const space = {url: `/spaces/${this._pairedDevice.identity.id}`, id: this._pairedDevice.identity.id};\n\n    return this.webex.internal.lyra.space.unbindConversation(space, this._boundSpace)\n      .then((res) => {\n        this._boundSpace = null;\n\n        return Promise.resolve(res);\n      })\n      .catch((err) => {\n        this.logger.error('DeviceManager#unbindSpace: failed to unbind Space to device');\n\n        return Promise.reject(err);\n      });\n  },\n\n  /**\n  * Gets the audio state of the paired device\n  * similar to device.getAudioState()\n  * @returns {Promise<audioState>}\n  */\n  getAudioState() {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#getAudioState: Currently no device is paired');\n\n      return Promise.reject(new Error('DeviceManager#getAudioState: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.getAudioState(this._pairedDevice);\n  },\n\n  /**\n  * Updates audio state of the paired device, should be called every 10 minutes\n  * or when mic or volume state is changed\n  * similar to device.putAudioState()\n  * @param {object} space\n  * @param {object} audioState\n  * @returns {Promise<audioState>}\n  */\n  putAudioState(space, audioState = {}) {\n    return this.webex.internal.lyra.device.putAudioState(space, audioState);\n  },\n\n  /**\n  * Mutes paired device\n  * similar to device.mute()\n  * @returns {Promise<audioState>}\n  */\n  mute() {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#mute: Currently no device is paired');\n\n      return Promise.reject(new Error('DeviceManager#mute: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.mute(this._pairedDevice);\n  },\n\n  /**\n  * Unmutes paired device\n  * similar to device.unmute()\n  * @returns {Promise<audioState>}\n  */\n  unmute() {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#unmute: Currently no device is paired');\n\n      return Promise.reject(new Error('DeviceManager#unmute: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.unmute(this._pairedDevice);\n  },\n\n  /**\n  * Increases paired device's volume\n  * similar to device.increaseVolume()\n  * @returns {Promise<audioState>}\n  */\n  increaseVolume() {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#increaseVolume: Currently no device is paired');\n\n      return Promise.reject(new Error('DeviceManager#increaseVolume: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.increaseVolume(this._pairedDevice);\n  },\n\n  /**\n  * Decreases paired device's volume\n  * similar to device.decreaseVolume()\n  * @returns {Promise<audioState>}\n  */\n  decreaseVolume() {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#decreaseVolume: Currently no device is paired');\n\n      return Promise.reject(new Error('DeviceManager#decreaseVolume: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.decreaseVolume(this._pairedDevice);\n  },\n\n  /**\n  * Sets paired device's volume but should use increase and decrease api instead\n  * similar to device.setVolume()\n  * @param {number} level\n  * @returns {Promise<audioState>}\n  */\n  setVolume(level = 0) {\n    if (!this._pairedDevice) {\n      this.logger.error('DeviceManager#setVolume: Currently no device is paired');\n\n      return Promise.reject(new Error('DeviceManager#setVolume: Currently no device is paired'));\n    }\n\n    return this.webex.internal.lyra.device.setVolume(this._pairedDevice, level);\n  },\n\n  /**\n  * Utility function to update decrypted device name on device object\n  * @param {Array} deviceArray\n  * @returns {device}\n  */\n  _updateDeviceMetadata(deviceArray = []) {\n    if (!deviceArray.length) {\n      return Promise.resolve(deviceArray);\n    }\n    const devices = cloneDeep(deviceArray);\n\n    return Promise.all(devices.map(\n      (device, index) => this.webex.internal.services.waitForCatalog('postauth')\n        .then(() => {\n          if (device.deviceClass === UC_CLOUD) {\n            device.id = `${this.webex.internal.services.get('wdm')}/${device.id}`;\n          }\n\n          return this._decryptDeviceName(device);\n        })\n        .then((updatedDevice) => {\n          devices[index] = updatedDevice;\n\n          return Promise.resolve();\n        })\n    ))\n      .then(() => Promise.resolve(devices));\n  },\n\n  /**\n  * Utility function to update decrypted device name on device object\n  * @param {object} inDevice\n  * @returns {device}\n  */\n  _decryptDeviceName(inDevice = {}) {\n    const device = cloneDeep(inDevice);\n\n    if (device.metadata &&\n      device.metadata.encryptedUserAssignedName &&\n      device.metadata.encryptionKeyUrl) {\n      return this.webex.internal.encryption.decryptText(\n        device.metadata.encryptionKeyUrl, device.metadata.encryptedUserAssignedName\n      )\n        .then((decryptedDeviceName) => {\n          // set userAssignedName as the decypted value, unset encryptedUserAssignedName since it's not needed\n          device.metadata.encryptedUserAssignedName = undefined;\n          device.metadata.userAssignedName = decryptedDeviceName;\n\n          return Promise.resolve(device);\n        })\n        .catch((err) => {\n          // unset encryptedUserAssignedName if failed to decrypt\n          device.metadata.encryptedUserAssignedName = undefined;\n          this.logger.error('DeviceCollection#_decryptDeviceName: failed to decrypt device name', err);\n        });\n    }\n\n    return Promise.resolve(device);\n  },\n\n  /**\n  * Utility function to update device info on mercury updates\n  * @param {object} device\n  * @returns {device}\n  */\n  _receiveDeviceUpdates(device) {\n    // we care only the updates are for the registered devices\n    if (device && device.spaceUrl) {\n      const deviceId = device.spaceUrl.substring(device.spaceUrl.lastIndexOf('/') + 1);\n      const existingDevice = DeviceCollection.get(deviceId);\n\n      if (existingDevice) {\n        return this.webex.internal.lyra.space.get({id: deviceId})\n          .then((space) => {\n            const device = DeviceCollection.get(deviceId);\n\n            if (device &&\n              space.occupants &&\n              (!space.occupants.self || !space.occupants.self.verified)) {\n              device.productName = space.devices && space.devices[0] && space.devices[0].productName ||\n              DEFAULT_PRODUCT_NAME;\n              // pin challenge is not verified reset _pairedDevice if ids\n              // match\n              const pairedDeviceId = this._pairedDevice && (this._pairedDevice.id || this._pairedDevice.identity.id);\n\n              if (pairedDeviceId === deviceId) {\n                this._pairedDevice = null;\n                this.logger.info(`DeviceManager#_receiveDeviceUpdates: device ${deviceId} lost pairing`);\n\n                return Promise.resolve();\n              }\n              // we do not want to reset the device pending PIN challenge\n              if (this._devicePendingPinChallenge.identity.id !== deviceId) {\n                return this.upsert(device);\n              }\n\n              return Promise.resolve();\n            }\n\n            return Promise.resolve();\n          })\n          .catch((err) => {\n            this.logger.error('DeviceManager#_receiveDeviceUpdates: failed to receive updates for Lyra space', err);\n          });\n      }\n    }\n\n    return Promise.resolve();\n  }\n\n\n});\n\nexport default DeviceManager;\n"]},"metadata":{},"sourceType":"script"}