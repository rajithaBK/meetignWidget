{"ast":null,"code":"\"use strict\";\n\nvar _Array$from = require(\"@babel/runtime-corejs2/core-js/array/from\");\n\nvar _Symbol = require(\"@babel/runtime-corejs2/core-js/symbol\");\n\nvar _Symbol$iterator = require(\"@babel/runtime-corejs2/core-js/symbol/iterator\");\n\nvar _Array$isArray = require(\"@babel/runtime-corejs2/core-js/array/is-array\");\n\nvar _Object$keys3 = require(\"@babel/runtime-corejs2/core-js/object/keys\");\n\nvar _Object$getOwnPropertySymbols = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\");\n\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\");\n\nvar _Object$getOwnPropertyDescriptors = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\");\n\nvar _Object$defineProperties = require(\"@babel/runtime-corejs2/core-js/object/define-properties\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/keys\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/toConsumableArray\"));\n\nvar _url = _interopRequireDefault(require(\"url\"));\n\nvar _ampersandState = _interopRequireDefault(require(\"ampersand-state\"));\n\nvar _serviceUrl = _interopRequireDefault(require(\"./service-url\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = _Object$keys3(object);\n\n  if (_Object$getOwnPropertySymbols) {\n    var symbols = _Object$getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return _Object$getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (_Object$getOwnPropertyDescriptors) {\n      _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof _Symbol !== \"undefined\" && o[_Symbol$iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (_Array$isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return _Array$from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/* eslint-disable no-underscore-dangle */\n\n/**\n * @class\n */\n\n\nvar ServiceCatalog = _ampersandState.default.extend({\n  namespace: 'ServiceCatalog',\n  props: {\n    serviceGroups: ['object', true, function () {\n      return {\n        discovery: [],\n        override: [],\n        preauth: [],\n        postauth: [],\n        signin: []\n      };\n    }],\n    status: ['object', true, function () {\n      return {\n        discovery: {\n          ready: false,\n          collecting: false\n        },\n        override: {\n          ready: false,\n          collecting: false\n        },\n        preauth: {\n          ready: false,\n          collecting: false\n        },\n        postauth: {\n          ready: false,\n          collecting: false\n        },\n        signin: {\n          ready: false,\n          collecting: false\n        }\n      };\n    }],\n    isReady: ['boolean', false, false],\n    allowedDomains: ['array', false, function () {\n      return [];\n    }]\n  },\n\n  /**\n   * @private\n   * Search the service url array to locate a `ServiceUrl`\n   * class object based on its name.\n   * @param {string} name\n   * @param {string} [serviceGroup]\n   * @returns {ServiceUrl}\n   */\n  _getUrl: function _getUrl(name, serviceGroup) {\n    var serviceUrls = typeof serviceGroup === 'string' ? this.serviceGroups[serviceGroup] || [] : [].concat((0, _toConsumableArray2.default)(this.serviceGroups.override), (0, _toConsumableArray2.default)(this.serviceGroups.postauth), (0, _toConsumableArray2.default)(this.serviceGroups.signin), (0, _toConsumableArray2.default)(this.serviceGroups.preauth), (0, _toConsumableArray2.default)(this.serviceGroups.discovery));\n    return serviceUrls.find(function (serviceUrl) {\n      return serviceUrl.name === name;\n    });\n  },\n\n  /**\n   * @private\n   * Generate an array of `ServiceUrl`s that is organized from highest auth\n   * level to lowest auth level.\n   * @returns {Array<ServiceUrl>} - array of `ServiceUrl`s\n   */\n  _listServiceUrls: function _listServiceUrls() {\n    return [].concat((0, _toConsumableArray2.default)(this.serviceGroups.override), (0, _toConsumableArray2.default)(this.serviceGroups.postauth), (0, _toConsumableArray2.default)(this.serviceGroups.signin), (0, _toConsumableArray2.default)(this.serviceGroups.preauth), (0, _toConsumableArray2.default)(this.serviceGroups.discovery));\n  },\n\n  /**\n   * @private\n   * Safely load one or more `ServiceUrl`s into this `Services` instance.\n   * @param {string} serviceGroup\n   * @param  {Array<ServiceUrl>} services\n   * @returns {Services}\n   */\n  _loadServiceUrls: function _loadServiceUrls(serviceGroup, services) {\n    var _this = this; // declare namespaces outside of loop\n\n\n    var existingService;\n    services.forEach(function (service) {\n      existingService = _this._getUrl(service.name, serviceGroup);\n\n      if (!existingService) {\n        _this.serviceGroups[serviceGroup].push(service);\n      }\n    });\n    return this;\n  },\n\n  /**\n   * @private\n   * Safely unload one or more `ServiceUrl`s into this `Services` instance\n   * @param {string} serviceGroup\n   * @param  {Array<ServiceUrl>} services\n   * @returns {Services}\n   */\n  _unloadServiceUrls: function _unloadServiceUrls(serviceGroup, services) {\n    var _this2 = this; // declare namespaces outside of loop\n\n\n    var existingService;\n    services.forEach(function (service) {\n      existingService = _this2._getUrl(service.name, serviceGroup);\n\n      if (existingService) {\n        _this2.serviceGroups[serviceGroup].splice(_this2.serviceGroups[serviceGroup].indexOf(existingService), 1);\n      }\n    });\n    return this;\n  },\n\n  /**\n   * Clear all collected catalog data and reset catalog status.\n   *\n   * @returns {void}\n   */\n  clean: function clean() {\n    this.serviceGroups.preauth.length = 0;\n    this.serviceGroups.signin.length = 0;\n    this.serviceGroups.postauth.length = 0;\n    this.status.preauth = {\n      ready: false\n    };\n    this.status.signin = {\n      ready: false\n    };\n    this.status.postauth = {\n      ready: false\n    };\n  },\n\n  /**\n   * Search over all service groups to find a cluster id based\n   * on a given url.\n   * @param {string} url - Must be parsable by `Url`\n   * @returns {string} - ClusterId of a given url\n   */\n  findClusterId: function findClusterId(url) {\n    var incomingUrlObj = _url.default.parse(url);\n\n    var serviceUrlObj;\n\n    for (var _i = 0, _Object$keys = (0, _keys.default)(this.serviceGroups); _i < _Object$keys.length; _i++) {\n      var key = _Object$keys[_i];\n\n      var _iterator = _createForOfIteratorHelper(this.serviceGroups[key]),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var service = _step.value;\n          serviceUrlObj = _url.default.parse(service.defaultUrl);\n\n          var _iterator2 = _createForOfIteratorHelper(service.hosts),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _host = _step2.value;\n\n              if (incomingUrlObj.hostname === _host.host && _host.id) {\n                return _host.id;\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          if (serviceUrlObj.hostname === incomingUrlObj.hostname && service.hosts.length > 0) {\n            // no exact match, so try to grab the first home cluster\n            var _iterator3 = _createForOfIteratorHelper(service.hosts),\n                _step3;\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var host = _step3.value;\n\n                if (host.homeCluster) {\n                  return host.id;\n                }\n              } // no match found still, so return the first entry\n\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n\n            return service.hosts[0].id;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    return undefined;\n  },\n\n  /**\n   * Search over all service groups and return a service value from a provided\n   * clusterId. Currently, this method will return either a service name, or a\n   * service url depending on the `value` parameter. If the `value` parameter\n   * is set to `name`, it will return a service name to be utilized within the\n   * Services plugin methods.\n   * @param {object} params\n   * @param {string} params.clusterId - clusterId of found service\n   * @param {boolean} [params.priorityHost = true] - returns priority host url if true\n   * @param {string} [params.serviceGroup] - specify service group\n   * @returns {object} service\n   * @returns {string} service.name\n   * @returns {string} service.url\n   */\n  findServiceFromClusterId: function findServiceFromClusterId() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        clusterId = _ref.clusterId,\n        _ref$priorityHost = _ref.priorityHost,\n        priorityHost = _ref$priorityHost === void 0 ? true : _ref$priorityHost,\n        serviceGroup = _ref.serviceGroup;\n\n    var serviceUrls = typeof serviceGroup === 'string' ? this.serviceGroups[serviceGroup] || [] : [].concat((0, _toConsumableArray2.default)(this.serviceGroups.override), (0, _toConsumableArray2.default)(this.serviceGroups.postauth), (0, _toConsumableArray2.default)(this.serviceGroups.signin), (0, _toConsumableArray2.default)(this.serviceGroups.preauth), (0, _toConsumableArray2.default)(this.serviceGroups.discovery));\n    var identifiedServiceUrl = serviceUrls.find(function (serviceUrl) {\n      return serviceUrl.hosts.find(function (host) {\n        return host.id === clusterId;\n      });\n    });\n\n    if (identifiedServiceUrl) {\n      return {\n        name: identifiedServiceUrl.name,\n        url: identifiedServiceUrl.get(priorityHost, clusterId)\n      };\n    }\n\n    return undefined;\n  },\n\n  /**\n   * Find a service based on the provided url.\n   * @param {string} url - Must be parsable by `Url`\n   * @returns {serviceUrl} - ServiceUrl assocated with provided url\n   */\n  findServiceUrlFromUrl: function findServiceUrlFromUrl(url) {\n    var incomingUrlObj = _url.default.parse(url);\n\n    var serviceUrls = [].concat((0, _toConsumableArray2.default)(this.serviceGroups.discovery), (0, _toConsumableArray2.default)(this.serviceGroups.preauth), (0, _toConsumableArray2.default)(this.serviceGroups.signin), (0, _toConsumableArray2.default)(this.serviceGroups.postauth), (0, _toConsumableArray2.default)(this.serviceGroups.override));\n    return serviceUrls.find(function (serviceUrl) {\n      if (incomingUrlObj.hostname === _url.default.parse(serviceUrl.defaultUrl).hostname) {\n        return true;\n      }\n\n      if (serviceUrl.hosts.find(function (host) {\n        return host.host === incomingUrlObj.hostname;\n      })) {\n        return true;\n      }\n\n      return false;\n    });\n  },\n\n  /**\n   * Finds an allowed domain that matches a specific url.\n   *\n   * @param {string} url - The url to match the allowed domains against.\n   * @returns {string} - The matching allowed domain.\n   */\n  findAllowedDomain: function findAllowedDomain(url) {\n    var urlObj = _url.default.parse(url);\n\n    if (!urlObj.host) {\n      return undefined;\n    }\n\n    return this.allowedDomains.find(function (allowedDomain) {\n      return urlObj.host.includes(allowedDomain);\n    });\n  },\n\n  /**\n   * Get a service url from the current services list by name.\n   * @param {string} name\n   * @param {boolean} priorityHost\n   * @param {string} serviceGroup\n   * @returns {string}\n   */\n  get: function get(name, priorityHost, serviceGroup) {\n    var serviceUrl = this._getUrl(name, serviceGroup);\n\n    return serviceUrl ? serviceUrl.get(priorityHost) : undefined;\n  },\n\n  /**\n   * Get the current allowed domains list.\n   *\n   * @returns {Array<string>} - the current allowed domains list.\n   */\n  getAllowedDomains: function getAllowedDomains() {\n    return (0, _toConsumableArray2.default)(this.allowedDomains);\n  },\n\n  /**\n   * Creates an object where the keys are the service names\n   * and the values are the service urls.\n   * @param {boolean} priorityHost - use the highest priority if set to `true`\n   * @param {string} [serviceGroup]\n   * @returns {Record<string, string>}\n   */\n  list: function list(priorityHost, serviceGroup) {\n    var output = {};\n    var serviceUrls = typeof serviceGroup === 'string' ? this.serviceGroups[serviceGroup] || [] : [].concat((0, _toConsumableArray2.default)(this.serviceGroups.discovery), (0, _toConsumableArray2.default)(this.serviceGroups.preauth), (0, _toConsumableArray2.default)(this.serviceGroups.signin), (0, _toConsumableArray2.default)(this.serviceGroups.postauth), (0, _toConsumableArray2.default)(this.serviceGroups.override));\n\n    if (serviceUrls) {\n      serviceUrls.forEach(function (serviceUrl) {\n        output[serviceUrl.name] = serviceUrl.get(priorityHost);\n      });\n    }\n\n    return output;\n  },\n\n  /**\n   * Mark a priority host service url as failed.\n   * This will mark the host associated with the\n   * `ServiceUrl` to be removed from the its\n   * respective host array, and then return the next\n   * viable host from the `ServiceUrls` host array,\n   * or the `ServiceUrls` default url if no other priority\n   * hosts are available, or if `noPriorityHosts` is set to\n   * `true`.\n   * @param {string} url\n   * @param {boolean} noPriorityHosts\n   * @returns {string}\n   */\n  markFailedUrl: function markFailedUrl(url, noPriorityHosts) {\n    var _this3 = this;\n\n    var serviceUrl = this._getUrl((0, _keys.default)(this.list()).find(function (key) {\n      return _this3._getUrl(key).failHost(url);\n    }));\n\n    if (!serviceUrl) {\n      return undefined;\n    }\n\n    return noPriorityHosts ? serviceUrl.get(false) : serviceUrl.get(true);\n  },\n\n  /**\n   * Set the allowed domains for the catalog.\n   *\n   * @param {Array<string>} allowedDomains - allowed domains to be assigned.\n   * @returns {void}\n   */\n  setAllowedDomains: function setAllowedDomains(allowedDomains) {\n    this.allowedDomains = (0, _toConsumableArray2.default)(allowedDomains);\n  },\n\n  /**\n   * Update the current list of `ServiceUrl`s against a provided\n   * service hostmap.\n   * @emits ServiceCatalog#preauthorized\n   * @emits ServiceCatalog#postauthorized\n   * @param {string} serviceGroup\n   * @param {object} serviceHostmap\n   * @returns {Services}\n   */\n  updateServiceUrls: function updateServiceUrls(serviceGroup, serviceHostmap) {\n    var _this4 = this;\n\n    var currentServiceUrls = this.serviceGroups[serviceGroup];\n    var unusedUrls = currentServiceUrls.filter(function (serviceUrl) {\n      return serviceHostmap.every(function (item) {\n        return item.name !== serviceUrl.name;\n      });\n    });\n\n    this._unloadServiceUrls(serviceGroup, unusedUrls);\n\n    serviceHostmap.forEach(function (serviceObj) {\n      var service = _this4._getUrl(serviceObj.name, serviceGroup);\n\n      if (service) {\n        service.defaultUrl = serviceObj.defaultUrl;\n        service.hosts = serviceObj.hosts || [];\n      } else {\n        _this4._loadServiceUrls(serviceGroup, [new _serviceUrl.default(_objectSpread({}, serviceObj))]);\n      }\n    });\n    this.status[serviceGroup].ready = true;\n    this.trigger(serviceGroup);\n    return this;\n  },\n\n  /**\n   * Wait until the service catalog is available,\n   * or reject after a timeout of 60 seconds.\n   * @param {string} serviceGroup\n   * @param {number} [timeout] - in seconds\n   * @returns {Promise<void>}\n   */\n  waitForCatalog: function waitForCatalog(serviceGroup, timeout) {\n    var _this5 = this;\n\n    return new _promise.default(function (resolve, reject) {\n      if (_this5.status[serviceGroup].ready) {\n        resolve();\n      }\n\n      var timeoutTimer = setTimeout(function () {\n        return reject(new Error(\"services: timeout occured while waiting for '\".concat(serviceGroup, \"' catalog to populate\")));\n      }, timeout ? timeout * 1000 : 60000);\n\n      _this5.once(serviceGroup, function () {\n        clearTimeout(timeoutTimer);\n        resolve();\n      });\n    });\n  }\n});\n/* eslint-enable no-underscore-dangle */\n\n\nvar _default = ServiceCatalog;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["ServiceCatalog","AmpState","extend","namespace","props","serviceGroups","discovery","override","preauth","postauth","signin","status","ready","collecting","isReady","allowedDomains","_getUrl","name","serviceGroup","serviceUrls","find","serviceUrl","_listServiceUrls","_loadServiceUrls","services","existingService","forEach","service","_this","push","_unloadServiceUrls","_this2","splice","indexOf","clean","length","findClusterId","url","incomingUrlObj","Url","parse","serviceUrlObj","key","defaultUrl","hosts","host","hostname","id","_iterator2","homeCluster","_iterator3","_iterator","undefined","findServiceFromClusterId","clusterId","priorityHost","identifiedServiceUrl","get","findServiceUrlFromUrl","findAllowedDomain","urlObj","allowedDomain","includes","getAllowedDomains","list","output","markFailedUrl","noPriorityHosts","_this3","failHost","setAllowedDomains","updateServiceUrls","serviceHostmap","currentServiceUrls","unusedUrls","filter","every","item","serviceObj","_this4","ServiceUrl","trigger","waitForCatalog","timeout","resolve","reject","_this5","timeoutTimer","setTimeout","Error","once","clearTimeout"],"sources":["service-catalog.js"],"sourcesContent":["import Url from 'url';\n\nimport AmpState from 'ampersand-state';\n\nimport ServiceUrl from './service-url';\n\n/* eslint-disable no-underscore-dangle */\n/**\n * @class\n */\nconst ServiceCatalog = AmpState.extend({\n  namespace: 'ServiceCatalog',\n\n  props: {\n    serviceGroups: ['object', true, (() => ({\n      discovery: [],\n      override: [],\n      preauth: [],\n      postauth: [],\n      signin: []\n    }))],\n    status: ['object', true, (() => ({\n      discovery: {\n        ready: false,\n        collecting: false\n      },\n      override: {\n        ready: false,\n        collecting: false\n      },\n      preauth: {\n        ready: false,\n        collecting: false\n      },\n      postauth: {\n        ready: false,\n        collecting: false\n      },\n      signin: {\n        ready: false,\n        collecting: false\n      }\n    }))],\n    isReady: ['boolean', false, false],\n    allowedDomains: ['array', false, (() => [])]\n  },\n\n  /**\n   * @private\n   * Search the service url array to locate a `ServiceUrl`\n   * class object based on its name.\n   * @param {string} name\n   * @param {string} [serviceGroup]\n   * @returns {ServiceUrl}\n   */\n  _getUrl(name, serviceGroup) {\n    const serviceUrls = (typeof serviceGroup === 'string') ?\n      this.serviceGroups[serviceGroup] || [] :\n      [\n        ...this.serviceGroups.override,\n        ...this.serviceGroups.postauth,\n        ...this.serviceGroups.signin,\n        ...this.serviceGroups.preauth,\n        ...this.serviceGroups.discovery\n      ];\n\n    return serviceUrls.find((serviceUrl) => serviceUrl.name === name);\n  },\n\n  /**\n   * @private\n   * Generate an array of `ServiceUrl`s that is organized from highest auth\n   * level to lowest auth level.\n   * @returns {Array<ServiceUrl>} - array of `ServiceUrl`s\n   */\n  _listServiceUrls() {\n    return [\n      ...this.serviceGroups.override,\n      ...this.serviceGroups.postauth,\n      ...this.serviceGroups.signin,\n      ...this.serviceGroups.preauth,\n      ...this.serviceGroups.discovery\n    ];\n  },\n\n  /**\n   * @private\n   * Safely load one or more `ServiceUrl`s into this `Services` instance.\n   * @param {string} serviceGroup\n   * @param  {Array<ServiceUrl>} services\n   * @returns {Services}\n   */\n  _loadServiceUrls(serviceGroup, services) {\n    // declare namespaces outside of loop\n    let existingService;\n\n    services.forEach((service) => {\n      existingService = this._getUrl(service.name, serviceGroup);\n\n      if (!existingService) {\n        this.serviceGroups[serviceGroup].push(service);\n      }\n    });\n\n    return this;\n  },\n\n  /**\n   * @private\n   * Safely unload one or more `ServiceUrl`s into this `Services` instance\n   * @param {string} serviceGroup\n   * @param  {Array<ServiceUrl>} services\n   * @returns {Services}\n   */\n  _unloadServiceUrls(serviceGroup, services) {\n    // declare namespaces outside of loop\n    let existingService;\n\n    services.forEach((service) => {\n      existingService = this._getUrl(service.name, serviceGroup);\n\n      if (existingService) {\n        this.serviceGroups[serviceGroup].splice(\n          this.serviceGroups[serviceGroup].indexOf(existingService), 1\n        );\n      }\n    });\n\n    return this;\n  },\n\n  /**\n   * Clear all collected catalog data and reset catalog status.\n   *\n   * @returns {void}\n   */\n  clean() {\n    this.serviceGroups.preauth.length = 0;\n    this.serviceGroups.signin.length = 0;\n    this.serviceGroups.postauth.length = 0;\n    this.status.preauth = {ready: false};\n    this.status.signin = {ready: false};\n    this.status.postauth = {ready: false};\n  },\n\n  /**\n   * Search over all service groups to find a cluster id based\n   * on a given url.\n   * @param {string} url - Must be parsable by `Url`\n   * @returns {string} - ClusterId of a given url\n   */\n  findClusterId(url) {\n    const incomingUrlObj = Url.parse(url);\n    let serviceUrlObj;\n\n    for (const key of Object.keys(this.serviceGroups)) {\n      for (const service of this.serviceGroups[key]) {\n        serviceUrlObj = Url.parse(service.defaultUrl);\n\n        for (const host of service.hosts) {\n          if (incomingUrlObj.hostname === host.host && host.id) {\n            return host.id;\n          }\n        }\n\n        if (serviceUrlObj.hostname === incomingUrlObj.hostname &&\n          service.hosts.length > 0) {\n          // no exact match, so try to grab the first home cluster\n          for (const host of service.hosts) {\n            if (host.homeCluster) {\n              return host.id;\n            }\n          }\n\n          // no match found still, so return the first entry\n          return service.hosts[0].id;\n        }\n      }\n    }\n\n    return undefined;\n  },\n\n  /**\n   * Search over all service groups and return a service value from a provided\n   * clusterId. Currently, this method will return either a service name, or a\n   * service url depending on the `value` parameter. If the `value` parameter\n   * is set to `name`, it will return a service name to be utilized within the\n   * Services plugin methods.\n   * @param {object} params\n   * @param {string} params.clusterId - clusterId of found service\n   * @param {boolean} [params.priorityHost = true] - returns priority host url if true\n   * @param {string} [params.serviceGroup] - specify service group\n   * @returns {object} service\n   * @returns {string} service.name\n   * @returns {string} service.url\n   */\n  findServiceFromClusterId({clusterId, priorityHost = true, serviceGroup} = {}) {\n    const serviceUrls = (typeof serviceGroup === 'string') ?\n      this.serviceGroups[serviceGroup] || [] : [\n        ...this.serviceGroups.override,\n        ...this.serviceGroups.postauth,\n        ...this.serviceGroups.signin,\n        ...this.serviceGroups.preauth,\n        ...this.serviceGroups.discovery\n      ];\n\n    const identifiedServiceUrl = serviceUrls.find(\n      (serviceUrl) => serviceUrl.hosts.find(\n        (host) => host.id === clusterId\n      )\n    );\n\n    if (identifiedServiceUrl) {\n      return {\n        name: identifiedServiceUrl.name,\n        url: identifiedServiceUrl.get(priorityHost, clusterId)\n      };\n    }\n\n    return undefined;\n  },\n\n  /**\n   * Find a service based on the provided url.\n   * @param {string} url - Must be parsable by `Url`\n   * @returns {serviceUrl} - ServiceUrl assocated with provided url\n   */\n  findServiceUrlFromUrl(url) {\n    const incomingUrlObj = Url.parse(url);\n    const serviceUrls = [\n      ...this.serviceGroups.discovery,\n      ...this.serviceGroups.preauth,\n      ...this.serviceGroups.signin,\n      ...this.serviceGroups.postauth,\n      ...this.serviceGroups.override\n    ];\n\n    return serviceUrls.find(\n      (serviceUrl) => {\n        if (incomingUrlObj.hostname ===\n          Url.parse(serviceUrl.defaultUrl).hostname) {\n          return true;\n        }\n\n        if (serviceUrl.hosts.find((host) => host.host === incomingUrlObj.hostname)) {\n          return true;\n        }\n\n        return false;\n      }\n    );\n  },\n\n  /**\n   * Finds an allowed domain that matches a specific url.\n   *\n   * @param {string} url - The url to match the allowed domains against.\n   * @returns {string} - The matching allowed domain.\n   */\n  findAllowedDomain(url) {\n    const urlObj = Url.parse(url);\n\n    if (!urlObj.host) {\n      return undefined;\n    }\n\n    return this.allowedDomains.find(\n      (allowedDomain) => urlObj.host.includes(allowedDomain)\n    );\n  },\n\n  /**\n   * Get a service url from the current services list by name.\n   * @param {string} name\n   * @param {boolean} priorityHost\n   * @param {string} serviceGroup\n   * @returns {string}\n   */\n  get(name, priorityHost, serviceGroup) {\n    const serviceUrl = this._getUrl(name, serviceGroup);\n\n    return (serviceUrl) ? serviceUrl.get(priorityHost) : undefined;\n  },\n\n  /**\n   * Get the current allowed domains list.\n   *\n   * @returns {Array<string>} - the current allowed domains list.\n   */\n  getAllowedDomains() {\n    return [...this.allowedDomains];\n  },\n\n  /**\n   * Creates an object where the keys are the service names\n   * and the values are the service urls.\n   * @param {boolean} priorityHost - use the highest priority if set to `true`\n   * @param {string} [serviceGroup]\n   * @returns {Record<string, string>}\n   */\n  list(priorityHost, serviceGroup) {\n    const output = {};\n\n    const serviceUrls = (typeof serviceGroup === 'string') ?\n      this.serviceGroups[serviceGroup] || [] :\n      [\n        ...this.serviceGroups.discovery,\n        ...this.serviceGroups.preauth,\n        ...this.serviceGroups.signin,\n        ...this.serviceGroups.postauth,\n        ...this.serviceGroups.override\n      ];\n\n    if (serviceUrls) {\n      serviceUrls.forEach((serviceUrl) => {\n        output[serviceUrl.name] = serviceUrl.get(priorityHost);\n      });\n    }\n\n    return output;\n  },\n\n  /**\n   * Mark a priority host service url as failed.\n   * This will mark the host associated with the\n   * `ServiceUrl` to be removed from the its\n   * respective host array, and then return the next\n   * viable host from the `ServiceUrls` host array,\n   * or the `ServiceUrls` default url if no other priority\n   * hosts are available, or if `noPriorityHosts` is set to\n   * `true`.\n   * @param {string} url\n   * @param {boolean} noPriorityHosts\n   * @returns {string}\n   */\n  markFailedUrl(url, noPriorityHosts) {\n    const serviceUrl = this._getUrl(Object.keys(this.list()).find(\n      (key) => this._getUrl(key).failHost(url)\n    ));\n\n    if (!serviceUrl) {\n      return undefined;\n    }\n\n    return (noPriorityHosts) ? serviceUrl.get(false) : serviceUrl.get(true);\n  },\n\n  /**\n   * Set the allowed domains for the catalog.\n   *\n   * @param {Array<string>} allowedDomains - allowed domains to be assigned.\n   * @returns {void}\n   */\n  setAllowedDomains(allowedDomains) {\n    this.allowedDomains = [...allowedDomains];\n  },\n\n  /**\n   * Update the current list of `ServiceUrl`s against a provided\n   * service hostmap.\n   * @emits ServiceCatalog#preauthorized\n   * @emits ServiceCatalog#postauthorized\n   * @param {string} serviceGroup\n   * @param {object} serviceHostmap\n   * @returns {Services}\n   */\n  updateServiceUrls(serviceGroup, serviceHostmap) {\n    const currentServiceUrls = this.serviceGroups[serviceGroup];\n\n    const unusedUrls = currentServiceUrls.filter(\n      (serviceUrl) => serviceHostmap.every(\n        (item) => item.name !== serviceUrl.name\n      )\n    );\n\n    this._unloadServiceUrls(serviceGroup, unusedUrls);\n\n    serviceHostmap.forEach((serviceObj) => {\n      const service = this._getUrl(serviceObj.name, serviceGroup);\n\n      if (service) {\n        service.defaultUrl = serviceObj.defaultUrl;\n        service.hosts = serviceObj.hosts || [];\n      }\n      else {\n        this._loadServiceUrls(serviceGroup, [new ServiceUrl({\n          ...serviceObj\n        })]);\n      }\n    });\n\n    this.status[serviceGroup].ready = true;\n    this.trigger(serviceGroup);\n\n    return this;\n  },\n\n  /**\n   * Wait until the service catalog is available,\n   * or reject after a timeout of 60 seconds.\n   * @param {string} serviceGroup\n   * @param {number} [timeout] - in seconds\n   * @returns {Promise<void>}\n   */\n  waitForCatalog(serviceGroup, timeout) {\n    return new Promise((resolve, reject) => {\n      if (this.status[serviceGroup].ready) {\n        resolve();\n      }\n\n      const timeoutTimer = setTimeout(() => reject(\n        new Error(`services: timeout occured while waiting for '${serviceGroup}' catalog to populate`)\n      ), (timeout) ? timeout * 1000 : 60000);\n\n      this.once(serviceGroup, () => {\n        clearTimeout(timeoutTimer);\n        resolve();\n      });\n    });\n  }\n});\n/* eslint-enable no-underscore-dangle */\n\nexport default ServiceCatalog;\n"]},"metadata":{},"sourceType":"script"}