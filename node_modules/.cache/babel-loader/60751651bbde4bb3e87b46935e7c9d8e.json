{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = retry;\n\nvar _assign = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/assign\"));\n\nvar _apply = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/reflect/apply\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/typeof\"));\n\nvar _wrap2 = _interopRequireDefault(require(\"lodash/wrap\"));\n\nvar _isFunction2 = _interopRequireDefault(require(\"lodash/isFunction\"));\n\nvar _defaults2 = _interopRequireDefault(require(\"lodash/defaults\"));\n\nvar _events = require(\"events\");\n\nvar _backoff = _interopRequireDefault(require(\"backoff\"));\n/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\n/* eslint max-nested-callbacks: [0] */\n\n/**\n * Makes a promise-returning method retryable according to the specified backoff\n * pattern\n * @param {Object} options\n * @param {boolean} options.backoff\n * @param {number} options.delay\n * @param {number} options.initialDelay\n * @param {number} options.maxAttempts\n * @param {number} options.maxDelay\n *\n * @returns {Function}\n */\n\n\nfunction retry() {\n  for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n    params[_key] = arguments[_key];\n  }\n\n  var options = params[0] || {};\n  options = (0, _assign.default)({}, options);\n  (0, _defaults2.default)(options, {\n    backoff: true,\n    delay: 1,\n    maxAttempts: 3\n  });\n  var strategyOptions;\n\n  if (options.backoff) {\n    strategyOptions = {\n      initialDelay: options.delay,\n      maxDelay: options.maxDelay\n    };\n  } else {\n    strategyOptions = {\n      initialDelay: 1,\n      maxDelay: 1\n    };\n  }\n\n  if (params.length === 3) {\n    return (0, _apply.default)(retryDecorator, null, params);\n  }\n\n  return retryDecorator;\n  /**\n   * @param {Object} target\n   * @param {string} prop\n   * @param {Object} descriptor\n   * @private\n   * @returns {Object}\n   */\n\n  function retryDecorator(target, prop, descriptor) {\n    descriptor.value = (0, _wrap2.default)(descriptor.value, function retryExecutor(fn) {\n      var _this = this;\n\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      var emitter = new _events.EventEmitter();\n      var promise = new _promise.default(function (resolve, reject) {\n        // backoff.call is not Function.prototype.call; it's an unfortunate naming\n        // collision.\n\n        /* eslint prefer-reflect: [0] */\n        var call = _backoff.default.call(function (cb) {\n          /* eslint no-invalid-this: [0] */\n          var innerPromise = (0, _apply.default)(fn, _this, args);\n\n          if ((0, _isFunction2.default)(innerPromise.on)) {\n            innerPromise.on('progress', emitter.emit.bind(emitter, 'progress'));\n            innerPromise.on('upload-progress', emitter.emit.bind(emitter, 'upload-progress'));\n            innerPromise.on('download-progress', emitter.emit.bind(emitter, 'download-progress'));\n          }\n\n          return innerPromise.then(function (res) {\n            cb(null, res);\n          }).catch(function (reason) {\n            if (!reason) {\n              reason = new Error('retryable method failed without providing an error object');\n            }\n\n            cb(reason);\n          });\n        }, function (err, res) {\n          if (err) {\n            return reject(err);\n          }\n\n          return resolve(res);\n        });\n\n        call.setStrategy(new _backoff.default.ExponentialStrategy(strategyOptions));\n\n        if (options.maxAttempts) {\n          call.failAfter(options.maxAttempts - 1);\n        }\n\n        call.start();\n      });\n\n      promise.on = function on(key, callback) {\n        emitter.on(key, callback);\n        return promise;\n      };\n\n      return promise;\n    }); // This *should* make decorators compatible with AmpersandState class\n    // definitions\n\n    if ((0, _typeof2.default)(target) === 'object' && !target.prototype) {\n      target[prop] = descriptor.value;\n    }\n\n    return descriptor;\n  }\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;AAGA;AAPA;AACA;AACA;;AAOA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACe,SAASA,KAAT,GAA0B;AAAA,oCAARC,MAAQ;AAARA,UAAQ,MAARA,GAAQC,eAARD;AAAQ;;AACvC,MAAIE,OAAO,GAAGF,MAAM,CAAC,CAAD,CAANA,IAAa,EAA3B;AAEAE,SAAO,GAAG,qBAAc,EAAd,EAAkBA,OAAlB,CAAVA;AACA,0BAASA,OAAT,EAAkB;AAChBC,WAAO,EAAE,IADO;AAEhBC,SAAK,EAAE,CAFS;AAGhBC,eAAW,EAAE;AAHG,GAAlB;AAMA,MAAIC,eAAJ;;AAEA,MAAIJ,OAAO,CAACC,OAAZ,EAAqB;AACnBG,mBAAe,GAAG;AAChBC,kBAAY,EAAEL,OAAO,CAACE,KADN;AAEhBI,cAAQ,EAAEN,OAAO,CAACM;AAFF,KAAlBF;AADF,SAMK;AACHA,mBAAe,GAAG;AAChBC,kBAAY,EAAE,CADE;AAEhBC,cAAQ,EAAE;AAFM,KAAlBF;AAID;;AAED,MAAIN,MAAM,CAACS,MAAPT,KAAkB,CAAtB,EAAyB;AACvB,WAAO,oBAAcU,cAAd,EAA8B,IAA9B,EAAoCV,MAApC,CAAP;AACD;;AAED,SAAOU,cAAP;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,WAASA,cAAT,CAAwBC,MAAxB,EAAgCC,IAAhC,EAAsCC,UAAtC,EAAkD;AAChDA,cAAU,CAACC,KAAXD,GAAmB,oBAAKA,UAAU,CAACC,KAAhB,EAAuB,SAASC,aAAT,CAAuBC,EAAvB,EAAoC;AAAA;;AAAA,yCAANC,IAAM;AAANA,YAAM,WAANA,GAAMhB,gBAANgB;AAAM;;AAC5E,UAAMC,OAAO,GAAG,IAAIC,oBAAJ,EAAhB;AACA,UAAMC,OAAO,GAAG,qBAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AAC/C;AACA;;AACA;AACA,YAAMC,IAAI,GAAGpB,iBAAQoB,IAARpB,CACX,UAACqB,EAAD,EAAQ;AACN;AACA,cAAMC,YAAY,GAAG,oBAAcT,EAAd,EAAkBU,KAAlB,EAAwBT,IAAxB,CAArB;;AAEA,cAAI,0BAAWQ,YAAY,CAACE,EAAxB,CAAJ,EAAiC;AAC/BF,wBAAY,CAACE,EAAbF,CAAgB,UAAhBA,EAA4BP,OAAO,CAACU,IAARV,CAAaW,IAAbX,CAAkBA,OAAlBA,EAA2B,UAA3BA,CAA5BO;AACAA,wBAAY,CAACE,EAAbF,CAAgB,iBAAhBA,EAAmCP,OAAO,CAACU,IAARV,CAAaW,IAAbX,CAAkBA,OAAlBA,EAA2B,iBAA3BA,CAAnCO;AACAA,wBAAY,CAACE,EAAbF,CAAgB,mBAAhBA,EAAqCP,OAAO,CAACU,IAARV,CAAaW,IAAbX,CAAkBA,OAAlBA,EAA2B,mBAA3BA,CAArCO;AACD;;AAED,iBAAOA,YAAY,CAChBK,IADIL,CACC,UAACM,GAAD,EAAS;AACbP,cAAE,CAAC,IAAD,EAAOO,GAAP,CAAFP;AAFG,aAIJQ,KAJIP,CAIE,UAACQ,MAAD,EAAY;AACjB,gBAAI,CAACA,MAAL,EAAa;AACXA,oBAAM,GAAG,IAAIC,KAAJ,CAAU,2DAAV,CAATD;AACD;;AACDT,cAAE,CAACS,MAAD,CAAFT;AARG,YAAP;AAXS,WAsBX,UAACW,GAAD,EAAMJ,GAAN,EAAc;AACZ,cAAII,GAAJ,EAAS;AACP,mBAAOb,MAAM,CAACa,GAAD,CAAb;AACD;;AAED,iBAAOd,OAAO,CAACU,GAAD,CAAd;AA3BS,UAAb;;AA+BAR,YAAI,CAACa,WAALb,CAAiB,IAAIpB,iBAAQkC,mBAAZ,CAAgC/B,eAAhC,CAAjBiB;;AACA,YAAIrB,OAAO,CAACG,WAAZ,EAAyB;AACvBkB,cAAI,CAACe,SAALf,CAAerB,OAAO,CAACG,WAARH,GAAsB,CAArCqB;AACD;;AAEDA,YAAI,CAACgB,KAALhB;AAxCc,QAAhB;;AA2CAH,aAAO,CAACO,EAARP,GAAa,SAASO,EAAT,CAAYa,GAAZ,EAAiBC,QAAjB,EAA2B;AACtCvB,eAAO,CAACS,EAART,CAAWsB,GAAXtB,EAAgBuB,QAAhBvB;AAEA,eAAOE,OAAP;AAHF;;AAMA,aAAOA,OAAP;AAnDiB,MAAnBP,CADgD,CAuDhD;AACA;;AACA,QAAI,sBAAOF,MAAP,MAAkB,QAAlB,IAA8B,CAACA,MAAM,CAAC+B,SAA1C,EAAqD;AACnD/B,YAAM,CAACC,IAAD,CAAND,GAAeE,UAAU,CAACC,KAA1BH;AACD;;AAED,WAAOE,UAAP;AACD;AACF","names":["retry","params","arguments","options","backoff","delay","maxAttempts","strategyOptions","initialDelay","maxDelay","length","retryDecorator","target","prop","descriptor","value","retryExecutor","fn","args","emitter","EventEmitter","promise","resolve","reject","call","cb","innerPromise","_this","on","emit","bind","then","res","catch","reason","Error","err","setStrategy","ExponentialStrategy","failAfter","start","key","callback","prototype"],"sources":["retry.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {EventEmitter} from 'events';\n\nimport {defaults, isFunction, wrap} from 'lodash';\nimport backoff from 'backoff';\n\n/* eslint max-nested-callbacks: [0] */\n\n/**\n * Makes a promise-returning method retryable according to the specified backoff\n * pattern\n * @param {Object} options\n * @param {boolean} options.backoff\n * @param {number} options.delay\n * @param {number} options.initialDelay\n * @param {number} options.maxAttempts\n * @param {number} options.maxDelay\n *\n * @returns {Function}\n */\nexport default function retry(...params) {\n  let options = params[0] || {};\n\n  options = Object.assign({}, options);\n  defaults(options, {\n    backoff: true,\n    delay: 1,\n    maxAttempts: 3\n  });\n\n  let strategyOptions;\n\n  if (options.backoff) {\n    strategyOptions = {\n      initialDelay: options.delay,\n      maxDelay: options.maxDelay\n    };\n  }\n  else {\n    strategyOptions = {\n      initialDelay: 1,\n      maxDelay: 1\n    };\n  }\n\n  if (params.length === 3) {\n    return Reflect.apply(retryDecorator, null, params);\n  }\n\n  return retryDecorator;\n\n  /**\n   * @param {Object} target\n   * @param {string} prop\n   * @param {Object} descriptor\n   * @private\n   * @returns {Object}\n   */\n  function retryDecorator(target, prop, descriptor) {\n    descriptor.value = wrap(descriptor.value, function retryExecutor(fn, ...args) {\n      const emitter = new EventEmitter();\n      const promise = new Promise((resolve, reject) => {\n        // backoff.call is not Function.prototype.call; it's an unfortunate naming\n        // collision.\n        /* eslint prefer-reflect: [0] */\n        const call = backoff.call(\n          (cb) => {\n            /* eslint no-invalid-this: [0] */\n            const innerPromise = Reflect.apply(fn, this, args);\n\n            if (isFunction(innerPromise.on)) {\n              innerPromise.on('progress', emitter.emit.bind(emitter, 'progress'));\n              innerPromise.on('upload-progress', emitter.emit.bind(emitter, 'upload-progress'));\n              innerPromise.on('download-progress', emitter.emit.bind(emitter, 'download-progress'));\n            }\n\n            return innerPromise\n              .then((res) => {\n                cb(null, res);\n              })\n              .catch((reason) => {\n                if (!reason) {\n                  reason = new Error('retryable method failed without providing an error object');\n                }\n                cb(reason);\n              });\n          },\n          (err, res) => {\n            if (err) {\n              return reject(err);\n            }\n\n            return resolve(res);\n          }\n        );\n\n        call.setStrategy(new backoff.ExponentialStrategy(strategyOptions));\n        if (options.maxAttempts) {\n          call.failAfter(options.maxAttempts - 1);\n        }\n\n        call.start();\n      });\n\n      promise.on = function on(key, callback) {\n        emitter.on(key, callback);\n\n        return promise;\n      };\n\n      return promise;\n    });\n\n    // This *should* make decorators compatible with AmpersandState class\n    // definitions\n    if (typeof target === 'object' && !target.prototype) {\n      target[prop] = descriptor.value;\n    }\n\n    return descriptor;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}