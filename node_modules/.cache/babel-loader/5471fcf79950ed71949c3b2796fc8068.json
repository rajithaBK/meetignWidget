{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/map\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _has2 = _interopRequireDefault(require(\"lodash/has\"));\n\nvar _common = require(\"@webex/common\");\n\nvar _webexPlugin = _interopRequireDefault(require(\"./webex-plugin\"));\n\nvar _webexHttpError = _interopRequireDefault(require(\"./webex-http-error\"));\n/**\n * Base class for coalescing requests to batched APIs\n * @class Batcher\n */\n\n\nvar Batcher = _webexPlugin.default.extend({\n  session: {\n    deferreds: {\n      type: 'object',\n      default: function _default() {\n        return new _map.default();\n      }\n    },\n    queue: {\n      type: 'array',\n      default: function _default() {\n        return [];\n      }\n    }\n  },\n  derived: {\n    bounce: {\n      fn: function fn() {\n        var _this = this;\n\n        return (0, _common.cappedDebounce)(function () {\n          return _this.executeQueue.apply(_this, arguments);\n        }, this.config.batcherWait, {\n          maxCalls: this.config.batcherMaxCalls,\n          maxWait: this.config.batcherMaxWait\n        });\n      }\n    }\n  },\n\n  /**\n   * Requests an item from a batched API\n   * @param {Object} item\n   * @returns {Promise<mixed>}\n   */\n  request: function request(item) {\n    var _this2 = this; // So far, I can't find a way to avoid three layers of nesting here.\n\n    /* eslint max-nested-callbacks: [0] */\n\n\n    var defer = new _common.Defer();\n    this.fingerprintRequest(item).then(function (idx) {\n      if (_this2.deferreds.has(idx)) {\n        defer.resolve(_this2.deferreds.get(idx).promise);\n        return;\n      }\n\n      _this2.deferreds.set(idx, defer);\n\n      _this2.prepareItem(item).then(function (req) {\n        defer.promise = defer.promise.then((0, _common.tap)(function () {\n          return _this2.deferreds.delete(idx);\n        })).catch(function (reason) {\n          _this2.deferreds.delete(idx);\n\n          return _promise.default.reject(reason);\n        });\n\n        _this2.enqueue(req).then(function () {\n          return _this2.bounce();\n        }).catch(function (reason) {\n          return defer.reject(reason);\n        });\n      }).catch(function (reason) {\n        return defer.reject(reason);\n      });\n    }).catch(function (reason) {\n      return defer.reject(reason);\n    });\n    return defer.promise;\n  },\n\n  /**\n   * Adds an item to the queue.\n   * Intended to be overridden\n   * @param {mixed} req\n   * @returns {Promise<undefined>}\n   */\n  enqueue: function enqueue(req) {\n    this.queue.push(req);\n    return _promise.default.resolve();\n  },\n\n  /**\n   * Transform the item before adding it to the queue\n   * Intended to be overridden\n   * @param {mixed} item\n   * @returns {Promise<mixed>}\n   */\n  prepareItem: function prepareItem(item) {\n    return _promise.default.resolve(item);\n  },\n\n  /**\n   * Detaches the current queue, does any appropriate transforms, and submits it\n   * to the API.\n   * @returns {Promise<undefined>}\n   */\n  executeQueue: function executeQueue() {\n    var _this3 = this;\n\n    var queue = this.queue.splice(0, this.config.batcherMaxCalls);\n    return new _promise.default(function (resolve) {\n      resolve(_this3.prepareRequest(queue).then(function (payload) {\n        return _this3.submitHttpRequest(payload).then(function (res) {\n          return _this3.handleHttpSuccess(res);\n        });\n      }).catch(function (reason) {\n        if (reason instanceof _webexHttpError.default) {\n          return _this3.handleHttpError(reason);\n        }\n\n        return _promise.default.all(queue.map(function (item) {\n          return _this3.getDeferredForRequest(item).then(function (defer) {\n            defer.reject(reason);\n          });\n        }));\n      }));\n    }).catch(function (reason) {\n      _this3.logger.error(process.env.NODE_ENV === 'production' ? reason : reason.stack);\n\n      return _promise.default.reject(reason);\n    });\n  },\n\n  /**\n   * Performs any final transforms on the queue before submitting it to the API\n   * Intended to be overridden\n   * @param {Object|Array} queue\n   * @returns {Promise<Object>}\n   */\n  prepareRequest: function prepareRequest(queue) {\n    return _promise.default.resolve(queue);\n  },\n\n  /**\n   * Submits the prepared request body to the API.\n   * This method *must* be overridden\n   * @param {Object} payload\n   * @returns {Promise<HttpResponseObject>}\n   */\n  // eslint-disable-next-line no-unused-vars\n  submitHttpRequest: function submitHttpRequest(payload) {\n    throw new Error('request() must be implemented');\n  },\n\n  /**\n   * Actions taken when the http request returns a success\n   * Intended to be overridden\n   * @param {Promise<HttpResponseObject>} res\n   * @returns {Promise<undefined>}\n   */\n  handleHttpSuccess: function handleHttpSuccess(res) {\n    var _this4 = this;\n\n    return _promise.default.all((res.body && res.body.items || res.body).map(function (item) {\n      return _this4.acceptItem(item);\n    }));\n  },\n\n  /**\n   * Actions taken when the http request returns a failure. Typically, this\n   * means failing the entire queue, but could be overridden in some\n   * implementations to e.g. reenqueue.\n   * Intended to be overridden\n   * @param {WebexHttpError} reason\n   * @returns {Promise<undefined>}\n   */\n  handleHttpError: function handleHttpError(reason) {\n    var _this5 = this;\n\n    if (reason instanceof _webexHttpError.default) {\n      if ((0, _has2.default)(reason, 'options.body.map')) {\n        return _promise.default.all(reason.options.body.map(function (item) {\n          return _this5.getDeferredForRequest(item).then(function (defer) {\n            defer.reject(reason);\n          });\n        }));\n      }\n    }\n\n    this.logger.error('http error handler called without a WebexHttpError object', reason);\n    return _promise.default.reject(reason);\n  },\n\n  /**\n   * Determines if the item succeeded or failed and delegates accordingly\n   * @param {Object} item\n   * @returns {Promise<undefined>}\n   */\n  acceptItem: function acceptItem(item) {\n    var _this6 = this;\n\n    return this.didItemFail(item).then(function (didFail) {\n      if (didFail) {\n        return _this6.handleItemFailure(item);\n      }\n\n      return _this6.handleItemSuccess(item);\n    });\n  },\n\n  /**\n   * Indicates if the specified response item implies a success or a failure\n   * Intended to be overridden\n   * @param {Object} item\n   * @returns {Promise<Boolean>}\n   */\n  // eslint-disable-next-line no-unused-vars\n  didItemFail: function didItemFail(item) {\n    return _promise.default.resolve(false);\n  },\n\n  /**\n   * Finds the Defer for the specified item and rejects its promise\n   * Intended to be overridden\n   * @param {Object} item\n   * @returns {Promise<undefined>}\n   */\n  handleItemFailure: function handleItemFailure(item) {\n    return this.getDeferredForResponse(item).then(function (defer) {\n      defer.reject(item);\n    });\n  },\n\n  /**\n   * Finds the Defer for the specified item and resolves its promise\n   * Intended to be overridden\n   * @param {Object} item\n   * @returns {Promise<undefined>}\n   */\n  handleItemSuccess: function handleItemSuccess(item) {\n    return this.getDeferredForResponse(item).then(function (defer) {\n      defer.resolve(item);\n    });\n  },\n\n  /**\n   * Returns the Deferred for the specified request item\n   * @param {Object} item\n   * @returns {Promise<Defer>}\n   */\n  getDeferredForRequest: function getDeferredForRequest(item) {\n    var _this7 = this;\n\n    return this.fingerprintRequest(item).then(function (idx) {\n      var defer = _this7.deferreds.get(idx);\n      /* istanbul ignore if */\n\n\n      if (!defer) {\n        throw new Error('Could not find pending request for received response');\n      }\n\n      return defer;\n    });\n  },\n\n  /**\n   * Returns the Deferred for the specified response item\n   * @param {Object} item\n   * @returns {Promise<Defer>}\n   */\n  getDeferredForResponse: function getDeferredForResponse(item) {\n    var _this8 = this;\n\n    return this.fingerprintResponse(item).then(function (idx) {\n      var defer = _this8.deferreds.get(idx);\n      /* istanbul ignore if */\n\n\n      if (!defer) {\n        throw new Error('Could not find pending request for received response');\n      }\n\n      return defer;\n    });\n  },\n\n  /**\n   * Generates a unique identifier for the item in a request payload\n   * Intended to be overridden\n   * Note that overrides must return a primitive.\n   * @param {Object} item\n   * @returns {Promise<primitive>}\n   */\n  // eslint-disable-next-line no-unused-vars\n  fingerprintRequest: function fingerprintRequest(item) {\n    throw new Error('fingerprintRequest() must be implemented');\n  },\n\n  /**\n   * Generates a unique identifier for the item in a response payload\n   * Intended to be overridden\n   * Note that overrides must return a primitive.\n   * @param {Object} item\n   * @returns {Promise<primitive>}\n   */\n  // eslint-disable-next-line no-unused-vars\n  fingerprintResponse: function fingerprintResponse(item) {\n    throw new Error('fingerprintResponse() must be implemented');\n  },\n  version: \"1.154.2\"\n});\n\nvar _default2 = Batcher;\nexports.default = _default2;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;AAKA;;AAMA;;AACA;AAEA;AACA;AACA;AACA;;;AACA,IAAMA,OAAO,GAAGC,qBAAYC,MAAZD,CAAmB;AACjCE,SAAO,EAAE;AACPC,aAAS,EAAE;AACTC,UAAI,EAAE,QADG;AAETC,aAFS,sBAEC;AACR,eAAO,kBAAP;AACD;AAJQ,KADJ;AAOPC,SAAK,EAAE;AACLF,UAAI,EAAE,OADD;AAELC,aAFK,sBAEK;AACR,eAAO,EAAP;AACD;AAJI;AAPA,GADwB;AAgBjCE,SAAO,EAAE;AACPC,UAAM,EAAE;AACNC,QADM,gBACD;AAAA;;AACH,eAAO,4BAAe;AAAA,iBAAaC,KAAI,CAACC,YAAL,cAAIC,SAAJ,CAAb;AAAf,WAAwD,KAAKC,MAAL,CAAYC,WAApE,EAAiF;AACtFC,kBAAQ,EAAE,KAAKF,MAAL,CAAYG,eADgE;AAEtFC,iBAAO,EAAE,KAAKJ,MAAL,CAAYK;AAFiE,SAAjF,CAAP;AAID;AANK;AADD,GAhBwB;;AA2BjC;AACF;AACA;AACA;AACA;AACEC,SAhCiC,mBAgCzBC,IAhCyB,EAgCnB;AAAA,uBACZ;;AACA;;;AACA,QAAMC,KAAK,GAAG,IAAIC,aAAJ,EAAd;AAEA,SAAKC,kBAAL,CAAwBH,IAAxB,EACGI,IADH,CACQ,UAACC,GAAD,EAAS;AACb,UAAIC,MAAI,CAACvB,SAAL,CAAewB,GAAf,CAAmBF,GAAnB,CAAJ,EAA6B;AAC3BJ,aAAK,CAACO,OAANP,CAAcK,MAAI,CAACvB,SAAL,CAAe0B,GAAf,CAAmBJ,GAAnB,EAAwBK,OAAtCT;AAEA;AACD;;AACDK,YAAI,CAACvB,SAAL,CAAe4B,GAAf,CAAmBN,GAAnB,EAAwBJ,KAAxB;;AACAK,YAAI,CAACM,WAAL,CAAiBZ,IAAjB,EACGI,IADH,CACQ,UAACS,GAAD,EAAS;AACbZ,aAAK,CAACS,OAANT,GAAgBA,KAAK,CAACS,OAANT,CACbG,IADaH,CACR,iBAAI;AAAA,iBAAMK,MAAI,CAACvB,SAAL,CAAe+B,MAAf,CAAsBT,GAAtB,CAAN;AAAJ,UADQJ,EAEbc,KAFad,CAEP,UAACe,MAAD,EAAY;AACjBV,gBAAI,CAACvB,SAAL,CAAe+B,MAAf,CAAsBT,GAAtB;;AAEA,iBAAOY,iBAAQC,MAAR,CAAeF,MAAf,CAAP;AALY,UAAhBf;;AAQAK,cAAI,CAACa,OAAL,CAAaN,GAAb,EACGT,IADH,CACQ;AAAA,iBAAME,MAAI,CAAClB,MAAL,EAAN;AADR,WAEG2B,KAFH,CAES,UAACC,MAAD;AAAA,iBAAYf,KAAK,CAACiB,MAANjB,CAAae,MAAbf,CAAZ;AAFT;AAVJ,SAcGc,KAdH,CAcS,UAACC,MAAD;AAAA,eAAYf,KAAK,CAACiB,MAANjB,CAAae,MAAbf,CAAZ;AAdT;AARJ,OAwBGc,KAxBH,CAwBS,UAACC,MAAD;AAAA,aAAYf,KAAK,CAACiB,MAANjB,CAAae,MAAbf,CAAZ;AAxBT;AA0BA,WAAOA,KAAK,CAACS,OAAb;AA/D+B;;AAkEjC;AACF;AACA;AACA;AACA;AACA;AACES,SAxEiC,mBAwEzBN,GAxEyB,EAwEpB;AACX,SAAK3B,KAAL,CAAWkC,IAAX,CAAgBP,GAAhB;AAEA,WAAOI,iBAAQT,OAAR,EAAP;AA3E+B;;AA8EjC;AACF;AACA;AACA;AACA;AACA;AACEI,aApFiC,uBAoFrBZ,IApFqB,EAoFf;AAChB,WAAOiB,iBAAQT,OAAR,CAAgBR,IAAhB,CAAP;AArF+B;;AAwFjC;AACF;AACA;AACA;AACA;AACET,cA7FiC,0BA6FlB;AAAA;;AACb,QAAML,KAAK,GAAG,KAAKA,KAAL,CAAWmC,MAAX,CAAkB,CAAlB,EAAqB,KAAK5B,MAAL,CAAYG,eAAjC,CAAd;AAEA,WAAO,qBAAY,UAACY,OAAD,EAAa;AAC9BA,aAAO,CAACc,MAAI,CAACC,cAAL,CAAoBrC,KAApB,EACLkB,IADK,CACA,UAACoB,OAAD;AAAA,eAAaF,MAAI,CAACG,iBAAL,CAAuBD,OAAvB,EAChBpB,IADgB,CACX,UAACsB,GAAD;AAAA,iBAASJ,MAAI,CAACK,iBAAL,CAAuBD,GAAvB,CAAT;AADW,UAAb;AADA,SAGLX,KAHK,CAGC,UAACC,MAAD,EAAY;AACjB,YAAIA,MAAM,YAAYY,uBAAtB,EAAsC;AACpC,iBAAON,MAAI,CAACO,eAAL,CAAqBb,MAArB,CAAP;AACD;;AAED,eAAOC,iBAAQa,GAAR,CAAY5C,KAAK,CAAC6C,GAAN7C,CAAU,UAACc,IAAD;AAAA,iBAAUsB,MAAI,CAACU,qBAAL,CAA2BhC,IAA3B,EACpCI,IADoC,CAC/B,UAACH,KAAD,EAAW;AACfA,iBAAK,CAACiB,MAANjB,CAAae,MAAbf;AAFmC,YAAV;AAAV,UAAZ,CAAP;AARI,QAAD,CAAPO;AADK,OAeJO,KAfI,CAeE,UAACC,MAAD,EAAY;AACjBM,YAAI,CAACW,MAAL,CAAYC,KAAZ,CAAkBC,OAAO,CAACC,GAARD,CAAYE,QAAZF,KAAyB,YAAzBA,GAAwCnB,MAAxCmB,GAAiDnB,MAAM,CAACsB,KAA1E;;AAEA,aAAOrB,iBAAQC,MAAR,CAAeF,MAAf,CAAP;AAlBG,MAAP;AAhG+B;;AAsHjC;AACF;AACA;AACA;AACA;AACA;AACEO,gBA5HiC,0BA4HlBrC,KA5HkB,EA4HX;AACpB,WAAO+B,iBAAQT,OAAR,CAAgBtB,KAAhB,CAAP;AA7H+B;;AAgIjC;AACF;AACA;AACA;AACA;AACA;AACE;AACAuC,mBAvIiC,6BAuIfD,OAvIe,EAuIN;AACzB,UAAM,IAAIe,KAAJ,CAAU,+BAAV,CAAN;AAxI+B;;AA2IjC;AACF;AACA;AACA;AACA;AACA;AACEZ,mBAjJiC,6BAiJfD,GAjJe,EAiJV;AAAA;;AACrB,WAAOT,iBAAQa,GAAR,CAAY,CAACJ,GAAG,CAACc,IAAJd,IAAYA,GAAG,CAACc,IAAJd,CAASe,KAArBf,IAA8BA,GAAG,CAACc,IAAnC,EAAyCT,GAAzC,CAA6C,UAAC/B,IAAD;AAAA,aAAU0C,MAAI,CAACC,UAAL,CAAgB3C,IAAhB,CAAV;AAA7C,MAAZ,CAAP;AAlJ+B;;AAqJjC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACE6B,iBA7JiC,2BA6JjBb,MA7JiB,EA6JT;AAAA;;AACtB,QAAIA,MAAM,YAAYY,uBAAtB,EAAsC;AACpC,UAAI,mBAAIZ,MAAJ,EAAY,kBAAZ,CAAJ,EAAqC;AACnC,eAAOC,iBAAQa,GAAR,CAAYd,MAAM,CAAC4B,OAAP5B,CAAewB,IAAfxB,CAAoBe,GAApBf,CAAwB,UAAChB,IAAD;AAAA,iBAAU6C,MAAI,CAACb,qBAAL,CAA2BhC,IAA3B,EAClDI,IADkD,CAC7C,UAACH,KAAD,EAAW;AACfA,iBAAK,CAACiB,MAANjB,CAAae,MAAbf;AAFiD,YAAV;AAAxB,UAAZ,CAAP;AAID;AACF;;AACD,SAAKgC,MAAL,CAAYC,KAAZ,CAAkB,2DAAlB,EAA+ElB,MAA/E;AAEA,WAAOC,iBAAQC,MAAR,CAAeF,MAAf,CAAP;AAxK+B;;AA2KjC;AACF;AACA;AACA;AACA;AACE2B,YAhLiC,sBAgLtB3C,IAhLsB,EAgLhB;AAAA;;AACf,WAAO,KAAK8C,WAAL,CAAiB9C,IAAjB,EACJI,IADI,CACC,UAAC2C,OAAD,EAAa;AACjB,UAAIA,OAAJ,EAAa;AACX,eAAOC,MAAI,CAACC,iBAAL,CAAuBjD,IAAvB,CAAP;AACD;;AAED,aAAOgD,MAAI,CAACE,iBAAL,CAAuBlD,IAAvB,CAAP;AANG,MAAP;AAjL+B;;AA2LjC;AACF;AACA;AACA;AACA;AACA;AACE;AACA8C,aAlMiC,uBAkMrB9C,IAlMqB,EAkMf;AAChB,WAAOiB,iBAAQT,OAAR,CAAgB,KAAhB,CAAP;AAnM+B;;AAsMjC;AACF;AACA;AACA;AACA;AACA;AACEyC,mBA5MiC,6BA4MfjD,IA5Me,EA4MT;AACtB,WAAO,KAAKmD,sBAAL,CAA4BnD,IAA5B,EACJI,IADI,CACC,UAACH,KAAD,EAAW;AACfA,WAAK,CAACiB,MAANjB,CAAaD,IAAbC;AAFG,MAAP;AA7M+B;;AAmNjC;AACF;AACA;AACA;AACA;AACA;AACEiD,mBAzNiC,6BAyNflD,IAzNe,EAyNT;AACtB,WAAO,KAAKmD,sBAAL,CAA4BnD,IAA5B,EACJI,IADI,CACC,UAACH,KAAD,EAAW;AACfA,WAAK,CAACO,OAANP,CAAcD,IAAdC;AAFG,MAAP;AA1N+B;;AAgOjC;AACF;AACA;AACA;AACA;AACE+B,uBArOiC,iCAqOXhC,IArOW,EAqOL;AAAA;;AAC1B,WAAO,KAAKG,kBAAL,CAAwBH,IAAxB,EACJI,IADI,CACC,UAACC,GAAD,EAAS;AACb,UAAMJ,KAAK,GAAGmD,MAAI,CAACrE,SAAL,CAAe0B,GAAf,CAAmBJ,GAAnB,CAAd;AAEA;;;AACA,UAAI,CAACJ,KAAL,EAAY;AACV,cAAM,IAAIsC,KAAJ,CAAU,sDAAV,CAAN;AACD;;AAED,aAAOtC,KAAP;AATG,MAAP;AAtO+B;;AAmPjC;AACF;AACA;AACA;AACA;AACEkD,wBAxPiC,kCAwPVnD,IAxPU,EAwPJ;AAAA;;AAC3B,WAAO,KAAKqD,mBAAL,CAAyBrD,IAAzB,EACJI,IADI,CACC,UAACC,GAAD,EAAS;AACb,UAAMJ,KAAK,GAAGqD,MAAI,CAACvE,SAAL,CAAe0B,GAAf,CAAmBJ,GAAnB,CAAd;AAEA;;;AACA,UAAI,CAACJ,KAAL,EAAY;AACV,cAAM,IAAIsC,KAAJ,CAAU,sDAAV,CAAN;AACD;;AAED,aAAOtC,KAAP;AATG,MAAP;AAzP+B;;AAsQjC;AACF;AACA;AACA;AACA;AACA;AACA;AACE;AACAE,oBA9QiC,8BA8QdH,IA9Qc,EA8QR;AACvB,UAAM,IAAIuC,KAAJ,CAAU,0CAAV,CAAN;AA/Q+B;;AAkRjC;AACF;AACA;AACA;AACA;AACA;AACA;AACE;AACAc,qBA1RiC,+BA0RbrD,IA1Ra,EA0RP;AACxB,UAAM,IAAIuC,KAAJ,CAAU,2CAAV,CAAN;AA3R+B;AAAAgB;AAAA,CAAnB3E,CAAhB;;gBA+ReD","names":["Batcher","WebexPlugin","extend","session","deferreds","type","default","queue","derived","bounce","fn","_this","executeQueue","arguments","config","batcherWait","maxCalls","batcherMaxCalls","maxWait","batcherMaxWait","request","item","defer","Defer","fingerprintRequest","then","idx","_this2","has","resolve","get","promise","set","prepareItem","req","delete","catch","reason","_promise","reject","enqueue","push","splice","_this3","prepareRequest","payload","submitHttpRequest","res","handleHttpSuccess","WebexHttpError","handleHttpError","all","map","getDeferredForRequest","logger","error","process","env","NODE_ENV","stack","Error","body","items","_this4","acceptItem","options","_this5","didItemFail","didFail","_this6","handleItemFailure","handleItemSuccess","getDeferredForResponse","_this7","fingerprintResponse","_this8","version"],"sources":["batcher.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {has} from 'lodash';\nimport {\n  cappedDebounce,\n  Defer,\n  tap\n} from '@webex/common';\n\nimport WebexPlugin from './webex-plugin';\nimport WebexHttpError from './webex-http-error';\n\n/**\n * Base class for coalescing requests to batched APIs\n * @class Batcher\n */\nconst Batcher = WebexPlugin.extend({\n  session: {\n    deferreds: {\n      type: 'object',\n      default() {\n        return new Map();\n      }\n    },\n    queue: {\n      type: 'array',\n      default() {\n        return [];\n      }\n    }\n  },\n\n  derived: {\n    bounce: {\n      fn() {\n        return cappedDebounce((...args) => this.executeQueue(...args), this.config.batcherWait, {\n          maxCalls: this.config.batcherMaxCalls,\n          maxWait: this.config.batcherMaxWait\n        });\n      }\n    }\n  },\n\n  /**\n   * Requests an item from a batched API\n   * @param {Object} item\n   * @returns {Promise<mixed>}\n   */\n  request(item) {\n    // So far, I can't find a way to avoid three layers of nesting here.\n    /* eslint max-nested-callbacks: [0] */\n    const defer = new Defer();\n\n    this.fingerprintRequest(item)\n      .then((idx) => {\n        if (this.deferreds.has(idx)) {\n          defer.resolve(this.deferreds.get(idx).promise);\n\n          return;\n        }\n        this.deferreds.set(idx, defer);\n        this.prepareItem(item)\n          .then((req) => {\n            defer.promise = defer.promise\n              .then(tap(() => this.deferreds.delete(idx)))\n              .catch((reason) => {\n                this.deferreds.delete(idx);\n\n                return Promise.reject(reason);\n              });\n\n            this.enqueue(req)\n              .then(() => this.bounce())\n              .catch((reason) => defer.reject(reason));\n          })\n          .catch((reason) => defer.reject(reason));\n      })\n      .catch((reason) => defer.reject(reason));\n\n    return defer.promise;\n  },\n\n  /**\n   * Adds an item to the queue.\n   * Intended to be overridden\n   * @param {mixed} req\n   * @returns {Promise<undefined>}\n   */\n  enqueue(req) {\n    this.queue.push(req);\n\n    return Promise.resolve();\n  },\n\n  /**\n   * Transform the item before adding it to the queue\n   * Intended to be overridden\n   * @param {mixed} item\n   * @returns {Promise<mixed>}\n   */\n  prepareItem(item) {\n    return Promise.resolve(item);\n  },\n\n  /**\n   * Detaches the current queue, does any appropriate transforms, and submits it\n   * to the API.\n   * @returns {Promise<undefined>}\n   */\n  executeQueue() {\n    const queue = this.queue.splice(0, this.config.batcherMaxCalls);\n\n    return new Promise((resolve) => {\n      resolve(this.prepareRequest(queue)\n        .then((payload) => this.submitHttpRequest(payload)\n          .then((res) => this.handleHttpSuccess(res)))\n        .catch((reason) => {\n          if (reason instanceof WebexHttpError) {\n            return this.handleHttpError(reason);\n          }\n\n          return Promise.all(queue.map((item) => this.getDeferredForRequest(item)\n            .then((defer) => {\n              defer.reject(reason);\n            })));\n        }));\n    })\n      .catch((reason) => {\n        this.logger.error(process.env.NODE_ENV === 'production' ? reason : reason.stack);\n\n        return Promise.reject(reason);\n      });\n  },\n\n  /**\n   * Performs any final transforms on the queue before submitting it to the API\n   * Intended to be overridden\n   * @param {Object|Array} queue\n   * @returns {Promise<Object>}\n   */\n  prepareRequest(queue) {\n    return Promise.resolve(queue);\n  },\n\n  /**\n   * Submits the prepared request body to the API.\n   * This method *must* be overridden\n   * @param {Object} payload\n   * @returns {Promise<HttpResponseObject>}\n   */\n  // eslint-disable-next-line no-unused-vars\n  submitHttpRequest(payload) {\n    throw new Error('request() must be implemented');\n  },\n\n  /**\n   * Actions taken when the http request returns a success\n   * Intended to be overridden\n   * @param {Promise<HttpResponseObject>} res\n   * @returns {Promise<undefined>}\n   */\n  handleHttpSuccess(res) {\n    return Promise.all((res.body && res.body.items || res.body).map((item) => this.acceptItem(item)));\n  },\n\n  /**\n   * Actions taken when the http request returns a failure. Typically, this\n   * means failing the entire queue, but could be overridden in some\n   * implementations to e.g. reenqueue.\n   * Intended to be overridden\n   * @param {WebexHttpError} reason\n   * @returns {Promise<undefined>}\n   */\n  handleHttpError(reason) {\n    if (reason instanceof WebexHttpError) {\n      if (has(reason, 'options.body.map')) {\n        return Promise.all(reason.options.body.map((item) => this.getDeferredForRequest(item)\n          .then((defer) => {\n            defer.reject(reason);\n          })));\n      }\n    }\n    this.logger.error('http error handler called without a WebexHttpError object', reason);\n\n    return Promise.reject(reason);\n  },\n\n  /**\n   * Determines if the item succeeded or failed and delegates accordingly\n   * @param {Object} item\n   * @returns {Promise<undefined>}\n   */\n  acceptItem(item) {\n    return this.didItemFail(item)\n      .then((didFail) => {\n        if (didFail) {\n          return this.handleItemFailure(item);\n        }\n\n        return this.handleItemSuccess(item);\n      });\n  },\n\n  /**\n   * Indicates if the specified response item implies a success or a failure\n   * Intended to be overridden\n   * @param {Object} item\n   * @returns {Promise<Boolean>}\n   */\n  // eslint-disable-next-line no-unused-vars\n  didItemFail(item) {\n    return Promise.resolve(false);\n  },\n\n  /**\n   * Finds the Defer for the specified item and rejects its promise\n   * Intended to be overridden\n   * @param {Object} item\n   * @returns {Promise<undefined>}\n   */\n  handleItemFailure(item) {\n    return this.getDeferredForResponse(item)\n      .then((defer) => {\n        defer.reject(item);\n      });\n  },\n\n  /**\n   * Finds the Defer for the specified item and resolves its promise\n   * Intended to be overridden\n   * @param {Object} item\n   * @returns {Promise<undefined>}\n   */\n  handleItemSuccess(item) {\n    return this.getDeferredForResponse(item)\n      .then((defer) => {\n        defer.resolve(item);\n      });\n  },\n\n  /**\n   * Returns the Deferred for the specified request item\n   * @param {Object} item\n   * @returns {Promise<Defer>}\n   */\n  getDeferredForRequest(item) {\n    return this.fingerprintRequest(item)\n      .then((idx) => {\n        const defer = this.deferreds.get(idx);\n\n        /* istanbul ignore if */\n        if (!defer) {\n          throw new Error('Could not find pending request for received response');\n        }\n\n        return defer;\n      });\n  },\n\n  /**\n   * Returns the Deferred for the specified response item\n   * @param {Object} item\n   * @returns {Promise<Defer>}\n   */\n  getDeferredForResponse(item) {\n    return this.fingerprintResponse(item)\n      .then((idx) => {\n        const defer = this.deferreds.get(idx);\n\n        /* istanbul ignore if */\n        if (!defer) {\n          throw new Error('Could not find pending request for received response');\n        }\n\n        return defer;\n      });\n  },\n\n  /**\n   * Generates a unique identifier for the item in a request payload\n   * Intended to be overridden\n   * Note that overrides must return a primitive.\n   * @param {Object} item\n   * @returns {Promise<primitive>}\n   */\n  // eslint-disable-next-line no-unused-vars\n  fingerprintRequest(item) {\n    throw new Error('fingerprintRequest() must be implemented');\n  },\n\n  /**\n   * Generates a unique identifier for the item in a response payload\n   * Intended to be overridden\n   * Note that overrides must return a primitive.\n   * @param {Object} item\n   * @returns {Promise<primitive>}\n   */\n  // eslint-disable-next-line no-unused-vars\n  fingerprintResponse(item) {\n    throw new Error('fingerprintResponse() must be implemented');\n  }\n});\n\nexport default Batcher;\n"]},"metadata":{},"sourceType":"script"}