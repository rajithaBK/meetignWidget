{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _forEach2 = _interopRequireDefault(require(\"lodash/forEach\"));\n\nvar _find2 = _interopRequireDefault(require(\"lodash/find\"));\n\nvar _keys2 = _interopRequireDefault(require(\"lodash/keys\"));\n\nvar _constants = require(\"../constants\");\n\nvar _browserDetection = _interopRequireDefault(require(\"../common/browser-detection\"));\n\nvar _BrowserDetection = (0, _browserDetection.default)(),\n    isBrowser = _BrowserDetection.isBrowser;\n\nvar StatsTransformer = {\n  isFF: isBrowser('firefox')\n}; // convert the ids from the parsed stats objects into understandable keys\n\nStatsTransformer.simplify = function (stat) {\n  return (0, _find2.default)((0, _keys2.default)(StatsTransformer.isFF ? _constants.DEFAULT_FF_TRANSFORM_REGEX : _constants.DEFAULT_TRANSFORM_REGEX), function (key) {\n    var value;\n\n    if (StatsTransformer.isFF) {\n      // FF stats are formatted poorly so we have to take what we can get\n      value = _constants.DEFAULT_FF_TRANSFORM_REGEX[key].regex.test(\"\".concat(stat.type).concat(stat.kind ? \"_\".concat(stat.kind) : '', \"_\").concat(stat.id)) ? key : false;\n    } else {\n      // no other parameters necessary besides id\n      value = _constants.DEFAULT_TRANSFORM_REGEX[key].regex.test(stat.id) ? key : false;\n    }\n\n    if (value) {\n      // others were included but have a value that exclude them from the list because of duplicates that weren't chosen\n      if (_constants.DEFAULT_TRANSFORM_REGEX[value].decider) {\n        if (stat[_constants.DEFAULT_TRANSFORM_REGEX[value].decider] !== _constants.DEFAULT_TRANSFORM_REGEX[value].selector) {\n          value = false;\n        }\n\n        return value;\n      } // // some types need to check against a type field as well\n\n\n      if (_constants.DEFAULT_TRANSFORM_REGEX[value].profiler) {\n        var mapStatToReadableType = stat[_constants.DEFAULT_TRANSFORM_REGEX[value].profiler.type];\n\n        if (!(mapStatToReadableType && mapStatToReadableType.includes(_constants.DEFAULT_TRANSFORM_REGEX[value].profiler.value) && value.toLowerCase().includes(_constants.DEFAULT_TRANSFORM_REGEX[value].profiler.value))) {\n          value = false;\n          return value;\n        }\n      }\n    }\n\n    return value;\n  });\n}; // parse the RTCStatsReport, extracting only the data we care about\n\n\nStatsTransformer.parse = function (report) {\n  var target = {}; // from the stats object\n  // get the rtc stats report\n\n  if (report && report.forEach && report.size > 0) {\n    report.forEach(function (stat) {\n      // each report has internal data\n      if (stat && stat.type) {\n        // pull only certain types\n        if (_constants.DEFAULT_GET_STATS_FILTER.types.includes(stat.type)) {\n          // insert into the target the statistic mapped to it's statical id\n          target[stat.id] = stat;\n        }\n      }\n    });\n  }\n\n  return target;\n};\n\nStatsTransformer.convert = function (parsed, options) {\n  // supply your own simplification function (rather than id as the key)\n  if (options.simplifyFn) {\n    return options.simplifyFn(parsed);\n  } // else use ours that stores things like rtcOutAudio, rtpInVideo, etc\n\n\n  var target = {};\n  (0, _forEach2.default)(parsed, function (stat) {\n    var key = StatsTransformer.simplify(stat);\n\n    if (key) {\n      target[key] = stat;\n    }\n  });\n  return target;\n}; // transform the RTCStatsReport into a much more readable, processable format\n\n\nStatsTransformer.transform = function (report) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    simplifyFn: undefined\n  };\n  var data; // first parse it and cut out not necessary data\n\n  var parsed = StatsTransformer.parse(report); // either convert the data or store each stat with it's id mapped as the key to the stat object itself\n\n  if (_constants.DEFAULT_TRANSFORM_REGEX) {\n    data = StatsTransformer.convert(parsed, options);\n  } else {\n    data = parsed;\n  }\n\n  return data;\n};\n\nvar _default = StatsTransformer;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["isBrowser","StatsTransformer","isFF","simplify","stat","DEFAULT_FF_TRANSFORM_REGEX","DEFAULT_TRANSFORM_REGEX","key","value","regex","test","type","kind","id","decider","selector","profiler","mapStatToReadableType","includes","toLowerCase","parse","report","target","forEach","size","DEFAULT_GET_STATS_FILTER","types","convert","parsed","options","simplifyFn","transform","undefined","data"],"sources":["transformer.js"],"sourcesContent":["import {keys, find, forEach} from 'lodash';\n\nimport {\n  DEFAULT_TRANSFORM_REGEX, DEFAULT_FF_TRANSFORM_REGEX, DEFAULT_GET_STATS_FILTER\n} from '../constants';\nimport BrowserDetection from '../common/browser-detection';\n\nconst {isBrowser} = BrowserDetection();\n\nconst StatsTransformer = {\n  isFF: isBrowser('firefox')\n};\n\n// convert the ids from the parsed stats objects into understandable keys\nStatsTransformer.simplify = (stat) => find(keys(StatsTransformer.isFF ? DEFAULT_FF_TRANSFORM_REGEX : DEFAULT_TRANSFORM_REGEX), (key) => {\n  let value;\n\n  if (StatsTransformer.isFF) {\n    // FF stats are formatted poorly so we have to take what we can get\n    value = (DEFAULT_FF_TRANSFORM_REGEX[key].regex.test(`${stat.type}${stat.kind ? `_${stat.kind}` : ''}_${stat.id}`) ? key : false);\n  }\n  else {\n    // no other parameters necessary besides id\n    value = (DEFAULT_TRANSFORM_REGEX[key].regex.test(stat.id) ? key : false);\n  }\n\n  if (value) {\n    // others were included but have a value that exclude them from the list because of duplicates that weren't chosen\n    if (DEFAULT_TRANSFORM_REGEX[value].decider) {\n      if (stat[DEFAULT_TRANSFORM_REGEX[value].decider] !== DEFAULT_TRANSFORM_REGEX[value].selector) {\n        value = false;\n      }\n\n      return value;\n    }\n    // // some types need to check against a type field as well\n    if (DEFAULT_TRANSFORM_REGEX[value].profiler) {\n      const mapStatToReadableType = stat[DEFAULT_TRANSFORM_REGEX[value].profiler.type];\n\n      if (!((mapStatToReadableType && mapStatToReadableType.includes(DEFAULT_TRANSFORM_REGEX[value].profiler.value)) &&\n      (value.toLowerCase().includes(DEFAULT_TRANSFORM_REGEX[value].profiler.value)))) {\n        value = false;\n\n        return value;\n      }\n    }\n  }\n\n  return value;\n});\n\n// parse the RTCStatsReport, extracting only the data we care about\nStatsTransformer.parse = (report) => {\n  const target = {};\n\n  // from the stats object\n  // get the rtc stats report\n  if (report && report.forEach && report.size > 0) {\n    report.forEach((stat) => {\n      // each report has internal data\n      if (stat && stat.type) {\n        // pull only certain types\n        if (DEFAULT_GET_STATS_FILTER.types.includes(stat.type)) {\n          // insert into the target the statistic mapped to it's statical id\n          target[stat.id] = stat;\n        }\n      }\n    });\n  }\n\n  return target;\n};\n\nStatsTransformer.convert = (parsed, options) => {\n  // supply your own simplification function (rather than id as the key)\n  if (options.simplifyFn) {\n    return options.simplifyFn(parsed);\n  }\n  // else use ours that stores things like rtcOutAudio, rtpInVideo, etc\n  const target = {};\n\n  forEach(parsed, (stat) => {\n    const key = StatsTransformer.simplify(stat);\n\n    if (key) {\n      target[key] = stat;\n    }\n  });\n\n  return target;\n};\n\n// transform the RTCStatsReport into a much more readable, processable format\nStatsTransformer.transform = (report, options = {simplifyFn: undefined}) => {\n  let data;\n  // first parse it and cut out not necessary data\n  const parsed = StatsTransformer.parse(report);\n\n  // either convert the data or store each stat with it's id mapped as the key to the stat object itself\n  if (DEFAULT_TRANSFORM_REGEX) {\n    data = StatsTransformer.convert(parsed, options);\n  }\n  else {\n    data = parsed;\n  }\n\n  return data;\n};\nexport default StatsTransformer;\n"]},"metadata":{},"sourceType":"script"}