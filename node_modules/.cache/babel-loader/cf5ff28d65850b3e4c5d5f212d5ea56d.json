{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n_Object$defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function get() {\n    return _encryption.default;\n  }\n});\n\n_Object$defineProperty(exports, \"KmsError\", {\n  enumerable: true,\n  get: function get() {\n    return _kmsErrors.KmsError;\n  }\n});\n\n_Object$defineProperty(exports, \"DryError\", {\n  enumerable: true,\n  get: function get() {\n    return _kmsErrors.DryError;\n  }\n});\n\n_Object$defineProperty(exports, \"KMS\", {\n  enumerable: true,\n  get: function get() {\n    return _kms.default;\n  }\n});\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _isString2 = _interopRequireDefault(require(\"lodash/isString\"));\n\nvar _isObject2 = _interopRequireDefault(require(\"lodash/isObject\"));\n\nvar _has2 = _interopRequireDefault(require(\"lodash/has\"));\n\nvar _webexCore = require(\"@webex/webex-core\");\n\nvar _encryption = _interopRequireDefault(require(\"./encryption\"));\n\nvar _config = _interopRequireDefault(require(\"./config\"));\n\nvar _kmsErrors = require(\"./kms-errors\");\n\nrequire(\"@webex/internal-plugin-device\");\n\nrequire(\"@webex/internal-plugin-mercury\");\n\nvar _kmsDryErrorInterceptor = _interopRequireDefault(require(\"./kms-dry-error-interceptor\"));\n\nvar _kms = _interopRequireDefault(require(\"./kms\"));\n/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n// Note: There's a bug where if bind gets replayed because of a timeout in which\n// the original request eventually completed, there'll be an error indicating\n// the key can't be bound (because it already has been). This could be mitigated\n// by using Promise.race to resolve replays (as more requests get enqueue for a\n// specific action, accept whichever one completes first).\n\n\nvar interceptors;\n\nif (process.env.NODE_ENV === 'test') {\n  interceptors = {\n    KmsDryErrorInterceptor: _kmsDryErrorInterceptor.default.create\n  };\n}\n\n(0, _webexCore.registerInternalPlugin)('encryption', _encryption.default, {\n  payloadTransformer: {\n    predicates: [{\n      name: 'encryptKmsMessage',\n      direction: 'outbound',\n      // I don't see any practical way to reduce complexity here.\n      // eslint-disable-next-line complexity\n      test: function test(ctx, options) {\n        if (!(0, _has2.default)(options, 'body.kmsMessage')) {\n          return _promise.default.resolve(false);\n        }\n\n        if (!(0, _isObject2.default)(options.body.kmsMessage)) {\n          return _promise.default.resolve(false);\n        } // If this is a template for a kms message, assume another transform\n        // will fill it in later. This is a bit of a leaky abstraction, but the\n        // alternative is building a complex rules engine for controlling\n        // ordering of transforms\n\n\n        if (options.body.kmsMessage.keyUris && options.body.kmsMessage.keyUris.length === 0) {\n          return _promise.default.resolve(false);\n        }\n\n        if (options.body.kmsMessage.resourceUri && (options.body.kmsMessage.resourceUri.includes('<KRO>') || options.body.kmsMessage.resourceUri.includes('<KEYURL>'))) {\n          return _promise.default.resolve(false);\n        }\n\n        if (options.body.kmsMessage.uri && (options.body.kmsMessage.uri.includes('<KRO>') || options.body.kmsMessage.uri.includes('<KEYURL>'))) {\n          return _promise.default.resolve(false);\n        }\n\n        return _promise.default.resolve(true);\n      },\n      extract: function extract(options) {\n        return _promise.default.resolve(options.body);\n      }\n    }, {\n      name: 'decryptKmsMessage',\n      direction: 'inbound',\n      test: function test(ctx, response) {\n        return _promise.default.resolve((0, _has2.default)(response, 'body.kmsMessage') && (0, _isString2.default)(response.body.kmsMessage));\n      },\n      extract: function extract(response) {\n        return _promise.default.resolve(response.body);\n      }\n    }, {\n      name: 'decryptErrorResponse',\n      direction: 'inbound',\n      test: function test(ctx, reason) {\n        return _promise.default.resolve(Boolean(reason.body && reason.body.errorCode === 1900000));\n      },\n      extract: function extract(reason) {\n        return _promise.default.resolve(reason);\n      }\n    }],\n    transforms: [{\n      name: 'encryptKmsMessage',\n      fn: function fn(ctx, object) {\n        if (!object) {\n          return _promise.default.resolve();\n        }\n\n        if (!object.kmsMessage) {\n          return _promise.default.resolve();\n        }\n\n        if ((0, _isString2.default)(object.kmsMessage)) {\n          return _promise.default.resolve();\n        }\n\n        return ctx.webex.internal.encryption.kms.prepareRequest(object.kmsMessage).then(function (req) {\n          object.kmsMessage = req.wrapped;\n        });\n      }\n    }, {\n      name: 'decryptKmsMessage',\n      fn: function fn(ctx, object) {\n        return ctx.webex.internal.encryption.kms.decryptKmsMessage(object.kmsMessage).then(function (kmsMessage) {\n          object.kmsMessage = kmsMessage;\n        });\n      }\n    }, {\n      name: 'decryptErrorResponse',\n      fn: function fn(ctx, reason) {\n        var promises = reason.body.errors.map(function (error) {\n          return ctx.webex.internal.encryption.kms.decryptKmsMessage(error.description).then(function (desc) {\n            error.description = desc;\n          });\n        });\n        promises.push(ctx.webex.internal.encryption.kms.decryptKmsMessage(reason.body.message).then(function (kmsMessage) {\n          reason.body.message = kmsMessage;\n        }));\n        return _promise.default.all(promises).then(function () {\n          return _promise.default.reject(new _kmsErrors.DryError(reason));\n        });\n      }\n    }]\n  },\n  interceptors: interceptors,\n  config: _config.default\n});","map":{"version":3,"mappings":"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","names":["require","interceptors","process","env","NODE_ENV","KmsDryErrorInterceptor","create","Encryption","payloadTransformer","predicates","name","direction","test","ctx","options","_promise","resolve","body","kmsMessage","keyUris","length","resourceUri","includes","uri","extract","response","reason","Boolean","errorCode","transforms","fn","object","webex","internal","encryption","kms","prepareRequest","then","req","wrapped","decryptKmsMessage","promises","errors","map","error","description","desc","push","message","all","reject","DryError","config"],"sources":["index.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\n// Note: There's a bug where if bind gets replayed because of a timeout in which\n// the original request eventually completed, there'll be an error indicating\n// the key can't be bound (because it already has been). This could be mitigated\n// by using Promise.race to resolve replays (as more requests get enqueue for a\n// specific action, accept whichever one completes first).\n\nimport {registerInternalPlugin} from '@webex/webex-core';\nimport {has, isObject, isString} from 'lodash';\n\nimport Encryption from './encryption';\nimport config from './config';\nimport {DryError} from './kms-errors';\nimport '@webex/internal-plugin-device';\nimport '@webex/internal-plugin-mercury';\nimport KmsDryErrorInterceptor from './kms-dry-error-interceptor';\n\nlet interceptors;\n\nif (process.env.NODE_ENV === 'test') {\n  interceptors = {\n    KmsDryErrorInterceptor: KmsDryErrorInterceptor.create\n  };\n}\n\nregisterInternalPlugin('encryption', Encryption, {\n  payloadTransformer: {\n    predicates: [{\n      name: 'encryptKmsMessage',\n      direction: 'outbound',\n      // I don't see any practical way to reduce complexity here.\n      // eslint-disable-next-line complexity\n      test(ctx, options) {\n        if (!has(options, 'body.kmsMessage')) {\n          return Promise.resolve(false);\n        }\n\n        if (!isObject(options.body.kmsMessage)) {\n          return Promise.resolve(false);\n        }\n\n        // If this is a template for a kms message, assume another transform\n        // will fill it in later. This is a bit of a leaky abstraction, but the\n        // alternative is building a complex rules engine for controlling\n        // ordering of transforms\n        if (options.body.kmsMessage.keyUris && options.body.kmsMessage.keyUris.length === 0) {\n          return Promise.resolve(false);\n        }\n        if (options.body.kmsMessage.resourceUri && (options.body.kmsMessage.resourceUri.includes('<KRO>') || options.body.kmsMessage.resourceUri.includes('<KEYURL>'))) {\n          return Promise.resolve(false);\n        }\n        if (options.body.kmsMessage.uri && (options.body.kmsMessage.uri.includes('<KRO>') || options.body.kmsMessage.uri.includes('<KEYURL>'))) {\n          return Promise.resolve(false);\n        }\n\n        return Promise.resolve(true);\n      },\n      extract(options) {\n        return Promise.resolve(options.body);\n      }\n    }, {\n      name: 'decryptKmsMessage',\n      direction: 'inbound',\n      test(ctx, response) {\n        return Promise.resolve(has(response, 'body.kmsMessage') && isString(response.body.kmsMessage));\n      },\n      extract(response) {\n        return Promise.resolve(response.body);\n      }\n    }, {\n      name: 'decryptErrorResponse',\n      direction: 'inbound',\n      test(ctx, reason) {\n        return Promise.resolve(Boolean(reason.body && reason.body.errorCode === 1900000));\n      },\n      extract(reason) {\n        return Promise.resolve(reason);\n      }\n    }],\n    transforms: [{\n      name: 'encryptKmsMessage',\n      fn(ctx, object) {\n        if (!object) {\n          return Promise.resolve();\n        }\n\n        if (!object.kmsMessage) {\n          return Promise.resolve();\n        }\n\n        if (isString(object.kmsMessage)) {\n          return Promise.resolve();\n        }\n\n        return ctx.webex.internal.encryption.kms.prepareRequest(object.kmsMessage)\n          .then((req) => {\n            object.kmsMessage = req.wrapped;\n          });\n      }\n    }, {\n      name: 'decryptKmsMessage',\n      fn(ctx, object) {\n        return ctx.webex.internal.encryption.kms.decryptKmsMessage(object.kmsMessage)\n          .then((kmsMessage) => {\n            object.kmsMessage = kmsMessage;\n          });\n      }\n    }, {\n      name: 'decryptErrorResponse',\n      fn(ctx, reason) {\n        const promises = reason.body.errors.map((error) => ctx.webex.internal.encryption.kms.decryptKmsMessage(error.description)\n          .then((desc) => {\n            error.description = desc;\n          }));\n\n        promises.push(ctx.webex.internal.encryption.kms.decryptKmsMessage(reason.body.message)\n          .then((kmsMessage) => {\n            reason.body.message = kmsMessage;\n          }));\n\n        return Promise.all(promises)\n          .then(() => Promise.reject(new DryError(reason)));\n      }\n    }]\n  },\n  interceptors,\n  config\n});\n\nexport {default} from './encryption';\nexport {default as KMS} from './kms';\nexport {KmsError, DryError} from './kms-errors';\n"]},"metadata":{},"sourceType":"script"}