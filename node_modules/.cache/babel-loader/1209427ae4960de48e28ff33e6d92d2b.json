{"ast":null,"code":"\"use strict\";\n\nvar _Reflect$construct = require(\"@babel/runtime-corejs2/core-js/reflect/construct\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime-corejs2/regenerator\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/keys\"));\n\nvar _values = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/values\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/createClass\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/getPrototypeOf\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/defineProperty\"));\n\nrequire(\"@webex/internal-plugin-mercury\");\n\nvar _webexCore = require(\"@webex/webex-core\");\n\nrequire(\"webrtc-adapter\");\n\nvar _metrics = _interopRequireDefault(require(\"../metrics\"));\n\nvar _config = require(\"../metrics/config\");\n\nvar _loggerConfig = _interopRequireDefault(require(\"../common/logs/logger-config\"));\n\nvar _config2 = _interopRequireDefault(require(\"../common/config\"));\n\nvar _loggerProxy = _interopRequireDefault(require(\"../common/logs/logger-proxy\"));\n\nvar _request = _interopRequireDefault(require(\"../common/logs/request\"));\n\nvar _triggerProxy = _interopRequireDefault(require(\"../common/events/trigger-proxy\"));\n\nvar _media = _interopRequireDefault(require(\"../media\"));\n\nvar _util = _interopRequireDefault(require(\"../meeting/util\"));\n\nvar _constants = require(\"../constants\");\n\nvar _meetingInfo = _interopRequireDefault(require(\"../meeting-info\"));\n\nvar _meetingInfoV = _interopRequireDefault(require(\"../meeting-info/meeting-info-v2\"));\n\nvar _meeting = _interopRequireDefault(require(\"../meeting\"));\n\nvar _personalMeetingRoom = _interopRequireDefault(require(\"../personal-meeting-room\"));\n\nvar _reachability = _interopRequireDefault(require(\"../reachability\"));\n\nvar _request2 = _interopRequireDefault(require(\"../meetings/request\"));\n\nvar _analyzer = _interopRequireDefault(require(\"../analyzer/analyzer\"));\n\nvar _calculator = _interopRequireDefault(require(\"../analyzer/calculator\"));\n\nvar _passwordError = _interopRequireDefault(require(\"../common/errors/password-error\"));\n\nvar _captchaError = _interopRequireDefault(require(\"../common/errors/captcha-error\"));\n\nvar _collection = _interopRequireDefault(require(\"./collection\"));\n\nvar _util2 = _interopRequireDefault(require(\"./util\"));\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2.default)(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;\n      result = _Reflect$construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0, _possibleConstructorReturn2.default)(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false;\n  if (_Reflect$construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n   * Meetings Ready Event\n   * Emitted when the meetings instance on webex is ready\n   * @event meetings:ready\n   * @instance\n   * @memberof Meetings\n   */\n\n/**\n   * Meetings Network Disconnected Event\n   * Emitted when the meetings instance is disconnected from\n   * the internal mercury server\n   * @event network:disconnected\n   * @instance\n   * @memberof Meetings\n   */\n\n/**\n * Meetings Registered Event\n * Emitted when the meetings instance has been registered and listening\n * @event meetings:registered\n * @instance\n * @memberof Meetings\n */\n\n/**\n    * Meeting Removed Event\n    * Emitted when a meeting was removed from the cache of meetings\n    * @event meeting:removed\n    * @instance\n    * @type {Object}\n    * @property {String} meetingId the removed meeting\n    * @property {Object} response the server response\n    * @property {String} type what type of meeting it was\n    * @memberof Meetings\n    */\n\n/**\n    * Meeting Added Event\n    * Emitted when a meeting was added to the cache of meetings\n    * @event meeting:added\n    * @instance\n    * @type {Object}\n    * @property {String} meetingId the added meeting\n    * @property {String} type what type of meeting it was\n    * @memberof Meetings\n    */\n\n/**\n   * Maintain a cache of meetings and sync with services.\n   * @class\n   */\n\n\nvar Meetings = /*#__PURE__*/function (_WebexPlugin) {\n  (0, _inherits2.default)(Meetings, _WebexPlugin);\n\n  var _super = _createSuper(Meetings);\n  /**\n   * Initializes the Meetings Plugin\n   * @constructor\n   * @public\n   * @memberof Meetings\n   */\n\n\n  function Meetings() {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, Meetings);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    /**\n     * The Meetings request to interact with server\n     * @instance\n     * @type {Object}\n     * @private\n     * @memberof Meetings\n     */\n\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), \"namespace\", _constants.MEETINGS);\n    _this.request = new _request2.default({}, {\n      parent: _this.webex\n    });\n    /**\n     * Log upload request helper\n     * @instance\n     * @type {Object}\n     * @private\n     * @memberof Meetings\n     */\n\n    _this.loggerRequest = new _request.default({\n      webex: _this.webex\n    });\n    _this.meetingCollection = new _collection.default();\n    /**\n     * The PersonalMeetingRoom object to interact with server\n     * @instance\n     * @type {Object}\n     * @public\n     * @memberof Meetings\n     */\n\n    _this.personalMeetingRoom = null;\n    /**\n     * The Reachability object to interact with server, starts as null until {@link Meeting#setReachability} is called\n     * starts as null\n     * @instance\n     * @type {Object}\n     * @private\n     * @memberof Meetings\n     */\n\n    _this.reachability = null;\n    /**\n     * If the meetings plugin has been registered and listening via {@link Meetings#register}\n     * @instance\n     * @type {Boolean}\n     * @public\n     * @memberof Meetings\n     */\n\n    _this.registered = false;\n    /**\n     * The public interface for the internal Media util files. These are helpful to expose outside the context\n     * of a meeting so that a user can access media without creating a meeting instance.\n     * @instance\n     * @type {Object}\n     * @private\n     * @memberof Meetings\n     */\n\n    _this.media = {\n      getUserMedia: _media.default.getUserMedia,\n      getSupportedDevice: _media.default.getSupportedDevice\n    };\n\n    _loggerProxy.default.set(_this.webex.logger);\n\n    _this.onReady();\n\n    _util2.default.checkH264Support({\n      disableNotifications: true\n    });\n\n    _metrics.default.initialSetup(_this.meetingCollection, _this.webex);\n\n    return _this;\n  }\n  /**\n   * handle locus events and takes meeting actions with them as they come in\n   * @param {Object} data a locus event\n   * @param {String} data.locusUrl\n   * @param {Object} data.locus\n   * @param {String} data.eventType\n   * @returns {undefined}\n   * @private\n   * @memberof Meetings\n   */\n\n\n  (0, _createClass2.default)(Meetings, [{\n    key: \"handleLocusEvent\",\n    value: function handleLocusEvent(data) {\n      var _data$locus,\n          _data$locus$replaces,\n          _this2 = this;\n\n      var meeting = null; // getting meeting by correlationId. This will happen for the new event\n      // Either the locus\n      // TODO : Add check for the callBack Address\n\n      meeting = this.meetingCollection.getByKey(_constants.LOCUS_URL, data.locusUrl) || this.meetingCollection.getByKey(_constants.CORRELATION_ID, _util2.default.checkForCorrelationId(this.webex.internal.device.url, data.locus)) || this.meetingCollection.getByKey(_constants.SIP_URI, data.locus.self && data.locus.self.callbackInfo && data.locus.self.callbackInfo.callbackAddress) || this.meetingCollection.getByKey(_constants.CONVERSATION_URL, data.locus.conversationUrl); // Special case when locus has got replaced, This only happend once if a replace locus exists\n      // https://sqbu-github.cisco.com/WebExSquared/locus/wiki/Locus-changing-mid-call\n\n      if (!meeting && ((_data$locus = data.locus) === null || _data$locus === void 0 ? void 0 : (_data$locus$replaces = _data$locus.replaces) === null || _data$locus$replaces === void 0 ? void 0 : _data$locus$replaces.length) > 0) {\n        // Always the last element in the replace is the active one\n        meeting = this.meetingCollection.getByKey(_constants.LOCUS_URL, data.locus.replaces[data.locus.replaces.length - 1].locusUrl);\n      }\n\n      if (!meeting) {\n        // TODO: create meeting when we get a meeting object\n        // const checkForEnded = (locus) => {\n        // TODO: you already ended the meeting but you got an event later\n        // Mainly for 1:1 Callsor meeting\n        // Happens mainly after refresh\n        // 1:1 Meeting\n        // 1)  You ended a call before but you got a mercury event\n        // Make sure end the call and cleanup the meeting only if the mercury\n        // event says so\n        // 2) Maintain lastSync time in the meetings object which helps to compare\n        // If the meeting came befor or after the sync . ANy meeting start time before the sync time is invalid\n        // For space Meeting\n        // Check the locus object and see who has joined\n        // };\n        // rather then locus object change to locus url\n        if (data.locus && data.locus.fullState && data.locus.fullState.state === _constants.LOCUS.STATE.INACTIVE) {\n          // just ignore the event as its already ended and not active\n          _loggerProxy.default.logger.warn('Meetings:index#handleLocusEvent --> Locus event received for meeting, after it was ended.');\n\n          return;\n        } // When its wireless share or guest and user leaves the meeting we dont have to keep the meeting object\n        // Any future events will be neglected\n\n\n        if (data.locus && data.locus.self && data.locus.self.state === _constants._LEFT_ && data.locus.self.removed === true) {\n          // just ignore the event as its already ended and not active\n          _loggerProxy.default.logger.warn('Meetings:index#handleLocusEvent --> Locus event received for meeting, after it was ended.');\n\n          return;\n        }\n\n        this.create(data.locus, _constants._LOCUS_ID_).then(function (newMeeting) {\n          meeting = newMeeting;\n\n          if (data.eventType === _constants.LOCUSEVENT.DIFFERENCE) {\n            // its a delta object and we have a new meeting\n            meeting.locusInfo.initialSetup(data.locus, meeting);\n          } else {\n            // Its a new meeting and have a fresh locus object\n            meeting.locusInfo.initialSetup(data.locus);\n          }\n        }).catch(function (e) {\n          console.log(e);\n        }).finally(function () {\n          // There will be cases where locus event comes in gets created and deleted because its a 1:1 and meeting gets deleted\n          // because the other user left so before sending 'added' event make sure it exists in the collection\n          if (_this2.getMeetingByType(_constants._ID_, meeting.id)) {\n            _metrics.default.postEvent({\n              event: _config.eventType.REMOTE_STARTED,\n              meeting: meeting,\n              data: {\n                trigger: _config.trigger.MERCURY_EVENT\n              }\n            });\n\n            _triggerProxy.default.trigger(_this2, {\n              file: 'meetings',\n              function: 'handleLocusEvent'\n            }, _constants.EVENT_TRIGGERS.MEETING_ADDED, {\n              meeting: meeting,\n              type: meeting.type === _constants._MEETING_ ? _constants._JOIN_ : _constants._INCOMING_\n            });\n          } else {\n            // Meeting got added but was not found in the collection. It might have got destroyed\n            _loggerProxy.default.logger.warn('Meetings:index#handleLocusEvent --> Created and destroyed meeting object before sending an event');\n          }\n        });\n      } else {\n        meeting.locusInfo.parse(meeting, data);\n      }\n    }\n    /**\n     * handles locus events through mercury that are not roap\n     * @param {Object} envelope\n     * @param {Object} envelope.data\n     * @param {String} envelope.data.eventType\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n\n  }, {\n    key: \"handleLocusMercury\",\n    value: function handleLocusMercury(envelope) {\n      var data = envelope.data;\n      var eventType = data.eventType;\n\n      if (eventType && eventType !== _constants.LOCUSEVENT.MESSAGE_ROAP) {\n        this.handleLocusEvent(data);\n      }\n    }\n    /**\n     * handles mecury offline event\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n\n  }, {\n    key: \"handleMercuryOffline\",\n    value: function handleMercuryOffline() {\n      _triggerProxy.default.trigger(this, {\n        file: 'meetings/index',\n        function: 'handleMercuryOffline'\n      }, _constants.EVENT_TRIGGERS.MEETINGS_NETWORK_DISCONNECTED);\n    }\n    /**\n     * registers for locus and roap mercury events\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n\n  }, {\n    key: \"listenForEvents\",\n    value: function listenForEvents() {\n      var _this3 = this;\n\n      this.webex.internal.mercury.on(_constants.LOCUSEVENT.LOCUS_MERCURY, function (envelope) {\n        _this3.handleLocusMercury(envelope);\n      });\n      this.webex.internal.mercury.on(_constants.ROAP.ROAP_MERCURY, function (envelope) {\n        _util2.default.handleRoapMercury(envelope, _this3.meetingCollection);\n      });\n      this.webex.internal.mercury.on(_constants.ONLINE, function () {\n        _this3.syncMeetings();\n      });\n      this.webex.internal.mercury.on(_constants.OFFLINE, function () {\n        _this3.handleMercuryOffline();\n      });\n    }\n    /**\n     * stops listening for locus and roap mercury events\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n\n  }, {\n    key: \"stopListeningForEvents\",\n    value: function stopListeningForEvents() {\n      this.webex.internal.mercury.off(_constants.LOCUSEVENT.LOCUS_MERCURY);\n      this.webex.internal.mercury.off(_constants.ROAP.ROAP_MERCURY);\n      this.webex.internal.mercury.off(_constants.ONLINE);\n    }\n    /**\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n\n  }, {\n    key: \"onReady\",\n    value: function onReady() {\n      var _this4 = this;\n\n      this.webex.once(_constants.READY, function () {\n        _config2.default.set(_this4.config);\n\n        _loggerConfig.default.set(_this4.config.logging);\n        /**\n        * The MeetingInfo object to interact with server\n        * @instance\n        * @type {Object}\n        * @private\n        * @memberof Meetings\n        */\n\n\n        _this4.meetingInfo = _this4.config.experimental.enableUnifiedMeetings ? new _meetingInfoV.default(_this4.webex) : new _meetingInfo.default(_this4.webex);\n        _this4.personalMeetingRoom = new _personalMeetingRoom.default({\n          meetingInfo: _this4.meetingInfo\n        }, {\n          parent: _this4.webex\n        });\n\n        _triggerProxy.default.trigger(_this4, {\n          file: 'meetings',\n          function: 'onReady'\n        }, _constants.EVENT_TRIGGERS.MEETINGS_READY);\n      });\n    }\n    /**\n     * API to toggle unified meetings\n     * @param {Boolean} changeState\n     * @private\n     * @memberof Meetings\n     * @returns {undefined}\n    */\n\n  }, {\n    key: \"_toggleUnifiedMeetings\",\n    value: function _toggleUnifiedMeetings(changeState) {\n      var _this$config, _this$config$experime;\n\n      if (typeof changeState !== 'boolean') {\n        return;\n      }\n\n      if (((_this$config = this.config) === null || _this$config === void 0 ? void 0 : (_this$config$experime = _this$config.experimental) === null || _this$config$experime === void 0 ? void 0 : _this$config$experime.enableUnifiedMeetings) !== changeState) {\n        this.config.experimental.enableUnifiedMeetings = changeState;\n        this.meetingInfo = changeState ? new _meetingInfoV.default(this.webex) : new _meetingInfo.default(this.webex);\n      }\n    }\n    /**\n     * Explicitly sets up the meetings plugin by registering\n     * the device, connecting to mercury, and listening for locus events.\n     *\n     * @returns {Promise}\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: \"register\",\n    value: function register() {\n      var _this5 = this;\n\n      if (!this.webex.canAuthorize) {\n        _loggerProxy.default.logger.error('Meetings:index#register --> ERROR, Unable to register, SDK cannot authorize');\n\n        return _promise.default.reject(new Error('SDK cannot authorize'));\n      }\n\n      if (this.registered) {\n        _loggerProxy.default.logger.info('Meetings:index#register --> INFO, Meetings plugin already registered');\n\n        return _promise.default.resolve();\n      }\n\n      return _promise.default.all([this.getGeoHint(), this.startReachability().catch(function (error) {\n        _loggerProxy.default.logger.error(\"Meetings:index#register --> GDM error, \".concat(error.message));\n      }), this.webex.internal.device.register().then(function () {\n        return _loggerProxy.default.logger.info(\"Meetings:index#register --> INFO, Device registered \".concat(_this5.webex.internal.device.url));\n      }).then(function () {\n        return _this5.webex.internal.mercury.connect();\n      }), _util2.default.checkH264Support.call(this)]).then(function () {\n        _this5.listenForEvents();\n\n        _triggerProxy.default.trigger(_this5, {\n          file: 'meetings',\n          function: 'register'\n        }, _constants.EVENT_TRIGGERS.MEETINGS_REGISTERED);\n\n        _this5.registered = true;\n\n        _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.MEETINGS_REGISTRATION_SUCCESS);\n      }).catch(function (error) {\n        _loggerProxy.default.logger.error(\"Meetings:index#register --> ERROR, Unable to register, \".concat(error.message));\n\n        _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.MEETINGS_REGISTRATION_FAILED, {\n          reason: error.message,\n          stack: error.stack\n        });\n\n        return _promise.default.reject(error);\n      });\n    }\n    /**\n     * Explicitly tears down the meetings plugin by deregistering\n     * the device, disconnecting from mercury, and stops listening to locus events\n     *\n     * @returns {Promise}\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: \"unregister\",\n    value: function unregister() {\n      var _this6 = this;\n\n      if (!this.registered) {\n        _loggerProxy.default.logger.info('Meetings:index#unregister --> INFO, Meetings plugin already unregistered');\n\n        return _promise.default.resolve();\n      }\n\n      this.stopListeningForEvents();\n      return this.webex.internal.mercury.disconnect().then(function () {\n        return _this6.webex.internal.device.unregister();\n      }).then(function () {\n        _triggerProxy.default.trigger(_this6, {\n          file: 'meetings',\n          function: 'unregister'\n        }, _constants.EVENT_TRIGGERS.MEETINGS_UNREGISTERED);\n\n        _this6.registered = false;\n      });\n    }\n    /**\n     * Uploads logs to the webex services for tracking\n     * @param {Object} [options={}]\n     * @param {String} [options.callStart] Call Start Time\n     * @param {String} [options.feedbackId] ID used for tracking\n     * @param {String} [options.locusId]\n     * @param {String} [options.correlationId]\n     * @param {String} [options.meetingId] webex meeting ID\n     * @param {String} [options.userId] userId\n     * @param {String} [options.orgId] org id\n     * @returns {String} feedback ID logs were submitted under\n     */\n\n  }, {\n    key: \"uploadLogs\",\n    value: function uploadLogs() {\n      var _this7 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _loggerProxy.default.logger.info('Meetings:index#uploadLogs --> uploading logs');\n\n      return this.loggerRequest.uploadLogs(options).then(function (uploadResult) {\n        _loggerProxy.default.logger.info('Meetings:index#uploadLogs --> Upload logs for meeting completed.', uploadResult);\n\n        _triggerProxy.default.trigger(_this7, {\n          file: 'meetings',\n          function: 'uploadLogs'\n        }, _constants.EVENT_TRIGGERS.MEETING_LOG_UPLOAD_SUCCESS, {\n          meetingId: options.meetingId,\n          details: uploadResult\n        });\n      }).catch(function (uploadError) {\n        _loggerProxy.default.logger.error('Meetings:index#uploadLogs --> Unable to upload logs for meeting', uploadError);\n\n        _triggerProxy.default.trigger(_this7, {\n          file: 'meetings',\n          function: 'uploadLogs'\n        }, _constants.EVENT_TRIGGERS.MEETING_LOG_UPLOAD_FAILURE, {\n          meetingId: options.meetingId,\n          reason: uploadError\n        });\n\n        _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.UPLOAD_LOGS_FAILURE, {\n          meetingId: options.meetingsId,\n          reason: uploadError.message,\n          stack: uploadError.stack,\n          code: uploadError.code\n        });\n      });\n    }\n    /**\n     * initializes the reachability instance for Meetings\n     * @returns {undefined}\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: \"setReachability\",\n    value: function setReachability() {\n      this.reachability = new _reachability.default(this.webex);\n    }\n    /**\n     * gets the reachability instance for Meetings\n     * @returns {Reachability}\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: \"getReachability\",\n    value: function getReachability() {\n      return this.reachability;\n    }\n    /**\n     * initializes and starts gathering reachability for Meetings\n     * @returns {Promise}\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: \"startReachability\",\n    value: function startReachability() {\n      if (!this.reachability) {\n        this.setReachability();\n      }\n\n      return this.getReachability().gatherReachability();\n    }\n    /**\n     * Get geoHint for info for meetings\n     * @returns {Promise}\n     * @private\n     * @memberof Meetings\n     */\n\n  }, {\n    key: \"getGeoHint\",\n    value: function getGeoHint() {\n      var _this8 = this;\n\n      return this.request.fetchGeoHint().then(function (res) {\n        _this8.geoHintInfo = res;\n      });\n    }\n    /**\n     * gets the personal meeting room instance, for saved PMR values for this user\n     * @returns {PersonalMeetingRoom}\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: \"getPersonalMeetingRoom\",\n    value: function getPersonalMeetingRoom() {\n      return this.personalMeetingRoom;\n    }\n    /**\n     * @param {Meeting} meeting\n     * @param {Object} reason\n     * @param {String} type\n     * @returns {Undefined}\n     * @private\n     * @memberof Meetings\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy(meeting, reason) {\n      _util.default.cleanUp(meeting);\n\n      this.meetingCollection.delete(meeting.id);\n\n      _triggerProxy.default.trigger(this, {\n        file: 'meetings',\n        function: 'destroy'\n      }, _constants.EVENT_TRIGGERS.MEETING_REMOVED, {\n        meetingId: meeting.id,\n        reason: reason\n      });\n    }\n    /**\n     * Create a meeting.\n     * @param {string} destination - sipURL, spaceId, phonenumber, or locus object}\n     * @param {string} [type] - the optional specified type, such as locusId\n     * @returns {Promise<Meeting>} A new Meeting.\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: \"create\",\n    value: function create(destination) {\n      var _this9 = this;\n\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null; // TODO: type should be from a dictionary\n      // Validate meeting information based on the provided destination and\n      // type. This must be performed prior to determining if the meeting is\n      // found in the collection, as we mutate the destination for hydra person\n      // id values.\n\n      return this.meetingInfo.fetchInfoOptions(destination, type) // Catch a failure to fetch info options.\n      .catch(function (error) {\n        _loggerProxy.default.logger.info(\"Meetings:index#create --> INFO, unable to determine info options: \".concat(error.message));\n      }).then(function () {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // Normalize the destination.\n\n        var targetDest = options.destination || destination; // check for the conversation URL then sip Url\n\n        var meeting = null;\n\n        if (type === _constants._CONVERSATION_URL_ || options.type === _constants._CONVERSATION_URL_) {\n          meeting = _this9.meetingCollection.getByKey(_constants.CONVERSATION_URL, targetDest);\n        } // Attempt to collect the meeting if it exists.\n\n\n        if (!meeting) {\n          meeting = _this9.meetingCollection.getByKey(_constants.SIP_URI, targetDest);\n        } // Validate if a meeting was found.\n\n\n        if (!meeting) {\n          // Create a meeting based on the normalized destination and type.\n          return _this9.createMeeting(targetDest, type).then(function (createdMeeting) {\n            // If the meeting was successfully created.\n            if (createdMeeting && createdMeeting.on) {\n              // Create a destruction event for the meeting.\n              createdMeeting.on(_constants.EVENTS.DESTROY_MEETING, function (payload) {\n                if (_this9.config.autoUploadLogs) {\n                  var _createdMeeting$locus, _createdMeeting$locus2, _createdMeeting$locus3, _createdMeeting$locus4;\n\n                  _this9.uploadLogs({\n                    callStart: (_createdMeeting$locus = createdMeeting.locusInfo) === null || _createdMeeting$locus === void 0 ? void 0 : (_createdMeeting$locus2 = _createdMeeting$locus.fullState) === null || _createdMeeting$locus2 === void 0 ? void 0 : _createdMeeting$locus2.lastActive,\n                    correlationId: createdMeeting.correlationId,\n                    feedbackId: createdMeeting.correlationId,\n                    locusId: createdMeeting.locusId,\n                    meetingId: (_createdMeeting$locus3 = createdMeeting.locusInfo) === null || _createdMeeting$locus3 === void 0 ? void 0 : (_createdMeeting$locus4 = _createdMeeting$locus3.info) === null || _createdMeeting$locus4 === void 0 ? void 0 : _createdMeeting$locus4.webExMeetingId\n                  }).then(function () {\n                    return _this9.destroy(createdMeeting, payload.reason);\n                  });\n                } else {\n                  _this9.destroy(createdMeeting, payload.reason);\n                }\n              });\n              createdMeeting.on(_constants.EVENTS.REQUEST_UPLOAD_LOGS, function (meetingInstance) {\n                if (_this9.config.autoUploadLogs) {\n                  var _meetingInstance$locu, _meetingInstance$locu2, _meetingInstance$locu3, _meetingInstance$locu4;\n\n                  _this9.uploadLogs({\n                    callStart: meetingInstance === null || meetingInstance === void 0 ? void 0 : (_meetingInstance$locu = meetingInstance.locusInfo) === null || _meetingInstance$locu === void 0 ? void 0 : (_meetingInstance$locu2 = _meetingInstance$locu.fullState) === null || _meetingInstance$locu2 === void 0 ? void 0 : _meetingInstance$locu2.lastActive,\n                    correlationId: meetingInstance.correlationId,\n                    feedbackId: meetingInstance.correlationId,\n                    locusId: meetingInstance.locusId,\n                    meetingId: (_meetingInstance$locu3 = meetingInstance.locusInfo) === null || _meetingInstance$locu3 === void 0 ? void 0 : (_meetingInstance$locu4 = _meetingInstance$locu3.info) === null || _meetingInstance$locu4 === void 0 ? void 0 : _meetingInstance$locu4.webExMeetingId\n                  });\n                }\n              });\n            } else {\n              _loggerProxy.default.logger.error(\"Meetings:index#create --> ERROR, meeting does not have on method, will not be destroyed, meeting cleanup impossible for meeting: \".concat(meeting));\n            } // Return the newly created meeting.\n\n\n            return _promise.default.resolve(createdMeeting);\n          });\n        } // Return the existing meeting.\n\n\n        return _promise.default.resolve(meeting);\n      });\n    }\n    /**\n     * @param {String} destination see create()\n     * @param {String} type see create()\n     * @returns {Promise} a new meeting instance complete with meeting info and destination\n     * @private\n     * @memberof Meetings\n     */\n\n  }, {\n    key: \"createMeeting\",\n    value: function () {\n      var _createMeeting = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(destination) {\n        var type,\n            meeting,\n            meetingAddedType,\n            _args = arguments;\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                type = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;\n                meeting = new _meeting.default({\n                  userId: this.webex.internal.device.userId,\n                  deviceUrl: this.webex.internal.device.url,\n                  orgId: this.webex.internal.device.orgId,\n                  roapSeq: 0,\n                  locus: type === _constants._LOCUS_ID_ ? destination : null,\n                  // pass the locus object if present\n                  meetingInfoProvider: this.meetingInfo\n                }, {\n                  parent: this.webex\n                });\n                this.meetingCollection.set(meeting);\n                _context.prev = 3;\n                _context.next = 6;\n                return meeting.fetchMeetingInfo({\n                  destination: destination,\n                  type: type\n                });\n\n              case 6:\n                _context.next = 13;\n                break;\n\n              case 8:\n                _context.prev = 8;\n                _context.t0 = _context[\"catch\"](3);\n\n                if (!(_context.t0 instanceof _captchaError.default) && !(_context.t0 instanceof _passwordError.default)) {\n                  // if there is no meeting info we assume its a 1:1 call or wireless share\n                  _loggerProxy.default.logger.info(\"Meetings:index#createMeeting --> Info Unable to fetch meeting info for \".concat(destination, \".\"));\n\n                  _loggerProxy.default.logger.info('Meetings:index#createMeeting --> Info assuming this destination is a 1:1 or wireless share');\n                }\n\n                _loggerProxy.default.logger.debug(\"Meetings:index#createMeeting --> Debug \".concat(_context.t0, \" fetching /meetingInfo for creation.\")); // We need to save this info for future reference\n\n\n                meeting.destination = destination;\n\n              case 13:\n                _context.prev = 13; // For type LOCUS_ID we need to parse the locus object to get the information\n                // about the caller and callee\n                // Meeting Added event will be created in `handleLocusEvent`\n\n                if (type !== _constants._LOCUS_ID_) {\n                  if (!meeting.sipUri) {\n                    meeting.setSipUri(destination);\n                  } // TODO: check if we have to move this to parser\n\n\n                  meetingAddedType = _util2.default.getMeetingAddedType(type); // We typically shouldn't need to trigger both and event and return a promise.\n                  // Is this a special case? We want to make the public API usage as simple as possible.\n\n                  _triggerProxy.default.trigger(this, {\n                    file: 'meetings',\n                    function: 'createMeeting'\n                  }, _constants.EVENT_TRIGGERS.MEETING_ADDED, {\n                    meeting: meeting,\n                    type: meetingAddedType\n                  });\n                }\n\n                return _context.finish(13);\n\n              case 16:\n                return _context.abrupt(\"return\", meeting);\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[3, 8, 13, 16]]);\n      }));\n\n      function createMeeting(_x) {\n        return _createMeeting.apply(this, arguments);\n      }\n\n      return createMeeting;\n    }()\n    /**\n     * get a specifc meeting given it's type matched to the value, i.e., locus url\n     * @param {String} type\n     * @param {Object} value\n     * @returns {Meeting}\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: \"getMeetingByType\",\n    value: function getMeetingByType(type, value) {\n      return this.meetingCollection.getByKey(type, value);\n    }\n    /**\n     * Get all meetings.\n     * @param {object} options\n     * @param {object} options.startDate - get meetings after this start date\n     * @param {object} options.endDate - get meetings before this end date\n     * @returns {Object} All currently active meetings.\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: \"getAllMeetings\",\n    value: function getAllMeetings() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // Options may include other parameters to filter this collection\n      // of meetings.\n\n      return this.meetingCollection.getAll(options);\n    }\n    /**\n     * syncs all the meeting from server\n     * @returns {undefined}\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: \"syncMeetings\",\n    value: function syncMeetings() {\n      var _this10 = this;\n\n      return this.request.getActiveMeetings().then(function (locusArray) {\n        var activeLocusUrl = [];\n\n        if (locusArray !== null && locusArray !== void 0 && locusArray.loci && locusArray.loci.length > 0) {\n          locusArray.loci.forEach(function (locus) {\n            activeLocusUrl.push(locus.url);\n\n            _this10.handleLocusEvent({\n              locus: locus,\n              locusUrl: locus.url\n            });\n          });\n        }\n\n        var meetingsCollection = _this10.meetingCollection.getAll();\n\n        if ((0, _keys.default)(meetingsCollection).length > 0) {\n          // Some time the mercury event is missed after mercury reconnect\n          // if sync returns no locus then clear all the meetings\n          for (var _i = 0, _Object$values = (0, _values.default)(meetingsCollection); _i < _Object$values.length; _i++) {\n            var meeting = _Object$values[_i];\n\n            if (!activeLocusUrl.includes(meeting.locusUrl)) {\n              // destroy function also uploads logs\n              _this10.destroy(meeting, _constants.MEETING_REMOVED_REASON.NO_MEETINGS_TO_SYNC);\n            }\n          }\n        }\n      });\n    }\n    /**\n     * Get all scheduled meetings.\n     * @param {object} options\n     * @param {object} options.startDate - get meetings after this start date\n     * @param {object} options.endDate - get meetings before this end date\n     * @returns {Object} All scheduled meetings.\n     * @memberof Meetings\n     */\n\n  }, {\n    key: \"getScheduledMeetings\",\n    value: function getScheduledMeetings() {\n      return this.meetingCollection.getAll({\n        scheduled: true\n      });\n    }\n    /**\n     * Get the logger instance for plugin-meetings\n     * @returns {Logger}\n     */\n\n  }, {\n    key: \"getLogger\",\n    value: function getLogger() {\n      return _loggerProxy.default.get();\n    }\n    /**\n     * Get the Stats Analyzer singleton\n     * @returns {StatsAnalyzer}\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: \"getAnalyzer\",\n    value: function getAnalyzer() {\n      return _analyzer.default;\n    }\n    /**\n     * Get the Stats Calculator singleton\n     * @returns {StatsCalculator}\n     * @public\n     * @memberof Meetings\n     */\n\n  }, {\n    key: \"getCalculator\",\n    value: function getCalculator() {\n      return _calculator.default;\n    }\n  }]);\n  return Meetings;\n}(_webexCore.WebexPlugin);\n\nexports.default = Meetings;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIAA;;AACA;;AAEAA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAwBA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;IACqBC,Q;;;;AAGjB;AACJ;AACA;AACA;AACA;AACA;;;AACI,sBAAqB;AAAA;;AAAA;;AAAA,sCAANC,IAAM;AAANA,UAAM,MAANA,GAAMC,eAAND;AAAM;;AACnBE,oDAASF,IAAT;AAEA;AACN;AACA;AACA;AACA;AACA;AACA;;AATyB,4FARTG,mBAQS;AAUnBD,UAAKE,OAAL,GAAe,IAAIC,iBAAJ,CAAY,EAAZ,EAAgB;AAACC,YAAM,EAAEJ,MAAKK;AAAd,KAAhB,CAAf;AACA;AACN;AACA;AACA;AACA;AACA;AACA;;AACML,UAAKM,aAAL,GAAqB,IAAIC,gBAAJ,CAAkB;AAACF,WAAK,EAAEL,MAAKK;AAAb,KAAlB,CAArB;AACAL,UAAKQ,iBAAL,GAAyB,IAAIC,mBAAJ,EAAzB;AACA;AACN;AACA;AACA;AACA;AACA;AACA;;AACMT,UAAKU,mBAAL,GAA2B,IAA3B;AACA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AACMV,UAAKW,YAAL,GAAoB,IAApB;AAEA;AACN;AACA;AACA;AACA;AACA;AACA;;AACMX,UAAKY,UAAL,GAAkB,KAAlB;AAEA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AACMZ,UAAKa,KAAL,GAAa;AACXC,kBAAY,EAAEC,eAAMD,YADT;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","names":["require","Meetings","args","arguments","_this","MEETINGS","request","Request","parent","webex","loggerRequest","LoggerRequest","meetingCollection","MeetingCollection","personalMeetingRoom","reachability","registered","media","getUserMedia","Media","getSupportedDevice","LoggerProxy","set","logger","onReady","MeetingsUtil","checkH264Support","disableNotifications","Metrics","initialSetup","data","meeting","getByKey","LOCUS_URL","locusUrl","CORRELATION_ID","checkForCorrelationId","internal","device","url","locus","SIP_URI","self","callbackInfo","callbackAddress","CONVERSATION_URL","conversationUrl","replaces","length","fullState","state","LOCUS","STATE","INACTIVE","warn","_LEFT_","removed","create","_LOCUS_ID_","then","newMeeting","eventType","LOCUSEVENT","DIFFERENCE","locusInfo","catch","e","console","log","finally","_this2","getMeetingByType","_ID_","id","postEvent","event","REMOTE_STARTED","trigger","MERCURY_EVENT","Trigger","file","function","EVENT_TRIGGERS","MEETING_ADDED","type","_MEETING_","_JOIN_","_INCOMING_","parse","envelope","MESSAGE_ROAP","handleLocusEvent","MEETINGS_NETWORK_DISCONNECTED","mercury","on","LOCUS_MERCURY","_this3","handleLocusMercury","ROAP","ROAP_MERCURY","handleRoapMercury","ONLINE","syncMeetings","OFFLINE","handleMercuryOffline","off","once","READY","StaticConfig","_this4","config","LoggerConfig","logging","meetingInfo","experimental","enableUnifiedMeetings","MeetingInfoV2","MeetingInfo","PersonalMeetingRoom","MEETINGS_READY","changeState","canAuthorize","error","_promise","reject","Error","info","resolve","all","getGeoHint","startReachability","message","register","_this5","connect","call","listenForEvents","MEETINGS_REGISTERED","sendBehavioralMetric","BEHAVIORAL_METRICS","MEETINGS_REGISTRATION_SUCCESS","MEETINGS_REGISTRATION_FAILED","reason","stack","stopListeningForEvents","disconnect","_this6","unregister","MEETINGS_UNREGISTERED","options","uploadLogs","uploadResult","_this7","MEETING_LOG_UPLOAD_SUCCESS","meetingId","details","uploadError","MEETING_LOG_UPLOAD_FAILURE","UPLOAD_LOGS_FAILURE","meetingsId","code","Reachability","setReachability","getReachability","gatherReachability","fetchGeoHint","res","_this8","geoHintInfo","MeetingUtil","cleanUp","delete","MEETING_REMOVED","destination","fetchInfoOptions","targetDest","_CONVERSATION_URL_","_this9","createMeeting","createdMeeting","EVENTS","DESTROY_MEETING","payload","autoUploadLogs","callStart","_createdMeeting$locus","_createdMeeting$locus2","lastActive","correlationId","feedbackId","locusId","_createdMeeting$locus3","_createdMeeting$locus4","webExMeetingId","destroy","REQUEST_UPLOAD_LOGS","meetingInstance","_meetingInstance$locu","_meetingInstance$locu2","_meetingInstance$locu3","_meetingInstance$locu4","Meeting","userId","deviceUrl","orgId","roapSeq","meetingInfoProvider","_context","fetchMeetingInfo","CaptchaError","PasswordError","debug","sipUri","setSipUri","meetingAddedType","getMeetingAddedType","value","getAll","getActiveMeetings","locusArray","activeLocusUrl","loci","forEach","push","_this10","meetingsCollection","includes","MEETING_REMOVED_REASON","NO_MEETINGS_TO_SYNC","scheduled","get","StatsAnalyzer","StatsCalculator","WebexPlugin"],"sources":["index.js"],"sourcesContent":["/*!\n  * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n*/\n\nimport '@webex/internal-plugin-mercury';\nimport {WebexPlugin} from '@webex/webex-core';\n\nimport 'webrtc-adapter';\n\nimport Metrics from '../metrics';\nimport {trigger, eventType} from '../metrics/config';\nimport LoggerConfig from '../common/logs/logger-config';\nimport StaticConfig from '../common/config';\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport LoggerRequest from '../common/logs/request';\nimport Trigger from '../common/events/trigger-proxy';\nimport Media from '../media';\nimport MeetingUtil from '../meeting/util';\nimport {\n  MEETINGS,\n  EVENTS,\n  EVENT_TRIGGERS,\n  READY,\n  LOCUSEVENT,\n  LOCUS_URL,\n  ROAP,\n  ONLINE,\n  OFFLINE,\n  _MEETING_,\n  _JOIN_,\n  _LOCUS_ID_,\n  _INCOMING_,\n  LOCUS,\n  CORRELATION_ID,\n  SIP_URI,\n  _LEFT_,\n  _ID_,\n  MEETING_REMOVED_REASON,\n  _CONVERSATION_URL_,\n  CONVERSATION_URL,\n  BEHAVIORAL_METRICS\n} from '../constants';\nimport MeetingInfo from '../meeting-info';\nimport MeetingInfoV2 from '../meeting-info/meeting-info-v2';\nimport Meeting from '../meeting';\nimport PersonalMeetingRoom from '../personal-meeting-room';\nimport Reachability from '../reachability';\nimport Request from '../meetings/request';\nimport StatsAnalyzer from '../analyzer/analyzer';\nimport StatsCalculator from '../analyzer/calculator';\nimport PasswordError from '../common/errors/password-error';\nimport CaptchaError from '../common/errors/captcha-error';\n\nimport MeetingCollection from './collection';\nimport MeetingsUtil from './util';\n\n\n/**\n   * Meetings Ready Event\n   * Emitted when the meetings instance on webex is ready\n   * @event meetings:ready\n   * @instance\n   * @memberof Meetings\n   */\n\n/**\n   * Meetings Network Disconnected Event\n   * Emitted when the meetings instance is disconnected from\n   * the internal mercury server\n   * @event network:disconnected\n   * @instance\n   * @memberof Meetings\n   */\n\n/**\n * Meetings Registered Event\n * Emitted when the meetings instance has been registered and listening\n * @event meetings:registered\n * @instance\n * @memberof Meetings\n */\n\n/**\n    * Meeting Removed Event\n    * Emitted when a meeting was removed from the cache of meetings\n    * @event meeting:removed\n    * @instance\n    * @type {Object}\n    * @property {String} meetingId the removed meeting\n    * @property {Object} response the server response\n    * @property {String} type what type of meeting it was\n    * @memberof Meetings\n    */\n\n/**\n    * Meeting Added Event\n    * Emitted when a meeting was added to the cache of meetings\n    * @event meeting:added\n    * @instance\n    * @type {Object}\n    * @property {String} meetingId the added meeting\n    * @property {String} type what type of meeting it was\n    * @memberof Meetings\n    */\n\n/**\n   * Maintain a cache of meetings and sync with services.\n   * @class\n   */\nexport default class Meetings extends WebexPlugin {\n    namespace = MEETINGS;\n\n    /**\n     * Initializes the Meetings Plugin\n     * @constructor\n     * @public\n     * @memberof Meetings\n     */\n    constructor(...args) {\n      super(...args);\n\n      /**\n       * The Meetings request to interact with server\n       * @instance\n       * @type {Object}\n       * @private\n       * @memberof Meetings\n       */\n      this.request = new Request({}, {parent: this.webex});\n      /**\n       * Log upload request helper\n       * @instance\n       * @type {Object}\n       * @private\n       * @memberof Meetings\n       */\n      this.loggerRequest = new LoggerRequest({webex: this.webex});\n      this.meetingCollection = new MeetingCollection();\n      /**\n       * The PersonalMeetingRoom object to interact with server\n       * @instance\n       * @type {Object}\n       * @public\n       * @memberof Meetings\n       */\n      this.personalMeetingRoom = null;\n      /**\n       * The Reachability object to interact with server, starts as null until {@link Meeting#setReachability} is called\n       * starts as null\n       * @instance\n       * @type {Object}\n       * @private\n       * @memberof Meetings\n       */\n      this.reachability = null;\n\n      /**\n       * If the meetings plugin has been registered and listening via {@link Meetings#register}\n       * @instance\n       * @type {Boolean}\n       * @public\n       * @memberof Meetings\n       */\n      this.registered = false;\n\n      /**\n       * The public interface for the internal Media util files. These are helpful to expose outside the context\n       * of a meeting so that a user can access media without creating a meeting instance.\n       * @instance\n       * @type {Object}\n       * @private\n       * @memberof Meetings\n       */\n      this.media = {\n        getUserMedia: Media.getUserMedia,\n        getSupportedDevice: Media.getSupportedDevice\n      };\n\n      LoggerProxy.set(this.webex.logger);\n\n      this.onReady();\n      MeetingsUtil.checkH264Support({disableNotifications: true});\n      Metrics.initialSetup(this.meetingCollection, this.webex);\n    }\n\n    /**\n     * handle locus events and takes meeting actions with them as they come in\n     * @param {Object} data a locus event\n     * @param {String} data.locusUrl\n     * @param {Object} data.locus\n     * @param {String} data.eventType\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n    handleLocusEvent(data) {\n      let meeting = null;\n\n      // getting meeting by correlationId. This will happen for the new event\n      // Either the locus\n      // TODO : Add check for the callBack Address\n      meeting = this.meetingCollection.getByKey(LOCUS_URL, data.locusUrl) ||\n      this.meetingCollection.getByKey(CORRELATION_ID, MeetingsUtil.checkForCorrelationId(this.webex.internal.device.url, data.locus)) ||\n      this.meetingCollection.getByKey(SIP_URI, data.locus.self && data.locus.self.callbackInfo && data.locus.self.callbackInfo.callbackAddress) ||\n      this.meetingCollection.getByKey(CONVERSATION_URL, data.locus.conversationUrl);\n\n      // Special case when locus has got replaced, This only happend once if a replace locus exists\n      // https://sqbu-github.cisco.com/WebExSquared/locus/wiki/Locus-changing-mid-call\n\n      if (!meeting && data.locus?.replaces?.length > 0) {\n        // Always the last element in the replace is the active one\n        meeting = this.meetingCollection.getByKey(LOCUS_URL, data.locus.replaces[data.locus.replaces.length - 1].locusUrl);\n      }\n\n      if (!meeting) {\n        // TODO: create meeting when we get a meeting object\n        // const checkForEnded = (locus) => {\n        // TODO: you already ended the meeting but you got an event later\n        // Mainly for 1:1 Callsor meeting\n        // Happens mainly after refresh\n\n        // 1:1 Meeting\n        // 1)  You ended a call before but you got a mercury event\n        // Make sure end the call and cleanup the meeting only if the mercury\n        // event says so\n        // 2) Maintain lastSync time in the meetings object which helps to compare\n        // If the meeting came befor or after the sync . ANy meeting start time before the sync time is invalid\n\n        // For space Meeting\n        // Check the locus object and see who has joined\n\n        // };\n        // rather then locus object change to locus url\n\n        if (data.locus && data.locus.fullState && data.locus.fullState.state === LOCUS.STATE.INACTIVE) {\n          // just ignore the event as its already ended and not active\n          LoggerProxy.logger.warn('Meetings:index#handleLocusEvent --> Locus event received for meeting, after it was ended.');\n\n          return;\n        }\n\n\n        // When its wireless share or guest and user leaves the meeting we dont have to keep the meeting object\n        // Any future events will be neglected\n\n        if (data.locus && data.locus.self && (data.locus.self.state === _LEFT_ && data.locus.self.removed === true)) {\n          // just ignore the event as its already ended and not active\n          LoggerProxy.logger.warn('Meetings:index#handleLocusEvent --> Locus event received for meeting, after it was ended.');\n\n          return;\n        }\n\n        this.create(data.locus, _LOCUS_ID_).then((newMeeting) => {\n          meeting = newMeeting;\n\n          if (data.eventType === LOCUSEVENT.DIFFERENCE) {\n            // its a delta object and we have a new meeting\n            meeting.locusInfo.initialSetup(data.locus, meeting);\n          }\n          else {\n            // Its a new meeting and have a fresh locus object\n            meeting.locusInfo.initialSetup(data.locus);\n          }\n        }).catch((e) => {\n          console.log(e);\n        })\n          .finally(() => {\n            // There will be cases where locus event comes in gets created and deleted because its a 1:1 and meeting gets deleted\n            // because the other user left so before sending 'added' event make sure it exists in the collection\n\n            if (this.getMeetingByType(_ID_, meeting.id)) {\n              Metrics.postEvent({event: eventType.REMOTE_STARTED, meeting, data: {trigger: trigger.MERCURY_EVENT}});\n              Trigger.trigger(\n                this,\n                {\n                  file: 'meetings',\n                  function: 'handleLocusEvent'\n                },\n                EVENT_TRIGGERS.MEETING_ADDED,\n                {\n                  meeting,\n                  type: meeting.type === _MEETING_ ? _JOIN_ : _INCOMING_\n                }\n              );\n            }\n            else {\n              // Meeting got added but was not found in the collection. It might have got destroyed\n              LoggerProxy.logger.warn('Meetings:index#handleLocusEvent --> Created and destroyed meeting object before sending an event');\n            }\n          });\n      }\n      else {\n        meeting.locusInfo.parse(meeting, data);\n      }\n    }\n\n    /**\n     * handles locus events through mercury that are not roap\n     * @param {Object} envelope\n     * @param {Object} envelope.data\n     * @param {String} envelope.data.eventType\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n    handleLocusMercury(envelope) {\n      const {data} = envelope;\n      const {eventType} = data;\n\n      if (eventType && eventType !== LOCUSEVENT.MESSAGE_ROAP) {\n        this.handleLocusEvent(data);\n      }\n    }\n\n\n    /**\n     * handles mecury offline event\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n    handleMercuryOffline() {\n      Trigger.trigger(\n        this,\n        {\n          file: 'meetings/index',\n          function: 'handleMercuryOffline'\n        },\n        EVENT_TRIGGERS.MEETINGS_NETWORK_DISCONNECTED,\n      );\n    }\n\n\n    /**\n     * registers for locus and roap mercury events\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n    listenForEvents() {\n      this.webex.internal.mercury.on(LOCUSEVENT.LOCUS_MERCURY, (envelope) => {\n        this.handleLocusMercury(envelope);\n      });\n      this.webex.internal.mercury.on(ROAP.ROAP_MERCURY, (envelope) => {\n        MeetingsUtil.handleRoapMercury(envelope, this.meetingCollection);\n      });\n\n      this.webex.internal.mercury.on(ONLINE, () => {\n        this.syncMeetings();\n      });\n\n      this.webex.internal.mercury.on(OFFLINE, () => {\n        this.handleMercuryOffline();\n      });\n    }\n\n    /**\n     * stops listening for locus and roap mercury events\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n    stopListeningForEvents() {\n      this.webex.internal.mercury.off(LOCUSEVENT.LOCUS_MERCURY);\n      this.webex.internal.mercury.off(ROAP.ROAP_MERCURY);\n      this.webex.internal.mercury.off(ONLINE);\n    }\n\n    /**\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n    onReady() {\n      this.webex.once(READY, () => {\n        StaticConfig.set(this.config);\n        LoggerConfig.set(this.config.logging);\n\n        /**\n       * The MeetingInfo object to interact with server\n       * @instance\n       * @type {Object}\n       * @private\n       * @memberof Meetings\n       */\n        this.meetingInfo = this.config.experimental.enableUnifiedMeetings ? new MeetingInfoV2(this.webex) : new MeetingInfo(this.webex);\n        this.personalMeetingRoom = new PersonalMeetingRoom({meetingInfo: this.meetingInfo}, {parent: this.webex});\n\n        Trigger.trigger(\n          this,\n          {\n            file: 'meetings',\n            function: 'onReady'\n          },\n          EVENT_TRIGGERS.MEETINGS_READY\n        );\n      });\n    }\n\n    /**\n     * API to toggle unified meetings\n     * @param {Boolean} changeState\n     * @private\n     * @memberof Meetings\n     * @returns {undefined}\n    */\n    _toggleUnifiedMeetings(changeState) {\n      if (typeof changeState !== 'boolean') {\n        return;\n      }\n      if (this.config?.experimental?.enableUnifiedMeetings !== changeState) {\n        this.config.experimental.enableUnifiedMeetings = changeState;\n        this.meetingInfo = changeState ? new MeetingInfoV2(this.webex) : new MeetingInfo(this.webex);\n      }\n    }\n\n    /**\n     * Explicitly sets up the meetings plugin by registering\n     * the device, connecting to mercury, and listening for locus events.\n     *\n     * @returns {Promise}\n     * @public\n     * @memberof Meetings\n     */\n    register() {\n      if (!this.webex.canAuthorize) {\n        LoggerProxy.logger.error('Meetings:index#register --> ERROR, Unable to register, SDK cannot authorize');\n\n        return Promise.reject(new Error('SDK cannot authorize'));\n      }\n\n\n      if (this.registered) {\n        LoggerProxy.logger.info('Meetings:index#register --> INFO, Meetings plugin already registered');\n\n        return Promise.resolve();\n      }\n\n      return Promise.all([\n        this.getGeoHint(),\n        this.startReachability().catch((error) => {\n          LoggerProxy.logger.error(`Meetings:index#register --> GDM error, ${error.message}`);\n        }),\n        this.webex.internal.device.register()\n          .then(() => LoggerProxy.logger.info(`Meetings:index#register --> INFO, Device registered ${this.webex.internal.device.url}`))\n          .then(() => this.webex.internal.mercury.connect()),\n        MeetingsUtil.checkH264Support.call(this)\n      ]).then(() => {\n        this.listenForEvents();\n        Trigger.trigger(\n          this,\n          {\n            file: 'meetings',\n            function: 'register'\n          },\n          EVENT_TRIGGERS.MEETINGS_REGISTERED\n        );\n        this.registered = true;\n        Metrics.sendBehavioralMetric(\n          BEHAVIORAL_METRICS.MEETINGS_REGISTRATION_SUCCESS,\n        );\n      })\n        .catch((error) => {\n          LoggerProxy.logger.error(`Meetings:index#register --> ERROR, Unable to register, ${error.message}`);\n\n          Metrics.sendBehavioralMetric(\n            BEHAVIORAL_METRICS.MEETINGS_REGISTRATION_FAILED,\n            {\n              reason: error.message,\n              stack: error.stack\n            }\n          );\n\n          return Promise.reject(error);\n        });\n    }\n\n    /**\n     * Explicitly tears down the meetings plugin by deregistering\n     * the device, disconnecting from mercury, and stops listening to locus events\n     *\n     * @returns {Promise}\n     * @public\n     * @memberof Meetings\n     */\n    unregister() {\n      if (!this.registered) {\n        LoggerProxy.logger.info('Meetings:index#unregister --> INFO, Meetings plugin already unregistered');\n\n        return Promise.resolve();\n      }\n\n      this.stopListeningForEvents();\n\n      return this.webex.internal.mercury.disconnect()\n        .then(() => this.webex.internal.device.unregister())\n        .then(() => {\n          Trigger.trigger(\n            this,\n            {\n              file: 'meetings',\n              function: 'unregister'\n            },\n            EVENT_TRIGGERS.MEETINGS_UNREGISTERED\n          );\n          this.registered = false;\n        });\n    }\n\n    /**\n     * Uploads logs to the webex services for tracking\n     * @param {Object} [options={}]\n     * @param {String} [options.callStart] Call Start Time\n     * @param {String} [options.feedbackId] ID used for tracking\n     * @param {String} [options.locusId]\n     * @param {String} [options.correlationId]\n     * @param {String} [options.meetingId] webex meeting ID\n     * @param {String} [options.userId] userId\n     * @param {String} [options.orgId] org id\n     * @returns {String} feedback ID logs were submitted under\n     */\n    uploadLogs(options = {}) {\n      LoggerProxy.logger.info('Meetings:index#uploadLogs --> uploading logs');\n\n      return this.loggerRequest.uploadLogs(options)\n        .then((uploadResult) => {\n          LoggerProxy.logger.info('Meetings:index#uploadLogs --> Upload logs for meeting completed.', uploadResult);\n          Trigger.trigger(\n            this,\n            {\n              file: 'meetings',\n              function: 'uploadLogs'\n            },\n            EVENT_TRIGGERS.MEETING_LOG_UPLOAD_SUCCESS,\n            {\n              meetingId: options.meetingId,\n              details: uploadResult\n            }\n          );\n        })\n        .catch((uploadError) => {\n          LoggerProxy.logger.error('Meetings:index#uploadLogs --> Unable to upload logs for meeting', uploadError);\n          Trigger.trigger(\n            this,\n            {\n              file: 'meetings',\n              function: 'uploadLogs'\n            },\n            EVENT_TRIGGERS.MEETING_LOG_UPLOAD_FAILURE,\n            {\n              meetingId: options.meetingId,\n              reason: uploadError\n            }\n          );\n\n          Metrics.sendBehavioralMetric(\n            BEHAVIORAL_METRICS.UPLOAD_LOGS_FAILURE,\n            {\n              meetingId: options.meetingsId,\n              reason: uploadError.message,\n              stack: uploadError.stack,\n              code: uploadError.code\n            }\n          );\n        });\n    }\n\n    /**\n     * initializes the reachability instance for Meetings\n     * @returns {undefined}\n     * @public\n     * @memberof Meetings\n     */\n    setReachability() {\n      this.reachability = new Reachability(this.webex);\n    }\n\n    /**\n     * gets the reachability instance for Meetings\n     * @returns {Reachability}\n     * @public\n     * @memberof Meetings\n     */\n    getReachability() {\n      return this.reachability;\n    }\n\n    /**\n     * initializes and starts gathering reachability for Meetings\n     * @returns {Promise}\n     * @public\n     * @memberof Meetings\n     */\n    startReachability() {\n      if (!this.reachability) {\n        this.setReachability();\n      }\n\n      return this.getReachability().gatherReachability();\n    }\n\n    /**\n     * Get geoHint for info for meetings\n     * @returns {Promise}\n     * @private\n     * @memberof Meetings\n     */\n    getGeoHint() {\n      return this.request.fetchGeoHint().then((res) => {\n        this.geoHintInfo = res;\n      });\n    }\n\n    /**\n     * gets the personal meeting room instance, for saved PMR values for this user\n     * @returns {PersonalMeetingRoom}\n     * @public\n     * @memberof Meetings\n     */\n    getPersonalMeetingRoom() {\n      return this.personalMeetingRoom;\n    }\n\n    /**\n     * @param {Meeting} meeting\n     * @param {Object} reason\n     * @param {String} type\n     * @returns {Undefined}\n     * @private\n     * @memberof Meetings\n     */\n    destroy(meeting, reason) {\n      MeetingUtil.cleanUp(meeting);\n      this.meetingCollection.delete(meeting.id);\n      Trigger.trigger(\n        this,\n        {\n          file: 'meetings',\n          function: 'destroy'\n        },\n        EVENT_TRIGGERS.MEETING_REMOVED,\n        {\n          meetingId: meeting.id,\n          reason\n        }\n      );\n    }\n\n    /**\n     * Create a meeting.\n     * @param {string} destination - sipURL, spaceId, phonenumber, or locus object}\n     * @param {string} [type] - the optional specified type, such as locusId\n     * @returns {Promise<Meeting>} A new Meeting.\n     * @public\n     * @memberof Meetings\n     */\n    create(destination, type = null) {\n      // TODO: type should be from a dictionary\n\n      // Validate meeting information based on the provided destination and\n      // type. This must be performed prior to determining if the meeting is\n      // found in the collection, as we mutate the destination for hydra person\n      // id values.\n      return this.meetingInfo.fetchInfoOptions(destination, type)\n        // Catch a failure to fetch info options.\n        .catch((error) => {\n          LoggerProxy.logger.info(`Meetings:index#create --> INFO, unable to determine info options: ${error.message}`);\n        })\n        .then((options = {}) => {\n          // Normalize the destination.\n          const targetDest = options.destination || destination;\n\n          // check for the conversation URL then sip Url\n          let meeting = null;\n\n          if (type === _CONVERSATION_URL_ || options.type === _CONVERSATION_URL_) {\n            meeting = this.meetingCollection.getByKey(CONVERSATION_URL, targetDest);\n          }\n\n          // Attempt to collect the meeting if it exists.\n          if (!meeting) {\n            meeting = this.meetingCollection.getByKey(SIP_URI, targetDest);\n          }\n\n\n          // Validate if a meeting was found.\n          if (!meeting) {\n            // Create a meeting based on the normalized destination and type.\n            return this.createMeeting(targetDest, type)\n              .then((createdMeeting) => {\n                // If the meeting was successfully created.\n                if (createdMeeting && createdMeeting.on) {\n                  // Create a destruction event for the meeting.\n                  createdMeeting.on(EVENTS.DESTROY_MEETING, (payload) => {\n                    if (this.config.autoUploadLogs) {\n                      this.uploadLogs({\n                        callStart: createdMeeting.locusInfo?.fullState?.lastActive,\n                        correlationId: createdMeeting.correlationId,\n                        feedbackId: createdMeeting.correlationId,\n                        locusId: createdMeeting.locusId,\n                        meetingId: createdMeeting.locusInfo?.info?.webExMeetingId\n                      }).then(() => this.destroy(createdMeeting, payload.reason));\n                    }\n                    else {\n                      this.destroy(createdMeeting, payload.reason);\n                    }\n                  });\n\n                  createdMeeting.on(EVENTS.REQUEST_UPLOAD_LOGS, (meetingInstance) => {\n                    if (this.config.autoUploadLogs) {\n                      this.uploadLogs({\n                        callStart: meetingInstance?.locusInfo?.fullState?.lastActive,\n                        correlationId: meetingInstance.correlationId,\n                        feedbackId: meetingInstance.correlationId,\n                        locusId: meetingInstance.locusId,\n                        meetingId: meetingInstance.locusInfo?.info?.webExMeetingId\n                      });\n                    }\n                  });\n                }\n                else {\n                  LoggerProxy.logger.error(`Meetings:index#create --> ERROR, meeting does not have on method, will not be destroyed, meeting cleanup impossible for meeting: ${meeting}`);\n                }\n\n                // Return the newly created meeting.\n                return Promise.resolve(createdMeeting);\n              });\n          }\n\n          // Return the existing meeting.\n          return Promise.resolve(meeting);\n        });\n    }\n\n    /**\n     * @param {String} destination see create()\n     * @param {String} type see create()\n     * @returns {Promise} a new meeting instance complete with meeting info and destination\n     * @private\n     * @memberof Meetings\n     */\n    async createMeeting(destination, type = null) {\n      const meeting = new Meeting(\n        {\n          userId: this.webex.internal.device.userId,\n          deviceUrl: this.webex.internal.device.url,\n          orgId: this.webex.internal.device.orgId,\n          roapSeq: 0,\n          locus: type === _LOCUS_ID_ ? destination : null, // pass the locus object if present\n          meetingInfoProvider: this.meetingInfo\n        },\n        {\n          parent: this.webex\n        }\n      );\n\n      this.meetingCollection.set(meeting);\n\n      try {\n        await meeting.fetchMeetingInfo({destination, type});\n      }\n      catch (err) {\n        if (!(err instanceof CaptchaError) && !(err instanceof PasswordError)) {\n          // if there is no meeting info we assume its a 1:1 call or wireless share\n          LoggerProxy.logger.info(`Meetings:index#createMeeting --> Info Unable to fetch meeting info for ${destination}.`);\n          LoggerProxy.logger.info('Meetings:index#createMeeting --> Info assuming this destination is a 1:1 or wireless share');\n        }\n        LoggerProxy.logger.debug(`Meetings:index#createMeeting --> Debug ${err} fetching /meetingInfo for creation.`);\n        // We need to save this info for future reference\n        meeting.destination = destination;\n      }\n      finally {\n        // For type LOCUS_ID we need to parse the locus object to get the information\n        // about the caller and callee\n        // Meeting Added event will be created in `handleLocusEvent`\n        if (type !== _LOCUS_ID_) {\n          if (!meeting.sipUri) {\n            meeting.setSipUri(destination);\n          }\n\n          // TODO: check if we have to move this to parser\n          const meetingAddedType = MeetingsUtil.getMeetingAddedType(type);\n\n          // We typically shouldn't need to trigger both and event and return a promise.\n          // Is this a special case? We want to make the public API usage as simple as possible.\n          Trigger.trigger(\n            this,\n            {\n              file: 'meetings',\n              function: 'createMeeting'\n            },\n            EVENT_TRIGGERS.MEETING_ADDED,\n            {\n              meeting,\n              type: meetingAddedType\n            }\n          );\n        }\n      }\n\n      return meeting;\n\n      // Create the meeting calling the necessary service endpoints.\n\n      // Internally, there are many more destinations:\n      //\n      // - locusID\n      // - meetingURL\n      // - globalMeetingID, e.g, *00*meetingID\n      // - meetingID\n      // - meetingURL\n      // - PSTN\n      // - phone number\n      //\n      // Our job is to determine the appropriate one\n      // and its corresponding service so that developers\n      // need only sipURL or spaceID to get a meeting\n      // and its ID, but have the option to use createWithType()\n      // and specify those types to get meetingInfo\n    }\n\n    /**\n     * get a specifc meeting given it's type matched to the value, i.e., locus url\n     * @param {String} type\n     * @param {Object} value\n     * @returns {Meeting}\n     * @public\n     * @memberof Meetings\n     */\n    getMeetingByType(type, value) {\n      return this.meetingCollection.getByKey(type, value);\n    }\n\n    /**\n     * Get all meetings.\n     * @param {object} options\n     * @param {object} options.startDate - get meetings after this start date\n     * @param {object} options.endDate - get meetings before this end date\n     * @returns {Object} All currently active meetings.\n     * @public\n     * @memberof Meetings\n     */\n    getAllMeetings(options = {}) {\n      // Options may include other parameters to filter this collection\n      // of meetings.\n      return this.meetingCollection.getAll(options);\n    }\n\n    /**\n     * syncs all the meeting from server\n     * @returns {undefined}\n     * @public\n     * @memberof Meetings\n     */\n    syncMeetings() {\n      return this.request.getActiveMeetings().then((locusArray) => {\n        const activeLocusUrl = [];\n\n        if (locusArray?.loci && locusArray.loci.length > 0) {\n          locusArray.loci.forEach((locus) => {\n            activeLocusUrl.push(locus.url);\n            this.handleLocusEvent({\n              locus,\n              locusUrl: locus.url\n            });\n          });\n        }\n        const meetingsCollection = this.meetingCollection.getAll();\n\n        if (Object.keys(meetingsCollection).length > 0) {\n          // Some time the mercury event is missed after mercury reconnect\n          // if sync returns no locus then clear all the meetings\n          for (const meeting of Object.values(meetingsCollection)) {\n            if (!activeLocusUrl.includes(meeting.locusUrl)) {\n              // destroy function also uploads logs\n              this.destroy(meeting, MEETING_REMOVED_REASON.NO_MEETINGS_TO_SYNC);\n            }\n          }\n        }\n      });\n    }\n\n    /**\n     * Get all scheduled meetings.\n     * @param {object} options\n     * @param {object} options.startDate - get meetings after this start date\n     * @param {object} options.endDate - get meetings before this end date\n     * @returns {Object} All scheduled meetings.\n     * @memberof Meetings\n     */\n    getScheduledMeetings() {\n      return this.meetingCollection.getAll({scheduled: true});\n    }\n\n    /**\n     * Get the logger instance for plugin-meetings\n     * @returns {Logger}\n     */\n    getLogger() {\n      return LoggerProxy.get();\n    }\n\n    /**\n     * Get the Stats Analyzer singleton\n     * @returns {StatsAnalyzer}\n     * @public\n     * @memberof Meetings\n     */\n    getAnalyzer() {\n      return StatsAnalyzer;\n    }\n\n    /**\n     * Get the Stats Calculator singleton\n     * @returns {StatsCalculator}\n     * @public\n     * @memberof Meetings\n     */\n    getCalculator() {\n      return StatsCalculator;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}