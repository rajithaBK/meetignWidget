{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _javascriptStateMachine = _interopRequireDefault(require(\"javascript-state-machine\"));\n\nvar _history = _interopRequireDefault(require(\"javascript-state-machine/lib/history\"));\n\nvar _loggerProxy = _interopRequireDefault(require(\"../common/logs/logger-proxy\"));\n\nvar _triggerProxy = _interopRequireDefault(require(\"../common/events/trigger-proxy\"));\n\nvar _constants = require(\"../constants\");\n\nvar _parameter = _interopRequireDefault(require(\"../common/errors/parameter\")); // TODO: ensure that meeting can be destroyed when in an error state\n\n\nvar MeetingStateMachine = {\n  /**\n   * Initializes the StateMachine for the meeting\n   * @param {Meeting} meetingRef A reference to a meeting instance\n   * @returns {StateMachine}\n   */\n  create: function create(meetingRef) {\n    if (!meetingRef) {\n      throw new _parameter.default('You must initialize the meeting state machine with a meeting reference.');\n    }\n\n    return new _javascriptStateMachine.default({\n      init: _constants.MEETING_STATE_MACHINE.STATES.IDLE,\n      transitions: [// when ringing a meeting, it must be first IDLE, because all other states are invalid, it transitions to the RINGING state\n      {\n        name: _constants.MEETING_STATE_MACHINE.TRANSITIONS.RING,\n        from: [_constants.MEETING_STATE_MACHINE.STATES.IDLE, _constants.MEETING_STATE_MACHINE.STATES.ERROR, _constants.MEETING_STATE_MACHINE.STATES.JOINED],\n        to: _constants.MEETING_STATE_MACHINE.STATES.RINGING\n      }, // when joining a meeting, it must be from the RINGING or IDLE state, transitions to JOINED state, 1:1 will go to RINGING,\n      // others will go straight to JOINED with this transition\n      {\n        name: _constants.MEETING_STATE_MACHINE.TRANSITIONS.JOIN,\n        from: [_constants.MEETING_STATE_MACHINE.STATES.JOINED, _constants.MEETING_STATE_MACHINE.STATES.IDLE, _constants.MEETING_STATE_MACHINE.STATES.RINGING, _constants.MEETING_STATE_MACHINE.STATES.ERROR],\n        to: _constants.MEETING_STATE_MACHINE.STATES.JOINED\n      }, // signify that ringing has stopped and somebody else answered, move state to DECLINED, ANSWERED\n      {\n        name: _constants.MEETING_STATE_MACHINE.TRANSITIONS.REMOTE,\n        from: [_constants.MEETING_STATE_MACHINE.STATES.JOINED, _constants.MEETING_STATE_MACHINE.STATES.ERROR],\n\n        /**\n        * @param {Object} remote\n        * @param {Boolean} remote.remoteAnswered\n        * @param {Boolean} remote.remoteDeclined\n        * @returns {String}\n        */\n        to: function to(remote) {\n          // other user answered the call\n          if (remote.remoteAnswered) {\n            return _constants.MEETING_STATE_MACHINE.STATES.ANSWERED;\n          } // other user declined the call\n\n\n          if (remote.remoteDeclined) {\n            return _constants.MEETING_STATE_MACHINE.STATES.DECLINED;\n          } // default\n\n\n          return _constants.MEETING_STATE_MACHINE.STATES.ERROR;\n        }\n      }, // when leaving a meeting it must be from either the RINGING, JOINED, or ERROR states, and transitions it to the ENDED state\n      {\n        name: _constants.MEETING_STATE_MACHINE.TRANSITIONS.LEAVE,\n        from: [_constants.MEETING_STATE_MACHINE.STATES.IDLE, _constants.MEETING_STATE_MACHINE.STATES.RINGING, _constants.MEETING_STATE_MACHINE.STATES.JOINED, _constants.MEETING_STATE_MACHINE.STATES.ANSWERED, _constants.MEETING_STATE_MACHINE.STATES.DECLINED, _constants.MEETING_STATE_MACHINE.STATES.ERROR],\n        to: _constants.MEETING_STATE_MACHINE.STATES.ENDED\n      }, // when declining an incoming meeting it must be from the ringing state, and it moves to DECLINED state\n      {\n        name: _constants.MEETING_STATE_MACHINE.TRANSITIONS.DECLINE,\n        from: [_constants.MEETING_STATE_MACHINE.STATES.RINGING, _constants.MEETING_STATE_MACHINE.STATES.ERROR],\n        to: _constants.MEETING_STATE_MACHINE.STATES.ENDED\n      }, // transition from ANY state to ERROR state\n      {\n        name: _constants.MEETING_STATE_MACHINE.TRANSITIONS.FAIL,\n        from: '*',\n        to: _constants.MEETING_STATE_MACHINE.STATES.ERROR\n      }, // fail safe, transition from ANY state to IDLE state\n      {\n        name: _constants.MEETING_STATE_MACHINE.TRANSITIONS.RESET,\n        from: '*',\n        to: _constants.MEETING_STATE_MACHINE.STATES.IDLE\n      }],\n      data: {\n        /**\n         * The meeting instance to execute all state changes on\n         */\n        meeting: meetingRef\n      },\n      methods: {\n        /**\n         * Ring stop transition, to end the ring event for the meeting, and transition the state to ANSWERED OR DECLINED, only for outgoing meetings\n         * @param {Object} transition -- FiniteStateMachine automatically passed, not used\n         * @param {Object} stop -- {remoteAnswered: {Boolean}, remoteDeclined: {Boolean}}\n         * @returns {Boolean}\n         */\n        onRemote: function onRemote(transition, stop) {\n          if (this.meeting) {\n            _triggerProxy.default.trigger(this.meeting, {\n              file: 'meeting/state',\n              function: 'onRemote'\n            }, _constants.EVENT_TRIGGERS.MEETING_RINGING_STOP, {\n              id: this.meeting.id,\n              type: stop\n            });\n          }\n        },\n\n        /**\n         * Ring transition, to cause the ring event for the meeting, and transition the state to RINGING, for both incoming, and outgoing meetings\n         * @param {Object} transition -- FiniteStateMachine automatically passed, not used\n         * @param {String} type -- incoming call === INCOMING / or other meetings have a ring type of JOIN\n         * @returns {Boolean}\n         */\n        onRing: function onRing(transition, type) {\n          if (this.meeting) {\n            _triggerProxy.default.trigger(this.meeting, {\n              file: 'meeting/state',\n              function: 'onRing'\n            }, _constants.EVENT_TRIGGERS.MEETING_RINGING, {\n              type: type,\n              id: this.meeting.id\n            });\n          }\n        },\n\n        /**\n         * handle the entry to error state\n         * @param {Object} transition\n         * @param {Error} error\n         * @returns {Boolean}\n         */\n        onEnterError: function onEnterError(transition, error) {\n          _loggerProxy.default.logger.error(\"Meeting:state#onEnterError --> state->onEnterError#meeting.id: \".concat(this.meeting.id, \" | Transition '\").concat(transition === null || transition === void 0 ? void 0 : transition.transition, \"' : \").concat(transition === null || transition === void 0 ? void 0 : transition.from, \" -> \").concat(transition === null || transition === void 0 ? void 0 : transition.to, \", with error \").concat(error, \". Last states: \").concat(this.history));\n        },\n\n        /**\n         * After ANY transition occurs, we want to know what state the meeting moved to for debugging\n         * @param {Object} transition\n         * @returns {Boolean}\n         */\n        onAfterTransition: function onAfterTransition(transition) {\n          _loggerProxy.default.logger.log(\"Meeting:state#onAfterTransition --> state->onAfterTransition#meeting.id: \".concat(this.meeting.id, \" | Transition '\").concat(transition.transition, \"' : \").concat(transition.from, \" -> \").concat(transition.to, \" executed. Last states: \").concat(this.history));\n        }\n      },\n      // track the last 25 states entered\n      plugins: [new _history.default({\n        max: 25\n      })]\n    });\n  }\n};\nvar _default = MeetingStateMachine;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["MeetingStateMachine","create","meetingRef","ParameterError","StateMachine","init","MEETING_STATE_MACHINE","STATES","IDLE","transitions","name","TRANSITIONS","RING","from","ERROR","JOINED","to","RINGING","JOIN","REMOTE","remote","remoteAnswered","ANSWERED","remoteDeclined","DECLINED","LEAVE","ENDED","DECLINE","FAIL","RESET","data","meeting","methods","onRemote","transition","stop","Trigger","trigger","file","function","EVENT_TRIGGERS","MEETING_RINGING_STOP","id","type","onRing","MEETING_RINGING","onEnterError","error","LoggerProxy","logger","history","onAfterTransition","log","plugins","StateMachineHistory","max"],"sources":["state.js"],"sourcesContent":["import StateMachine from 'javascript-state-machine';\nimport StateMachineHistory from 'javascript-state-machine/lib/history';\n\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport Trigger from '../common/events/trigger-proxy';\nimport {MEETING_STATE_MACHINE, EVENT_TRIGGERS} from '../constants';\nimport ParameterError from '../common/errors/parameter';\n\n// TODO: ensure that meeting can be destroyed when in an error state\nconst MeetingStateMachine = {\n  /**\n   * Initializes the StateMachine for the meeting\n   * @param {Meeting} meetingRef A reference to a meeting instance\n   * @returns {StateMachine}\n   */\n  create(meetingRef) {\n    if (!meetingRef) {\n      throw new ParameterError('You must initialize the meeting state machine with a meeting reference.');\n    }\n\n    return new StateMachine({\n      init: MEETING_STATE_MACHINE.STATES.IDLE,\n      transitions: [\n        // when ringing a meeting, it must be first IDLE, because all other states are invalid, it transitions to the RINGING state\n        {\n          name: MEETING_STATE_MACHINE.TRANSITIONS.RING,\n          from: [MEETING_STATE_MACHINE.STATES.IDLE, MEETING_STATE_MACHINE.STATES.ERROR, MEETING_STATE_MACHINE.STATES.JOINED],\n          to: MEETING_STATE_MACHINE.STATES.RINGING\n        },\n        // when joining a meeting, it must be from the RINGING or IDLE state, transitions to JOINED state, 1:1 will go to RINGING,\n        // others will go straight to JOINED with this transition\n        {\n          name: MEETING_STATE_MACHINE.TRANSITIONS.JOIN,\n          from: [MEETING_STATE_MACHINE.STATES.JOINED, MEETING_STATE_MACHINE.STATES.IDLE, MEETING_STATE_MACHINE.STATES.RINGING, MEETING_STATE_MACHINE.STATES.ERROR],\n          to: MEETING_STATE_MACHINE.STATES.JOINED\n        },\n        // signify that ringing has stopped and somebody else answered, move state to DECLINED, ANSWERED\n        {\n          name: MEETING_STATE_MACHINE.TRANSITIONS.REMOTE,\n          from: [MEETING_STATE_MACHINE.STATES.JOINED, MEETING_STATE_MACHINE.STATES.ERROR],\n          /**\n         * @param {Object} remote\n         * @param {Boolean} remote.remoteAnswered\n         * @param {Boolean} remote.remoteDeclined\n         * @returns {String}\n         */\n          to(remote) {\n            // other user answered the call\n            if (remote.remoteAnswered) {\n              return MEETING_STATE_MACHINE.STATES.ANSWERED;\n            }\n            // other user declined the call\n            if (remote.remoteDeclined) {\n              return MEETING_STATE_MACHINE.STATES.DECLINED;\n            }\n\n            // default\n            return MEETING_STATE_MACHINE.STATES.ERROR;\n          }\n        },\n        // when leaving a meeting it must be from either the RINGING, JOINED, or ERROR states, and transitions it to the ENDED state\n        {\n          name: MEETING_STATE_MACHINE.TRANSITIONS.LEAVE,\n          from: [\n            MEETING_STATE_MACHINE.STATES.IDLE,\n            MEETING_STATE_MACHINE.STATES.RINGING,\n            MEETING_STATE_MACHINE.STATES.JOINED,\n            MEETING_STATE_MACHINE.STATES.ANSWERED,\n            MEETING_STATE_MACHINE.STATES.DECLINED,\n            MEETING_STATE_MACHINE.STATES.ERROR\n          ],\n          to: MEETING_STATE_MACHINE.STATES.ENDED\n        },\n        // when declining an incoming meeting it must be from the ringing state, and it moves to DECLINED state\n        {\n          name: MEETING_STATE_MACHINE.TRANSITIONS.DECLINE,\n          from: [MEETING_STATE_MACHINE.STATES.RINGING, MEETING_STATE_MACHINE.STATES.ERROR],\n          to: MEETING_STATE_MACHINE.STATES.ENDED\n        },\n        // transition from ANY state to ERROR state\n        {\n          name: MEETING_STATE_MACHINE.TRANSITIONS.FAIL,\n          from: '*',\n          to: MEETING_STATE_MACHINE.STATES.ERROR\n        },\n        // fail safe, transition from ANY state to IDLE state\n        {\n          name: MEETING_STATE_MACHINE.TRANSITIONS.RESET,\n          from: '*',\n          to: MEETING_STATE_MACHINE.STATES.IDLE\n        }\n      ],\n      data: {\n        /**\n         * The meeting instance to execute all state changes on\n         */\n        meeting: meetingRef\n      },\n      methods: {\n        /**\n         * Ring stop transition, to end the ring event for the meeting, and transition the state to ANSWERED OR DECLINED, only for outgoing meetings\n         * @param {Object} transition -- FiniteStateMachine automatically passed, not used\n         * @param {Object} stop -- {remoteAnswered: {Boolean}, remoteDeclined: {Boolean}}\n         * @returns {Boolean}\n         */\n        onRemote(transition, stop) {\n          if (this.meeting) {\n            Trigger.trigger(\n              this.meeting,\n              {\n                file: 'meeting/state',\n                function: 'onRemote'\n              },\n              EVENT_TRIGGERS.MEETING_RINGING_STOP,\n              {\n                id: this.meeting.id,\n                type: stop\n              }\n            );\n          }\n        },\n        /**\n         * Ring transition, to cause the ring event for the meeting, and transition the state to RINGING, for both incoming, and outgoing meetings\n         * @param {Object} transition -- FiniteStateMachine automatically passed, not used\n         * @param {String} type -- incoming call === INCOMING / or other meetings have a ring type of JOIN\n         * @returns {Boolean}\n         */\n        onRing(transition, type) {\n          if (this.meeting) {\n            Trigger.trigger(\n              this.meeting,\n              {\n                file: 'meeting/state',\n                function: 'onRing'\n              },\n              EVENT_TRIGGERS.MEETING_RINGING,\n              {\n                type,\n                id: this.meeting.id\n              }\n            );\n          }\n        },\n        /**\n         * handle the entry to error state\n         * @param {Object} transition\n         * @param {Error} error\n         * @returns {Boolean}\n         */\n        onEnterError(transition, error) {\n          LoggerProxy.logger.error(`Meeting:state#onEnterError --> state->onEnterError#meeting.id: ${this.meeting.id} | Transition '${transition?.transition}' : ${transition?.from} -> ${transition?.to}, with error ${error}. Last states: ${this.history}`);\n        },\n        /**\n         * After ANY transition occurs, we want to know what state the meeting moved to for debugging\n         * @param {Object} transition\n         * @returns {Boolean}\n         */\n        onAfterTransition(transition) {\n          LoggerProxy.logger.log(`Meeting:state#onAfterTransition --> state->onAfterTransition#meeting.id: ${this.meeting.id} | Transition '${transition.transition}' : ${transition.from} -> ${transition.to} executed. Last states: ${this.history}`);\n        }\n      },\n      // track the last 25 states entered\n      plugins: [new StateMachineHistory({max: 25})]\n    });\n  }\n};\n\nexport default MeetingStateMachine;\n"]},"metadata":{},"sourceType":"script"}