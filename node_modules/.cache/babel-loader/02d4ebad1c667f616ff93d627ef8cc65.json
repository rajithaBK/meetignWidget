{"ast":null,"code":"\"use strict\";\n\nvar _Array$from = require(\"@babel/runtime-corejs2/core-js/array/from\");\n\nvar _Symbol = require(\"@babel/runtime-corejs2/core-js/symbol\");\n\nvar _Symbol$iterator = require(\"@babel/runtime-corejs2/core-js/symbol/iterator\");\n\nvar _Array$isArray = require(\"@babel/runtime-corejs2/core-js/array/is-array\");\n\nvar _Object$keys = require(\"@babel/runtime-corejs2/core-js/object/keys\");\n\nvar _Object$getOwnPropertySymbols = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\");\n\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\");\n\nvar _Object$getOwnPropertyDescriptors = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\");\n\nvar _Object$defineProperties = require(\"@babel/runtime-corejs2/core-js/object/define-properties\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime-corejs2/regenerator\"));\n\nvar _map2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/map\"));\n\nvar _assign = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/assign\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/json/stringify\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/slicedToArray\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/typeof\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/toConsumableArray\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/asyncToGenerator\"));\n\nvar _awaitAsyncGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/awaitAsyncGenerator\"));\n\nvar _wrapAsyncGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/wrapAsyncGenerator\"));\n\nvar _uniq2 = _interopRequireDefault(require(\"lodash/uniq\"));\n\nvar _pick2 = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _omit2 = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _merge2 = _interopRequireDefault(require(\"lodash/merge\"));\n\nvar _map3 = _interopRequireDefault(require(\"lodash/map\"));\n\nvar _last2 = _interopRequireDefault(require(\"lodash/last\"));\n\nvar _isString2 = _interopRequireDefault(require(\"lodash/isString\"));\n\nvar _isObject2 = _interopRequireDefault(require(\"lodash/isObject\"));\n\nvar _isArray2 = _interopRequireDefault(require(\"lodash/isArray\"));\n\nvar _defaults2 = _interopRequireDefault(require(\"lodash/defaults\"));\n\nvar _cloneDeepWith2 = _interopRequireDefault(require(\"lodash/cloneDeepWith\"));\n\nvar _cloneDeep2 = _interopRequireDefault(require(\"lodash/cloneDeep\"));\n\nvar _querystring = _interopRequireDefault(require(\"querystring\"));\n\nvar _events = require(\"events\");\n\nvar _hmacSha = _interopRequireDefault(require(\"crypto-js/hmac-sha256\"));\n\nvar _encHex = _interopRequireDefault(require(\"crypto-js/enc-hex\"));\n\nvar _common = require(\"@webex/common\");\n\nvar _webexCore = require(\"@webex/webex-core\");\n\nvar _helperImage = require(\"@webex/helper-image\");\n\nvar _uuid = _interopRequireDefault(require(\"uuid\"));\n\nvar _convoError = require(\"./convo-error\");\n\nvar _shareActivity = _interopRequireDefault(require(\"./share-activity\"));\n\nvar _activityThreadOrdering = require(\"./activity-thread-ordering\");\n\nvar _activities = require(\"./activities\");\n\nvar _constants = require(\"./constants\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = _Object$keys(object);\n\n  if (_Object$getOwnPropertySymbols) {\n    var symbols = _Object$getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return _Object$getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (_Object$getOwnPropertyDescriptors) {\n      _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof _Symbol !== \"undefined\" && o[_Symbol$iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (_Array$isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return _Array$from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar CLUSTER_SERVICE = process.env.WEBEX_CONVERSATION_CLUSTER_SERVICE || _constants.DEFAULT_CLUSTER_SERVICE;\nvar DEFAULT_CLUSTER_IDENTIFIER = process.env.WEBEX_CONVERSATION_DEFAULT_CLUSTER || \"\".concat(_constants.DEFAULT_CLUSTER, \":\").concat(CLUSTER_SERVICE);\nvar idToUrl = new _map2.default();\n\nvar getConvoLimit = function getConvoLimit() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var limit;\n\n  if (options.conversationsLimit) {\n    limit = {\n      value: options.conversationsLimit,\n      name: 'conversationsLimit'\n    };\n  }\n\n  return limit;\n};\n\nvar Conversation = _webexCore.WebexPlugin.extend({\n  namespace: 'Conversation',\n\n  /**\n   * @param {String} cluster the cluster containing the id\n   * @param {UUID} [id] the id of the conversation.\n   *  If empty, just return the base URL.\n   * @returns {String} url of the conversation\n   */\n  getUrlFromClusterId: function getUrlFromClusterId() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$cluster = _ref.cluster,\n        cluster = _ref$cluster === void 0 ? 'us' : _ref$cluster,\n        id = _ref.id;\n\n    var clusterId = cluster === 'us' ? DEFAULT_CLUSTER_IDENTIFIER : cluster; // Determine if cluster has service name (non-US clusters from hydra do not)\n\n    if (clusterId.split(':').length < 4) {\n      // Add Service to cluster identifier\n      clusterId = \"\".concat(cluster, \":\").concat(CLUSTER_SERVICE);\n    }\n\n    var _ref2 = this.webex.internal.services.getServiceFromClusterId({\n      clusterId: clusterId\n    }) || {},\n        url = _ref2.url;\n\n    if (!url) {\n      throw Error(\"Could not find service for cluster [\".concat(cluster, \"]\"));\n    }\n\n    return id ? \"\".concat(url, \"/conversations/\").concat(id) : url;\n  },\n\n  /**\n   * @param {Object} conversation\n   * @param {Object} object\n   * @param {Object} activity\n   * @returns {Promise}\n   */\n  acknowledge: function acknowledge(conversation, object, activity) {\n    var _this2 = this;\n\n    var url = this.getConvoUrl(conversation);\n    var convoWithUrl = (0, _assign.default)({}, conversation, {\n      url: url\n    });\n\n    if (!(0, _isObject2.default)(object)) {\n      return _promise.default.reject(new Error('`object` must be an object'));\n    }\n\n    return this.prepare(activity, {\n      verb: 'acknowledge',\n      target: this.prepareConversation(convoWithUrl),\n      object: {\n        objectType: 'activity',\n        id: object.id,\n        url: object.url\n      }\n    }).then(function (a) {\n      return _this2.submit(a);\n    });\n  },\n\n  /**\n   * Adds a participant to a conversation\n   * @param {Object} conversation\n   * @param {Object|string} participant\n   * @param {Object} activity Reference to the activity that will eventually be\n   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a\n   * provisional activity\n   * @returns {Promise<Activity>}\n   */\n  add: function add(conversation, participant, activity) {\n    var _this3 = this;\n\n    var url = this.getConvoUrl(conversation);\n    var convoWithUrl = (0, _assign.default)({}, conversation, {\n      url: url\n    });\n    return this.webex.internal.user.asUUID(participant, {\n      create: true\n    }).then(function (id) {\n      return _this3.prepare(activity, {\n        verb: 'add',\n        target: _this3.prepareConversation(convoWithUrl),\n        object: {\n          id: id,\n          objectType: 'person'\n        },\n        kmsMessage: {\n          method: 'create',\n          uri: '/authorizations',\n          resourceUri: '<KRO>',\n          userIds: [id]\n        }\n      }).then(function (a) {\n        return _this3.submit(a);\n      });\n    });\n  },\n\n  /**\n   * Creates a conversation\n   * @param {Object} params\n   * @param {Array<Participant>} params.participants\n   * @param {Array<File>} params.files\n   * @param {string} params.comment\n   * @param {string} params.html\n   * @param {Object} params.displayName\n   * @param {string} params.classificationId\n   * @param {string} params.effectiveDate\n   * @param {Boolean} params.isDefaultClassification\n   * @param {Array<string>} params.tags\n   * @param {Boolean} params.favorite\n   * @param {Object} options\n   * @param {Boolean} options.allowPartialCreation\n   * @param {Boolean} options.forceGrouped\n   * @param {Boolean} options.skipOneOnOneFetch skips checking 1:1 exists before creating conversation\n   * @returns {Promise<Conversation>}\n   */\n  create: function create(params) {\n    var _this4 = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!params.participants || params.participants.length === 0) {\n      return _promise.default.reject(new Error('`params.participants` is required'));\n    }\n\n    return _promise.default.all(params.participants.map(function (participant) {\n      return _this4.webex.internal.user.asUUID(participant, {\n        create: true\n      }) // eslint-disable-next-line arrow-body-style\n      .catch(function (err) {\n        return options.allowPartialCreation ? undefined : _promise.default.reject(err);\n      });\n    })).then(function (participants) {\n      participants.unshift(_this4.webex.internal.device.userId);\n      participants = (0, _uniq2.default)(participants);\n      var validParticipants = participants.filter(function (participant) {\n        return participant;\n      });\n      params.participants = validParticipants; // check if original participants list was to create a 1:1\n\n      if (participants.length === 2 && !(options && options.forceGrouped)) {\n        if (!params.participants[1]) {\n          return _promise.default.reject(new _convoError.InvalidUserCreation());\n        }\n\n        if (options.skipOneOnOneFetch) {\n          return _this4._createOneOnOne(params);\n        }\n\n        return _this4._maybeCreateOneOnOneThenPost(params, options);\n      }\n\n      return _this4._createGrouped(params, options);\n    }).then(function (c) {\n      idToUrl.set(c.id, c.url);\n\n      if (!params.files) {\n        return c;\n      }\n\n      return _this4.webex.internal.conversation.share(c, params.files).then(function (a) {\n        c.activities.items.push(a);\n        return c;\n      });\n    });\n  },\n\n  /**\n   * @private\n   * generate a deterministic HMAC for a reaction\n   * @param {Object} displayName displayName of reaction we are sending\n   * @param {Object} parent parent activity of reaction\n   * @returns {Promise<HMAC>}\n   */\n  createReactionHmac: function createReactionHmac(displayName, parent) {\n    // not using webex.internal.encryption.getKey() because the JWK it returns does not have a 'k'\n    // property. we need jwk.k to correctly generate the HMAC\n    return this.webex.internal.encryption.unboundedStorage.get(parent.encryptionKeyUrl).then(function (keyString) {\n      var key = JSON.parse(keyString); // when we stringify this object, keys must be in this order to generate same HMAC as\n      // desktop clients\n\n      var formatjwk = {\n        k: key.jwk.k,\n        kid: key.jwk.kid,\n        kty: key.jwk.kty\n      };\n      var source = \"\".concat((0, _stringify.default)(formatjwk)).concat(parent.id).concat(displayName);\n\n      var hmac = _encHex.default.stringify((0, _hmacSha.default)(source, parent.id));\n\n      return _promise.default.resolve(hmac);\n    });\n  },\n\n  /**\n   * @typedef {Object} ReactionPayload\n   * @property {Object} actor\n   * @property {string} actor.objectType\n   * @property {string} actor.id\n   * @property {string} objectType\n   * @property {string} verb will be either add' or 'delete'\n   * @property {Object} target\n   * @property {string} target.id\n   * @property {string} target.objectType\n   * @property {Object} object this will change on delete vs. add\n   * @property {string} object.id present in delete case\n   * @property {string} object.objectType 'activity' in delete case, 'reaction2' in add case\n   * @property {string} object.displayName must be 'celebrate', 'heart', 'thumbsup', 'smiley', 'haha', 'confused', 'sad'\n   * @property {string} object.hmac\n   */\n\n  /**\n   * @private\n   * send add or delete reaction to convo service\n   * @param {Object} conversation\n   * The payload to send a reaction\n   * @param {ReactionPayload} reactionPayload\n   * @returns {Promise<Activity>}\n   */\n  sendReaction: function sendReaction(conversation, reactionPayload) {\n    var _this5 = this;\n\n    var url = this.getConvoUrl(conversation);\n    var convoWithUrl = (0, _assign.default)({}, conversation, {\n      url: url\n    });\n\n    if (!(0, _isObject2.default)(reactionPayload)) {\n      return _promise.default.reject(new Error('`object` must be an object'));\n    }\n\n    return this.prepare(reactionPayload, {\n      target: this.prepareConversation(convoWithUrl),\n      object: (0, _pick2.default)(reactionPayload, 'id', 'url', 'objectType')\n    }).then(function (act) {\n      return _this5.submit(act);\n    });\n  },\n\n  /**\n   * delete a reaction\n   * @param {Object} conversation\n   * @param {Object} reactionId\n   * @returns {Promise<Activity>}\n   */\n  deleteReaction: function deleteReaction(conversation, reactionId) {\n    var deleteReactionPayload = {\n      actor: {\n        objectType: 'person',\n        id: this.webex.internal.device.userId\n      },\n      object: {\n        id: reactionId,\n        objectType: 'activity'\n      },\n      objectType: 'activity',\n      target: {\n        id: conversation.id,\n        objectType: 'conversation'\n      },\n      verb: 'delete'\n    };\n    return this.sendReaction(conversation, deleteReactionPayload);\n  },\n\n  /**\n   * create a reaction\n   * @param {Object} conversation\n   * @param {Object} displayName must be 'celebrate', 'heart', 'thumbsup', 'smiley', 'haha', 'confused', 'sad'\n   * @param {Object} activity activity object from convo we are reacting to\n   * @returns {Promise<Activity>}\n   */\n  addReaction: function addReaction(conversation, displayName, activity) {\n    var _this6 = this;\n\n    return this.createReactionHmac(displayName, activity).then(function (hmac) {\n      var addReactionPayload = {\n        actor: {\n          objectType: 'person',\n          id: _this6.webex.internal.device.userId\n        },\n        target: {\n          id: conversation.id,\n          objectType: 'conversation'\n        },\n        verb: 'add',\n        objectType: 'activity',\n        parent: {\n          type: 'reaction',\n          id: activity.id\n        },\n        object: {\n          objectType: 'reaction2',\n          displayName: displayName,\n          hmac: hmac\n        }\n      };\n      return _this6.sendReaction(conversation, addReactionPayload);\n    });\n  },\n\n  /**\n   * delete content\n   * @param {Object} conversation\n   * @param {Object} object\n   * @param {Object} activity\n   * @returns {Promise}\n   */\n  delete: function _delete(conversation, object, activity) {\n    var _this7 = this;\n\n    var url = this.getConvoUrl(conversation);\n    var convoWithUrl = (0, _assign.default)({}, conversation, {\n      url: url\n    });\n\n    if (!(0, _isObject2.default)(object)) {\n      return _promise.default.reject(new Error('`object` must be an object'));\n    }\n\n    return this.prepare(activity, {\n      verb: 'delete',\n      target: this.prepareConversation(convoWithUrl),\n      object: (0, _pick2.default)(object, 'id', 'url', 'objectType')\n    }).then(function (a) {\n      return _this7.submit(a);\n    });\n  },\n\n  /**\n   * Downloads the file specified in item.scr or item.url\n   * @param {Object} item\n   * @param {Object} item.scr\n   * @param {string} item.url\n   * @param {Object} options\n   * @param {Object} options.headers\n   * @param {boolean} options.shouldNotAddExifData\n   * @returns {Promise<File>}\n   */\n  download: function download(item) {\n    var _this8 = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var isEncrypted = Boolean(item.scr && item.scr.key);\n    var shunt = new _events.EventEmitter();\n    var promise;\n\n    if (isEncrypted) {\n      promise = this.webex.internal.encryption.download(item.scr, item.options);\n    } else if (item.scr && item.scr.loc) {\n      promise = this._downloadUnencryptedFile(item.scr.loc, options);\n    } else {\n      promise = this._downloadUnencryptedFile(item.url, options);\n    }\n\n    promise = promise.on('progress', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return shunt.emit.apply(shunt, ['progress'].concat(args));\n    }).then(function (res) {\n      if (options.shouldNotAddExifData) {\n        return res;\n      }\n\n      return (0, _helperImage.readExifData)(item, res);\n    }).then(function (file) {\n      _this8.logger.info('conversation: file downloaded');\n\n      if (item.displayName && !file.name) {\n        file.name = item.displayName;\n      }\n\n      if (!file.type && item.mimeType) {\n        file.type = item.mimeType;\n      }\n\n      return file;\n    });\n    (0, _common.proxyEvents)(shunt, promise);\n    return promise;\n  },\n\n  /**\n   * Downloads an unencrypted file\n   * @param {string} uri\n   * @param {Object} options\n   * @param {Ojbect} options.headers\n   * @returns {Promise<File>}\n   */\n  _downloadUnencryptedFile: function _downloadUnencryptedFile(uri) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _assign.default)(options, {\n      uri: uri,\n      responseType: 'buffer'\n    });\n    var promise = this.request(options).then(function (res) {\n      return res.body;\n    });\n    (0, _common.proxyEvents)(options.download, promise);\n    return promise;\n  },\n\n  /**\n   * Helper method that expands a set of parameters into an activty object\n   * @param {string} verb\n   * @param {Object} object\n   * @param {Object} target\n   * @param {Object|string} actor\n   * @returns {Object}\n   */\n  expand: function expand(verb, object, target, actor) {\n    var activity = {\n      actor: actor,\n      objectType: 'activity',\n      verb: verb\n    };\n\n    if (!actor) {\n      actor = this.webex.internal.device.userId;\n    }\n\n    if ((0, _isString2.default)(actor)) {\n      activity.actor = {\n        objectType: 'person',\n        id: actor\n      };\n    }\n\n    if (object) {\n      activity.object = object;\n    }\n\n    if (target) {\n      activity.target = target;\n    }\n\n    return activity;\n  },\n\n  /**\n  * Gets an array of activities with an array of activity URLS\n  * @param {Array} activityUrls\n  * @param {Object} options\n  * @param {String} options.cluster cluster where the activities are located\n  * @param {String} options.url base convo url where the activities are located\n  * @returns {Promise<Object>} Resolves with the activities\n  */\n  bulkActivitiesFetch: function bulkActivitiesFetch(activityUrls) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var cluster, url;\n\n    if (typeof options === 'string') {\n      cluster = options;\n    } else {\n      cluster = options.cluster;\n      url = options.url;\n    }\n\n    var resource = 'bulk_activities_fetch';\n    var params = {\n      method: 'POST',\n      body: {\n        activityUrls: activityUrls\n      }\n    };\n\n    if (url) {\n      var uri = \"\".concat(url, \"/\").concat(resource);\n      (0, _assign.default)(params, {\n        uri: uri\n      });\n    } else if (cluster) {\n      var _uri = \"\".concat(this.getUrlFromClusterId({\n        cluster: cluster\n      }), \"/\").concat(resource);\n\n      (0, _assign.default)(params, {\n        uri: _uri\n      });\n    } else {\n      (0, _assign.default)(params, {\n        api: 'conversation',\n        resource: resource\n      });\n    }\n\n    return this.webex.request(params).then(function (res) {\n      var activitiesArr = [];\n\n      if (res.body.multistatus) {\n        res.body.multistatus.forEach(function (statusData) {\n          if (statusData.status === '200' && statusData.data && statusData.data.activity) {\n            activitiesArr.push(statusData.data.activity);\n          }\n        });\n      }\n\n      return activitiesArr;\n    });\n  },\n\n  /**\n   * Fetches a single conversation\n   * @param {Object} conversation\n   * @param {String} [conversation.url] The URL where the conversation is located.\n   * @param {String|UUID} [conversation.user] The user to look up in the conversation service\n   *   If specified, the user lookup will take precedence over the url lookup\n   * @param {Object} options\n   * @returns {Promise<Conversation>}\n   */\n  get: function get(conversation) {\n    var _this9 = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var user = conversation.user;\n    var uri;\n\n    try {\n      uri = !user ? this.getConvoUrl(conversation) : '';\n    } catch (err) {\n      return _promise.default.reject(Error(err));\n    }\n\n    var params = {\n      qs: (0, _assign.default)({\n        uuidEntryFormat: true,\n        personRefresh: true,\n        activitiesLimit: 0,\n        includeConvWithDeletedUserUUID: false,\n        includeParticipants: false\n      }, (0, _omit2.default)(options, 'id', 'user', 'url'))\n    }; // Default behavior is to set includeParticipants=false,\n    // which makes the payload lighter by removing participant info.\n    // If the caller explicitly sets the participantAckFilter or\n    // participantsLimit, we don't want that default setting.\n\n    if ('participantAckFilter' in options || 'participantsLimit' in options) {\n      delete params.qs.includeParticipants;\n    }\n\n    return _promise.default.resolve(user ? this.webex.internal.user.asUUID(user) : null).then(function (userId) {\n      if (userId) {\n        (0, _assign.default)(params, {\n          service: 'conversation',\n          resource: \"conversations/user/\".concat(userId)\n        });\n      } else {\n        params.uri = uri;\n      }\n\n      return _this9.request(params);\n    }).then((0, _common.tap)(function (_ref3) {\n      var body = _ref3.body;\n      var id = body.id,\n          url = body.url;\n\n      _this9._recordUUIDs(body);\n\n      idToUrl.set(id, url);\n    })).then(function (res) {\n      return res.body;\n    });\n  },\n\n  /**\n   * Leaves the conversation or removes the specified user from the specified\n   * conversation\n   * @param {Object} conversation\n   * @param {Object|string} participant If not specified, defaults to current\n   * user\n   * @param {Object} activity Reference to the activity that will eventually be\n   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a\n   * provisional activity\n   * @returns {Promise<Activity>}\n   */\n  leave: function leave(conversation, participant, activity) {\n    var _this10 = this;\n\n    var convoWithUrl = (0, _assign.default)({}, conversation, {\n      url: this.getConvoUrl(conversation)\n    });\n    return _promise.default.resolve().then(function () {\n      if (!participant) {\n        participant = _this10.webex.internal.device.userId;\n      }\n\n      return _this10.webex.internal.user.asUUID(participant).then(function (id) {\n        return _this10.prepare(activity, {\n          verb: 'leave',\n          target: _this10.prepareConversation(convoWithUrl),\n          object: {\n            id: id,\n            objectType: 'person'\n          },\n          kmsMessage: {\n            method: 'delete',\n            uri: \"<KRO>/authorizations?\".concat(_querystring.default.stringify({\n              authId: id\n            }))\n          }\n        });\n      });\n    }).then(function (a) {\n      return _this10.submit(a);\n    });\n  },\n\n  /**\n   * Lists a set of conversations. By default does not fetch activities or\n   * participants\n   * @param {Object} options\n   * @param {boolean} options.summary - when true, use conversationSummary resource\n   * @param {Number} options.conversationsLimit - limit the number of conversations fetched\n   * @param {boolean} options.deferDecrypt - when true, deferDecrypt tells the\n   * payload transformer to normalize (but not decrypt) each received\n   * conversation. Instead, the received conversations will each have a bound\n   * decrypt method that can be executed at the consumer's leisure\n   * @returns {Promise<Array<Conversation>>}\n   */\n  list: function list() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._list({\n      service: 'conversation',\n      resource: options.summary ? 'conversationsSummary' : 'conversations',\n      qs: (0, _omit2.default)(options, ['deferDecrypt', 'summary']),\n      deferDecrypt: options.deferDecrypt,\n      limit: getConvoLimit(options)\n    }).then(function (results) {\n      var _iterator = _createForOfIteratorHelper(results),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var convo = _step.value;\n          idToUrl.set(convo.id, convo.url);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return results;\n    });\n  },\n\n  /**\n   * Paginates through a set of conversations. By default does not fetch activities or\n   * participants\n   * @param {Object} options\n   * @param {boolean} options.deferDecrypt - when true, deferDecrypt tells the\n   * payload transformer to normalize (but not decrypt) each received\n   * conversation. Instead, the received conversations will each have a bound\n   * decrypt method that can be executed at the consumer's leisure\n   * @param {Page} options.page - After the first result has been returned to a consumer,\n   * you can pass the Page back to the sdk to get the next list of results.\n   * @returns {Promise<Array<Conversation>>}\n   */\n  paginate: function paginate() {\n    var _arguments = arguments,\n        _this11 = this;\n\n    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {\n      var options, queryOptions, reqOptions;\n      return _regenerator.default.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              options = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : {};\n\n              if (!options.page) {\n                _context.next = 5;\n                break;\n              }\n\n              if (!(!options.page.links || !options.page.links.next)) {\n                _context.next = 4;\n                break;\n              }\n\n              throw new Error('No link to follow for the provided page');\n\n            case 4:\n              return _context.abrupt(\"return\", _this11.request({\n                url: options.page.links.next\n              }).then(function (res) {\n                return {\n                  page: new _webexCore.Page(res, _this11.webex)\n                };\n              }));\n\n            case 5:\n              // No page - so this is the first request to kick off the pagination process\n              queryOptions = (0, _assign.default)({\n                personRefresh: true,\n                uuidEntryFormat: true,\n                activitiesLimit: 0,\n                participantsLimit: 0,\n                paginate: true\n              }, (0, _omit2.default)(options, ['deferDecrypt', 'url']));\n              reqOptions = {\n                qs: queryOptions,\n                deferDecrypt: options.deferDecrypt,\n                limit: getConvoLimit(options)\n              }; // if options.url is present we likely received one or more additional urls due to federation. In this case\n              // we need to initialize pagination against that url instead of the default home cluster\n\n              if (options.url) {\n                reqOptions.uri = \"\".concat(options.url, \"/conversations\");\n              } else {\n                reqOptions.service = 'conversation';\n                reqOptions.resource = 'conversations';\n              }\n\n              return _context.abrupt(\"return\", _this11.request(reqOptions).then(function (res) {\n                var response = {\n                  page: new _webexCore.Page(res, _this11.webex)\n                };\n\n                if (res.body && res.body.additionalUrls) {\n                  response.additionalUrls = res.body.additionalUrls;\n                }\n\n                return response;\n              }));\n\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }))();\n  },\n\n  /**\n   * Lists the conversations the current user has left. By default does not\n   * fetch activities or participants\n   * @param {Object} options\n   * @returns {Promise<Array<Conversation>>}\n   */\n  listLeft: function listLeft(options) {\n    return this._list({\n      service: 'conversation',\n      resource: 'conversations/left',\n      qs: options,\n      limit: getConvoLimit(options)\n    }).then(function (results) {\n      var _iterator2 = _createForOfIteratorHelper(results),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var convo = _step2.value;\n          idToUrl.set(convo.id, convo.url);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return results;\n    });\n  },\n\n  /**\n   * List activities for the specified conversation\n   * @param {Object} options\n   * @param {String} options.conversationUrl URL to the conversation\n   * @returns {Promise<Array<Activity>>}\n   */\n  listActivities: function listActivities(options) {\n    return this._listActivities((0, _assign.default)(options, {\n      resource: 'activities'\n    }));\n  },\n\n  /**\n   * @typedef QueryOptions\n   * @param {number} [limit] The limit of child activities that can be returned per request\n   * @param {boolean} [latestActivityFirst] Sort order for the child activities\n   * @param {boolean} [includeParentActivity] Enables the parent activity to be returned in the activity list\n   * @param {string} [sinceDate] Get all child activities after this date\n   * @param {string} [maxDate] Get all child activities before this date\n   * @param {boolean} [latestActivityFirst] Sort order for the child activities\n   * @param {string} [activityType] The type of children to return the parents of, a null value here returns parents of all types of children.\n   * The value is one of 'reply', 'edit', 'cardAction', 'reaction', 'reactionSummary', 'reactionSelfSummary'\n   */\n\n  /**\n   * Get all parent ids for a conversation.\n   * @param {string} conversationUrl conversation URL.\n   * @param {QueryOptions} [query] object containing query string values to be appended to the url\n   * @returns {Promise<Array<String>>}\n   */\n  listParentActivityIds: function listParentActivityIds(conversationUrl, query) {\n    var _this12 = this;\n\n    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {\n      var params, response;\n      return _regenerator.default.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              params = {\n                method: 'GET',\n                url: \"\".concat(conversationUrl, \"/parents\"),\n                qs: query\n              };\n              _context2.next = 3;\n              return _this12.request(params);\n\n            case 3:\n              response = _context2.sent;\n              return _context2.abrupt(\"return\", response.body);\n\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }))();\n  },\n\n  /**\n   * Returns a list of _all_ child activities for a given parentId within a given conversation\n   * @param {object} [options = {}]\n   * @param {string} [options.conversationUrl] targeted conversation URL\n   * @param {string} [options.activityParentId] parent id of edit activities or thread activities\n   * @param {QueryOptions} [options.query] object containing query string values to be appended to the url\n   * @returns {Promise<Array>}\n   */\n  listAllChildActivitiesByParentId: function listAllChildActivitiesByParentId() {\n    var _arguments2 = arguments,\n        _this13 = this;\n\n    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {\n      var options, conversationUrl, activityParentId, query, activityType, initialResponse, page, items, _iterator3, _step3, activity;\n\n      return _regenerator.default.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              options = _arguments2.length > 0 && _arguments2[0] !== undefined ? _arguments2[0] : {};\n              conversationUrl = options.conversationUrl, activityParentId = options.activityParentId, query = options.query;\n              activityType = query.activityType;\n              _context3.next = 5;\n              return _this13.listChildActivitiesByParentId(conversationUrl, activityParentId, activityType, query);\n\n            case 5:\n              initialResponse = _context3.sent;\n              page = new _webexCore.Page(initialResponse, _this13.webex);\n              items = (0, _toConsumableArray2.default)(page.items);\n\n            case 8:\n              if (!page.hasNext()) {\n                _context3.next = 16;\n                break;\n              }\n\n              _context3.next = 11;\n              return page.next();\n\n            case 11:\n              page = _context3.sent;\n              _iterator3 = _createForOfIteratorHelper(page);\n\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  activity = _step3.value;\n                  items.push(activity);\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n\n              _context3.next = 8;\n              break;\n\n            case 16:\n              // reverse list if needed (see _list for precedent)\n              if (items.length && (0, _last2.default)(items).published < items[0].published) {\n                items.reverse();\n              }\n\n              return _context3.abrupt(\"return\", items);\n\n            case 18:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }))();\n  },\n\n  /**\n   * Return a list of child activities with a given conversation, parentId and other constraints.\n   * @param {string} conversationUrl targeted conversation URL\n   * @param {string} activityParentId parent id of edit activities or thread activities\n   * @param {string} activityType type of child activity to return\n   * The value is one of 'reply', 'edit', 'cardAction', 'reaction', 'reactionSummary', 'reactionSelfSummary'\n   * @param {QueryOptions} [query = {}] object containing query string values to be appended to the url\n   * @returns {Promise<Array>}\n   */\n  listChildActivitiesByParentId: function listChildActivitiesByParentId(conversationUrl, activityParentId, activityType) {\n    var _arguments3 = arguments,\n        _this14 = this;\n\n    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {\n      var query, finalQuery, params;\n      return _regenerator.default.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              query = _arguments3.length > 3 && _arguments3[3] !== undefined ? _arguments3[3] : {};\n              finalQuery = _objectSpread(_objectSpread({}, query), {}, {\n                activityType: activityType\n              });\n              params = {\n                method: 'GET',\n                url: \"\".concat(conversationUrl, \"/parents/\").concat(activityParentId),\n                qs: finalQuery\n              };\n              return _context4.abrupt(\"return\", _this14.request(params));\n\n            case 4:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }))();\n  },\n\n  /**\n   * Return an array of reactionSummary and reactionSelfSummary objects\n   * @param {string} conversationUrl targeted conversation URL\n   * @param {string} activityParentId parent id of reaction activities\n   * @param {QueryOptions} query object representing query parameters to pass to convo endpoint\n   * @returns {Promise<Array>}\n   */\n  getReactionSummaryByParentId: function getReactionSummaryByParentId(conversationUrl, activityParentId, query) {\n    var _this15 = this;\n\n    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5() {\n      var _yield$_this15$reques, body, reactionObjects;\n\n      return _regenerator.default.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.next = 2;\n              return _this15.request({\n                method: 'GET',\n                url: \"\".concat(conversationUrl, \"/activities/\").concat(activityParentId),\n                qs: query\n              });\n\n            case 2:\n              _yield$_this15$reques = _context5.sent;\n              body = _yield$_this15$reques.body;\n              reactionObjects = body.children ? body.children.filter(function (child) {\n                return child.type === 'reactionSelfSummary' || child.type === 'reactionSummary';\n              }) : [];\n              return _context5.abrupt(\"return\", reactionObjects);\n\n            case 6:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }))();\n  },\n\n  /**\n   * Lists activities in which the current user was mentioned\n   * @param {Object} options\n   * @returns {Promise<Array<Activity>>}\n   */\n  listMentions: function listMentions(options) {\n    return this._list({\n      service: 'conversation',\n      resource: 'mentions',\n      qs: (0, _omit2.default)(options, 'mentions')\n    });\n  },\n\n  /**\n   * Mutes the mentions of a conversation\n   * @param {Conversation~ConversationObject} conversation\n   * @param {Conversation~ActivityObject} activity\n   * @returns {Promise} Resolves with the created activity\n   */\n  muteMentions: function muteMentions(conversation, activity) {\n    return this.tag(conversation, {\n      tags: ['MENTION_NOTIFICATIONS_OFF']\n    }, activity);\n  },\n\n  /**\n   * Mutes the messages of a conversation\n   * @param {Conversation~ConversationObject} conversation\n   * @param {Conversation~ActivityObject} activity\n   * @returns {Promise} Resolves with the created activity\n   */\n  muteMessages: function muteMessages(conversation, activity) {\n    return this.tag(conversation, {\n      tags: ['MESSAGE_NOTIFICATIONS_OFF']\n    }, activity);\n  },\n\n  /**\n   * Starts ignoring conversation\n   * @param {Conversation~ConversationObject} conversation\n   * @param {Conversation~ActivityObject} activity\n   * @returns {Promise} Resolves with the created activity\n   */\n  ignore: function ignore(conversation, activity) {\n    return this.tag(conversation, {\n      tags: ['IGNORED']\n    }, activity);\n  },\n\n  /**\n   * @param {Object} conversation\n   * @param {Object} inputs\n   * @param {Object} parentActivity\n   * @param {Object} activity\n   * @returns {Promise}\n   */\n  cardAction: function cardAction(conversation, inputs, parentActivity) {\n    var _this16 = this;\n\n    var activity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var convoWithUrl = (0, _assign.default)({}, conversation, {\n      url: this.getConvoUrl(conversation)\n    });\n    activity.parent = {\n      id: parentActivity.id,\n      type: 'cardAction'\n    };\n    return this.prepare(activity, {\n      verb: 'cardAction',\n      target: this.prepareConversation(convoWithUrl),\n      object: (0, _assign.default)({\n        objectType: 'submit'\n      }, inputs)\n    }).then(function (a) {\n      return _this16.submit(a);\n    });\n  },\n\n  /**\n   * Posts a message to a conversation\n   * @param {Object} conversation\n   * @param {Object|string} message if string, treated as plaintext; if object,\n   * assumed to be object property of `post` activity\n   * @param {Object} activity Reference to the activity that will eventually be\n   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a\n   * provisional activity\n   * @returns {Promise<Activity>}\n   */\n  post: function post(conversation, message, activity) {\n    var _this17 = this;\n\n    var convoWithUrl = (0, _assign.default)({}, conversation, {\n      url: this.getConvoUrl(conversation)\n    });\n\n    if ((0, _isString2.default)(message)) {\n      message = {\n        displayName: message\n      };\n    }\n\n    return this.prepare(activity, {\n      verb: 'post',\n      target: this.prepareConversation(convoWithUrl),\n      object: (0, _assign.default)({\n        objectType: 'comment'\n      }, message)\n    }).then(function (a) {\n      return _this17.submit(a);\n    });\n  },\n  prepareConversation: function prepareConversation(conversation) {\n    return (0, _defaults2.default)((0, _pick2.default)(conversation, 'id', 'url', 'objectType', 'defaultActivityEncryptionKeyUrl', 'kmsResourceObjectUrl'), {\n      objectType: 'conversation'\n    });\n  },\n  prepare: function prepare(activity, params) {\n    var _this18 = this;\n\n    params = params || {};\n    activity = activity || {};\n    return _promise.default.resolve(activity.prepare ? activity.prepare(params) : activity).then(function (act) {\n      (0, _defaults2.default)(act, {\n        verb: params.verb,\n        kmsMessage: params.kmsMessage,\n        objectType: 'activity',\n        clientTempId: _uuid.default.v4(),\n        actor: _this18.webex.internal.device.userId\n      }); // Workaround because parent is a reserved props in Ampersand\n\n      if (activity.parentActivityId && activity.activityType || activity.parent && activity.parent.id && activity.parent.type) {\n        act.parent = {\n          id: activity.parentActivityId || activity.parent.id,\n          type: activity.activityType || activity.parent.type\n        };\n      }\n\n      if ((0, _isString2.default)(act.actor)) {\n        act.actor = {\n          objectType: 'person',\n          id: act.actor\n        };\n      }\n\n      ['actor', 'object'].forEach(function (key) {\n        if (params[key]) {\n          act[key] = act[key] || {};\n          (0, _defaults2.default)(act[key], params[key]);\n        }\n      });\n\n      if (params.target) {\n        (0, _merge2.default)(act, {\n          target: (0, _pick2.default)(params.target, 'id', 'url', 'objectType', 'kmsResourceObjectUrl', 'defaultActivityEncryptionKeyUrl')\n        });\n      }\n\n      ['object', 'target'].forEach(function (key) {\n        if (act[key] && act[key].url && !act[key].id) {\n          act[key].id = act[key].url.split('/').pop();\n        }\n      });\n      ['actor', 'object', 'target'].forEach(function (key) {\n        if (act[key] && !act[key].objectType) {\n          // Reminder: throwing here because it's the only way to get out of\n          // this loop in event of an error.\n          throw new Error(\"`act.\".concat(key, \".objectType` must be defined\"));\n        }\n      });\n\n      if (act.object && act.object.content && !act.object.displayName) {\n        return _promise.default.reject(new Error('Cannot submit activity object with `content` but no `displayName`'));\n      }\n\n      return act;\n    });\n  },\n\n  /**\n  * Get a subset of threads for a user.\n  * @param {Object} options\n  * @returns {Promise<Array<Activity>>}\n  */\n  listThreads: function listThreads(options) {\n    var _this19 = this;\n\n    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6() {\n      return _regenerator.default.wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              return _context6.abrupt(\"return\", _this19._list({\n                service: 'conversation',\n                resource: 'threads',\n                qs: (0, _omit2.default)(options, 'showAllTypes')\n              }));\n\n            case 1:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee6);\n    }))();\n  },\n\n  /**\n   * Handles incoming conversation.activity mercury messages\n   * @param {Event} event\n   * @returns {Promise}\n   */\n  processActivityEvent: function processActivityEvent(event) {\n    return this.webex.transform('inbound', event).then(function () {\n      return event;\n    });\n  },\n\n  /**\n   * Removes all mute-related tags\n   * @param {Conversation~ConversationObject} conversation\n   * @param {Conversation~ActivityObject} activity\n   * @returns {Promise} Resolves with the created activity\n   */\n  removeAllMuteTags: function removeAllMuteTags(conversation, activity) {\n    return this.untag(conversation, {\n      tags: ['MENTION_NOTIFICATIONS_OFF', 'MENTION_NOTIFICATIONS_ON', 'MESSAGE_NOTIFICATIONS_OFF', 'MESSAGE_NOTIFICATIONS_ON']\n    }, activity);\n  },\n\n  /**\n   * Creates a ShareActivty for the specified conversation\n   * @param {Object} conversation\n   * @param {Object} activity\n   * @returns {ShareActivty}\n   */\n  makeShare: function makeShare(conversation, activity) {\n    // if we pass activity as null then it does not take care of the\n    // clientTempId created by the web-client while making the provisional\n    // activity, hence we need to pass the activity which was created by the\n    // web-client. This fixes the issue where the image activities do not come\n    // back properly oriented from the server since the clientTempId is missing\n    return _shareActivity.default.create(conversation, activity, this.webex);\n  },\n\n  /**\n   * Assigns an avatar to a room\n   * @param {Object} conversation\n   * @param {File} avatar\n   * @returns {Promise<Activity>}\n   */\n  assign: function assign(conversation, avatar) {\n    var _this20 = this;\n\n    var uploadOptions = {\n      role: 'spaceAvatar'\n    };\n\n    if ((avatar.size || avatar.length) > 1024 * 1024) {\n      return _promise.default.reject(new Error('Room avatars must be less than 1MB'));\n    }\n\n    var convoWithUrl = (0, _assign.default)({}, conversation, {\n      url: this.getConvoUrl(conversation)\n    });\n    return _promise.default.resolve().then(function () {\n      var activity = _shareActivity.default.create(conversation, null, _this20.webex);\n\n      activity.enableThumbnails = false;\n      activity.add(avatar, uploadOptions);\n      return _this20.prepare(activity, {\n        target: _this20.prepareConversation(convoWithUrl)\n      });\n    }).then(function (a) {\n      // yes, this seems a little hacky; will likely be resolved as a result\n      // of #213\n      a.verb = 'assign';\n      return _this20.submit(a);\n    });\n  },\n\n  /**\n   * Get url from convo object. If there isn't one, get it from the cache\n   *\n   * @param {String} url The location of the conversation\n   * @param {UUID} id If there is no url, fall back to id to lookup in cache or with cluster\n   * @param {String} cluster Used with id to lookup url\n   * @param {UUID} generalConversationUuid If this is a team, the id of the general conversation\n   * @param {Object} conversations If this is a team, the list of conversations in the team\n   * @returns {String} url for the specific convo\n   */\n  getConvoUrl: function getConvoUrl(_ref4) {\n    var id = _ref4.id,\n        url = _ref4.url,\n        cluster = _ref4.cluster,\n        conversations = _ref4.conversations,\n        generalConversationUuid = _ref4.generalConversationUuid;\n\n    if (generalConversationUuid) {\n      // This is a Team\n      // Because Convo doesn't have an endpoint for the team URL\n      // we have to use the general convo URL.\n      var generalConvo = conversations.items.find(function (convo) {\n        return convo.id === generalConversationUuid;\n      });\n      return generalConvo.url;\n    }\n\n    if (url) {\n      return url;\n    }\n\n    if (id) {\n      if (cluster) {\n        return this.getUrlFromClusterId({\n          cluster: cluster,\n          id: id\n        });\n      }\n\n      this.logger.warn('You should be using the `url` instead of the `id` property');\n      var relatedUrl = idToUrl.get(id);\n\n      if (!relatedUrl) {\n        throw Error('Could not find the `url` from the given `id`');\n      }\n\n      return relatedUrl;\n    }\n\n    throw Error('The space needs a `url` property');\n  },\n\n  /**\n   * Sets the typing status of the current user in a conversation\n   *\n   * @param {Object} conversation\n   * @param {Object} options\n   * @param {boolean} options.typing\n   * @returns {Promise}\n   */\n  updateTypingStatus: function updateTypingStatus(conversation, options) {\n    if (!conversation.id) {\n      if (conversation.url) {\n        conversation.id = conversation.url.split('/').pop();\n      } else {\n        return _promise.default.reject(new Error('conversation: could not identify conversation'));\n      }\n    }\n\n    var eventType;\n\n    if (options.typing) {\n      eventType = 'status.start_typing';\n    } else {\n      eventType = 'status.stop_typing';\n    }\n\n    var url = this.getConvoUrl(conversation);\n    var resource = 'status/typing';\n    var params = {\n      method: 'POST',\n      body: {\n        conversationId: conversation.id,\n        eventType: eventType\n      },\n      url: \"\".concat(url, \"/\").concat(resource)\n    };\n    return this.request(params);\n  },\n\n  /**\n   * Shares files to the specified conversation\n   * @param {Object} conversation\n   * @param {ShareActivity|Array<File>} activity\n   * @returns {Promise<Activity>}\n   */\n  share: function share(conversation, activity) {\n    var _this21 = this;\n\n    if ((0, _isArray2.default)(activity)) {\n      activity = {\n        object: {\n          files: activity\n        }\n      };\n    }\n\n    var convoWithUrl = (0, _assign.default)({}, conversation, {\n      url: this.getConvoUrl(conversation)\n    });\n\n    if (!(activity instanceof _shareActivity.default)) {\n      activity = _shareActivity.default.create(convoWithUrl, activity, this.webex);\n    }\n\n    return this.prepare(activity, {\n      target: this.prepareConversation(convoWithUrl)\n    }).then(function (a) {\n      return _this21.submit(a);\n    });\n  },\n\n  /**\n   * Submits an activity to the conversation service\n   * @param {Object} activity\n   * @param {String} [endpoint] endpoint to submit activity. If empty, find in activity\n   * @returns {Promise<Activity>}\n   */\n  submit: function submit(activity, endpoint) {\n    var _this22 = this;\n\n    var url = endpoint || this.getConvoUrl(activity.target);\n    var resource = activity.verb === 'share' ? 'content' : 'activities';\n    var params = {\n      method: 'POST',\n      body: activity,\n      qs: {\n        personRefresh: true\n      },\n      url: \"\".concat(url, \"/\").concat(resource)\n    };\n\n    if (activity.verb === 'share') {\n      (0, _assign.default)(params.qs, {\n        transcode: true,\n        async: false\n      });\n    }\n    /**\n     * helper to cloneDeepWith for copying instance function\n     * @param {Object|String|Symbol|Array|Date} value (recursive value to clone from params)\n     * @returns {Object|null}\n     */\n    // eslint-disable-next-line consistent-return\n\n\n    var customActivityCopy = function customActivityCopy(value) {\n      var files = params.body.object.files;\n\n      if (files && value && files.items.length > 0 && value.constructor === files.items[0].scr.constructor) {\n        var copySrc = (0, _cloneDeep2.default)(value);\n        copySrc.toJWE = value.toJWE;\n        copySrc.toJSON = value.toJSON;\n        return copySrc;\n      }\n    };\n\n    var cloneActivity = (0, _cloneDeepWith2.default)(params, customActivityCopy); // triggers user-activity to reset logout timer\n\n    this.webex.trigger('user-activity');\n    return this.request(params).then(function (res) {\n      return res.body;\n    }).catch(function (error) {\n      // handle when key need to rotate\n      if (error.body && error.body.errorCode === _constants.KEY_ROTATION_REQUIRED) {\n        cloneActivity.body.target.defaultActivityEncryptionKeyUrl = null;\n\n        _this22.request(cloneActivity);\n      } else if (error.body && (error.body.errorCode === _constants.KEY_ALREADY_ROTATED || error.body.errorCode === _constants.ENCRYPTION_KEY_URL_MISMATCH)) {\n        // handle when key need to update\n        _this22.webex.request({\n          method: 'GET',\n          api: 'conversation',\n          resource: \"conversations/\".concat(params.body.target.id)\n        }).then(function (res) {\n          cloneActivity.body.target.defaultActivityEncryptionKeyUrl = res.body.defaultActivityEncryptionkeyUrl;\n\n          _this22.request(cloneActivity);\n        });\n      } else {\n        throw error;\n      }\n    });\n  },\n\n  /**\n   * Remove the avatar from a room\n   * @param {Conversation~ConversationObject} conversation\n   * @param {Conversation~ActivityObject} activity\n   * @returns {Promise}\n   */\n  unassign: function unassign(conversation, activity) {\n    var _this23 = this;\n\n    var convoWithUrl = (0, _assign.default)({}, conversation, {\n      url: this.getConvoUrl(conversation)\n    });\n    return this.prepare(activity, {\n      verb: 'unassign',\n      target: this.prepareConversation(convoWithUrl),\n      object: {\n        objectType: 'content',\n        files: {\n          items: []\n        }\n      }\n    }).then(function (a) {\n      return _this23.submit(a);\n    });\n  },\n\n  /**\n   * Mutes the mentions of a conversation\n   * @param {Conversation~ConversationObject} conversation\n   * @param {Conversation~ActivityObject} activity\n   * @returns {Promise} Resolves with the created activity\n   */\n  unmuteMentions: function unmuteMentions(conversation, activity) {\n    return this.tag(conversation, {\n      tags: ['MENTION_NOTIFICATIONS_ON']\n    }, activity);\n  },\n\n  /**\n   * Mutes the messages of a conversation\n   * @param {Conversation~ConversationObject} conversation\n   * @param {Conversation~ActivityObject} activity\n   * @returns {Promise} Resolves with the created activity\n   */\n  unmuteMessages: function unmuteMessages(conversation, activity) {\n    return this.tag(conversation, {\n      tags: ['MESSAGE_NOTIFICATIONS_ON']\n    }, activity);\n  },\n\n  /**\n   * Stops ignoring conversation\n   * @param {Conversation~ConversationObject} conversation\n   * @param {Conversation~ActivityObject} activity\n   * @returns {Promise} Resolves with the created activity\n   */\n  unignore: function unignore(conversation, activity) {\n    return this.untag(conversation, {\n      tags: ['IGNORED']\n    }, activity);\n  },\n\n  /**\n   * Update an existing activity\n   * @param {Object} conversation\n   * @param {Object} object\n   * @param {Object} activity\n   * @returns {Promise}\n   */\n  update: function update(conversation, object, activity) {\n    var _this24 = this;\n\n    if (!(0, _isObject2.default)(object)) {\n      return _promise.default.reject(new Error('`object` must be an object'));\n    }\n\n    var convoWithUrl = (0, _assign.default)({}, conversation, {\n      url: this.getConvoUrl(conversation)\n    });\n    return this.prepare(activity, {\n      verb: 'update',\n      target: this.prepareConversation(convoWithUrl),\n      object: object\n    }).then(function (a) {\n      return _this24.submit(a);\n    });\n  },\n\n  /**\n   * Sets a new key for the conversation\n   * @param {Object} conversation\n   * @param {Key|string} key (optional)\n   * @param {Object} activity Reference to the activity that will eventually be\n   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a\n   * provisional activity\n   * @returns {Promise<Activity>}\n   */\n  updateKey: function updateKey(conversation, key, activity) {\n    var _this25 = this;\n\n    var convoWithUrl = (0, _assign.default)({}, conversation, {\n      url: this.getConvoUrl(conversation)\n    });\n    return this.get(convoWithUrl, {\n      activitiesLimit: 0,\n      includeParticipants: true\n    }).then(function (c) {\n      return _this25._updateKey(c, key, activity);\n    });\n  },\n\n  /**\n   * Sets a new key for the conversation\n   * @param {Object} conversation\n   * @param {Key|string} key (optional)\n   * @param {Object} activity Reference to the activity that will eventually be\n   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a\n   * provisional activity\n   * @private\n   * @returns {Promise<Activity>}\n   */\n  _updateKey: function _updateKey(conversation, key, activity) {\n    var _this26 = this;\n\n    var convoWithUrl = (0, _assign.default)({}, conversation, {\n      url: this.getConvoUrl(conversation)\n    });\n    return _promise.default.resolve(key || this.webex.internal.encryption.kms.createUnboundKeys({\n      count: 1\n    })).then(function (keys) {\n      var k = (0, _isArray2.default)(keys) ? keys[0] : keys;\n      var params = {\n        verb: 'updateKey',\n        target: _this26.prepareConversation(convoWithUrl),\n        object: {\n          defaultActivityEncryptionKeyUrl: k.uri,\n          objectType: 'conversation'\n        }\n      }; // Reminder: the kmsResourceObjectUrl is only usable if there is\n      // defaultActivityEncryptionKeyUrl.\n      // Valid defaultActivityEncryptionKeyUrl start with 'kms:'\n\n      if (convoWithUrl.kmsResourceObjectUrl && convoWithUrl.kmsResourceObjectUrl.startsWith('kms:')) {\n        params.kmsMessage = {\n          method: 'update',\n          resourceUri: '<KRO>',\n          uri: k.uri\n        };\n      } else {\n        params.kmsMessage = {\n          method: 'create',\n          uri: '/resources',\n          userIds: (0, _map3.default)(convoWithUrl.participants.items, 'id'),\n          keyUris: [k.uri]\n        };\n      }\n\n      return _this26.prepare(activity, params).then(function (a) {\n        return _this26.submit(a);\n      });\n    });\n  },\n\n  /**\n   * @param {Object} payload\n   * @param {Object} options\n   * @private\n   * @returns {Promise<Activity>}\n   */\n  _create: function _create(payload) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.request({\n      method: 'POST',\n      service: 'conversation',\n      resource: 'conversations',\n      body: payload,\n      qs: {\n        forceCreate: options.allowPartialCreation\n      }\n    }).then(function (res) {\n      return res.body;\n    });\n  },\n\n  /**\n   * @param {Object} params\n   * @param {Object} options\n   * @private\n   * @returns {Promise}\n   */\n  _createGrouped: function _createGrouped(params, options) {\n    return this._create(this._prepareConversationForCreation(params), options);\n  },\n\n  /**\n   * @param {Object} params\n   * @param {Object} options\n   * @private\n   * @returns {Promise}\n   */\n  _createOneOnOne: function _createOneOnOne(params) {\n    var payload = this._prepareConversationForCreation(params);\n\n    payload.tags = ['ONE_ON_ONE'];\n    return this._create(payload);\n  },\n\n  /**\n   * Get the current conversation url.\n   *\n   * @returns {Promise<string>} - conversation url\n   */\n  getConversationUrl: function getConversationUrl() {\n    var _this27 = this;\n\n    this.logger.info('conversation: getting the conversation service url');\n    var convoUrl = this.webex.internal.services.get('conversation'); // Validate if the conversation url exists in the services plugin and\n    // resolve with its value.\n\n    if (convoUrl) {\n      return _promise.default.resolve(convoUrl);\n    } // Wait for the postauth catalog to update and then try to retrieve the\n    // conversation service url again.\n\n\n    return this.webex.internal.waitForCatalog('postauth').then(function () {\n      return _this27.webex.internal.services.get('conversation');\n    }).catch(function (error) {\n      _this27.logger.warn('conversation: unable to get conversation url', error.message);\n\n      return _promise.default.reject(error);\n    });\n  },\n\n  /**\n   * @param {Object} conversation\n   * @private\n   * @returns {Promise}\n   */\n  _inferConversationUrl: function _inferConversationUrl(conversation) {\n    var _this28 = this;\n\n    if (conversation.id) {\n      return this.webex.internal.feature.getFeature('developer', 'web-high-availability').then(function (haMessagingEnabled) {\n        if (haMessagingEnabled) {\n          // recompute conversation URL each time as the host may have changed\n          // since last usage\n          return _this28.getConversationUrl().then(function (url) {\n            conversation.url = \"\".concat(url, \"/conversations/\").concat(conversation.id);\n            return conversation;\n          });\n        }\n\n        if (!conversation.url) {\n          return _this28.getConversationUrl().then(function (url) {\n            conversation.url = \"\".concat(url, \"/conversations/\").concat(conversation.id);\n            /* istanbul ignore else */\n\n            if (process.env.NODE_ENV !== 'production') {\n              _this28.logger.warn('conversation: inferred conversation url from conversation id; please pass whole conversation objects to Conversation methods');\n            }\n\n            return conversation;\n          });\n        }\n\n        return _promise.default.resolve(conversation);\n      });\n    }\n\n    return _promise.default.resolve(conversation);\n  },\n\n  /**\n   * @param {Object} options\n   * @param {String} options.conversationUrl URL to the conversation\n   * @param {String} options.resource The URL resource to hit for a list of objects\n   * @private\n   * @returns {Promise<Array<Activity>>}\n   */\n  _listActivities: function _listActivities(options) {\n    var id = options.conversationId;\n    var url = this.getConvoUrl({\n      url: options.conversationUrl,\n      id: id\n    });\n    var resource = options.resource;\n    return this._list({\n      qs: (0, _omit2.default)(options, 'resource'),\n      url: \"\".concat(url, \"/\").concat(resource)\n    });\n  },\n\n  /**\n   * common interface for facade of generator functions\n   * @typedef {object} IGeneratorResponse\n   * @param {boolean} done whether there is more to fetch\n   * @param {any} value the value yielded or returned by generator\n   */\n\n  /**\n   * @param {object} options\n   * @param {string} options.conversationId\n   * @param {string} options.conversationUrl,\n   * @param {boolean} options.includeChildren, If set to true, parent activities will be enhanced with child objects\n   * @param {number} options.minActivities how many activities to return in first batch\n   * @param {?string} [options.queryType] one of older, newer, mid. defines which direction to fetch\n   * @param {?object} [options.search] server activity to use as search middle date\n   *\n   * @returns {object}\n   * returns three functions:\n   *\n   * getOlder - gets older activities than oldest fetched\n   *\n   * getNewer - gets newer activities than newest fetched\n   *\n   * jumpToActivity - gets searched-for activity and surrounding activities\n   */\n  listActivitiesThreadOrdered: function listActivitiesThreadOrdered(options) {\n    var _this29 = this;\n\n    var conversationUrl = options.conversationUrl,\n        conversationId = options.conversationId;\n\n    if (!conversationUrl && !conversationId) {\n      throw new Error('must provide a conversation URL or conversation ID');\n    }\n\n    var url = this.getConvoUrl({\n      url: conversationUrl,\n      id: conversationId\n    });\n\n    var baseOptions = _objectSpread(_objectSpread({}, (0, _omit2.default)(options, ['conversationUrl', 'conversationId'])), {}, {\n      url: url\n    });\n\n    var olderOptions = _objectSpread(_objectSpread({}, baseOptions), {}, {\n      queryType: _activities.OLDER\n    });\n\n    var threadOrderer = this._listActivitiesThreadOrdered(baseOptions);\n    /**\n     * gets queried activity and surrounding activities\n     * calling this function creates a new generator instance, losing the previous instance's internal state\n     * this ensures that jumping to older and newer activities is relative to a single set of timestamps, not many\n     * @param {object} searchObject activity object from convo\n     * @returns {IGeneratorResponse}\n     */\n\n\n    var jumpToActivity = /*#__PURE__*/function () {\n      var _ref5 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7(searchObject) {\n        var newUrl, searchOptions, _yield$threadOrderer$, searchResults;\n\n        return _regenerator.default.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (searchObject) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                throw new Error('Search must be an activity object from conversation service');\n\n              case 2:\n                newUrl = searchObject.target && searchObject.target.url;\n\n                if (newUrl) {\n                  _context7.next = 5;\n                  break;\n                }\n\n                throw new Error('Search object must have a target url!');\n\n              case 5:\n                searchOptions = _objectSpread(_objectSpread({}, baseOptions), {}, {\n                  url: newUrl,\n                  queryType: _activities.MID,\n                  search: searchObject\n                });\n                threadOrderer = _this29._listActivitiesThreadOrdered(searchOptions);\n                _context7.next = 9;\n                return threadOrderer.next(searchOptions);\n\n              case 9:\n                _yield$threadOrderer$ = _context7.sent;\n                searchResults = _yield$threadOrderer$.value;\n                return _context7.abrupt(\"return\", {\n                  done: true,\n                  value: searchResults\n                });\n\n              case 12:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n\n      return function jumpToActivity(_x) {\n        return _ref5.apply(this, arguments);\n      };\n    }();\n    /**\n     * gets older activities than oldest fetched\n     * @returns {IGeneratorResponse}\n     */\n\n\n    var getOlder = /*#__PURE__*/function () {\n      var _ref6 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8() {\n        var _yield$threadOrderer$2, _yield$threadOrderer$3, value, oldestInBatch, moreActivitiesExist;\n\n        return _regenerator.default.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return threadOrderer.next(olderOptions);\n\n              case 2:\n                _yield$threadOrderer$2 = _context8.sent;\n                _yield$threadOrderer$3 = _yield$threadOrderer$2.value;\n                value = _yield$threadOrderer$3 === void 0 ? [] : _yield$threadOrderer$3;\n                oldestInBatch = value[0] && value[0].activity;\n                moreActivitiesExist = oldestInBatch && (0, _activities.getActivityType)(oldestInBatch) !== _activities.ACTIVITY_TYPES.CREATE;\n                return _context8.abrupt(\"return\", {\n                  done: !moreActivitiesExist,\n                  value: value\n                });\n\n              case 8:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }));\n\n      return function getOlder() {\n        return _ref6.apply(this, arguments);\n      };\n    }();\n    /**\n     * gets newer activities than newest fetched\n     * @returns {IGeneratorResponse}\n     */\n\n\n    var getNewer = /*#__PURE__*/function () {\n      var _ref7 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee9() {\n        var newerOptions, _yield$threadOrderer$4, value;\n\n        return _regenerator.default.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                newerOptions = _objectSpread(_objectSpread({}, baseOptions), {}, {\n                  queryType: _activities.NEWER\n                });\n                _context9.next = 3;\n                return threadOrderer.next(newerOptions);\n\n              case 3:\n                _yield$threadOrderer$4 = _context9.sent;\n                value = _yield$threadOrderer$4.value;\n                return _context9.abrupt(\"return\", {\n                  done: !value.length,\n                  value: value\n                });\n\n              case 6:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9);\n      }));\n\n      return function getNewer() {\n        return _ref7.apply(this, arguments);\n      };\n    }();\n\n    return {\n      jumpToActivity: jumpToActivity,\n      getNewer: getNewer,\n      getOlder: getOlder\n    };\n  },\n\n  /**\n    * Represents reactions to messages\n    * @typedef {object} Reaction\n    * @property {object} activity reaction2summary server activity object\n    */\n\n  /**\n   * Represents a root (parent, with or without children) activity, along with any replies and reactions\n   * @typedef {object} Activity\n   * @property {object} activity server activity object\n   * @property {Reaction} reactions\n   * @property {Reaction} reactionSelf\n   */\n\n  /**\n   * @generator\n   * @method\n   * @async\n   * @private\n   * @param {object} options\n   * @param {string} options.url\n   * @param {boolean} options.includeChildren, If set to true, parent activities will be enhanced with child objects\n   * @param {string} [options.minActivities] how many activities to return in first batch\n   * @param {string} [options.queryType] one of older, newer, mid. defines which direction to fetch\n   * @param {object} [options.search] server activity to use as search middle date\n   *\n   * @yields {Activity[]}\n   *\n   * @returns {void}\n   */\n  _listActivitiesThreadOrdered: function _listActivitiesThreadOrdered() {\n    var _this = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return (0, _wrapAsyncGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee10() {\n      var _options$minActivitie, minActivities, _options$queryType, queryType, convoUrl, _options$search, search, includeChildren, _bookendManager, setBookends, getNewestAct, getOldestAct, defaultBatchSize, batchSize, _activityManager, getActivityHandlerByKey, getActivityByTypeAndParentId, query, _loop, _ret;\n\n      return _regenerator.default.wrap(function _callee10$(_context12) {\n        while (1) {\n          switch (_context12.prev = _context12.next) {\n            case 0:\n              // ***********************************************\n              // INSTANCE STATE VARIABLES\n              // variables that will be used for the life of the generator\n              // ***********************************************\n              _options$minActivitie = options.minActivities, minActivities = _options$minActivitie === void 0 ? _activityThreadOrdering.defaultMinDisplayableActivities : _options$minActivitie, _options$queryType = options.queryType, queryType = _options$queryType === void 0 ? _activities.INITIAL : _options$queryType; // must fetch initially before getting newer activities!\n\n              if (queryType === _activities.NEWER) {\n                queryType = _activities.INITIAL;\n              }\n\n              convoUrl = options.url, _options$search = options.search, search = _options$search === void 0 ? {} : _options$search, includeChildren = options.includeChildren; // manage oldest, newest activities (ie bookends)\n\n              _bookendManager = (0, _activityThreadOrdering.bookendManager)(), setBookends = _bookendManager.setBookends, getNewestAct = _bookendManager.getNewestAct, getOldestAct = _bookendManager.getOldestAct; // default batch should be equal to minActivities when fetching back in time, but halved when fetching newer due to subsequent child fetches filling up the minActivities count\n              // reduces server RTs when fetching older activities\n\n              defaultBatchSize = queryType === _activities.INITIAL || queryType === _activities.OLDER ? minActivities : Math.max(_activityThreadOrdering.minBatchSize, Math.ceil(minActivities / 2));\n              batchSize = defaultBatchSize; // exposes activity states and handlers with simple getters\n\n              _activityManager = (0, _activityThreadOrdering.activityManager)(), getActivityHandlerByKey = _activityManager.getActivityHandlerByKey, getActivityByTypeAndParentId = _activityManager.getActivityByTypeAndParentId; // set initial query\n\n              query = (0, _activityThreadOrdering.getQuery)(queryType, {\n                activityToSearch: search,\n                batchSize: batchSize\n              });\n              /* eslint-disable no-await-in-loop */\n\n              /* eslint-disable no-loop-func */\n\n              _loop = /*#__PURE__*/_regenerator.default.mark(function _loop() {\n                var _rootActivityManager, getRootActivityHash, addNewRoot, _noMoreActivitiesMana, getNoMoreActs, checkAndSetNoMoreActs, checkAndSetNoOlderActs, checkAndSetNoNewerActs, getActivityHandlerByType, handleNewActivity, handleNewActivities, handleOlderQuery, handleNewerQuery, handleSearch, getQueryResponseHandler, incrementLoopCounter, _loop2, _ret2, orderedActivities, getRepliesByParentId, orderedRoots, nextOptions, currentOldestPublishedDate, currentNewestPublishedDate;\n\n                return _regenerator.default.wrap(function _loop$(_context11) {\n                  while (1) {\n                    switch (_context11.prev = _context11.next) {\n                      case 0:\n                        // ***********************************************\n                        // EXECUTION STATE VARIABLES\n                        // variables that will be used for each \"batch\" of activities asked for\n                        // ***********************************************\n                        // stores all \"root\" activities (activities that are, or could be, thread parents)\n                        _rootActivityManager = (0, _activityThreadOrdering.rootActivityManager)(), getRootActivityHash = _rootActivityManager.getRootActivityHash, addNewRoot = _rootActivityManager.addNewRoot; // used to determine if we should continue to fetch older activities\n                        // must be set per iteration, as querying newer activities is still valid when all end of convo has been reached\n\n                        _noMoreActivitiesMana = (0, _activityThreadOrdering.noMoreActivitiesManager)(), getNoMoreActs = _noMoreActivitiesMana.getNoMoreActs, checkAndSetNoMoreActs = _noMoreActivitiesMana.checkAndSetNoMoreActs, checkAndSetNoOlderActs = _noMoreActivitiesMana.checkAndSetNoOlderActs, checkAndSetNoNewerActs = _noMoreActivitiesMana.checkAndSetNoNewerActs;\n\n                        getActivityHandlerByType = function getActivityHandlerByType(type) {\n                          var _ACTIVITY_TYPES$ROOT$;\n\n                          return (_ACTIVITY_TYPES$ROOT$ = {}, (0, _defineProperty2.default)(_ACTIVITY_TYPES$ROOT$, _activities.ACTIVITY_TYPES.ROOT, addNewRoot), (0, _defineProperty2.default)(_ACTIVITY_TYPES$ROOT$, _activities.ACTIVITY_TYPES.REPLY, getActivityHandlerByKey(_activities.ACTIVITY_TYPES.REPLY)), (0, _defineProperty2.default)(_ACTIVITY_TYPES$ROOT$, _activities.ACTIVITY_TYPES.EDIT, getActivityHandlerByKey(_activities.ACTIVITY_TYPES.EDIT)), (0, _defineProperty2.default)(_ACTIVITY_TYPES$ROOT$, _activities.ACTIVITY_TYPES.REACTION, getActivityHandlerByKey(_activities.ACTIVITY_TYPES.REACTION)), (0, _defineProperty2.default)(_ACTIVITY_TYPES$ROOT$, _activities.ACTIVITY_TYPES.REACTION_SELF, getActivityHandlerByKey(_activities.ACTIVITY_TYPES.REACTION_SELF)), (0, _defineProperty2.default)(_ACTIVITY_TYPES$ROOT$, _activities.ACTIVITY_TYPES.TOMBSTONE, addNewRoot), (0, _defineProperty2.default)(_ACTIVITY_TYPES$ROOT$, _activities.ACTIVITY_TYPES.CREATE, addNewRoot), _ACTIVITY_TYPES$ROOT$)[type];\n                        };\n\n                        handleNewActivity = function handleNewActivity(activity) {\n                          var actType = (0, _activities.getActivityType)(activity); // ignore deletes\n\n                          if ((0, _activities.isDeleteActivity)(activity)) {\n                            return;\n                          }\n\n                          var activityHandler = getActivityHandlerByType(actType);\n                          activityHandler(activity);\n                        };\n\n                        handleNewActivities = function handleNewActivities(activities) {\n                          activities.forEach(function (act) {\n                            handleNewActivity(act);\n                            checkAndSetNoOlderActs(act);\n                          });\n                        };\n\n                        handleOlderQuery = function handleOlderQuery(activities) {\n                          setBookends(activities, _activities.OLDER);\n                          handleNewActivities(activities);\n                        };\n\n                        handleNewerQuery = function handleNewerQuery(activities) {\n                          checkAndSetNoNewerActs(activities);\n\n                          if (activities.length) {\n                            setBookends(activities, _activities.NEWER);\n                            handleNewActivities(activities);\n                          }\n                        };\n\n                        handleSearch = function handleSearch(activities) {\n                          setBookends(activities, _activities.MID);\n                          handleNewActivities(activities);\n                        };\n\n                        getQueryResponseHandler = function getQueryResponseHandler(type) {\n                          var _OLDER$NEWER$MID$INIT;\n\n                          return (_OLDER$NEWER$MID$INIT = {}, (0, _defineProperty2.default)(_OLDER$NEWER$MID$INIT, _activities.OLDER, handleOlderQuery), (0, _defineProperty2.default)(_OLDER$NEWER$MID$INIT, _activities.NEWER, handleNewerQuery), (0, _defineProperty2.default)(_OLDER$NEWER$MID$INIT, _activities.MID, handleSearch), (0, _defineProperty2.default)(_OLDER$NEWER$MID$INIT, _activities.INITIAL, handleOlderQuery), _OLDER$NEWER$MID$INIT)[type];\n                        }; // ***********************************************\n                        // INNER LOOP\n                        // responsible for fetching and building our maps of activities\n                        // fetch until minActivities is reached, or no more acts to fetch, or we hit our max fetch count\n                        // ***********************************************\n\n\n                        incrementLoopCounter = (0, _activityThreadOrdering.getLoopCounterFailsafe)();\n                        _loop2 = /*#__PURE__*/_regenerator.default.mark(function _loop2() {\n                          var allBatchActivitiesConfig, $allBatchActivitiesFetch, $fetchRequests, params, $parentsFetch, _yield$_awaitAsyncGen, _yield$_awaitAsyncGen2, allBatchActivities, _yield$_awaitAsyncGen3, parents, handler, _parents$reply, replyIds, _parents$edit, editIds, _parents$reaction, reactionIds, $reactionFetches, $replyFetches, $editFetches, _iterator4, _step4, activity, actId, childFetchOptions, _yield$_awaitAsyncGen4, _yield$_awaitAsyncGen5, reactions, replies, edits, newReplyReactions, allReactions, rootActivityHash, visibleActivitiesCount, _iterator5, _step5, rootActivity, rootId, repliesByRootId, currentOldestPublishedDate, currentNewestPublishedDate;\n\n                          return _regenerator.default.wrap(function _loop2$(_context10) {\n                            while (1) {\n                              switch (_context10.prev = _context10.next) {\n                                case 0:\n                                  // count loops and throw if we detect infinite loop\n                                  incrementLoopCounter(); // configure fetch request. Use a smaller limit when fetching newer or mids to account for potential children fetches\n\n                                  allBatchActivitiesConfig = _objectSpread({\n                                    conversationUrl: convoUrl,\n                                    limit: batchSize,\n                                    includeChildren: includeChildren\n                                  }, query); // request activities in batches\n\n                                  $allBatchActivitiesFetch = _this.listActivities(allBatchActivitiesConfig); // contain fetches in array to parallelize fetching as needed\n\n                                  $fetchRequests = [$allBatchActivitiesFetch]; // if query requires recursive fetches for children acts, add the additional fetch\n\n                                  if (queryType === _activities.MID || queryType === _activities.NEWER) {\n                                    params = {\n                                      activityType: null\n                                    };\n\n                                    if (query.sinceDate) {\n                                      params.sinceDate = query.sinceDate;\n                                    }\n\n                                    $parentsFetch = _this.listParentActivityIds(convoUrl, params);\n                                    $fetchRequests.push($parentsFetch);\n                                  } // we dont always need to fetch for parents\n\n\n                                  _context10.next = 7;\n                                  return (0, _awaitAsyncGenerator2.default)(_promise.default.all($fetchRequests));\n\n                                case 7:\n                                  _yield$_awaitAsyncGen = _context10.sent;\n                                  _yield$_awaitAsyncGen2 = (0, _slicedToArray2.default)(_yield$_awaitAsyncGen, 2);\n                                  allBatchActivities = _yield$_awaitAsyncGen2[0];\n                                  _yield$_awaitAsyncGen3 = _yield$_awaitAsyncGen2[1];\n                                  parents = _yield$_awaitAsyncGen3 === void 0 ? {} : _yield$_awaitAsyncGen3; // use query type to decide how to handle response\n\n                                  handler = getQueryResponseHandler(queryType);\n                                  handler(allBatchActivities);\n                                  /*\n                                    next we must selectively fetch the children of each of the parents to ensure completeness\n                                    do this by checking the hash for each of the above parent IDs\n                                    fetch children when we have a parent whose ID is represented in the parent ID lists\n                                  */\n\n                                  _parents$reply = parents.reply, replyIds = _parents$reply === void 0 ? [] : _parents$reply, _parents$edit = parents.edit, editIds = _parents$edit === void 0 ? [] : _parents$edit, _parents$reaction = parents.reaction, reactionIds = _parents$reaction === void 0 ? [] : _parents$reaction; // if no parent IDs returned, do nothing\n\n                                  if (!(replyIds.length || editIds.length || reactionIds.length)) {\n                                    _context10.next = 35;\n                                    break;\n                                  }\n\n                                  $reactionFetches = [];\n                                  $replyFetches = [];\n                                  $editFetches = [];\n                                  _iterator4 = _createForOfIteratorHelper(allBatchActivities);\n\n                                  try {\n                                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                                      activity = _step4.value;\n                                      actId = activity.id;\n                                      childFetchOptions = {\n                                        conversationUrl: convoUrl,\n                                        activityParentId: actId\n                                      };\n\n                                      if (reactionIds.includes(actId)) {\n                                        $reactionFetches.push(_this.getReactionSummaryByParentId(convoUrl, actId, {\n                                          activityType: 'reactionSummary',\n                                          includeChildren: true\n                                        }));\n                                      }\n\n                                      if (replyIds.includes(actId)) {\n                                        childFetchOptions.query = {\n                                          activityType: 'reply'\n                                        };\n                                        $replyFetches.push(_this.listAllChildActivitiesByParentId(childFetchOptions));\n                                      }\n\n                                      if (editIds.includes(actId)) {\n                                        childFetchOptions.query = {\n                                          activityType: 'edit'\n                                        };\n                                        $editFetches.push(_this.listAllChildActivitiesByParentId(childFetchOptions));\n                                      }\n                                    } // parallelize fetch for speeedz\n\n                                  } catch (err) {\n                                    _iterator4.e(err);\n                                  } finally {\n                                    _iterator4.f();\n                                  }\n\n                                  _context10.next = 23;\n                                  return (0, _awaitAsyncGenerator2.default)(_promise.default.all([_promise.default.all($reactionFetches), _promise.default.all($replyFetches), _promise.default.all($editFetches)]));\n\n                                case 23:\n                                  _yield$_awaitAsyncGen4 = _context10.sent;\n                                  _yield$_awaitAsyncGen5 = (0, _slicedToArray2.default)(_yield$_awaitAsyncGen4, 3);\n                                  reactions = _yield$_awaitAsyncGen5[0];\n                                  replies = _yield$_awaitAsyncGen5[1];\n                                  edits = _yield$_awaitAsyncGen5[2];\n                                  _context10.next = 30;\n                                  return (0, _awaitAsyncGenerator2.default)(_promise.default.all(replies.filter(function (reply) {\n                                    return replyIds.includes(reply.id);\n                                  }).map(function (reply) {\n                                    return _this.getReactionSummaryByParentId(convoUrl, reply.id, {\n                                      activityType: 'reactionSummary',\n                                      includeChildren: true\n                                    });\n                                  })));\n\n                                case 30:\n                                  newReplyReactions = _context10.sent;\n                                  allReactions = [].concat((0, _toConsumableArray2.default)(reactions), (0, _toConsumableArray2.default)(newReplyReactions)); // stick them into activity hashes\n\n                                  replies.forEach(function (replyArr) {\n                                    return handleNewActivities(replyArr);\n                                  });\n                                  edits.forEach(function (editArr) {\n                                    return handleNewActivities(editArr);\n                                  });\n                                  allReactions.forEach(function (reactionArr) {\n                                    return handleNewActivities(reactionArr);\n                                  });\n\n                                case 35:\n                                  rootActivityHash = getRootActivityHash();\n                                  visibleActivitiesCount = rootActivityHash.size;\n                                  _iterator5 = _createForOfIteratorHelper(rootActivityHash.values());\n\n                                  try {\n                                    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                                      rootActivity = _step5.value;\n                                      rootId = rootActivity.id;\n                                      repliesByRootId = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.REPLY, rootId);\n\n                                      if (repliesByRootId && repliesByRootId.size) {\n                                        visibleActivitiesCount += repliesByRootId.size || 0;\n                                      }\n                                    } // stop fetching if we've reached desired count of visible activities\n\n                                  } catch (err) {\n                                    _iterator5.e(err);\n                                  } finally {\n                                    _iterator5.f();\n                                  }\n\n                                  if (!(visibleActivitiesCount >= minActivities)) {\n                                    _context10.next = 41;\n                                    break;\n                                  }\n\n                                  return _context10.abrupt(\"return\", \"break\");\n\n                                case 41:\n                                  checkAndSetNoMoreActs(queryType, visibleActivitiesCount, batchSize); // batchSize should be equal to minimum activities when fetching older activities\n                                  // covers \"best case\" when we reach minActivities on the first fetch\n\n                                  if (queryType === _activities.OLDER) {\n                                    batchSize = minActivities;\n                                  } // since a MID query can bump the batchSize, we need to reset it _after_ a potential MID query\n                                  // reset batchSize in case of MID queries bumping it up\n\n\n                                  if (queryType === _activities.NEWER) {\n                                    batchSize = defaultBatchSize;\n                                  }\n\n                                  currentOldestPublishedDate = (0, _activities.getPublishedDate)(getOldestAct());\n                                  currentNewestPublishedDate = (0, _activities.getPublishedDate)(getNewestAct()); // we're still building our activity list - derive new query from prior query and start loop again\n\n                                  if (queryType === _activities.INITIAL) {\n                                    query = (0, _activityThreadOrdering.getQuery)(_activities.OLDER, {\n                                      oldestPublishedDate: currentOldestPublishedDate,\n                                      batchSize: batchSize\n                                    });\n                                  } else {\n                                    query = (0, _activityThreadOrdering.getQuery)(queryType, {\n                                      batchSize: batchSize,\n                                      activityToSearch: search,\n                                      oldestPublishedDate: currentOldestPublishedDate,\n                                      newestPublishedDate: currentNewestPublishedDate\n                                    });\n                                  } // if we're still building out the midDate search, bump the search limit to include activities on both sides\n\n\n                                  if (queryType === _activities.MID) {\n                                    batchSize += _activityThreadOrdering.batchSizeIncrementCount;\n                                  }\n\n                                case 48:\n                                case \"end\":\n                                  return _context10.stop();\n                              }\n                            }\n                          }, _loop2);\n                        });\n\n                      case 11:\n                        if (getNoMoreActs()) {\n                          _context11.next = 18;\n                          break;\n                        }\n\n                        return _context11.delegateYield(_loop2(), \"t0\", 13);\n\n                      case 13:\n                        _ret2 = _context11.t0;\n\n                        if (!(_ret2 === \"break\")) {\n                          _context11.next = 16;\n                          break;\n                        }\n\n                        return _context11.abrupt(\"break\", 18);\n\n                      case 16:\n                        _context11.next = 11;\n                        break;\n\n                      case 18:\n                        orderedActivities = [];\n\n                        getRepliesByParentId = function getRepliesByParentId(replyParentId) {\n                          var replies = [];\n                          var repliesByParentId = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.REPLY, replyParentId);\n\n                          if (!repliesByParentId) {\n                            return replies;\n                          }\n\n                          var sortedReplies = (0, _activities.sortActivitiesByPublishedDate)((0, _activityThreadOrdering.getActivityObjectsFromMap)(repliesByParentId));\n                          sortedReplies.forEach(function (replyActivity) {\n                            var replyId = replyActivity.id;\n                            var edit = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.EDIT, replyId);\n                            var reaction = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.REACTION, replyId);\n                            var reactionSelf = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.REACTION_SELF, replyId);\n                            var latestActivity = edit || replyActivity; // hash of root activities (in case of plain reply) and the reply activity (in case of edit)\n\n                            var allRelevantActivitiesArr = [].concat((0, _toConsumableArray2.default)((0, _activityThreadOrdering.getActivityObjectsFromMap)(getRootActivityHash())), (0, _toConsumableArray2.default)((0, _activityThreadOrdering.getActivityObjectsFromMap)(repliesByParentId)));\n                            var allRelevantActivities = allRelevantActivitiesArr.reduce(function (hashMap, act) {\n                              hashMap[act.id] = act;\n                              return hashMap;\n                            }, {});\n\n                            var finalReply = _this._createParsedServerActivity(latestActivity, allRelevantActivities);\n\n                            var fullReply = {\n                              id: replyId,\n                              activity: finalReply,\n                              reaction: reaction,\n                              reactionSelf: reactionSelf\n                            };\n                            var sanitizedFullReply = (0, _activities.sanitizeActivity)(fullReply);\n                            replies.push(sanitizedFullReply);\n                          });\n                          return replies;\n                        };\n\n                        orderedRoots = (0, _activities.sortActivitiesByPublishedDate)((0, _activityThreadOrdering.getActivityObjectsFromMap)(getRootActivityHash()));\n                        orderedRoots.forEach(function (rootActivity) {\n                          var rootId = rootActivity.id;\n                          var replies = getRepliesByParentId(rootId);\n                          var edit = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.EDIT, rootId);\n                          var reaction = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.REACTION, rootId);\n                          var reactionSelf = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.REACTION_SELF, rootId);\n                          var latestActivity = edit || rootActivity;\n\n                          var finalActivity = _this._createParsedServerActivity(latestActivity, (0, _defineProperty2.default)({}, rootId, rootActivity));\n\n                          var fullRoot = {\n                            id: rootId,\n                            activity: finalActivity,\n                            reaction: reaction,\n                            reactionSelf: reactionSelf\n                          };\n                          var sanitizedFullRoot = (0, _activities.sanitizeActivity)(fullRoot);\n                          orderedActivities.push(sanitizedFullRoot);\n                          replies.forEach(function (reply) {\n                            return orderedActivities.push(reply);\n                          });\n                        });\n                        _context11.next = 24;\n                        return orderedActivities;\n\n                      case 24:\n                        nextOptions = _context11.sent;\n\n                        if (!nextOptions) {\n                          _context11.next = 33;\n                          break;\n                        }\n\n                        minActivities = nextOptions.minActivities || minActivities;\n                        currentOldestPublishedDate = (0, _activities.getPublishedDate)(getOldestAct());\n                        currentNewestPublishedDate = (0, _activities.getPublishedDate)(getNewestAct());\n                        queryType = nextOptions.queryType;\n                        query = (0, _activityThreadOrdering.getQuery)(queryType, {\n                          activityToSearch: search,\n                          oldestPublishedDate: currentOldestPublishedDate,\n                          newestPublishedDate: currentNewestPublishedDate,\n                          batchSize: batchSize\n                        });\n                        _context11.next = 34;\n                        break;\n\n                      case 33:\n                        return _context11.abrupt(\"return\", {\n                          v: void 0\n                        });\n\n                      case 34:\n                      case \"end\":\n                        return _context11.stop();\n                    }\n                  }\n                }, _loop);\n              });\n\n            case 9:\n              if (!true) {\n                _context12.next = 16;\n                break;\n              }\n\n              return _context12.delegateYield(_loop(), \"t0\", 11);\n\n            case 11:\n              _ret = _context12.t0;\n\n              if (!((0, _typeof2.default)(_ret) === \"object\")) {\n                _context12.next = 14;\n                break;\n              }\n\n              return _context12.abrupt(\"return\", _ret.v);\n\n            case 14:\n              _context12.next = 9;\n              break;\n\n            case 16:\n            case \"end\":\n              return _context12.stop();\n          }\n        }\n      }, _callee10);\n    }))();\n  },\n\n  /**\n   * @typedef {object} EditActivity\n   * @property {object} editParent\n   *\n   * @typedef {object} ReplyActivity\n   * @property {object} replyParent\n   *\n   * @typedef {object} EditedReplyActivity\n   * @property {object} replyParent\n   * @property {object} editParent\n   *\n   * @typedef {EditActivity | ReplyActivity | EditedReplyActivity} ParsedServerActivity\n   */\n\n  /**\n    * hashmap of server activities, keyed by id\n    * @typedef {object} ActivityHash\n    * @property {Object}\n    */\n\n  /**\n   * extends a given server object with fields that point to their parent activities from the hashmap passed in\n   * @param {object} activity server activity\n   * @param {ActivityHash} allActivitiesHash hashmap of all server activities caller would like to pass in\n   * @returns {ParsedServerActivity} server activity extended with edit and reply parent fields\n   */\n  _createParsedServerActivity: function _createParsedServerActivity(activity) {\n    var allActivitiesHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var isOrphan = (0, _activities.getIsActivityOrphaned)(activity, allActivitiesHash);\n\n    if (isOrphan) {\n      throw new Error('activity has a parent that cannot be found in allActivitiesHash! please handle this as necessary');\n    }\n\n    var activityType = (0, _activities.determineActivityType)(activity, allActivitiesHash);\n\n    switch (activityType) {\n      case _activities.ACTIVITY_TYPES.ROOT:\n        {\n          return (0, _activities.createRootActivity)(activity);\n        }\n\n      case _activities.ACTIVITY_TYPES.EDIT:\n        {\n          // `activities` must also have the original activity\n          return (0, _activities.createEditActivity)(activity, allActivitiesHash);\n        }\n\n      case _activities.ACTIVITY_TYPES.REPLY:\n        {\n          return (0, _activities.createReplyActivity)(activity);\n        }\n\n      case _activities.ACTIVITY_TYPES.REPLY_EDIT:\n        {\n          // `activities` must also have the reply activity\n          return (0, _activities.createReplyEditActivity)(activity, allActivitiesHash);\n        }\n\n      default:\n        {\n          return activity;\n        }\n    }\n  },\n\n  /**\n   * @param {Object} options\n   * @private\n   * @returns {Promise<Array<Conversation>>}\n   */\n  _list: function _list(options) {\n    var _this30 = this;\n\n    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee11() {\n      var res, list, limit, results, _iterator6, _step6, result, items;\n\n      return _regenerator.default.wrap(function _callee11$(_context13) {\n        while (1) {\n          switch (_context13.prev = _context13.next) {\n            case 0:\n              options.qs = (0, _assign.default)({\n                personRefresh: true,\n                uuidEntryFormat: true,\n                activitiesLimit: 0,\n                participantsLimit: 0\n              }, options.qs);\n              _context13.next = 3;\n              return _this30.request(options);\n\n            case 3:\n              res = _context13.sent;\n\n              if (!res.body || !res.body.items || res.body.items.length === 0) {\n                list = [];\n              } else {\n                list = res.body.items.slice(0);\n\n                if ((0, _last2.default)(list).published < list[0].published) {\n                  list.reverse();\n                }\n              } // The user has more data in another cluster.\n              // Follow the 'additionalUrls' for that data.\n\n\n              if (!res.body.additionalUrls) {\n                _context13.next = 14;\n                break;\n              }\n\n              limit = 0; // If the user asked for a specific amount of data,\n              // don't fetch more than what was asked.\n              // Here we figure out how much is left from the original request.\n              // Divide that by the number of additional URLS.\n              // This won't get us the exact limit but it will retrieve something\n              // from every cluster listed.\n\n              if (options.limit) {\n                limit = Math.floor((options.limit.value - list.length) / res.body.additionalUrls.length);\n              } // If the limit is 0 for some reason,\n              // don't bother requesting from other clusters\n\n\n              if (!(!options.limit || limit !== 0)) {\n                _context13.next = 14;\n                break;\n              }\n\n              _context13.next = 11;\n              return _promise.default.all(res.body.additionalUrls.map(function (host) {\n                var url = \"\".concat(host, \"/\").concat(options.resource);\n                var newOptions = (0, _assign.default)({}, options, {\n                  uri: url,\n                  url: url\n                });\n\n                if (options.limit) {\n                  newOptions.qs[newOptions.limit.name] = limit;\n                }\n\n                return _this30.request(newOptions);\n              }));\n\n            case 11:\n              results = _context13.sent;\n              _iterator6 = _createForOfIteratorHelper(results);\n\n              try {\n                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                  result = _step6.value;\n\n                  if (result.body && result.body.items && result.body.items.length) {\n                    items = result.body.items;\n\n                    if ((0, _last2.default)(items).published < items[0].published) {\n                      items.reverse();\n                    }\n\n                    list = list.concat(items);\n                  }\n                }\n              } catch (err) {\n                _iterator6.e(err);\n              } finally {\n                _iterator6.f();\n              }\n\n            case 14:\n              _context13.next = 16;\n              return _promise.default.all(list.map(function (item) {\n                return _this30._recordUUIDs(item);\n              }));\n\n            case 16:\n              return _context13.abrupt(\"return\", list);\n\n            case 17:\n            case \"end\":\n              return _context13.stop();\n          }\n        }\n      }, _callee11);\n    }))();\n  },\n\n  /**\n   * @param {Object} params\n   * @param {Object} options\n   * @private\n   * @returns {Promise<Conversation>}\n   */\n  _maybeCreateOneOnOneThenPost: function _maybeCreateOneOnOneThenPost(params, options) {\n    var _this31 = this;\n\n    return this.get((0, _defaults2.default)({\n      // the use of uniq in Conversation#create guarantees participant[1] will\n      // always be the other user\n      user: params.participants[1]\n    }), (0, _assign.default)(options, {\n      includeConvWithDeletedUserUUID: true,\n      includeParticipants: true\n    })).then(function (conversation) {\n      if (params.comment || params.html) {\n        return _this31.post(conversation, {\n          content: params.html,\n          displayName: params.comment\n        }).then(function (activity) {\n          conversation.activities.items.push(activity);\n          return conversation;\n        });\n      }\n\n      return conversation;\n    }).catch(function (reason) {\n      if (reason.statusCode !== 404) {\n        return _promise.default.reject(reason);\n      }\n\n      return _this31._createOneOnOne(params);\n    });\n  },\n\n  /**\n   * @param {Object} params\n   * @private\n   * @returns {Object}\n   */\n  _prepareConversationForCreation: function _prepareConversationForCreation(params) {\n    var _this32 = this;\n\n    var payload = {\n      activities: {\n        items: [this.expand('create')]\n      },\n      objectType: 'conversation',\n      kmsMessage: {\n        method: 'create',\n        uri: '/resources',\n        userIds: (0, _cloneDeep2.default)(params.participants),\n        keyUris: []\n      }\n    };\n\n    if (params.displayName) {\n      payload.displayName = params.displayName;\n    }\n\n    if (params.tags) {\n      payload.tags = params.tags;\n    }\n\n    params.participants.forEach(function (participant) {\n      payload.activities.items.push(_this32.expand('add', {\n        objectType: 'person',\n        id: participant\n      }));\n    });\n\n    if (params.comment) {\n      payload.activities.items.push(this.expand('post', {\n        objectType: 'comment',\n        content: params.html,\n        displayName: params.comment\n      }));\n    }\n\n    if (!params.isDefaultClassification && params.classificationId) {\n      payload.activities.items.push(this.expand('update', {\n        objectType: 'classification',\n        classificationId: params.classificationId,\n        effectiveDate: params.effectiveDate\n      }));\n    }\n\n    if (params.favorite) {\n      payload.activities.items.push(this.expand('favorite', {\n        objectType: 'conversation'\n      }));\n    }\n\n    return payload;\n  },\n\n  /**\n   * @param {Object} conversation\n   * @private\n   * @returns {Promise}\n   */\n  _recordUUIDs: function _recordUUIDs(conversation) {\n    var _this33 = this;\n\n    if (!conversation.participants || !conversation.participants.items) {\n      return _promise.default.resolve(conversation);\n    }\n\n    return _promise.default.all(conversation.participants.items.map(function (participant) {\n      // ROOMs or LYRA_SPACEs do not have email addresses, so there's no point attempting to\n      // record their UUIDs.\n      if (participant.type === 'ROOM' || participant.type === 'LYRA_SPACE') {\n        return _promise.default.resolve();\n      }\n\n      return _this33.webex.internal.user.recordUUID(participant).catch(function (err) {\n        return _this33.logger.warn('Could not record uuid', err);\n      });\n    }));\n  },\n  version: \"1.154.2\"\n});\n\n['favorite', 'hide', 'lock', 'mute', 'unfavorite', 'unhide', 'unlock', 'unmute'].forEach(function (verb) {\n  Conversation.prototype[verb] = function submitSimpleActivity(conversation, activity) {\n    var _this34 = this;\n\n    var convoWithUrl = this.prepareConversation((0, _assign.default)({}, conversation, {\n      url: this.getConvoUrl(conversation)\n    }));\n    return this.prepare(activity, {\n      verb: verb,\n      object: convoWithUrl,\n      target: convoWithUrl\n    }).then(function (a) {\n      return _this34.submit(a);\n    });\n  };\n});\n['assignModerator', 'unassignModerator'].forEach(function (verb) {\n  Conversation.prototype[verb] = function submitModerationChangeActivity(conversation, moderator, activity) {\n    var _this35 = this;\n\n    var convoWithUrl = (0, _assign.default)({}, conversation, {\n      url: this.getConvoUrl(conversation)\n    });\n    return _promise.default.all([convoWithUrl, moderator ? this.webex.internal.user.asUUID(moderator) : this.webex.internal.device.userId]).then(function (_ref8) {\n      var _ref9 = (0, _slicedToArray2.default)(_ref8, 2),\n          c = _ref9[0],\n          userId = _ref9[1];\n\n      return _this35.prepare(activity, {\n        verb: verb,\n        target: _this35.prepareConversation(c),\n        object: {\n          id: userId,\n          objectType: 'person'\n        }\n      });\n    }).then(function (a) {\n      return _this35.submit(a);\n    });\n  };\n});\n/**\n * Sets/unsets space property for convo\n * @param {Object} conversation\n * @param {string} tag\n * @param {Activity} activity\n * @returns {Promise<Activity>}\n */\n\n['setSpaceProperty', 'unsetSpaceProperty'].forEach(function (fnName) {\n  var verb = fnName.startsWith('set') ? 'set' : 'unset';\n\n  Conversation.prototype[fnName] = function submitSpacePropertyActivity(conversation, tag, activity) {\n    var _this36 = this;\n\n    if (!(0, _isString2.default)(tag)) {\n      return _promise.default.reject(new Error('`tag` must be a string'));\n    }\n\n    var convoWithUrl = (0, _assign.default)({}, conversation, {\n      url: this.getConvoUrl(conversation)\n    });\n    return this.prepare(activity, {\n      verb: verb,\n      target: this.prepareConversation(convoWithUrl),\n      object: {\n        tags: [tag],\n        objectType: 'spaceProperty'\n      }\n    }).then(function (a) {\n      return _this36.submit(a);\n    });\n  };\n});\n['tag', 'untag'].forEach(function (verb) {\n  Conversation.prototype[verb] = function submitObjectActivity(conversation, object, activity) {\n    var _this37 = this;\n\n    if (!(0, _isObject2.default)(object)) {\n      return _promise.default.reject(new Error('`object` must be an object'));\n    }\n\n    var c = this.prepareConversation((0, _assign.default)({}, conversation, {\n      url: this.getConvoUrl(conversation)\n    }));\n    return this.prepare(activity, {\n      verb: verb,\n      target: c,\n      object: (0, _assign.default)(c, object)\n    }).then(function (a) {\n      return _this37.submit(a);\n    });\n  };\n});\nvar _default = Conversation;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["CLUSTER_SERVICE","process","env","WEBEX_CONVERSATION_CLUSTER_SERVICE","DEFAULT_CLUSTER_SERVICE","DEFAULT_CLUSTER_IDENTIFIER","WEBEX_CONVERSATION_DEFAULT_CLUSTER","DEFAULT_CLUSTER","idToUrl","getConvoLimit","options","limit","conversationsLimit","value","name","Conversation","WebexPlugin","extend","namespace","getUrlFromClusterId","cluster","id","clusterId","split","length","webex","internal","services","getServiceFromClusterId","url","Error","acknowledge","conversation","object","activity","getConvoUrl","convoWithUrl","_promise","reject","prepare","verb","target","prepareConversation","objectType","then","a","_this2","submit","add","participant","user","asUUID","create","_this3","kmsMessage","method","uri","resourceUri","userIds","params","participants","all","map","_this4","catch","err","allowPartialCreation","undefined","unshift","device","userId","validParticipants","filter","forceGrouped","InvalidUserCreation","skipOneOnOneFetch","_createOneOnOne","_maybeCreateOneOnOneThenPost","_createGrouped","c","set","files","share","activities","items","push","createReactionHmac","displayName","parent","encryption","unboundedStorage","get","encryptionKeyUrl","keyString","key","JSON","parse","formatjwk","k","jwk","kid","kty","source","hmac","hex","stringify","resolve","sendReaction","reactionPayload","act","_this5","deleteReaction","reactionId","deleteReactionPayload","actor","addReaction","addReactionPayload","_this6","type","delete","_this7","download","item","isEncrypted","Boolean","scr","shunt","EventEmitter","promise","loc","_downloadUnencryptedFile","on","args","arguments","emit","res","shouldNotAddExifData","file","_this8","logger","info","mimeType","responseType","request","body","expand","bulkActivitiesFetch","activityUrls","resource","api","activitiesArr","multistatus","forEach","statusData","status","data","qs","uuidEntryFormat","personRefresh","activitiesLimit","includeConvWithDeletedUserUUID","includeParticipants","service","_this9","_recordUUIDs","leave","_this10","querystring","authId","list","_list","summary","deferDecrypt","results","convo","_iterator","paginate","page","_context","links","next","_this11","Page","queryOptions","participantsLimit","reqOptions","response","additionalUrls","listLeft","_iterator2","listActivities","_listActivities","listParentActivityIds","conversationUrl","query","_context2","_this12","listAllChildActivitiesByParentId","activityParentId","activityType","_context3","_this13","listChildActivitiesByParentId","initialResponse","hasNext","_iterator3","published","reverse","finalQuery","_this14","getReactionSummaryByParentId","_context5","_this15","_yield$_this15$reques","reactionObjects","children","child","listMentions","muteMentions","tag","tags","muteMessages","ignore","cardAction","inputs","parentActivity","_this16","post","message","_this17","clientTempId","uuid","v4","_this18","parentActivityId","pop","content","listThreads","_this19","processActivityEvent","event","transform","removeAllMuteTags","untag","makeShare","ShareActivity","assign","avatar","uploadOptions","role","size","_this20","enableThumbnails","conversations","generalConversationUuid","generalConvo","find","warn","relatedUrl","updateTypingStatus","eventType","typing","conversationId","_this21","endpoint","transcode","async","customActivityCopy","constructor","copySrc","toJWE","toJSON","cloneActivity","trigger","error","errorCode","KEY_ROTATION_REQUIRED","defaultActivityEncryptionKeyUrl","_this22","KEY_ALREADY_ROTATED","ENCRYPTION_KEY_URL_MISMATCH","defaultActivityEncryptionkeyUrl","unassign","_this23","unmuteMentions","unmuteMessages","unignore","update","_this24","updateKey","_this25","_updateKey","kms","createUnboundKeys","count","keys","_this26","kmsResourceObjectUrl","startsWith","keyUris","_create","payload","forceCreate","_prepareConversationForCreation","getConversationUrl","convoUrl","waitForCatalog","_this27","_inferConversationUrl","feature","getFeature","haMessagingEnabled","_this28","NODE_ENV","listActivitiesThreadOrdered","baseOptions","olderOptions","queryType","OLDER","threadOrderer","_listActivitiesThreadOrdered","jumpToActivity","searchObject","_context7","newUrl","searchOptions","MID","search","_this29","_yield$threadOrderer$","searchResults","done","getOlder","_context8","_yield$threadOrderer$2","_yield$threadOrderer$3","oldestInBatch","moreActivitiesExist","ACTIVITY_TYPES","CREATE","getNewer","newerOptions","NEWER","_context9","_yield$threadOrderer$4","_options$minActivitie","minActivities","defaultMinDisplayableActivities","INITIAL","_options$search","includeChildren","_bookendManager","setBookends","getNewestAct","getOldestAct","defaultBatchSize","Math","max","minBatchSize","ceil","batchSize","_activityManager","getActivityHandlerByKey","getActivityByTypeAndParentId","activityToSearch","_loop","_rootActivityManager","getRootActivityHash","addNewRoot","_noMoreActivitiesMana","getNoMoreActs","checkAndSetNoMoreActs","checkAndSetNoOlderActs","checkAndSetNoNewerActs","getActivityHandlerByType","ROOT","REPLY","EDIT","REACTION","REACTION_SELF","TOMBSTONE","handleNewActivity","actType","activityHandler","handleNewActivities","handleOlderQuery","handleNewerQuery","handleSearch","getQueryResponseHandler","incrementLoopCounter","_loop2","allBatchActivitiesConfig","$allBatchActivitiesFetch","_this","$fetchRequests","sinceDate","$parentsFetch","_context10","_yield$_awaitAsyncGen","_yield$_awaitAsyncGen2","allBatchActivities","_yield$_awaitAsyncGen3","parents","handler","_parents$reply","reply","replyIds","edit","editIds","reaction","reactionIds","$reactionFetches","$replyFetches","$editFetches","_iterator4","actId","childFetchOptions","includes","_yield$_awaitAsyncGen4","_yield$_awaitAsyncGen5","reactions","replies","edits","newReplyReactions","allReactions","replyArr","editArr","reactionArr","rootActivityHash","visibleActivitiesCount","_iterator5","values","rootActivity","rootId","repliesByRootId","currentOldestPublishedDate","currentNewestPublishedDate","oldestPublishedDate","newestPublishedDate","batchSizeIncrementCount","_context11","_ret2","orderedActivities","getRepliesByParentId","replyParentId","repliesByParentId","sortedReplies","replyActivity","replyId","reactionSelf","latestActivity","allRelevantActivitiesArr","allRelevantActivities","reduce","hashMap","finalReply","_createParsedServerActivity","fullReply","sanitizedFullReply","orderedRoots","finalActivity","fullRoot","sanitizedFullRoot","nextOptions","v","_context12","_ret","allActivitiesHash","isOrphan","REPLY_EDIT","_context13","_this30","slice","floor","host","newOptions","_iterator6","result","concat","comment","html","_this31","reason","statusCode","_this32","isDefaultClassification","classificationId","effectiveDate","favorite","_this33","recordUUID","version","prototype","submitSimpleActivity","_this34","submitModerationChangeActivity","moderator","_this35","fnName","submitSpacePropertyActivity","_this36","submitObjectActivity","_this37"],"sources":["conversation.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport querystring from 'querystring';\nimport {EventEmitter} from 'events';\n\nimport hmacSHA256 from 'crypto-js/hmac-sha256';\nimport hex from 'crypto-js/enc-hex';\nimport {proxyEvents, tap} from '@webex/common';\nimport {Page, WebexPlugin} from '@webex/webex-core';\nimport {cloneDeep, cloneDeepWith, defaults, isArray, isObject, isString, last, map, merge, omit, pick, uniq} from 'lodash';\nimport {readExifData} from '@webex/helper-image';\nimport uuid from 'uuid';\n\nimport {InvalidUserCreation} from './convo-error';\nimport ShareActivity from './share-activity';\nimport {\n  minBatchSize, defaultMinDisplayableActivities,\n  getLoopCounterFailsafe,\n  batchSizeIncrementCount,\n  getActivityObjectsFromMap,\n  bookendManager,\n  noMoreActivitiesManager,\n  getQuery,\n  rootActivityManager,\n  activityManager\n} from './activity-thread-ordering';\nimport {\n  ACTIVITY_TYPES,\n  getActivityType,\n  isDeleteActivity,\n  getIsActivityOrphaned,\n  determineActivityType,\n  createRootActivity,\n  createReplyActivity,\n  createEditActivity,\n  createReplyEditActivity,\n  OLDER, MID, INITIAL, NEWER,\n  getPublishedDate, sortActivitiesByPublishedDate,\n  sanitizeActivity\n} from './activities';\nimport {\n  DEFAULT_CLUSTER,\n  DEFAULT_CLUSTER_SERVICE,\n  ENCRYPTION_KEY_URL_MISMATCH,\n  KEY_ALREADY_ROTATED,\n  KEY_ROTATION_REQUIRED\n} from './constants';\n\n\nconst CLUSTER_SERVICE = process.env.WEBEX_CONVERSATION_CLUSTER_SERVICE || DEFAULT_CLUSTER_SERVICE;\nconst DEFAULT_CLUSTER_IDENTIFIER =\n  process.env.WEBEX_CONVERSATION_DEFAULT_CLUSTER ||\n  `${DEFAULT_CLUSTER}:${CLUSTER_SERVICE}`;\n\nconst idToUrl = new Map();\n\nconst getConvoLimit = (options = {}) => {\n  let limit;\n\n  if (options.conversationsLimit) {\n    limit = {\n      value: options.conversationsLimit,\n      name: 'conversationsLimit'\n    };\n  }\n\n  return limit;\n};\n\nconst Conversation = WebexPlugin.extend({\n  namespace: 'Conversation',\n\n  /**\n   * @param {String} cluster the cluster containing the id\n   * @param {UUID} [id] the id of the conversation.\n   *  If empty, just return the base URL.\n   * @returns {String} url of the conversation\n   */\n  getUrlFromClusterId({cluster = 'us', id} = {}) {\n    let clusterId =\n      cluster === 'us' ? DEFAULT_CLUSTER_IDENTIFIER : cluster;\n\n    // Determine if cluster has service name (non-US clusters from hydra do not)\n    if (clusterId.split(':').length < 4) {\n      // Add Service to cluster identifier\n      clusterId = `${cluster}:${CLUSTER_SERVICE}`;\n    }\n\n    const {url} = this.webex.internal.services\n      .getServiceFromClusterId({clusterId}) || {};\n\n    if (!url) {\n      throw Error(`Could not find service for cluster [${cluster}]`);\n    }\n\n    return id ? `${url}/conversations/${id}` : url;\n  },\n\n  /**\n   * @param {Object} conversation\n   * @param {Object} object\n   * @param {Object} activity\n   * @returns {Promise}\n   */\n  acknowledge(conversation, object, activity) {\n    const url = this.getConvoUrl(conversation);\n    const convoWithUrl = Object.assign({}, conversation, {url});\n\n    if (!isObject(object)) {\n      return Promise.reject(new Error('`object` must be an object'));\n    }\n\n    return this.prepare(activity, {\n      verb: 'acknowledge',\n      target: this.prepareConversation(convoWithUrl),\n      object: {\n        objectType: 'activity',\n        id: object.id,\n        url: object.url\n      }\n    })\n      .then((a) => this.submit(a));\n  },\n\n  /**\n   * Adds a participant to a conversation\n   * @param {Object} conversation\n   * @param {Object|string} participant\n   * @param {Object} activity Reference to the activity that will eventually be\n   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a\n   * provisional activity\n   * @returns {Promise<Activity>}\n   */\n  add(conversation, participant, activity) {\n    const url = this.getConvoUrl(conversation);\n    const convoWithUrl = Object.assign({}, conversation, {url});\n\n    return this.webex.internal.user.asUUID(participant, {create: true})\n      .then((id) => this.prepare(activity, {\n        verb: 'add',\n        target: this.prepareConversation(convoWithUrl),\n        object: {\n          id,\n          objectType: 'person'\n        },\n        kmsMessage: {\n          method: 'create',\n          uri: '/authorizations',\n          resourceUri: '<KRO>',\n          userIds: [\n            id\n          ]\n        }\n      })\n        .then((a) => this.submit(a)));\n  },\n\n  /**\n   * Creates a conversation\n   * @param {Object} params\n   * @param {Array<Participant>} params.participants\n   * @param {Array<File>} params.files\n   * @param {string} params.comment\n   * @param {string} params.html\n   * @param {Object} params.displayName\n   * @param {string} params.classificationId\n   * @param {string} params.effectiveDate\n   * @param {Boolean} params.isDefaultClassification\n   * @param {Array<string>} params.tags\n   * @param {Boolean} params.favorite\n   * @param {Object} options\n   * @param {Boolean} options.allowPartialCreation\n   * @param {Boolean} options.forceGrouped\n   * @param {Boolean} options.skipOneOnOneFetch skips checking 1:1 exists before creating conversation\n   * @returns {Promise<Conversation>}\n   */\n  create(params, options = {}) {\n    if (!params.participants || params.participants.length === 0) {\n      return Promise.reject(new Error('`params.participants` is required'));\n    }\n\n    return Promise.all(params.participants.map((participant) => this.webex.internal.user.asUUID(participant, {create: true})\n      // eslint-disable-next-line arrow-body-style\n      .catch((err) => {\n        return options.allowPartialCreation ? undefined : Promise.reject(err);\n      })))\n      .then((participants) => {\n        participants.unshift(this.webex.internal.device.userId);\n        participants = uniq(participants);\n\n        const validParticipants = participants.filter((participant) => participant);\n\n        params.participants = validParticipants;\n\n        // check if original participants list was to create a 1:1\n        if (participants.length === 2 && !(options && options.forceGrouped)) {\n          if (!params.participants[1]) {\n            return Promise.reject(new InvalidUserCreation());\n          }\n\n          if (options.skipOneOnOneFetch) {\n            return this._createOneOnOne(params);\n          }\n\n          return this._maybeCreateOneOnOneThenPost(params, options);\n        }\n\n        return this._createGrouped(params, options);\n      })\n      .then((c) => {\n        idToUrl.set(c.id, c.url);\n\n        if (!params.files) {\n          return c;\n        }\n\n        return this.webex.internal.conversation.share(c, params.files)\n          .then((a) => {\n            c.activities.items.push(a);\n\n            return c;\n          });\n      });\n  },\n\n  /**\n   * @private\n   * generate a deterministic HMAC for a reaction\n   * @param {Object} displayName displayName of reaction we are sending\n   * @param {Object} parent parent activity of reaction\n   * @returns {Promise<HMAC>}\n   */\n  createReactionHmac(displayName, parent) {\n    // not using webex.internal.encryption.getKey() because the JWK it returns does not have a 'k'\n    // property. we need jwk.k to correctly generate the HMAC\n\n    return this.webex.internal.encryption.unboundedStorage.get(parent.encryptionKeyUrl)\n      .then((keyString) => {\n        const key = JSON.parse(keyString);\n        // when we stringify this object, keys must be in this order to generate same HMAC as\n        // desktop clients\n        const formatjwk = {k: key.jwk.k, kid: key.jwk.kid, kty: key.jwk.kty};\n\n        const source = `${JSON.stringify(formatjwk)}${parent.id}${displayName}`;\n\n        const hmac = hex.stringify(hmacSHA256(source, parent.id));\n\n        return Promise.resolve(hmac);\n      });\n  },\n\n  /**\n   * @typedef {Object} ReactionPayload\n   * @property {Object} actor\n   * @property {string} actor.objectType\n   * @property {string} actor.id\n   * @property {string} objectType\n   * @property {string} verb will be either add' or 'delete'\n   * @property {Object} target\n   * @property {string} target.id\n   * @property {string} target.objectType\n   * @property {Object} object this will change on delete vs. add\n   * @property {string} object.id present in delete case\n   * @property {string} object.objectType 'activity' in delete case, 'reaction2' in add case\n   * @property {string} object.displayName must be 'celebrate', 'heart', 'thumbsup', 'smiley', 'haha', 'confused', 'sad'\n   * @property {string} object.hmac\n   */\n\n  /**\n   * @private\n   * send add or delete reaction to convo service\n   * @param {Object} conversation\n   * The payload to send a reaction\n   * @param {ReactionPayload} reactionPayload\n   * @returns {Promise<Activity>}\n   */\n  sendReaction(conversation, reactionPayload) {\n    const url = this.getConvoUrl(conversation);\n    const convoWithUrl = Object.assign({}, conversation, {url});\n\n    if (!isObject(reactionPayload)) {\n      return Promise.reject(new Error('`object` must be an object'));\n    }\n\n    return this.prepare(reactionPayload, {\n      target: this.prepareConversation(convoWithUrl),\n      object: pick(reactionPayload, 'id', 'url', 'objectType')\n    })\n      .then((act) => this.submit(act));\n  },\n\n  /**\n   * delete a reaction\n   * @param {Object} conversation\n   * @param {Object} reactionId\n   * @returns {Promise<Activity>}\n   */\n  deleteReaction(conversation, reactionId) {\n    const deleteReactionPayload = {\n      actor: {objectType: 'person', id: this.webex.internal.device.userId},\n      object: {\n        id: reactionId,\n        objectType: 'activity'\n      },\n      objectType: 'activity',\n      target: {\n        id: conversation.id,\n        objectType: 'conversation'\n      },\n      verb: 'delete'\n    };\n\n    return this.sendReaction(conversation, deleteReactionPayload);\n  },\n\n  /**\n   * create a reaction\n   * @param {Object} conversation\n   * @param {Object} displayName must be 'celebrate', 'heart', 'thumbsup', 'smiley', 'haha', 'confused', 'sad'\n   * @param {Object} activity activity object from convo we are reacting to\n   * @returns {Promise<Activity>}\n   */\n  addReaction(conversation, displayName, activity) {\n    return this.createReactionHmac(displayName, activity).then((hmac) => {\n      const addReactionPayload = {\n        actor: {objectType: 'person', id: this.webex.internal.device.userId},\n        target: {\n          id: conversation.id,\n          objectType: 'conversation'\n        },\n        verb: 'add',\n        objectType: 'activity',\n        parent: {\n          type: 'reaction',\n          id: activity.id\n        },\n        object: {\n          objectType: 'reaction2',\n          displayName,\n          hmac\n        }\n      };\n\n      return this.sendReaction(conversation, addReactionPayload);\n    });\n  },\n\n\n  /**\n   * delete content\n   * @param {Object} conversation\n   * @param {Object} object\n   * @param {Object} activity\n   * @returns {Promise}\n   */\n  delete(conversation, object, activity) {\n    const url = this.getConvoUrl(conversation);\n    const convoWithUrl = Object.assign({}, conversation, {url});\n\n    if (!isObject(object)) {\n      return Promise.reject(new Error('`object` must be an object'));\n    }\n\n    return this.prepare(activity, {\n      verb: 'delete',\n      target: this.prepareConversation(convoWithUrl),\n      object: pick(object, 'id', 'url', 'objectType')\n    })\n      .then((a) => this.submit(a));\n  },\n\n  /**\n   * Downloads the file specified in item.scr or item.url\n   * @param {Object} item\n   * @param {Object} item.scr\n   * @param {string} item.url\n   * @param {Object} options\n   * @param {Object} options.headers\n   * @param {boolean} options.shouldNotAddExifData\n   * @returns {Promise<File>}\n   */\n  download(item, options = {}) {\n    const isEncrypted = Boolean(item.scr && item.scr.key);\n    const shunt = new EventEmitter();\n    let promise;\n\n    if (isEncrypted) {\n      promise = this.webex.internal.encryption.download(item.scr, item.options);\n    }\n    else if (item.scr && item.scr.loc) {\n      promise = this._downloadUnencryptedFile(item.scr.loc, options);\n    }\n    else {\n      promise = this._downloadUnencryptedFile(item.url, options);\n    }\n\n    promise = promise\n      .on('progress', (...args) => shunt.emit('progress', ...args))\n      .then((res) => {\n        if (options.shouldNotAddExifData) {\n          return res;\n        }\n\n        return readExifData(item, res);\n      })\n      .then((file) => {\n        this.logger.info('conversation: file downloaded');\n\n        if (item.displayName && !file.name) {\n          file.name = item.displayName;\n        }\n\n        if (!file.type && item.mimeType) {\n          file.type = item.mimeType;\n        }\n\n        return file;\n      });\n\n    proxyEvents(shunt, promise);\n\n    return promise;\n  },\n\n  /**\n   * Downloads an unencrypted file\n   * @param {string} uri\n   * @param {Object} options\n   * @param {Ojbect} options.headers\n   * @returns {Promise<File>}\n   */\n  _downloadUnencryptedFile(uri, options = {}) {\n    Object.assign(options, {\n      uri,\n      responseType: 'buffer'\n    });\n\n    const promise = this.request(options)\n      .then((res) => res.body);\n\n    proxyEvents(options.download, promise);\n\n    return promise;\n  },\n\n  /**\n   * Helper method that expands a set of parameters into an activty object\n   * @param {string} verb\n   * @param {Object} object\n   * @param {Object} target\n   * @param {Object|string} actor\n   * @returns {Object}\n   */\n  expand(verb, object, target, actor) {\n    const activity = {\n      actor,\n      objectType: 'activity',\n      verb\n    };\n\n    if (!actor) {\n      actor = this.webex.internal.device.userId;\n    }\n\n    if (isString(actor)) {\n      activity.actor = {\n        objectType: 'person',\n        id: actor\n      };\n    }\n\n    if (object) {\n      activity.object = object;\n    }\n\n    if (target) {\n      activity.target = target;\n    }\n\n    return activity;\n  },\n\n  /**\n  * Gets an array of activities with an array of activity URLS\n  * @param {Array} activityUrls\n  * @param {Object} options\n  * @param {String} options.cluster cluster where the activities are located\n  * @param {String} options.url base convo url where the activities are located\n  * @returns {Promise<Object>} Resolves with the activities\n  */\n  bulkActivitiesFetch(activityUrls, options = {}) {\n    let cluster, url;\n\n    if (typeof options === 'string') {\n      cluster = options;\n    }\n    else {\n      ({cluster, url} = options);\n    }\n\n    const resource = 'bulk_activities_fetch';\n    const params = {\n      method: 'POST',\n      body: {\n        activityUrls\n      }\n    };\n\n    if (url) {\n      const uri = `${url}/${resource}`;\n\n      Object.assign(params, {\n        uri\n      });\n    }\n    else if (cluster) {\n      const uri = `${this.getUrlFromClusterId({cluster})}/${resource}`;\n\n      Object.assign(params, {\n        uri\n      });\n    }\n    else {\n      Object.assign(params, {\n        api: 'conversation',\n        resource\n      });\n    }\n\n    return this.webex.request(params)\n      .then((res) => {\n        const activitiesArr = [];\n\n        if (res.body.multistatus) {\n          res.body.multistatus.forEach((statusData) => {\n            if (statusData.status === '200' && statusData.data && statusData.data.activity) {\n              activitiesArr.push(statusData.data.activity);\n            }\n          });\n        }\n\n        return activitiesArr;\n      });\n  },\n\n  /**\n   * Fetches a single conversation\n   * @param {Object} conversation\n   * @param {String} [conversation.url] The URL where the conversation is located.\n   * @param {String|UUID} [conversation.user] The user to look up in the conversation service\n   *   If specified, the user lookup will take precedence over the url lookup\n   * @param {Object} options\n   * @returns {Promise<Conversation>}\n   */\n  get(conversation, options = {}) {\n    const {user} = conversation;\n    let uri;\n\n    try {\n      uri = !user ? this.getConvoUrl(conversation) : '';\n    }\n    catch (err) {\n      return Promise.reject(Error(err));\n    }\n\n    const params = {\n      qs: Object.assign({\n        uuidEntryFormat: true,\n        personRefresh: true,\n        activitiesLimit: 0,\n        includeConvWithDeletedUserUUID: false,\n        includeParticipants: false\n      }, omit(options, 'id', 'user', 'url'))\n    };\n\n    // Default behavior is to set includeParticipants=false,\n    // which makes the payload lighter by removing participant info.\n    // If the caller explicitly sets the participantAckFilter or\n    // participantsLimit, we don't want that default setting.\n    if (('participantAckFilter' in options) || ('participantsLimit' in options)) {\n      delete params.qs.includeParticipants;\n    }\n\n    return Promise.resolve(user ? this.webex.internal.user.asUUID(user) : null)\n      .then((userId) => {\n        if (userId) {\n          Object.assign(params, {\n            service: 'conversation',\n            resource: `conversations/user/${userId}`\n          });\n        }\n        else {\n          params.uri = uri;\n        }\n\n        return this.request(params);\n      })\n      .then(tap(({body}) => {\n        const {id, url} = body;\n\n        this._recordUUIDs(body);\n        idToUrl.set(id, url);\n      }))\n      .then((res) => res.body);\n  },\n\n  /**\n   * Leaves the conversation or removes the specified user from the specified\n   * conversation\n   * @param {Object} conversation\n   * @param {Object|string} participant If not specified, defaults to current\n   * user\n   * @param {Object} activity Reference to the activity that will eventually be\n   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a\n   * provisional activity\n   * @returns {Promise<Activity>}\n   */\n  leave(conversation, participant, activity) {\n    const convoWithUrl =\n      Object.assign(\n        {}, conversation, {url: this.getConvoUrl(conversation)}\n      );\n\n    return Promise.resolve()\n      .then(() => {\n        if (!participant) {\n          participant = this.webex.internal.device.userId;\n        }\n\n        return this.webex.internal.user.asUUID(participant)\n          .then((id) => this.prepare(activity, {\n            verb: 'leave',\n            target: this.prepareConversation(convoWithUrl),\n            object: {\n              id,\n              objectType: 'person'\n            },\n            kmsMessage: {\n              method: 'delete',\n              uri: `<KRO>/authorizations?${querystring.stringify({authId: id})}`\n            }\n          }));\n      })\n      .then((a) => this.submit(a));\n  },\n\n  /**\n   * Lists a set of conversations. By default does not fetch activities or\n   * participants\n   * @param {Object} options\n   * @param {boolean} options.summary - when true, use conversationSummary resource\n   * @param {Number} options.conversationsLimit - limit the number of conversations fetched\n   * @param {boolean} options.deferDecrypt - when true, deferDecrypt tells the\n   * payload transformer to normalize (but not decrypt) each received\n   * conversation. Instead, the received conversations will each have a bound\n   * decrypt method that can be executed at the consumer's leisure\n   * @returns {Promise<Array<Conversation>>}\n   */\n  list(options = {}) {\n    return this._list({\n      service: 'conversation',\n      resource: options.summary ? 'conversationsSummary' : 'conversations',\n      qs: omit(options, ['deferDecrypt', 'summary']),\n      deferDecrypt: options.deferDecrypt,\n      limit: getConvoLimit(options)\n    })\n      .then((results) => {\n        for (const convo of results) {\n          idToUrl.set(convo.id, convo.url);\n        }\n\n        return results;\n      });\n  },\n\n  /**\n   * Paginates through a set of conversations. By default does not fetch activities or\n   * participants\n   * @param {Object} options\n   * @param {boolean} options.deferDecrypt - when true, deferDecrypt tells the\n   * payload transformer to normalize (but not decrypt) each received\n   * conversation. Instead, the received conversations will each have a bound\n   * decrypt method that can be executed at the consumer's leisure\n   * @param {Page} options.page - After the first result has been returned to a consumer,\n   * you can pass the Page back to the sdk to get the next list of results.\n   * @returns {Promise<Array<Conversation>>}\n   */\n  async paginate(options = {}) {\n    if (options.page) {\n      // We were passed a page but we are out of results\n      if (!options.page.links || !options.page.links.next) {\n        throw new Error('No link to follow for the provided page');\n      }\n\n      // Go get the next page of results\n      return this.request({\n        url: options.page.links.next\n      }).then((res) => ({page: new Page(res, this.webex)}));\n    }\n\n    // No page - so this is the first request to kick off the pagination process\n    const queryOptions = Object.assign({\n      personRefresh: true,\n      uuidEntryFormat: true,\n      activitiesLimit: 0,\n      participantsLimit: 0,\n      paginate: true\n    }, omit(options, ['deferDecrypt', 'url']));\n\n    const reqOptions = {\n      qs: queryOptions,\n      deferDecrypt: options.deferDecrypt,\n      limit: getConvoLimit(options)\n    };\n\n    // if options.url is present we likely received one or more additional urls due to federation. In this case\n    // we need to initialize pagination against that url instead of the default home cluster\n    if (options.url) {\n      reqOptions.uri = `${options.url}/conversations`;\n    }\n    else {\n      reqOptions.service = 'conversation';\n      reqOptions.resource = 'conversations';\n    }\n\n\n    return this.request(reqOptions).then((res) => {\n      const response = {\n        page: new Page(res, this.webex)\n      };\n\n\n      if (res.body && res.body.additionalUrls) {\n        response.additionalUrls = res.body.additionalUrls;\n      }\n\n      return response;\n    });\n  },\n\n  /**\n   * Lists the conversations the current user has left. By default does not\n   * fetch activities or participants\n   * @param {Object} options\n   * @returns {Promise<Array<Conversation>>}\n   */\n  listLeft(options) {\n    return this._list({\n      service: 'conversation',\n      resource: 'conversations/left',\n      qs: options,\n      limit: getConvoLimit(options)\n    })\n      .then((results) => {\n        for (const convo of results) {\n          idToUrl.set(convo.id, convo.url);\n        }\n\n        return results;\n      });\n  },\n\n  /**\n   * List activities for the specified conversation\n   * @param {Object} options\n   * @param {String} options.conversationUrl URL to the conversation\n   * @returns {Promise<Array<Activity>>}\n   */\n  listActivities(options) {\n    return this._listActivities(Object.assign(options, {resource: 'activities'}));\n  },\n\n  /**\n   * @typedef QueryOptions\n   * @param {number} [limit] The limit of child activities that can be returned per request\n   * @param {boolean} [latestActivityFirst] Sort order for the child activities\n   * @param {boolean} [includeParentActivity] Enables the parent activity to be returned in the activity list\n   * @param {string} [sinceDate] Get all child activities after this date\n   * @param {string} [maxDate] Get all child activities before this date\n   * @param {boolean} [latestActivityFirst] Sort order for the child activities\n   * @param {string} [activityType] The type of children to return the parents of, a null value here returns parents of all types of children.\n   * The value is one of 'reply', 'edit', 'cardAction', 'reaction', 'reactionSummary', 'reactionSelfSummary'\n   */\n\n  /**\n   * Get all parent ids for a conversation.\n   * @param {string} conversationUrl conversation URL.\n   * @param {QueryOptions} [query] object containing query string values to be appended to the url\n   * @returns {Promise<Array<String>>}\n   */\n  async listParentActivityIds(conversationUrl, query) {\n    const params = {\n      method: 'GET',\n      url: `${conversationUrl}/parents`,\n      qs: query\n    };\n\n    const response = await this.request(params);\n\n    return response.body;\n  },\n\n  /**\n   * Returns a list of _all_ child activities for a given parentId within a given conversation\n   * @param {object} [options = {}]\n   * @param {string} [options.conversationUrl] targeted conversation URL\n   * @param {string} [options.activityParentId] parent id of edit activities or thread activities\n   * @param {QueryOptions} [options.query] object containing query string values to be appended to the url\n   * @returns {Promise<Array>}\n   */\n  async listAllChildActivitiesByParentId(options = {}) {\n    const {conversationUrl, activityParentId, query} = options;\n    const {activityType} = query;\n\n    const initialResponse = await this.listChildActivitiesByParentId(conversationUrl, activityParentId, activityType, query);\n\n    let page = new Page(initialResponse, this.webex);\n\n    const items = [...page.items];\n\n    while (page.hasNext()) {\n      // eslint-disable-next-line no-await-in-loop\n      page = await page.next();\n      for (const activity of page) {\n        items.push(activity);\n      }\n    }\n\n    // reverse list if needed (see _list for precedent)\n    if (items.length && last(items).published < items[0].published) {\n      items.reverse();\n    }\n\n    return items;\n  },\n\n  /**\n   * Return a list of child activities with a given conversation, parentId and other constraints.\n   * @param {string} conversationUrl targeted conversation URL\n   * @param {string} activityParentId parent id of edit activities or thread activities\n   * @param {string} activityType type of child activity to return\n   * The value is one of 'reply', 'edit', 'cardAction', 'reaction', 'reactionSummary', 'reactionSelfSummary'\n   * @param {QueryOptions} [query = {}] object containing query string values to be appended to the url\n   * @returns {Promise<Array>}\n   */\n  async listChildActivitiesByParentId(conversationUrl, activityParentId, activityType, query = {}) {\n    const finalQuery = {\n      ...query,\n      activityType\n    };\n    const params = {\n      method: 'GET',\n      url: `${conversationUrl}/parents/${activityParentId}`,\n      qs: finalQuery\n    };\n\n    return this.request(params);\n  },\n\n  /**\n   * Return an array of reactionSummary and reactionSelfSummary objects\n   * @param {string} conversationUrl targeted conversation URL\n   * @param {string} activityParentId parent id of reaction activities\n   * @param {QueryOptions} query object representing query parameters to pass to convo endpoint\n   * @returns {Promise<Array>}\n   */\n  async getReactionSummaryByParentId(conversationUrl, activityParentId, query) {\n    const {body} = await this.request({\n      method: 'GET',\n      url: `${conversationUrl}/activities/${activityParentId}`,\n      qs: query\n    });\n\n    const reactionObjects = body.children ? body.children.filter((child) => child.type === 'reactionSelfSummary' || child.type === 'reactionSummary') : [];\n\n    return reactionObjects;\n  },\n\n  /**\n   * Lists activities in which the current user was mentioned\n   * @param {Object} options\n   * @returns {Promise<Array<Activity>>}\n   */\n  listMentions(options) {\n    return this._list({\n      service: 'conversation',\n      resource: 'mentions',\n      qs: omit(options, 'mentions')\n    });\n  },\n\n  /**\n   * Mutes the mentions of a conversation\n   * @param {Conversation~ConversationObject} conversation\n   * @param {Conversation~ActivityObject} activity\n   * @returns {Promise} Resolves with the created activity\n   */\n  muteMentions(conversation, activity) {\n    return this.tag(conversation, {\n      tags: ['MENTION_NOTIFICATIONS_OFF']\n    }, activity);\n  },\n\n  /**\n   * Mutes the messages of a conversation\n   * @param {Conversation~ConversationObject} conversation\n   * @param {Conversation~ActivityObject} activity\n   * @returns {Promise} Resolves with the created activity\n   */\n  muteMessages(conversation, activity) {\n    return this.tag(conversation, {\n      tags: ['MESSAGE_NOTIFICATIONS_OFF']\n    }, activity);\n  },\n\n  /**\n   * Starts ignoring conversation\n   * @param {Conversation~ConversationObject} conversation\n   * @param {Conversation~ActivityObject} activity\n   * @returns {Promise} Resolves with the created activity\n   */\n  ignore(conversation, activity) {\n    return this.tag(conversation, {\n      tags: ['IGNORED']\n    }, activity);\n  },\n\n  /**\n   * @param {Object} conversation\n   * @param {Object} inputs\n   * @param {Object} parentActivity\n   * @param {Object} activity\n   * @returns {Promise}\n   */\n  cardAction(conversation, inputs, parentActivity, activity = {}) {\n    const convoWithUrl =\n      Object.assign(\n        {}, conversation, {url: this.getConvoUrl(conversation)}\n      );\n\n    activity.parent = {\n      id: parentActivity.id,\n      type: 'cardAction'\n    };\n\n    return this.prepare(activity, {\n      verb: 'cardAction',\n      target: this.prepareConversation(convoWithUrl),\n      object: Object.assign({objectType: 'submit'}, inputs)\n    })\n      .then((a) => this.submit(a));\n  },\n\n  /**\n   * Posts a message to a conversation\n   * @param {Object} conversation\n   * @param {Object|string} message if string, treated as plaintext; if object,\n   * assumed to be object property of `post` activity\n   * @param {Object} activity Reference to the activity that will eventually be\n   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a\n   * provisional activity\n   * @returns {Promise<Activity>}\n   */\n  post(conversation, message, activity) {\n    const convoWithUrl =\n      Object.assign(\n        {}, conversation, {url: this.getConvoUrl(conversation)}\n      );\n\n    if (isString(message)) {\n      message = {\n        displayName: message\n      };\n    }\n\n    return this.prepare(activity, {\n      verb: 'post',\n      target: this.prepareConversation(convoWithUrl),\n      object: Object.assign({objectType: 'comment'}, message)\n    })\n      .then((a) => this.submit(a));\n  },\n\n  prepareConversation(conversation) {\n    return defaults(pick(conversation, 'id', 'url', 'objectType', 'defaultActivityEncryptionKeyUrl', 'kmsResourceObjectUrl'), {\n      objectType: 'conversation'\n    });\n  },\n\n  prepare(activity, params) {\n    params = params || {};\n    activity = activity || {};\n\n    return Promise.resolve(activity.prepare ? activity.prepare(params) : activity)\n      .then((act) => {\n        defaults(act, {\n          verb: params.verb,\n          kmsMessage: params.kmsMessage,\n          objectType: 'activity',\n          clientTempId: uuid.v4(),\n          actor: this.webex.internal.device.userId\n        });\n\n        // Workaround because parent is a reserved props in Ampersand\n        if ((activity.parentActivityId && activity.activityType) || (activity.parent && activity.parent.id && activity.parent.type)) {\n          act.parent = {\n            id: activity.parentActivityId || activity.parent.id,\n            type: activity.activityType || activity.parent.type\n          };\n        }\n\n        if (isString(act.actor)) {\n          act.actor = {\n            objectType: 'person',\n            id: act.actor\n          };\n        }\n\n        ['actor', 'object'].forEach((key) => {\n          if (params[key]) {\n            act[key] = act[key] || {};\n            defaults(act[key], params[key]);\n          }\n        });\n\n        if (params.target) {\n          merge(act, {\n            target: pick(params.target, 'id', 'url', 'objectType', 'kmsResourceObjectUrl', 'defaultActivityEncryptionKeyUrl')\n          });\n        }\n\n        ['object', 'target'].forEach((key) => {\n          if (act[key] && act[key].url && !act[key].id) {\n            act[key].id = act[key].url.split('/').pop();\n          }\n        });\n\n        ['actor', 'object', 'target'].forEach((key) => {\n          if (act[key] && !act[key].objectType) {\n            // Reminder: throwing here because it's the only way to get out of\n            // this loop in event of an error.\n            throw new Error(`\\`act.${key}.objectType\\` must be defined`);\n          }\n        });\n\n        if (act.object && act.object.content && !act.object.displayName) {\n          return Promise.reject(new Error('Cannot submit activity object with `content` but no `displayName`'));\n        }\n\n        return act;\n      });\n  },\n\n  /**\n * Get a subset of threads for a user.\n * @param {Object} options\n * @returns {Promise<Array<Activity>>}\n */\n  async listThreads(options) {\n    return this._list({\n      service: 'conversation',\n      resource: 'threads',\n      qs: omit(options, 'showAllTypes')\n    });\n  },\n\n  /**\n   * Handles incoming conversation.activity mercury messages\n   * @param {Event} event\n   * @returns {Promise}\n   */\n  processActivityEvent(event) {\n    return this.webex.transform('inbound', event)\n      .then(() => event);\n  },\n\n  /**\n   * Removes all mute-related tags\n   * @param {Conversation~ConversationObject} conversation\n   * @param {Conversation~ActivityObject} activity\n   * @returns {Promise} Resolves with the created activity\n   */\n  removeAllMuteTags(conversation, activity) {\n    return this.untag(conversation, {\n      tags: [\n        'MENTION_NOTIFICATIONS_OFF',\n        'MENTION_NOTIFICATIONS_ON',\n        'MESSAGE_NOTIFICATIONS_OFF',\n        'MESSAGE_NOTIFICATIONS_ON'\n      ]\n    }, activity);\n  },\n\n  /**\n   * Creates a ShareActivty for the specified conversation\n   * @param {Object} conversation\n   * @param {Object} activity\n   * @returns {ShareActivty}\n   */\n  makeShare(conversation, activity) {\n    // if we pass activity as null then it does not take care of the\n    // clientTempId created by the web-client while making the provisional\n    // activity, hence we need to pass the activity which was created by the\n    // web-client. This fixes the issue where the image activities do not come\n    // back properly oriented from the server since the clientTempId is missing\n    return ShareActivity.create(conversation, activity, this.webex);\n  },\n\n  /**\n   * Assigns an avatar to a room\n   * @param {Object} conversation\n   * @param {File} avatar\n   * @returns {Promise<Activity>}\n   */\n  assign(conversation, avatar) {\n    const uploadOptions = {role: 'spaceAvatar'};\n\n    if ((avatar.size || avatar.length) > 1024 * 1024) {\n      return Promise.reject(new Error('Room avatars must be less than 1MB'));\n    }\n\n    const convoWithUrl =\n      Object.assign(\n        {}, conversation, {url: this.getConvoUrl(conversation)}\n      );\n\n    return Promise.resolve()\n      .then(() => {\n        const activity = ShareActivity.create(conversation, null, this.webex);\n\n        activity.enableThumbnails = false;\n        activity.add(avatar, uploadOptions);\n\n        return this.prepare(activity, {\n          target: this.prepareConversation(convoWithUrl)\n        });\n      })\n      .then((a) => {\n        // yes, this seems a little hacky; will likely be resolved as a result\n        // of #213\n        a.verb = 'assign';\n\n        return this.submit(a);\n      });\n  },\n\n  /**\n   * Get url from convo object. If there isn't one, get it from the cache\n   *\n   * @param {String} url The location of the conversation\n   * @param {UUID} id If there is no url, fall back to id to lookup in cache or with cluster\n   * @param {String} cluster Used with id to lookup url\n   * @param {UUID} generalConversationUuid If this is a team, the id of the general conversation\n   * @param {Object} conversations If this is a team, the list of conversations in the team\n   * @returns {String} url for the specific convo\n   */\n  getConvoUrl({\n    id, url, cluster, conversations, generalConversationUuid\n  }) {\n    if (generalConversationUuid) {\n      // This is a Team\n      // Because Convo doesn't have an endpoint for the team URL\n      // we have to use the general convo URL.\n      const generalConvo = conversations.items.find(\n        (convo) => convo.id === generalConversationUuid\n      );\n\n      return generalConvo.url;\n    }\n\n    if (url) {\n      return url;\n    }\n\n    if (id) {\n      if (cluster) {\n        return this.getUrlFromClusterId({cluster, id});\n      }\n      this.logger.warn(\n        'You should be using the `url` instead of the `id` property'\n      );\n      const relatedUrl = idToUrl.get(id);\n\n      if (!relatedUrl) {\n        throw Error('Could not find the `url` from the given `id`');\n      }\n\n      return relatedUrl;\n    }\n\n    throw Error('The space needs a `url` property');\n  },\n\n  /**\n   * Sets the typing status of the current user in a conversation\n   *\n   * @param {Object} conversation\n   * @param {Object} options\n   * @param {boolean} options.typing\n   * @returns {Promise}\n   */\n  updateTypingStatus(conversation, options) {\n    if (!conversation.id) {\n      if (conversation.url) {\n        conversation.id = conversation.url.split('/').pop();\n      }\n      else {\n        return Promise.reject(\n          new Error('conversation: could not identify conversation')\n        );\n      }\n    }\n\n    let eventType;\n\n    if (options.typing) {\n      eventType = 'status.start_typing';\n    }\n    else {\n      eventType = 'status.stop_typing';\n    }\n\n    const url = this.getConvoUrl(conversation);\n    const resource = 'status/typing';\n    const params = {\n      method: 'POST',\n      body: {\n        conversationId: conversation.id,\n        eventType\n      },\n      url: `${url}/${resource}`\n    };\n\n    return this.request(params);\n  },\n\n  /**\n   * Shares files to the specified conversation\n   * @param {Object} conversation\n   * @param {ShareActivity|Array<File>} activity\n   * @returns {Promise<Activity>}\n   */\n  share(conversation, activity) {\n    if (isArray(activity)) {\n      activity = {\n        object: {\n          files: activity\n        }\n      };\n    }\n\n    const convoWithUrl =\n      Object.assign(\n        {}, conversation, {url: this.getConvoUrl(conversation)}\n      );\n\n    if (!(activity instanceof ShareActivity)) {\n      activity = ShareActivity.create(convoWithUrl, activity, this.webex);\n    }\n\n    return this.prepare(activity, {\n      target: this.prepareConversation(convoWithUrl)\n    })\n      .then((a) => this.submit(a));\n  },\n\n\n  /**\n   * Submits an activity to the conversation service\n   * @param {Object} activity\n   * @param {String} [endpoint] endpoint to submit activity. If empty, find in activity\n   * @returns {Promise<Activity>}\n   */\n  submit(activity, endpoint) {\n    const url = endpoint || this.getConvoUrl(activity.target);\n    const resource = activity.verb === 'share' ? 'content' : 'activities';\n    const params = {\n      method: 'POST',\n      body: activity,\n      qs: {\n        personRefresh: true\n      },\n      url: `${url}/${resource}`\n    };\n\n    if (activity.verb === 'share') {\n      Object.assign(params.qs, {\n        transcode: true,\n        async: false\n      });\n    }\n    /**\n     * helper to cloneDeepWith for copying instance function\n     * @param {Object|String|Symbol|Array|Date} value (recursive value to clone from params)\n     * @returns {Object|null}\n     */\n    // eslint-disable-next-line consistent-return\n    const customActivityCopy = (value) => {\n      const {files} = params.body.object;\n\n      if (files && value && files.items.length > 0 && value.constructor === files.items[0].scr.constructor) {\n        const copySrc = cloneDeep(value);\n\n        copySrc.toJWE = value.toJWE;\n        copySrc.toJSON = value.toJSON;\n\n        return copySrc;\n      }\n    };\n    const cloneActivity = cloneDeepWith(params, customActivityCopy);\n\n    // triggers user-activity to reset logout timer\n    this.webex.trigger('user-activity');\n\n    return this.request(params)\n      .then((res) => res.body)\n      .catch((error) => {\n        // handle when key need to rotate\n        if (error.body && error.body.errorCode === KEY_ROTATION_REQUIRED) {\n          cloneActivity.body.target.defaultActivityEncryptionKeyUrl = null;\n          this.request(cloneActivity);\n        }\n        else if (\n          error.body &&\n    (error.body.errorCode === KEY_ALREADY_ROTATED || error.body.errorCode === ENCRYPTION_KEY_URL_MISMATCH)\n        ) {\n          // handle when key need to update\n          this.webex.request({\n            method: 'GET',\n            api: 'conversation',\n            resource: `conversations/${params.body.target.id}`\n          }).then((res) => {\n            cloneActivity.body.target.defaultActivityEncryptionKeyUrl = res.body.defaultActivityEncryptionkeyUrl;\n            this.request(cloneActivity);\n          });\n        }\n        else {\n          throw error;\n        }\n      });\n  },\n  /**\n   * Remove the avatar from a room\n   * @param {Conversation~ConversationObject} conversation\n   * @param {Conversation~ActivityObject} activity\n   * @returns {Promise}\n   */\n  unassign(conversation, activity) {\n    const convoWithUrl =\n      Object.assign(\n        {}, conversation, {url: this.getConvoUrl(conversation)}\n      );\n\n    return this.prepare(activity, {\n      verb: 'unassign',\n      target: this.prepareConversation(convoWithUrl),\n      object: {\n        objectType: 'content',\n        files: {\n          items: []\n        }\n      }\n    })\n      .then((a) => this.submit(a));\n  },\n\n  /**\n   * Mutes the mentions of a conversation\n   * @param {Conversation~ConversationObject} conversation\n   * @param {Conversation~ActivityObject} activity\n   * @returns {Promise} Resolves with the created activity\n   */\n  unmuteMentions(conversation, activity) {\n    return this.tag(conversation, {\n      tags: ['MENTION_NOTIFICATIONS_ON']\n    }, activity);\n  },\n\n  /**\n   * Mutes the messages of a conversation\n   * @param {Conversation~ConversationObject} conversation\n   * @param {Conversation~ActivityObject} activity\n   * @returns {Promise} Resolves with the created activity\n   */\n  unmuteMessages(conversation, activity) {\n    return this.tag(conversation, {\n      tags: ['MESSAGE_NOTIFICATIONS_ON']\n    }, activity);\n  },\n\n  /**\n   * Stops ignoring conversation\n   * @param {Conversation~ConversationObject} conversation\n   * @param {Conversation~ActivityObject} activity\n   * @returns {Promise} Resolves with the created activity\n   */\n  unignore(conversation, activity) {\n    return this.untag(conversation, {\n      tags: ['IGNORED']\n    }, activity);\n  },\n\n  /**\n   * Update an existing activity\n   * @param {Object} conversation\n   * @param {Object} object\n   * @param {Object} activity\n   * @returns {Promise}\n   */\n  update(conversation, object, activity) {\n    if (!isObject(object)) {\n      return Promise.reject(new Error('`object` must be an object'));\n    }\n\n    const convoWithUrl =\n      Object.assign(\n        {}, conversation, {url: this.getConvoUrl(conversation)}\n      );\n\n    return this.prepare(activity, {\n      verb: 'update',\n      target: this.prepareConversation(convoWithUrl),\n      object\n    })\n      .then((a) => this.submit(a));\n  },\n\n  /**\n   * Sets a new key for the conversation\n   * @param {Object} conversation\n   * @param {Key|string} key (optional)\n   * @param {Object} activity Reference to the activity that will eventually be\n   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a\n   * provisional activity\n   * @returns {Promise<Activity>}\n   */\n  updateKey(conversation, key, activity) {\n    const convoWithUrl =\n      Object.assign(\n        {}, conversation, {url: this.getConvoUrl(conversation)}\n      );\n\n    return this.get(convoWithUrl, {\n      activitiesLimit: 0,\n      includeParticipants: true\n    })\n      .then((c) => this._updateKey(c, key, activity));\n  },\n\n  /**\n   * Sets a new key for the conversation\n   * @param {Object} conversation\n   * @param {Key|string} key (optional)\n   * @param {Object} activity Reference to the activity that will eventually be\n   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a\n   * provisional activity\n   * @private\n   * @returns {Promise<Activity>}\n   */\n  _updateKey(conversation, key, activity) {\n    const convoWithUrl =\n      Object.assign(\n        {}, conversation, {url: this.getConvoUrl(conversation)}\n      );\n\n    return Promise.resolve(\n      key || this.webex.internal.encryption.kms.createUnboundKeys({count: 1})\n    )\n      .then((keys) => {\n        const k = isArray(keys) ? keys[0] : keys;\n        const params = {\n          verb: 'updateKey',\n          target: this.prepareConversation(convoWithUrl),\n          object: {\n            defaultActivityEncryptionKeyUrl: k.uri,\n            objectType: 'conversation'\n          }\n        };\n\n        // Reminder: the kmsResourceObjectUrl is only usable if there is\n        // defaultActivityEncryptionKeyUrl.\n        // Valid defaultActivityEncryptionKeyUrl start with 'kms:'\n        if (\n          convoWithUrl.kmsResourceObjectUrl &&\n          convoWithUrl.kmsResourceObjectUrl.startsWith('kms:')\n        ) {\n          params.kmsMessage = {\n            method: 'update',\n            resourceUri: '<KRO>',\n            uri: k.uri\n          };\n        }\n        else {\n          params.kmsMessage = {\n            method: 'create',\n            uri: '/resources',\n            userIds: map(convoWithUrl.participants.items, 'id'),\n            keyUris: [\n              k.uri\n            ]\n          };\n        }\n\n        return this.prepare(activity, params)\n          .then((a) => this.submit(a));\n      });\n  },\n\n  /**\n   * @param {Object} payload\n   * @param {Object} options\n   * @private\n   * @returns {Promise<Activity>}\n   */\n  _create(payload, options = {}) {\n    return this.request({\n      method: 'POST',\n      service: 'conversation',\n      resource: 'conversations',\n      body: payload,\n      qs: {\n        forceCreate: options.allowPartialCreation\n      }\n    })\n      .then((res) => res.body);\n  },\n\n  /**\n   * @param {Object} params\n   * @param {Object} options\n   * @private\n   * @returns {Promise}\n   */\n  _createGrouped(params, options) {\n    return this._create(this._prepareConversationForCreation(params), options);\n  },\n\n  /**\n   * @param {Object} params\n   * @param {Object} options\n   * @private\n   * @returns {Promise}\n   */\n  _createOneOnOne(params) {\n    const payload = this._prepareConversationForCreation(params);\n\n    payload.tags = ['ONE_ON_ONE'];\n\n    return this._create(payload);\n  },\n\n  /**\n   * Get the current conversation url.\n   *\n   * @returns {Promise<string>} - conversation url\n   */\n  getConversationUrl() {\n    this.logger.info('conversation: getting the conversation service url');\n\n    const convoUrl = this.webex.internal.services.get('conversation');\n\n    // Validate if the conversation url exists in the services plugin and\n    // resolve with its value.\n    if (convoUrl) {\n      return Promise.resolve(convoUrl);\n    }\n\n    // Wait for the postauth catalog to update and then try to retrieve the\n    // conversation service url again.\n    return this.webex.internal.waitForCatalog('postauth')\n      .then(() => this.webex.internal.services.get('conversation'))\n      .catch((error) => {\n        this.logger.warn(\n          'conversation: unable to get conversation url',\n          error.message\n        );\n\n        return Promise.reject(error);\n      });\n  },\n\n  /**\n   * @param {Object} conversation\n   * @private\n   * @returns {Promise}\n   */\n  _inferConversationUrl(conversation) {\n    if (conversation.id) {\n      return this.webex.internal.feature.getFeature('developer', 'web-high-availability')\n        .then((haMessagingEnabled) => {\n          if (haMessagingEnabled) {\n            // recompute conversation URL each time as the host may have changed\n            // since last usage\n            return this.getConversationUrl()\n              .then((url) => {\n                conversation.url = `${url}/conversations/${conversation.id}`;\n\n                return conversation;\n              });\n          }\n          if (!conversation.url) {\n            return this.getConversationUrl()\n              .then((url) => {\n                conversation.url = `${url}/conversations/${conversation.id}`;\n                /* istanbul ignore else */\n                if (process.env.NODE_ENV !== 'production') {\n                  this.logger.warn('conversation: inferred conversation url from conversation id; please pass whole conversation objects to Conversation methods');\n                }\n\n                return conversation;\n              });\n          }\n\n          return Promise.resolve(conversation);\n        });\n    }\n\n    return Promise.resolve(conversation);\n  },\n\n  /**\n   * @param {Object} options\n   * @param {String} options.conversationUrl URL to the conversation\n   * @param {String} options.resource The URL resource to hit for a list of objects\n   * @private\n   * @returns {Promise<Array<Activity>>}\n   */\n  _listActivities(options) {\n    const id = options.conversationId;\n    const url = this.getConvoUrl({url: options.conversationUrl, id});\n    const {resource} = options;\n\n    return this._list({\n      qs: omit(options, 'resource'),\n      url: `${url}/${resource}`\n    });\n  },\n\n\n  /**\n   * common interface for facade of generator functions\n   * @typedef {object} IGeneratorResponse\n   * @param {boolean} done whether there is more to fetch\n   * @param {any} value the value yielded or returned by generator\n   */\n\n  /**\n   * @param {object} options\n   * @param {string} options.conversationId\n   * @param {string} options.conversationUrl,\n   * @param {boolean} options.includeChildren, If set to true, parent activities will be enhanced with child objects\n   * @param {number} options.minActivities how many activities to return in first batch\n   * @param {?string} [options.queryType] one of older, newer, mid. defines which direction to fetch\n   * @param {?object} [options.search] server activity to use as search middle date\n   *\n   * @returns {object}\n   * returns three functions:\n   *\n   * getOlder - gets older activities than oldest fetched\n   *\n   * getNewer - gets newer activities than newest fetched\n   *\n   * jumpToActivity - gets searched-for activity and surrounding activities\n   */\n  listActivitiesThreadOrdered(options) {\n    const {\n      conversationUrl,\n      conversationId\n    } = options;\n\n    if (!conversationUrl && !conversationId) {\n      throw new Error('must provide a conversation URL or conversation ID');\n    }\n\n    const url = this.getConvoUrl({url: conversationUrl, id: conversationId});\n\n    const baseOptions = {...omit(options, ['conversationUrl', 'conversationId']), url};\n\n    const olderOptions = {...baseOptions, queryType: OLDER};\n\n    let threadOrderer = this._listActivitiesThreadOrdered(baseOptions);\n\n    /**\n     * gets queried activity and surrounding activities\n     * calling this function creates a new generator instance, losing the previous instance's internal state\n     * this ensures that jumping to older and newer activities is relative to a single set of timestamps, not many\n     * @param {object} searchObject activity object from convo\n     * @returns {IGeneratorResponse}\n     */\n    const jumpToActivity = async (searchObject) => {\n      if (!searchObject) {\n        throw new Error('Search must be an activity object from conversation service');\n      }\n      const newUrl = searchObject.target && searchObject.target.url;\n\n      if (!newUrl) {\n        throw new Error('Search object must have a target url!');\n      }\n\n      const searchOptions = {\n        ...baseOptions, url: newUrl, queryType: MID, search: searchObject\n      };\n\n      threadOrderer = this._listActivitiesThreadOrdered(searchOptions);\n\n      const {value: searchResults} = await threadOrderer.next(searchOptions);\n\n      return {\n        done: true,\n        value: searchResults\n      };\n    };\n\n    /**\n     * gets older activities than oldest fetched\n     * @returns {IGeneratorResponse}\n     */\n    const getOlder = async () => {\n      const {value = []} = await threadOrderer.next(olderOptions);\n\n      const oldestInBatch = value[0] && value[0].activity;\n      const moreActivitiesExist = oldestInBatch && getActivityType(oldestInBatch) !== ACTIVITY_TYPES.CREATE;\n\n      return {\n        done: !moreActivitiesExist,\n        value\n      };\n    };\n\n    /**\n     * gets newer activities than newest fetched\n     * @returns {IGeneratorResponse}\n     */\n    const getNewer = async () => {\n      const newerOptions = {...baseOptions, queryType: NEWER};\n\n      const {value} = await threadOrderer.next(newerOptions);\n\n      return {\n        done: !value.length,\n        value\n      };\n    };\n\n    return {\n      jumpToActivity,\n      getNewer,\n      getOlder\n    };\n  },\n\n  /**\n    * Represents reactions to messages\n    * @typedef {object} Reaction\n    * @property {object} activity reaction2summary server activity object\n    */\n\n  /**\n   * Represents a root (parent, with or without children) activity, along with any replies and reactions\n   * @typedef {object} Activity\n   * @property {object} activity server activity object\n   * @property {Reaction} reactions\n   * @property {Reaction} reactionSelf\n   */\n\n  /**\n   * @generator\n   * @method\n   * @async\n   * @private\n   * @param {object} options\n   * @param {string} options.url\n   * @param {boolean} options.includeChildren, If set to true, parent activities will be enhanced with child objects\n   * @param {string} [options.minActivities] how many activities to return in first batch\n   * @param {string} [options.queryType] one of older, newer, mid. defines which direction to fetch\n   * @param {object} [options.search] server activity to use as search middle date\n   *\n   * @yields {Activity[]}\n   *\n   * @returns {void}\n   */\n  async* _listActivitiesThreadOrdered(options = {}) {\n    // ***********************************************\n    // INSTANCE STATE VARIABLES\n    // variables that will be used for the life of the generator\n    // ***********************************************\n\n    let {\n      minActivities = defaultMinDisplayableActivities,\n      queryType = INITIAL\n    } = options;\n\n    // must fetch initially before getting newer activities!\n    if (queryType === NEWER) {\n      queryType = INITIAL;\n    }\n\n    const {\n      url: convoUrl,\n      search = {},\n      includeChildren\n    } = options;\n\n    // manage oldest, newest activities (ie bookends)\n    const {setBookends, getNewestAct, getOldestAct} = bookendManager();\n\n    // default batch should be equal to minActivities when fetching back in time, but halved when fetching newer due to subsequent child fetches filling up the minActivities count\n    // reduces server RTs when fetching older activities\n    const defaultBatchSize = (queryType === INITIAL || queryType === OLDER) ? minActivities : Math.max(minBatchSize, Math.ceil(minActivities / 2));\n    let batchSize = defaultBatchSize;\n\n    // exposes activity states and handlers with simple getters\n    const {getActivityHandlerByKey, getActivityByTypeAndParentId} = activityManager();\n\n    // set initial query\n    let query = getQuery(queryType, {activityToSearch: search, batchSize});\n\n    /* eslint-disable no-await-in-loop */\n    /* eslint-disable no-loop-func */\n    while (true) {\n      // ***********************************************\n      // EXECUTION STATE VARIABLES\n      // variables that will be used for each \"batch\" of activities asked for\n      // ***********************************************\n\n      // stores all \"root\" activities (activities that are, or could be, thread parents)\n      const {getRootActivityHash, addNewRoot} = rootActivityManager();\n\n      // used to determine if we should continue to fetch older activities\n      // must be set per iteration, as querying newer activities is still valid when all end of convo has been reached\n      const {\n        getNoMoreActs,\n        checkAndSetNoMoreActs,\n        checkAndSetNoOlderActs,\n        checkAndSetNoNewerActs\n      } = noMoreActivitiesManager();\n\n      const getActivityHandlerByType = (type) => ({\n        [ACTIVITY_TYPES.ROOT]: addNewRoot,\n        [ACTIVITY_TYPES.REPLY]: getActivityHandlerByKey(ACTIVITY_TYPES.REPLY),\n        [ACTIVITY_TYPES.EDIT]: getActivityHandlerByKey(ACTIVITY_TYPES.EDIT),\n        [ACTIVITY_TYPES.REACTION]: getActivityHandlerByKey(ACTIVITY_TYPES.REACTION),\n        [ACTIVITY_TYPES.REACTION_SELF]: getActivityHandlerByKey(ACTIVITY_TYPES.REACTION_SELF),\n        [ACTIVITY_TYPES.TOMBSTONE]: addNewRoot,\n        [ACTIVITY_TYPES.CREATE]: addNewRoot\n      }[type]);\n\n      const handleNewActivity = (activity) => {\n        const actType = getActivityType(activity);\n\n        // ignore deletes\n        if (isDeleteActivity(activity)) {\n          return;\n        }\n\n        const activityHandler = getActivityHandlerByType(actType);\n\n        activityHandler(activity);\n      };\n\n      const handleNewActivities = (activities) => {\n        activities.forEach((act) => {\n          handleNewActivity(act);\n          checkAndSetNoOlderActs(act);\n        });\n      };\n\n      const handleOlderQuery = (activities) => {\n        setBookends(activities, OLDER);\n        handleNewActivities(activities);\n      };\n      const handleNewerQuery = (activities) => {\n        checkAndSetNoNewerActs(activities);\n        if (activities.length) {\n          setBookends(activities, NEWER);\n          handleNewActivities(activities);\n        }\n      };\n      const handleSearch = (activities) => {\n        setBookends(activities, MID);\n        handleNewActivities(activities);\n      };\n\n      const getQueryResponseHandler = (type) => ({\n        [OLDER]: handleOlderQuery,\n        [NEWER]: handleNewerQuery,\n        [MID]: handleSearch,\n        [INITIAL]: handleOlderQuery\n      }[type]);\n\n      // ***********************************************\n      // INNER LOOP\n      // responsible for fetching and building our maps of activities\n      // fetch until minActivities is reached, or no more acts to fetch, or we hit our max fetch count\n      // ***********************************************\n\n      const incrementLoopCounter = getLoopCounterFailsafe();\n\n      while (!getNoMoreActs()) {\n        // count loops and throw if we detect infinite loop\n        incrementLoopCounter();\n\n        // configure fetch request. Use a smaller limit when fetching newer or mids to account for potential children fetches\n        const allBatchActivitiesConfig = {\n          conversationUrl: convoUrl,\n          limit: batchSize,\n          includeChildren,\n          ...query\n        };\n\n        // request activities in batches\n        const $allBatchActivitiesFetch = this.listActivities(allBatchActivitiesConfig);\n\n        // contain fetches in array to parallelize fetching as needed\n        const $fetchRequests = [$allBatchActivitiesFetch];\n\n        // if query requires recursive fetches for children acts, add the additional fetch\n        if (queryType === MID || queryType === NEWER) {\n          const params = {activityType: null};\n\n          if (query.sinceDate) {\n            params.sinceDate = query.sinceDate;\n          }\n\n          const $parentsFetch = this.listParentActivityIds(convoUrl, params);\n\n          $fetchRequests.push($parentsFetch);\n        }\n\n        // we dont always need to fetch for parents\n        const [\n          allBatchActivities,\n          parents = {}\n        ] = await Promise.all($fetchRequests);\n\n        // use query type to decide how to handle response\n        const handler = getQueryResponseHandler(queryType);\n\n        handler(allBatchActivities);\n\n        /*\n          next we must selectively fetch the children of each of the parents to ensure completeness\n          do this by checking the hash for each of the above parent IDs\n          fetch children when we have a parent whose ID is represented in the parent ID lists\n        */\n        const {\n          reply: replyIds = [],\n          edit: editIds = [],\n          reaction: reactionIds = []\n        } = parents;\n\n        // if no parent IDs returned, do nothing\n        if (replyIds.length || editIds.length || reactionIds.length) {\n          const $reactionFetches = [];\n          const $replyFetches = [];\n          const $editFetches = [];\n\n          for (const activity of allBatchActivities) {\n            const actId = activity.id;\n\n            const childFetchOptions = {\n              conversationUrl: convoUrl,\n              activityParentId: actId\n            };\n\n            if (reactionIds.includes(actId)) {\n              $reactionFetches.push(this.getReactionSummaryByParentId(convoUrl, actId, {activityType: 'reactionSummary', includeChildren: true}));\n            }\n            if (replyIds.includes(actId)) {\n              childFetchOptions.query = {activityType: 'reply'};\n              $replyFetches.push(this.listAllChildActivitiesByParentId(childFetchOptions));\n            }\n            if (editIds.includes(actId)) {\n              childFetchOptions.query = {activityType: 'edit'};\n              $editFetches.push(this.listAllChildActivitiesByParentId(childFetchOptions));\n            }\n          }\n\n          // parallelize fetch for speeedz\n          const [reactions, replies, edits] = await Promise.all([\n            Promise.all($reactionFetches),\n            Promise.all($replyFetches),\n            Promise.all($editFetches)\n          ]);\n\n          // new reactions may have come in that also need their reactions fetched\n          const newReplyReactions = await Promise.all(\n            replies\n              .filter((reply) => replyIds.includes(reply.id))\n              .map((reply) => this.getReactionSummaryByParentId(convoUrl, reply.id, {activityType: 'reactionSummary', includeChildren: true}))\n          );\n\n          const allReactions = [...reactions, ...newReplyReactions];\n\n          // stick them into activity hashes\n          replies.forEach((replyArr) => handleNewActivities(replyArr));\n          edits.forEach((editArr) => handleNewActivities(editArr));\n          allReactions.forEach((reactionArr) => handleNewActivities(reactionArr));\n        }\n\n        const rootActivityHash = getRootActivityHash();\n        let visibleActivitiesCount = rootActivityHash.size;\n\n        for (const rootActivity of rootActivityHash.values()) {\n          const {id: rootId} = rootActivity;\n          const repliesByRootId = getActivityByTypeAndParentId(ACTIVITY_TYPES.REPLY, rootId);\n\n          if (repliesByRootId && repliesByRootId.size) {\n            visibleActivitiesCount += repliesByRootId.size || 0;\n          }\n        }\n\n        // stop fetching if we've reached desired count of visible activities\n        if (visibleActivitiesCount >= minActivities) {\n          break;\n        }\n\n        checkAndSetNoMoreActs(queryType, visibleActivitiesCount, batchSize);\n\n        // batchSize should be equal to minimum activities when fetching older activities\n        // covers \"best case\" when we reach minActivities on the first fetch\n        if (queryType === OLDER) {\n          batchSize = minActivities;\n        }\n\n        // since a MID query can bump the batchSize, we need to reset it _after_ a potential MID query\n        // reset batchSize in case of MID queries bumping it up\n        if (queryType === NEWER) {\n          batchSize = defaultBatchSize;\n        }\n\n        const currentOldestPublishedDate = getPublishedDate(getOldestAct());\n        const currentNewestPublishedDate = getPublishedDate(getNewestAct());\n\n        // we're still building our activity list - derive new query from prior query and start loop again\n        if (queryType === INITIAL) {\n          query = getQuery(OLDER, {oldestPublishedDate: currentOldestPublishedDate, batchSize});\n        }\n        else {\n          query = getQuery(queryType, {\n            batchSize,\n            activityToSearch: search,\n            oldestPublishedDate: currentOldestPublishedDate,\n            newestPublishedDate: currentNewestPublishedDate\n          });\n        }\n\n        // if we're still building out the midDate search, bump the search limit to include activities on both sides\n        if (queryType === MID) {\n          batchSize += batchSizeIncrementCount;\n        }\n      }\n\n      const orderedActivities = [];\n\n      const getRepliesByParentId = (replyParentId) => {\n        const replies = [];\n\n        const repliesByParentId = getActivityByTypeAndParentId(ACTIVITY_TYPES.REPLY, replyParentId);\n\n        if (!repliesByParentId) {\n          return replies;\n        }\n\n        const sortedReplies = sortActivitiesByPublishedDate(getActivityObjectsFromMap(repliesByParentId));\n\n        sortedReplies.forEach((replyActivity) => {\n          const replyId = replyActivity.id;\n          const edit = getActivityByTypeAndParentId(ACTIVITY_TYPES.EDIT, replyId);\n          const reaction = getActivityByTypeAndParentId(ACTIVITY_TYPES.REACTION, replyId);\n          const reactionSelf = getActivityByTypeAndParentId(ACTIVITY_TYPES.REACTION_SELF, replyId);\n\n          const latestActivity = edit || replyActivity;\n          // hash of root activities (in case of plain reply) and the reply activity (in case of edit)\n          const allRelevantActivitiesArr = [...getActivityObjectsFromMap(getRootActivityHash()), ...getActivityObjectsFromMap(repliesByParentId)];\n          const allRelevantActivities = allRelevantActivitiesArr.reduce((hashMap, act) => {\n            hashMap[act.id] = act;\n\n            return hashMap;\n          }, {});\n\n          const finalReply = this._createParsedServerActivity(latestActivity, allRelevantActivities);\n\n          const fullReply = {\n            id: replyId,\n            activity: finalReply,\n            reaction,\n            reactionSelf\n          };\n\n          const sanitizedFullReply = sanitizeActivity(fullReply);\n\n          replies.push(sanitizedFullReply);\n        });\n\n        return replies;\n      };\n\n      const orderedRoots = sortActivitiesByPublishedDate(getActivityObjectsFromMap(getRootActivityHash()));\n\n      orderedRoots.forEach((rootActivity) => {\n        const rootId = rootActivity.id;\n        const replies = getRepliesByParentId(rootId);\n        const edit = getActivityByTypeAndParentId(ACTIVITY_TYPES.EDIT, rootId);\n        const reaction = getActivityByTypeAndParentId(ACTIVITY_TYPES.REACTION, rootId);\n        const reactionSelf = getActivityByTypeAndParentId(ACTIVITY_TYPES.REACTION_SELF, rootId);\n\n        const latestActivity = edit || rootActivity;\n        const finalActivity = this._createParsedServerActivity(latestActivity, {[rootId]: rootActivity});\n\n        const fullRoot = {\n          id: rootId,\n          activity: finalActivity,\n          reaction,\n          reactionSelf\n        };\n\n        const sanitizedFullRoot = sanitizeActivity(fullRoot);\n\n        orderedActivities.push(sanitizedFullRoot);\n        replies.forEach((reply) => orderedActivities.push(reply));\n      });\n\n      const nextOptions = yield orderedActivities;\n\n      if (nextOptions) {\n        minActivities = nextOptions.minActivities || minActivities;\n\n        const currentOldestPublishedDate = getPublishedDate(getOldestAct());\n        const currentNewestPublishedDate = getPublishedDate(getNewestAct());\n\n        queryType = nextOptions.queryType;\n        query = getQuery(queryType, {\n          activityToSearch: search,\n          oldestPublishedDate: currentOldestPublishedDate,\n          newestPublishedDate: currentNewestPublishedDate,\n          batchSize\n        });\n      }\n      else {\n        return;\n      }\n    }\n  },\n\n  /**\n   * @typedef {object} EditActivity\n   * @property {object} editParent\n   *\n   * @typedef {object} ReplyActivity\n   * @property {object} replyParent\n   *\n   * @typedef {object} EditedReplyActivity\n   * @property {object} replyParent\n   * @property {object} editParent\n   *\n   * @typedef {EditActivity | ReplyActivity | EditedReplyActivity} ParsedServerActivity\n   */\n\n  /**\n    * hashmap of server activities, keyed by id\n    * @typedef {object} ActivityHash\n    * @property {Object}\n    */\n\n  /**\n   * extends a given server object with fields that point to their parent activities from the hashmap passed in\n   * @param {object} activity server activity\n   * @param {ActivityHash} allActivitiesHash hashmap of all server activities caller would like to pass in\n   * @returns {ParsedServerActivity} server activity extended with edit and reply parent fields\n   */\n  _createParsedServerActivity(activity, allActivitiesHash = {}) {\n    const isOrphan = getIsActivityOrphaned(activity, allActivitiesHash);\n\n    if (isOrphan) {\n      throw new Error('activity has a parent that cannot be found in allActivitiesHash! please handle this as necessary');\n    }\n\n    const activityType = determineActivityType(activity, allActivitiesHash);\n\n    switch (activityType) {\n      case ACTIVITY_TYPES.ROOT: {\n        return createRootActivity(activity);\n      }\n      case ACTIVITY_TYPES.EDIT: {\n        // `activities` must also have the original activity\n        return createEditActivity(activity, allActivitiesHash);\n      }\n      case ACTIVITY_TYPES.REPLY: {\n        return createReplyActivity(activity);\n      }\n      case ACTIVITY_TYPES.REPLY_EDIT: {\n        // `activities` must also have the reply activity\n        return createReplyEditActivity(activity, allActivitiesHash);\n      }\n      default: {\n        return activity;\n      }\n    }\n  },\n\n  /**\n   * @param {Object} options\n   * @private\n   * @returns {Promise<Array<Conversation>>}\n   */\n  async _list(options) {\n    options.qs = Object.assign({\n      personRefresh: true,\n      uuidEntryFormat: true,\n      activitiesLimit: 0,\n      participantsLimit: 0\n    }, options.qs);\n\n    const res = await this.request(options);\n\n    let list;\n\n    if (!res.body || !res.body.items || res.body.items.length === 0) {\n      list = [];\n    }\n    else {\n      list = res.body.items.slice(0);\n      if (last(list).published < list[0].published) {\n        list.reverse();\n      }\n    }\n\n    // The user has more data in another cluster.\n    // Follow the 'additionalUrls' for that data.\n    if (res.body.additionalUrls) {\n      let limit = 0;\n\n      // If the user asked for a specific amount of data,\n      // don't fetch more than what was asked.\n      // Here we figure out how much is left from the original request.\n      // Divide that by the number of additional URLS.\n      // This won't get us the exact limit but it will retrieve something\n      // from every cluster listed.\n      if (options.limit) {\n        limit = Math.floor(\n          (options.limit.value - list.length) / res.body.additionalUrls.length\n        );\n      }\n\n      // If the limit is 0 for some reason,\n      // don't bother requesting from other clusters\n      if (!options.limit || limit !== 0) {\n        const results = await Promise.all(\n          res.body.additionalUrls.map((host) => {\n            const url = `${host}/${options.resource}`;\n            const newOptions = Object.assign({}, options, {uri: url, url});\n\n            if (options.limit) {\n              newOptions.qs[newOptions.limit.name] = limit;\n            }\n\n            return this.request(newOptions);\n          })\n        );\n\n        for (const result of results) {\n          if (result.body && result.body.items && result.body.items.length) {\n            const {items} = result.body;\n\n            if (last(items).published < items[0].published) {\n              items.reverse();\n            }\n            list = list.concat(items);\n          }\n        }\n      }\n    }\n\n    await Promise.all(list.map((item) => this._recordUUIDs(item)));\n\n    return list;\n  },\n\n  /**\n   * @param {Object} params\n   * @param {Object} options\n   * @private\n   * @returns {Promise<Conversation>}\n   */\n  _maybeCreateOneOnOneThenPost(params, options) {\n    return this.get(defaults({\n      // the use of uniq in Conversation#create guarantees participant[1] will\n      // always be the other user\n      user: params.participants[1]\n    }), Object.assign(options, {includeConvWithDeletedUserUUID: true, includeParticipants: true}))\n      .then((conversation) => {\n        if (params.comment || params.html) {\n          return this.post(conversation, {content: params.html, displayName: params.comment})\n            .then((activity) => {\n              conversation.activities.items.push(activity);\n\n              return conversation;\n            });\n        }\n\n        return conversation;\n      })\n      .catch((reason) => {\n        if (reason.statusCode !== 404) {\n          return Promise.reject(reason);\n        }\n\n        return this._createOneOnOne(params);\n      });\n  },\n\n  /**\n   * @param {Object} params\n   * @private\n   * @returns {Object}\n   */\n  _prepareConversationForCreation(params) {\n    const payload = {\n      activities: {\n        items: [\n          this.expand('create')\n        ]\n      },\n      objectType: 'conversation',\n      kmsMessage: {\n        method: 'create',\n        uri: '/resources',\n        userIds: cloneDeep(params.participants),\n        keyUris: []\n      }\n    };\n\n    if (params.displayName) {\n      payload.displayName = params.displayName;\n    }\n\n    if (params.tags) {\n      payload.tags = params.tags;\n    }\n\n    params.participants.forEach((participant) => {\n      payload.activities.items.push(this.expand('add', {\n        objectType: 'person',\n        id: participant\n      }));\n    });\n\n    if (params.comment) {\n      payload.activities.items.push(this.expand('post', {\n        objectType: 'comment',\n        content: params.html,\n        displayName: params.comment\n      }));\n    }\n\n    if (!params.isDefaultClassification && params.classificationId) {\n      payload.activities.items.push(this.expand('update', {\n        objectType: 'classification',\n        classificationId: params.classificationId,\n        effectiveDate: params.effectiveDate\n      }));\n    }\n\n    if (params.favorite) {\n      payload.activities.items.push(this.expand('favorite', {\n        objectType: 'conversation'\n      }));\n    }\n\n    return payload;\n  },\n\n  /**\n   * @param {Object} conversation\n   * @private\n   * @returns {Promise}\n   */\n  _recordUUIDs(conversation) {\n    if (!conversation.participants || !conversation.participants.items) {\n      return Promise.resolve(conversation);\n    }\n\n    return Promise.all(conversation.participants.items.map((participant) => {\n      // ROOMs or LYRA_SPACEs do not have email addresses, so there's no point attempting to\n      // record their UUIDs.\n      if (participant.type === 'ROOM' || participant.type === 'LYRA_SPACE') {\n        return Promise.resolve();\n      }\n\n      return this.webex.internal.user.recordUUID(participant)\n        .catch((err) => this.logger.warn('Could not record uuid', err));\n    }));\n  }\n});\n\n[\n  'favorite',\n  'hide',\n  'lock',\n  'mute',\n  'unfavorite',\n  'unhide',\n  'unlock',\n  'unmute'\n].forEach((verb) => {\n  Conversation.prototype[verb] = function submitSimpleActivity(conversation, activity) {\n    const convoWithUrl =\n      this.prepareConversation(\n        Object.assign(\n          {}, conversation, {url: this.getConvoUrl(conversation)}\n        )\n      );\n\n    return this.prepare(activity, {\n      verb,\n      object: convoWithUrl,\n      target: convoWithUrl\n    })\n      .then((a) => this.submit(a));\n  };\n});\n\n[\n  'assignModerator',\n  'unassignModerator'\n].forEach((verb) => {\n  Conversation.prototype[verb] = function submitModerationChangeActivity(conversation, moderator, activity) {\n    const convoWithUrl =\n      Object.assign(\n        {}, conversation, {url: this.getConvoUrl(conversation)}\n      );\n\n    return Promise.all([\n      convoWithUrl,\n      moderator ? this.webex.internal.user.asUUID(moderator) : this.webex.internal.device.userId\n    ])\n      .then(([c, userId]) => this.prepare(activity, {\n        verb,\n        target: this.prepareConversation(c),\n        object: {\n          id: userId,\n          objectType: 'person'\n        }\n      }))\n      .then((a) => this.submit(a));\n  };\n});\n\n/**\n * Sets/unsets space property for convo\n * @param {Object} conversation\n * @param {string} tag\n * @param {Activity} activity\n * @returns {Promise<Activity>}\n */\n[\n  'setSpaceProperty',\n  'unsetSpaceProperty'\n].forEach((fnName) => {\n  const verb = fnName.startsWith('set') ? 'set' : 'unset';\n\n  Conversation.prototype[fnName] = function submitSpacePropertyActivity(conversation, tag, activity) {\n    if (!isString(tag)) {\n      return Promise.reject(new Error('`tag` must be a string'));\n    }\n\n    const convoWithUrl =\n      Object.assign(\n        {}, conversation, {url: this.getConvoUrl(conversation)}\n      );\n\n    return this.prepare(activity, {\n      verb,\n      target: this.prepareConversation(convoWithUrl),\n      object: {\n        tags: [tag],\n        objectType: 'spaceProperty'\n      }\n    })\n      .then((a) => this.submit(a));\n  };\n});\n\n[\n  'tag',\n  'untag'\n].forEach((verb) => {\n  Conversation.prototype[verb] = function submitObjectActivity(conversation, object, activity) {\n    if (!isObject(object)) {\n      return Promise.reject(new Error('`object` must be an object'));\n    }\n\n    const c =\n      this.prepareConversation(\n        Object.assign(\n          {}, conversation, {url: this.getConvoUrl(conversation)}\n        )\n      );\n\n    return this.prepare(activity, {\n      verb,\n      target: c,\n      object: Object.assign(c, object)\n    })\n      .then((a) => this.submit(a));\n  };\n});\n\nexport default Conversation;\n"]},"metadata":{},"sourceType":"script"}