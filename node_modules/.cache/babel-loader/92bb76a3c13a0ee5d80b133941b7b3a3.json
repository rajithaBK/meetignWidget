{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.transforms = void 0;\n\nvar _symbol = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/symbol\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _deleteProperty = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/reflect/delete-property\"));\n\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/json/stringify\"));\n\nvar _isArray2 = _interopRequireDefault(require(\"lodash/isArray\"));\n\nvar _has2 = _interopRequireDefault(require(\"lodash/has\"));\n\nvar _get2 = _interopRequireDefault(require(\"lodash/get\"));\n\nvar _curry2 = _interopRequireDefault(require(\"lodash/curry\"));\n\nvar _capitalize2 = _interopRequireDefault(require(\"lodash/capitalize\"));\n\nvar _toArray = _interopRequireDefault(require(\"./to-array\"));\n\nvar KEY = (0, _symbol.default)('KEY');\nvar encryptTextProp = (0, _curry2.default)(function (name, ctx, key, object) {\n  return ctx.transform('encryptTextProp', name, key, object);\n});\nvar encryptJsonProp = (0, _curry2.default)(function (name, ctx, key, object) {\n  return ctx.transform('encryptJsonProp', name, key, object);\n}); // eslint-disable-next-line import/prefer-default-export\n\nvar transforms = (0, _toArray.default)('outbound', {\n  encryptObject: function encryptObject(ctx, key, object) {\n    if (!object) {\n      object = key;\n      key = undefined;\n    }\n\n    if (!object) {\n      return _promise.default.resolve();\n    }\n\n    if (!object.objectType) {\n      return _promise.default.resolve();\n    }\n\n    if (key === false) {\n      return _promise.default.resolve();\n    }\n\n    return ctx.transform(\"encrypt\".concat((0, _capitalize2.default)(object.objectType)), key, object);\n  },\n  encryptReaction2: function encryptReaction2(ctx, key, reaction2) {\n    return ctx.transform('encryptPropDisplayName', key, reaction2);\n  },\n  encryptConversation: function encryptConversation(ctx, key, conversation) {\n    if (key === false) {\n      return _promise.default.resolve();\n    }\n\n    return _promise.default.resolve(key || ctx.webex.internal.encryption.kms.createUnboundKeys({\n      count: 1\n    })).then(function (keys) {\n      var k = (0, _isArray2.default)(keys) ? keys[0] : keys;\n\n      if ((0, _has2.default)(conversation, 'kmsMessage.keyUris') && !conversation.kmsMessage.keyUris.includes(k.uri)) {\n        conversation.kmsMessage.keyUris.push(k.uri);\n      }\n\n      return _promise.default.all([// too many implicit returns on the same line is difficult to interpret\n      // eslint-disable-next-line arrow-body-style\n      (0, _has2.default)(conversation, 'activities.items') && conversation.activities.items.reduce(function (p, activity) {\n        // eslint-disable-next-line max-nested-callbacks\n        return p.then(function () {\n          return ctx.transform('encryptObject', k, activity);\n        });\n      }, _promise.default.resolve()), ctx.transform('encryptPropDisplayName', k, conversation)]).then(function () {\n        conversation.encryptionKeyUrl = k.uri || k; // we only want to set the defaultActivityEncryptionKeyUrl if we've\n        // bound a new key\n\n        if (!key) {\n          conversation.defaultActivityEncryptionKeyUrl = conversation.defaultActivityEncryptionKeyUrl || k.uri || k;\n        }\n      });\n    });\n  },\n  encryptActivity: function encryptActivity(ctx, key, activity) {\n    // Activity is already encrypted\n    if (activity.encryptionKeyUrl) {\n      return _promise.default.resolve();\n    }\n\n    return ctx.transform(\"encrypt\".concat((0, _capitalize2.default)(activity.verb), \"Activity\"), key, activity).then(function () {\n      key = key || activity[KEY];\n      return ctx.transform('prepareActivityKmsMessage', key, activity);\n    });\n  },\n  encryptVerbActivity: function encryptVerbActivity(ctx, key, activity) {\n    return ctx.transform('maybeEncryptTarget', key, activity).then(function () {\n      key = key || activity[KEY];\n    }).then(function () {\n      return ctx.transform('encryptObject', key, activity.object);\n    });\n  },\n  maybeEncryptTarget: function maybeEncryptTarget(ctx, key, activity) {\n    // This isn't quite right; if we just go by key, we have no guarantee that\n    // we have a proper KRO available for add activities\n    if (key) {\n      return _promise.default.resolve();\n    }\n\n    if ((0, _has2.default)(activity, 'target.defaultActivityEncryptionKeyUrl') && activity.target.defaultActivityEncryptionKeyUrl && (0, _has2.default)(activity, 'target.kmsResourceObjectUrl')) {\n      activity[KEY] = key || activity.target.defaultActivityEncryptionKeyUrl;\n      return _promise.default.resolve();\n    }\n\n    var conversationUrl = activity.target && activity.target.url;\n\n    if (!conversationUrl) {\n      return _promise.default.reject(new Error('Cannot determine encryption key for activity\\'s conversation; no key url or conversation url provided'));\n    }\n\n    return ctx.webex.internal.conversation.get({\n      url: conversationUrl\n    }).then(function (conversation) {\n      if (!conversation.defaultActivityEncryptionKeyUrl) {\n        return ctx.webex.internal.conversation.updateKey(conversation).then(function (updateKeyActivity) {\n          if (updateKeyActivity.kmsMessage.resource) {\n            activity.target.kmsResourceObjectUrl = updateKeyActivity.kmsMessage.resource.uri;\n          }\n\n          activity[KEY] = activity.target.defaultActivityEncryptionKeyUrl = updateKeyActivity.object.defaultActivityEncryptionKeyUrl;\n        });\n      }\n\n      if (!activity.target.defaultActivityEncryptionKeyUrl) {\n        ctx.webex.logger.warn('plugin-conversation: downloaded conversation to determine its defaultActivityEncryptionKeyUrl; make sure to pass all encryption related properties when calling Webex.conversation methods.');\n      }\n\n      if (!activity.target.kmsResourceObjectUrl) {\n        ctx.webex.logger.warn('plugin-conversation: downloaded conversation to determine its kmsResourceObjectUrl; make sure to pass all encryption related properties when calling Webex.conversation methods.');\n      }\n\n      activity[KEY] = activity.target.defaultActivityEncryptionKeyUrl = conversation.defaultActivityEncryptionKeyUrl;\n      activity.target.kmsResourceObjectUrl = conversation.kmsResourceObjectUrl;\n      return _promise.default.resolve();\n    });\n  },\n  prepareActivityKmsMessage: function prepareActivityKmsMessage(ctx, key, activity) {\n    if (activity.kmsMessage) {\n      if (!key && activity.verb === 'updateKey' && (0, _has2.default)(activity, 'object.defaultActivityEncryptionKeyUrl')) {\n        key = (0, _get2.default)(activity, 'object.defaultActivityEncryptionKeyUrl');\n      }\n\n      if (!key && activity.verb === 'leave' && (0, _has2.default)(activity, 'target.defaultActivityEncryptionKeyUrl')) {\n        key = (0, _get2.default)(activity, 'target.defaultActivityEncryptionKeyUrl');\n      }\n\n      if (key) {\n        var kro = activity.target.kmsResourceObjectUrl;\n        ['uri', 'resourceUri'].forEach(function (k) {\n          if (activity.kmsMessage[k] && !kro && activity.kmsMessage[k].includes('<KRO>')) {\n            throw new Error('encrypter: cannot determine kro');\n          }\n\n          if (activity.kmsMessage[k]) {\n            activity.kmsMessage[k] = activity.kmsMessage[k].replace('<KRO>', kro); // key may be a key or a key url\n\n            activity.kmsMessage[k] = activity.kmsMessage[k].replace('<KEYURL>', key.keyUrl || key);\n          }\n        });\n      } // If we made it this far and still don't have an encryption key, assume\n      // this is a conversation that is not encrypted and we're performing an\n      // action that should not encrypt it (e.g. `leave`)\n      else {\n        (0, _deleteProperty.default)(activity, 'kmsMessage');\n      }\n    }\n  },\n  encryptVerbActivityWithKey: {\n    direction: 'outbound',\n    fn: function fn(ctx, key, activity) {\n      return ctx.transform('encryptVerbActivity', key, activity).then(function () {\n        key = key || activity[KEY];\n        activity.encryptionKeyUrl = key.uri || key;\n      });\n    }\n  },\n  encryptAddActivity: {\n    direction: 'outbound',\n    fn: function fn(ctx, key, activity) {\n      if ((0, _has2.default)(activity, 'object.objectType') && activity.object.objectType === 'reaction2') {\n        return ctx.transform('encryptVerbActivityWithKey', key, activity);\n      }\n\n      return ctx.transform('encryptVerbActivity', key, activity);\n    }\n  },\n  encryptAssignActivity: {\n    direction: 'outbound',\n    alias: 'encryptVerbActivityWithKey'\n  },\n  encryptCreateActivity: {\n    direction: 'outbound',\n    alias: 'encryptVerbActivity'\n  },\n  encryptPostActivity: {\n    direction: 'outbound',\n    alias: 'encryptVerbActivityWithKey'\n  },\n  encryptShareActivity: {\n    direction: 'outbound',\n    alias: 'encryptVerbActivityWithKey'\n  },\n  encryptCardactionActivity: {\n    direction: 'outbound',\n    alias: 'encryptVerbActivityWithKey'\n  },\n  encryptUpdateActivity: {\n    direction: 'outbound',\n    alias: 'encryptVerbActivityWithKey'\n  },\n  encryptUpdateKeyActivity: {\n    direction: 'outbound',\n    alias: 'encryptVerbActivity'\n  },\n  encryptComment: function encryptComment(ctx, key, comment) {\n    return _promise.default.all([ctx.transform('encryptPropDisplayName', key, comment), ctx.transform('encryptPropContent', key, comment)]);\n  },\n  encryptContent: function encryptContent(ctx, key, content) {\n    var promises = content.files.items.map(function (item) {\n      return ctx.transform('encryptObject', key, item);\n    });\n    promises.push(ctx.transform('encryptPropContent', key, content));\n    promises.push(ctx.transform('encryptPropDisplayName', key, content));\n    return _promise.default.all(promises);\n  },\n  encryptFile: function encryptFile(ctx, key, file) {\n    if (file.image && !file.image.scr) {\n      return _promise.default.reject(new Error('`file.image` must have an `scr`'));\n    }\n\n    return _promise.default.all([ctx.transform('encryptPropScr', key, file), ctx.transform('encryptPropDisplayName', key, file), ctx.transform('encryptPropContent', key, file), file.image && ctx.transform('encryptPropScr', key, file.image)]);\n  },\n  encryptSubmit: function encryptSubmit(ctx, key, submit) {\n    return ctx.transform('encryptPropInputs', key, submit);\n  },\n  // TODO is this used for anything other than the now-removed stickies service?\n  encryptImageURI: function encryptImageURI(ctx, key, imageURI) {\n    return ctx.transform('encryptPropLocation', key, imageURI);\n  },\n  encryptPropContent: encryptTextProp('content'),\n  encryptPropDisplayName: encryptTextProp('displayName'),\n  encryptPropInputs: encryptJsonProp('inputs'),\n  encryptPropLocation: encryptTextProp('location'),\n  encryptPropScr: function encryptPropScr(ctx, key, object) {\n    if (!object.scr) {\n      return _promise.default.resolve();\n    }\n\n    return ctx.webex.internal.encryption.encryptScr(key, object.scr).then(function (scr) {\n      object.scr = scr;\n    });\n  },\n  encryptJsonProp: function encryptJsonProp(ctx, name, key, object) {\n    if (!object[name]) {\n      return _promise.default.resolve();\n    }\n\n    return ctx.webex.internal.encryption.encryptText(key.uri || key, (0, _stringify.default)(object[name])).then(function (ciphertext) {\n      object[name] = ciphertext;\n    });\n  },\n  encryptTextProp: function encryptTextProp(ctx, name, key, object) {\n    if (!object[name]) {\n      return _promise.default.resolve();\n    }\n\n    return ctx.webex.internal.encryption.encryptText(key.uri || key, object[name]).then(function (ciphertext) {\n      object[name] = ciphertext;\n    });\n  }\n});\nexports.transforms = transforms;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAYA;;AAEA,IAAMA,GAAG,GAAG,qBAAO,KAAP,CAAZ;AAEA,IAAMC,eAAe,GAAG,qBAAM,UAACC,IAAD,EAAOC,GAAP,EAAYC,GAAZ,EAAiBC,MAAjB;AAAA,SAA4BF,GAAG,CAACG,SAAJH,CAAc,iBAAdA,EAAiCD,IAAjCC,EAAuCC,GAAvCD,EAA4CE,MAA5CF,CAA5B;AAAN,EAAxB;AAEA,IAAMI,eAAe,GAAG,qBAAM,UAACL,IAAD,EAAOC,GAAP,EAAYC,GAAZ,EAAiBC,MAAjB;AAAA,SAA4BF,GAAG,CAACG,SAAJH,CAAc,iBAAdA,EAAiCD,IAAjCC,EAAuCC,GAAvCD,EAA4CE,MAA5CF,CAA5B;AAAN,EAAxB,C,CAEA;;AACO,IAAMK,UAAU,GAAG,sBAAQ,UAAR,EAAoB;AAC5CC,eAD4C,yBAC9BN,GAD8B,EACzBC,GADyB,EACpBC,MADoB,EACZ;AAC9B,QAAI,CAACA,MAAL,EAAa;AACXA,YAAM,GAAGD,GAATC;AACAD,SAAG,GAAGM,SAANN;AACD;;AAED,QAAI,CAACC,MAAL,EAAa;AACX,aAAOM,iBAAQC,OAAR,EAAP;AACD;;AAED,QAAI,CAACP,MAAM,CAACQ,UAAZ,EAAwB;AACtB,aAAOF,iBAAQC,OAAR,EAAP;AACD;;AAED,QAAIR,GAAG,KAAK,KAAZ,EAAmB;AACjB,aAAOO,iBAAQC,OAAR,EAAP;AACD;;AAED,WAAOT,GAAG,CAACG,SAAJH,kBAAwB,0BAAWE,MAAM,CAACQ,UAAlB,CAAxB,GAAyDT,GAAzDD,EAA8DE,MAA9DF,CAAP;AAnB0C;AAsB5CW,kBAtB4C,4BAsB3BX,GAtB2B,EAsBtBC,GAtBsB,EAsBjBW,SAtBiB,EAsBN;AACpC,WAAOZ,GAAG,CAACG,SAAJH,CAAc,wBAAdA,EAAwCC,GAAxCD,EAA6CY,SAA7CZ,CAAP;AAvB0C;AA0B5Ca,qBA1B4C,+BA0BxBb,GA1BwB,EA0BnBC,GA1BmB,EA0Bda,YA1Bc,EA0BA;AAC1C,QAAIb,GAAG,KAAK,KAAZ,EAAmB;AACjB,aAAOO,iBAAQC,OAAR,EAAP;AACD;;AAED,WAAOD,iBAAQC,OAAR,CAAgBR,GAAG,IAAID,GAAG,CAACe,KAAJf,CAAUgB,QAAVhB,CAAmBiB,UAAnBjB,CAA8BkB,GAA9BlB,CAAkCmB,iBAAlCnB,CAAoD;AAACoB,WAAK,EAAE;AAAR,KAApDpB,CAAvB,EACJqB,IADI,CACC,UAACC,IAAD,EAAU;AACd,UAAMC,CAAC,GAAG,uBAAQD,IAAR,IAAgBA,IAAI,CAAC,CAAD,CAApB,GAA0BA,IAApC;;AAEA,UAAI,mBAAIR,YAAJ,EAAkB,oBAAlB,KAA2C,CAACA,YAAY,CAACU,UAAbV,CAAwBW,OAAxBX,CAAgCY,QAAhCZ,CAAyCS,CAAC,CAACI,GAA3Cb,CAAhD,EAAiG;AAC/FA,oBAAY,CAACU,UAAbV,CAAwBW,OAAxBX,CAAgCc,IAAhCd,CAAqCS,CAAC,CAACI,GAAvCb;AACD;;AAED,aAAON,iBAAQqB,GAAR,CAAY,CACjB;AACA;AACA,yBAAIf,YAAJ,EAAkB,kBAAlB,KAAyCA,YAAY,CAACgB,UAAbhB,CAAwBiB,KAAxBjB,CAA8BkB,MAA9BlB,CAAqC,UAACmB,CAAD,EAAIC,QAAJ,EAAiB;AAC7F;AACA,eAAOD,CAAC,CAACZ,IAAFY,CAAO;AAAA,iBAAMjC,GAAG,CAACG,SAAJH,CAAc,eAAdA,EAA+BuB,CAA/BvB,EAAkCkC,QAAlClC,CAAN;AAAP,UAAP;AAFuC,SAGtCQ,iBAAQC,OAAR,EAHsCK,CAHxB,EAOjBd,GAAG,CAACG,SAAJH,CAAc,wBAAdA,EAAwCuB,CAAxCvB,EAA2Cc,YAA3Cd,CAPiB,CAAZ,EASJqB,IATI,CASC,YAAM;AACVP,oBAAY,CAACqB,gBAAbrB,GAAgCS,CAAC,CAACI,GAAFJ,IAASA,CAAzCT,CADU,CAEV;AACA;;AACA,YAAI,CAACb,GAAL,EAAU;AACRa,sBAAY,CAACsB,+BAAbtB,GAA+CA,YAAY,CAACsB,+BAAbtB,IAAgDS,CAAC,CAACI,GAAlDb,IAAyDS,CAAxGT;AACD;AAfE,QAAP;AARG,MAAP;AA/B0C;AA2D5CuB,iBA3D4C,2BA2D5BrC,GA3D4B,EA2DvBC,GA3DuB,EA2DlBiC,QA3DkB,EA2DR;AAClC;AACA,QAAIA,QAAQ,CAACC,gBAAb,EAA+B;AAC7B,aAAO3B,iBAAQC,OAAR,EAAP;AACD;;AAED,WAAOT,GAAG,CAACG,SAAJH,kBAAwB,0BAAWkC,QAAQ,CAACI,IAApB,CAAxB,eAA6DrC,GAA7DD,EAAkEkC,QAAlElC,EACJqB,IADIrB,CACC,YAAM;AACVC,SAAG,GAAGA,GAAG,IAAIiC,QAAQ,CAACrC,GAAD,CAArBI;AAEA,aAAOD,GAAG,CAACG,SAAJH,CAAc,2BAAdA,EAA2CC,GAA3CD,EAAgDkC,QAAhDlC,CAAP;AAJG,MAAP;AAjE0C;AAyE5CuC,qBAzE4C,+BAyExBvC,GAzEwB,EAyEnBC,GAzEmB,EAyEdiC,QAzEc,EAyEJ;AACtC,WAAOlC,GAAG,CAACG,SAAJH,CAAc,oBAAdA,EAAoCC,GAApCD,EAAyCkC,QAAzClC,EACJqB,IADIrB,CACC,YAAM;AACVC,SAAG,GAAGA,GAAG,IAAIiC,QAAQ,CAACrC,GAAD,CAArBI;AAFG,OAIJoB,IAJIrB,CAIC;AAAA,aAAMA,GAAG,CAACG,SAAJH,CAAc,eAAdA,EAA+BC,GAA/BD,EAAoCkC,QAAQ,CAAChC,MAA7CF,CAAN;AAJD,MAAP;AA1E0C;AAiF5CwC,oBAjF4C,8BAiFzBxC,GAjFyB,EAiFpBC,GAjFoB,EAiFfiC,QAjFe,EAiFL;AACrC;AACA;AACA,QAAIjC,GAAJ,EAAS;AACP,aAAOO,iBAAQC,OAAR,EAAP;AACD;;AAED,QAAI,mBAAIyB,QAAJ,EAAc,wCAAd,KACFA,QAAQ,CAACO,MAATP,CAAgBE,+BADd,IAEF,mBAAIF,QAAJ,EAAc,6BAAd,CAFF,EAGE;AACAA,cAAQ,CAACrC,GAAD,CAARqC,GAAgBjC,GAAG,IAAIiC,QAAQ,CAACO,MAATP,CAAgBE,+BAAvCF;AAEA,aAAO1B,iBAAQC,OAAR,EAAP;AACD;;AAED,QAAMiC,eAAe,GAAGR,QAAQ,CAACO,MAATP,IAAmBA,QAAQ,CAACO,MAATP,CAAgBS,GAA3D;;AAEA,QAAI,CAACD,eAAL,EAAsB;AACpB,aAAOlC,iBAAQoC,MAAR,CAAe,IAAIC,KAAJ,CAAU,uGAAV,CAAf,CAAP;AACD;;AAED,WAAO7C,GAAG,CAACe,KAAJf,CAAUgB,QAAVhB,CAAmBc,YAAnBd,CAAgC8C,GAAhC9C,CAAoC;AAAC2C,SAAG,EAAED;AAAN,KAApC1C,EACJqB,IADIrB,CACC,UAACc,YAAD,EAAkB;AACtB,UAAI,CAACA,YAAY,CAACsB,+BAAlB,EAAmD;AACjD,eAAOpC,GAAG,CAACe,KAAJf,CAAUgB,QAAVhB,CAAmBc,YAAnBd,CAAgC+C,SAAhC/C,CAA0Cc,YAA1Cd,EACJqB,IADIrB,CACC,UAACgD,iBAAD,EAAuB;AAC3B,cAAIA,iBAAiB,CAACxB,UAAlBwB,CAA6BC,QAAjC,EAA2C;AACzCf,oBAAQ,CAACO,MAATP,CAAgBgB,oBAAhBhB,GAAuCc,iBAAiB,CAACxB,UAAlBwB,CAA6BC,QAA7BD,CAAsCrB,GAA7EO;AACD;;AACDA,kBAAQ,CAACrC,GAAD,CAARqC,GAAgBA,QAAQ,CAACO,MAATP,CAAgBE,+BAAhBF,GAAkDc,iBAAiB,CAAC9C,MAAlB8C,CAAyBZ,+BAA3FF;AALG,UAAP;AAOD;;AAED,UAAI,CAACA,QAAQ,CAACO,MAATP,CAAgBE,+BAArB,EAAsD;AACpDpC,WAAG,CAACe,KAAJf,CAAUmD,MAAVnD,CAAiBoD,IAAjBpD,CAAsB,6LAAtBA;AACD;;AAED,UAAI,CAACkC,QAAQ,CAACO,MAATP,CAAgBgB,oBAArB,EAA2C;AACzClD,WAAG,CAACe,KAAJf,CAAUmD,MAAVnD,CAAiBoD,IAAjBpD,CAAsB,kLAAtBA;AACD;;AAEDkC,cAAQ,CAACrC,GAAD,CAARqC,GAAgBA,QAAQ,CAACO,MAATP,CAAgBE,+BAAhBF,GAAkDpB,YAAY,CAACsB,+BAA/EF;AACAA,cAAQ,CAACO,MAATP,CAAgBgB,oBAAhBhB,GAAuCpB,YAAY,CAACoC,oBAApDhB;AAEA,aAAO1B,iBAAQC,OAAR,EAAP;AAvBG,MAAP;AAvG0C;AAkI5C4C,2BAlI4C,qCAkIlBrD,GAlIkB,EAkIbC,GAlIa,EAkIRiC,QAlIQ,EAkIE;AAC5C,QAAIA,QAAQ,CAACV,UAAb,EAAyB;AACvB,UAAI,CAACvB,GAAD,IAAQiC,QAAQ,CAACI,IAATJ,KAAkB,WAA1B,IAAyC,mBAAIA,QAAJ,EAAc,wCAAd,CAA7C,EAAsG;AACpGjC,WAAG,GAAG,mBAAIiC,QAAJ,EAAc,wCAAd,CAANjC;AACD;;AAED,UAAI,CAACA,GAAD,IAAQiC,QAAQ,CAACI,IAATJ,KAAkB,OAA1B,IAAqC,mBAAIA,QAAJ,EAAc,wCAAd,CAAzC,EAAkG;AAChGjC,WAAG,GAAG,mBAAIiC,QAAJ,EAAc,wCAAd,CAANjC;AACD;;AAED,UAAIA,GAAJ,EAAS;AACP,YAAMqD,GAAG,GAAGpB,QAAQ,CAACO,MAATP,CAAgBgB,oBAA5B;AAEA,SAAC,KAAD,EAAQ,aAAR,EAAuBK,OAAvB,CAA+B,UAAChC,CAAD,EAAO;AACpC,cAAIW,QAAQ,CAACV,UAATU,CAAoBX,CAApBW,KAA0B,CAACoB,GAA3BpB,IAAkCA,QAAQ,CAACV,UAATU,CAAoBX,CAApBW,EAAuBR,QAAvBQ,CAAgC,OAAhCA,CAAtC,EAAgF;AAC9E,kBAAM,IAAIW,KAAJ,CAAU,iCAAV,CAAN;AACD;;AAED,cAAIX,QAAQ,CAACV,UAATU,CAAoBX,CAApBW,CAAJ,EAA4B;AAC1BA,oBAAQ,CAACV,UAATU,CAAoBX,CAApBW,IAAyBA,QAAQ,CAACV,UAATU,CAAoBX,CAApBW,EAAuBsB,OAAvBtB,CAA+B,OAA/BA,EAAwCoB,GAAxCpB,CAAzBA,CAD0B,CAE1B;;AACAA,oBAAQ,CAACV,UAATU,CAAoBX,CAApBW,IAAyBA,QAAQ,CAACV,UAATU,CAAoBX,CAApBW,EAAuBsB,OAAvBtB,CAA+B,UAA/BA,EAA2CjC,GAAG,CAACwD,MAAJxD,IAAcA,GAAzDiC,CAAzBA;AACD;AATH;AAHF,QAeA;AACA;AACA;AAjBA,WAkBK;AACH,qCAAuBA,QAAvB,EAAiC,YAAjC;AACD;AACF;AAjKyC;AAoK5CwB,4BAA0B,EAAE;AAC1BC,aAAS,EAAE,UADe;AAE1BC,MAF0B,cAEvB5D,GAFuB,EAElBC,GAFkB,EAEbiC,QAFa,EAEH;AACrB,aAAOlC,GAAG,CAACG,SAAJH,CAAc,qBAAdA,EAAqCC,GAArCD,EAA0CkC,QAA1ClC,EACJqB,IADIrB,CACC,YAAM;AACVC,WAAG,GAAGA,GAAG,IAAIiC,QAAQ,CAACrC,GAAD,CAArBI;AACAiC,gBAAQ,CAACC,gBAATD,GAA4BjC,GAAG,CAAC0B,GAAJ1B,IAAWA,GAAvCiC;AAHG,QAAP;AAKD;AARyB,GApKgB;AA+K5C2B,oBAAkB,EAAE;AAClBF,aAAS,EAAE,UADO;AAElBC,MAFkB,cAEf5D,GAFe,EAEVC,GAFU,EAELiC,QAFK,EAEK;AACrB,UAAI,mBAAIA,QAAJ,EAAc,mBAAd,KAAsCA,QAAQ,CAAChC,MAATgC,CAAgBxB,UAAhBwB,KAA+B,WAAzE,EAAsF;AACpF,eAAOlC,GAAG,CAACG,SAAJH,CAAc,4BAAdA,EAA4CC,GAA5CD,EAAiDkC,QAAjDlC,CAAP;AACD;;AAED,aAAOA,GAAG,CAACG,SAAJH,CAAc,qBAAdA,EAAqCC,GAArCD,EAA0CkC,QAA1ClC,CAAP;AACD;AARiB,GA/KwB;AA0L5C8D,uBAAqB,EAAE;AACrBH,aAAS,EAAE,UADU;AAErBI,SAAK,EAAE;AAFc,GA1LqB;AA+L5CC,uBAAqB,EAAE;AACrBL,aAAS,EAAE,UADU;AAErBI,SAAK,EAAE;AAFc,GA/LqB;AAoM5CE,qBAAmB,EAAE;AACnBN,aAAS,EAAE,UADQ;AAEnBI,SAAK,EAAE;AAFY,GApMuB;AAyM5CG,sBAAoB,EAAE;AACpBP,aAAS,EAAE,UADS;AAEpBI,SAAK,EAAE;AAFa,GAzMsB;AA8M5CI,2BAAyB,EAAE;AACzBR,aAAS,EAAE,UADc;AAEzBI,SAAK,EAAE;AAFkB,GA9MiB;AAmN5CK,uBAAqB,EAAE;AACrBT,aAAS,EAAE,UADU;AAErBI,SAAK,EAAE;AAFc,GAnNqB;AAwN5CM,0BAAwB,EAAE;AACxBV,aAAS,EAAE,UADa;AAExBI,SAAK,EAAE;AAFiB,GAxNkB;AA6N5CO,gBA7N4C,0BA6N7BtE,GA7N6B,EA6NxBC,GA7NwB,EA6NnBsE,OA7NmB,EA6NV;AAChC,WAAO/D,iBAAQqB,GAAR,CAAY,CACjB7B,GAAG,CAACG,SAAJH,CAAc,wBAAdA,EAAwCC,GAAxCD,EAA6CuE,OAA7CvE,CADiB,EAEjBA,GAAG,CAACG,SAAJH,CAAc,oBAAdA,EAAoCC,GAApCD,EAAyCuE,OAAzCvE,CAFiB,CAAZ,CAAP;AA9N0C;AAoO5CwE,gBApO4C,0BAoO7BxE,GApO6B,EAoOxBC,GApOwB,EAoOnBwE,OApOmB,EAoOV;AAChC,QAAMC,QAAQ,GAAGD,OAAO,CAACE,KAARF,CAAc1C,KAAd0C,CAAoBG,GAApBH,CAAwB,UAACI,IAAD;AAAA,aAAU7E,GAAG,CAACG,SAAJH,CAAc,eAAdA,EAA+BC,GAA/BD,EAAoC6E,IAApC7E,CAAV;AAAxB,MAAjB;AAEA0E,YAAQ,CAAC9C,IAAT8C,CAAc1E,GAAG,CAACG,SAAJH,CAAc,oBAAdA,EAAoCC,GAApCD,EAAyCyE,OAAzCzE,CAAd0E;AACAA,YAAQ,CAAC9C,IAAT8C,CAAc1E,GAAG,CAACG,SAAJH,CAAc,wBAAdA,EAAwCC,GAAxCD,EAA6CyE,OAA7CzE,CAAd0E;AAEA,WAAOlE,iBAAQqB,GAAR,CAAY6C,QAAZ,CAAP;AA1O0C;AA6O5CI,aA7O4C,uBA6OhC9E,GA7OgC,EA6O3BC,GA7O2B,EA6OtB8E,IA7OsB,EA6OhB;AAC1B,QAAIA,IAAI,CAACC,KAALD,IAAc,CAACA,IAAI,CAACC,KAALD,CAAWE,GAA9B,EAAmC;AACjC,aAAOzE,iBAAQoC,MAAR,CAAe,IAAIC,KAAJ,CAAU,iCAAV,CAAf,CAAP;AACD;;AAED,WAAOrC,iBAAQqB,GAAR,CAAY,CACjB7B,GAAG,CAACG,SAAJH,CAAc,gBAAdA,EAAgCC,GAAhCD,EAAqC+E,IAArC/E,CADiB,EAEjBA,GAAG,CAACG,SAAJH,CAAc,wBAAdA,EAAwCC,GAAxCD,EAA6C+E,IAA7C/E,CAFiB,EAGjBA,GAAG,CAACG,SAAJH,CAAc,oBAAdA,EAAoCC,GAApCD,EAAyC+E,IAAzC/E,CAHiB,EAIjB+E,IAAI,CAACC,KAALD,IAAc/E,GAAG,CAACG,SAAJH,CAAc,gBAAdA,EAAgCC,GAAhCD,EAAqC+E,IAAI,CAACC,KAA1ChF,CAJG,CAAZ,CAAP;AAlP0C;AA0P5CkF,eA1P4C,yBA0P9BlF,GA1P8B,EA0PzBC,GA1PyB,EA0PpBkF,MA1PoB,EA0PZ;AAC9B,WAAOnF,GAAG,CAACG,SAAJH,CAAc,mBAAdA,EAAmCC,GAAnCD,EAAwCmF,MAAxCnF,CAAP;AA3P0C;AA8P5C;AACAoF,iBA/P4C,2BA+P5BpF,GA/P4B,EA+PvBC,GA/PuB,EA+PlBoF,QA/PkB,EA+PR;AAClC,WAAOrF,GAAG,CAACG,SAAJH,CAAc,qBAAdA,EAAqCC,GAArCD,EAA0CqF,QAA1CrF,CAAP;AAhQ0C;AAmQ5CsF,oBAAkB,EAAExF,eAAe,CAAC,SAAD,CAnQS;AAqQ5CyF,wBAAsB,EAAEzF,eAAe,CAAC,aAAD,CArQK;AAuQ5C0F,mBAAiB,EAAEpF,eAAe,CAAC,QAAD,CAvQU;AAyQ5CqF,qBAAmB,EAAE3F,eAAe,CAAC,UAAD,CAzQQ;AA2Q5C4F,gBA3Q4C,0BA2Q7B1F,GA3Q6B,EA2QxBC,GA3QwB,EA2QnBC,MA3QmB,EA2QX;AAC/B,QAAI,CAACA,MAAM,CAAC+E,GAAZ,EAAiB;AACf,aAAOzE,iBAAQC,OAAR,EAAP;AACD;;AAED,WAAOT,GAAG,CAACe,KAAJf,CAAUgB,QAAVhB,CAAmBiB,UAAnBjB,CAA8B2F,UAA9B3F,CAAyCC,GAAzCD,EAA8CE,MAAM,CAAC+E,GAArDjF,EACJqB,IADIrB,CACC,UAACiF,GAAD,EAAS;AACb/E,YAAM,CAAC+E,GAAP/E,GAAa+E,GAAb/E;AAFG,MAAP;AAhR0C;AAsR5CE,iBAtR4C,2BAsR5BJ,GAtR4B,EAsRvBD,IAtRuB,EAsRjBE,GAtRiB,EAsRZC,MAtRY,EAsRJ;AACtC,QAAI,CAACA,MAAM,CAACH,IAAD,CAAX,EAAmB;AACjB,aAAOS,iBAAQC,OAAR,EAAP;AACD;;AAED,WAAOT,GAAG,CAACe,KAAJf,CAAUgB,QAAVhB,CAAmBiB,UAAnBjB,CAA8B4F,WAA9B5F,CAA0CC,GAAG,CAAC0B,GAAJ1B,IAAWA,GAArDD,EAA0D,wBAAeE,MAAM,CAACH,IAAD,CAArB,CAA1DC,EACJqB,IADIrB,CACC,UAAC6F,UAAD,EAAgB;AACpB3F,YAAM,CAACH,IAAD,CAANG,GAAe2F,UAAf3F;AAFG,MAAP;AA3R0C;AAiS5CJ,iBAjS4C,2BAiS5BE,GAjS4B,EAiSvBD,IAjSuB,EAiSjBE,GAjSiB,EAiSZC,MAjSY,EAiSJ;AACtC,QAAI,CAACA,MAAM,CAACH,IAAD,CAAX,EAAmB;AACjB,aAAOS,iBAAQC,OAAR,EAAP;AACD;;AAED,WAAOT,GAAG,CAACe,KAAJf,CAAUgB,QAAVhB,CAAmBiB,UAAnBjB,CAA8B4F,WAA9B5F,CAA0CC,GAAG,CAAC0B,GAAJ1B,IAAWA,GAArDD,EAA0DE,MAAM,CAACH,IAAD,CAAhEC,EACJqB,IADIrB,CACC,UAAC6F,UAAD,EAAgB;AACpB3F,YAAM,CAACH,IAAD,CAANG,GAAe2F,UAAf3F;AAFG,MAAP;AAID;AA1S2C,CAApB,CAAnB","names":["KEY","encryptTextProp","name","ctx","key","object","transform","encryptJsonProp","transforms","encryptObject","undefined","_promise","resolve","objectType","encryptReaction2","reaction2","encryptConversation","conversation","webex","internal","encryption","kms","createUnboundKeys","count","then","keys","k","kmsMessage","keyUris","includes","uri","push","all","activities","items","reduce","p","activity","encryptionKeyUrl","defaultActivityEncryptionKeyUrl","encryptActivity","verb","encryptVerbActivity","maybeEncryptTarget","target","conversationUrl","url","reject","Error","get","updateKey","updateKeyActivity","resource","kmsResourceObjectUrl","logger","warn","prepareActivityKmsMessage","kro","forEach","replace","keyUrl","encryptVerbActivityWithKey","direction","fn","encryptAddActivity","encryptAssignActivity","alias","encryptCreateActivity","encryptPostActivity","encryptShareActivity","encryptCardactionActivity","encryptUpdateActivity","encryptUpdateKeyActivity","encryptComment","comment","encryptContent","content","promises","files","map","item","encryptFile","file","image","scr","encryptSubmit","submit","encryptImageURI","imageURI","encryptPropContent","encryptPropDisplayName","encryptPropInputs","encryptPropLocation","encryptPropScr","encryptScr","encryptText","ciphertext"],"sources":["encryption-transforms.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {\n  capitalize,\n  curry,\n  get,\n  has,\n  isArray\n} from 'lodash';\n\nimport toArray from './to-array';\n\nconst KEY = Symbol('KEY');\n\nconst encryptTextProp = curry((name, ctx, key, object) => ctx.transform('encryptTextProp', name, key, object));\n\nconst encryptJsonProp = curry((name, ctx, key, object) => ctx.transform('encryptJsonProp', name, key, object));\n\n// eslint-disable-next-line import/prefer-default-export\nexport const transforms = toArray('outbound', {\n  encryptObject(ctx, key, object) {\n    if (!object) {\n      object = key;\n      key = undefined;\n    }\n\n    if (!object) {\n      return Promise.resolve();\n    }\n\n    if (!object.objectType) {\n      return Promise.resolve();\n    }\n\n    if (key === false) {\n      return Promise.resolve();\n    }\n\n    return ctx.transform(`encrypt${capitalize(object.objectType)}`, key, object);\n  },\n\n  encryptReaction2(ctx, key, reaction2) {\n    return ctx.transform('encryptPropDisplayName', key, reaction2);\n  },\n\n  encryptConversation(ctx, key, conversation) {\n    if (key === false) {\n      return Promise.resolve();\n    }\n\n    return Promise.resolve(key || ctx.webex.internal.encryption.kms.createUnboundKeys({count: 1}))\n      .then((keys) => {\n        const k = isArray(keys) ? keys[0] : keys;\n\n        if (has(conversation, 'kmsMessage.keyUris') && !conversation.kmsMessage.keyUris.includes(k.uri)) {\n          conversation.kmsMessage.keyUris.push(k.uri);\n        }\n\n        return Promise.all([\n          // too many implicit returns on the same line is difficult to interpret\n          // eslint-disable-next-line arrow-body-style\n          has(conversation, 'activities.items') && conversation.activities.items.reduce((p, activity) => {\n            // eslint-disable-next-line max-nested-callbacks\n            return p.then(() => ctx.transform('encryptObject', k, activity));\n          }, Promise.resolve()),\n          ctx.transform('encryptPropDisplayName', k, conversation)\n        ])\n          .then(() => {\n            conversation.encryptionKeyUrl = k.uri || k;\n            // we only want to set the defaultActivityEncryptionKeyUrl if we've\n            // bound a new key\n            if (!key) {\n              conversation.defaultActivityEncryptionKeyUrl = conversation.defaultActivityEncryptionKeyUrl || k.uri || k;\n            }\n          });\n      });\n  },\n\n  encryptActivity(ctx, key, activity) {\n    // Activity is already encrypted\n    if (activity.encryptionKeyUrl) {\n      return Promise.resolve();\n    }\n\n    return ctx.transform(`encrypt${capitalize(activity.verb)}Activity`, key, activity)\n      .then(() => {\n        key = key || activity[KEY];\n\n        return ctx.transform('prepareActivityKmsMessage', key, activity);\n      });\n  },\n\n  encryptVerbActivity(ctx, key, activity) {\n    return ctx.transform('maybeEncryptTarget', key, activity)\n      .then(() => {\n        key = key || activity[KEY];\n      })\n      .then(() => ctx.transform('encryptObject', key, activity.object));\n  },\n\n  maybeEncryptTarget(ctx, key, activity) {\n    // This isn't quite right; if we just go by key, we have no guarantee that\n    // we have a proper KRO available for add activities\n    if (key) {\n      return Promise.resolve();\n    }\n\n    if (has(activity, 'target.defaultActivityEncryptionKeyUrl') &&\n      activity.target.defaultActivityEncryptionKeyUrl &&\n      has(activity, 'target.kmsResourceObjectUrl')\n    ) {\n      activity[KEY] = key || activity.target.defaultActivityEncryptionKeyUrl;\n\n      return Promise.resolve();\n    }\n\n    const conversationUrl = activity.target && activity.target.url;\n\n    if (!conversationUrl) {\n      return Promise.reject(new Error('Cannot determine encryption key for activity\\'s conversation; no key url or conversation url provided'));\n    }\n\n    return ctx.webex.internal.conversation.get({url: conversationUrl})\n      .then((conversation) => {\n        if (!conversation.defaultActivityEncryptionKeyUrl) {\n          return ctx.webex.internal.conversation.updateKey(conversation)\n            .then((updateKeyActivity) => {\n              if (updateKeyActivity.kmsMessage.resource) {\n                activity.target.kmsResourceObjectUrl = updateKeyActivity.kmsMessage.resource.uri;\n              }\n              activity[KEY] = activity.target.defaultActivityEncryptionKeyUrl = updateKeyActivity.object.defaultActivityEncryptionKeyUrl;\n            });\n        }\n\n        if (!activity.target.defaultActivityEncryptionKeyUrl) {\n          ctx.webex.logger.warn('plugin-conversation: downloaded conversation to determine its defaultActivityEncryptionKeyUrl; make sure to pass all encryption related properties when calling Webex.conversation methods.');\n        }\n\n        if (!activity.target.kmsResourceObjectUrl) {\n          ctx.webex.logger.warn('plugin-conversation: downloaded conversation to determine its kmsResourceObjectUrl; make sure to pass all encryption related properties when calling Webex.conversation methods.');\n        }\n\n        activity[KEY] = activity.target.defaultActivityEncryptionKeyUrl = conversation.defaultActivityEncryptionKeyUrl;\n        activity.target.kmsResourceObjectUrl = conversation.kmsResourceObjectUrl;\n\n        return Promise.resolve();\n      });\n  },\n\n  prepareActivityKmsMessage(ctx, key, activity) {\n    if (activity.kmsMessage) {\n      if (!key && activity.verb === 'updateKey' && has(activity, 'object.defaultActivityEncryptionKeyUrl')) {\n        key = get(activity, 'object.defaultActivityEncryptionKeyUrl');\n      }\n\n      if (!key && activity.verb === 'leave' && has(activity, 'target.defaultActivityEncryptionKeyUrl')) {\n        key = get(activity, 'target.defaultActivityEncryptionKeyUrl');\n      }\n\n      if (key) {\n        const kro = activity.target.kmsResourceObjectUrl;\n\n        ['uri', 'resourceUri'].forEach((k) => {\n          if (activity.kmsMessage[k] && !kro && activity.kmsMessage[k].includes('<KRO>')) {\n            throw new Error('encrypter: cannot determine kro');\n          }\n\n          if (activity.kmsMessage[k]) {\n            activity.kmsMessage[k] = activity.kmsMessage[k].replace('<KRO>', kro);\n            // key may be a key or a key url\n            activity.kmsMessage[k] = activity.kmsMessage[k].replace('<KEYURL>', key.keyUrl || key);\n          }\n        });\n      }\n      // If we made it this far and still don't have an encryption key, assume\n      // this is a conversation that is not encrypted and we're performing an\n      // action that should not encrypt it (e.g. `leave`)\n      else {\n        Reflect.deleteProperty(activity, 'kmsMessage');\n      }\n    }\n  },\n\n  encryptVerbActivityWithKey: {\n    direction: 'outbound',\n    fn(ctx, key, activity) {\n      return ctx.transform('encryptVerbActivity', key, activity)\n        .then(() => {\n          key = key || activity[KEY];\n          activity.encryptionKeyUrl = key.uri || key;\n        });\n    }\n  },\n\n  encryptAddActivity: {\n    direction: 'outbound',\n    fn(ctx, key, activity) {\n      if (has(activity, 'object.objectType') && activity.object.objectType === 'reaction2') {\n        return ctx.transform('encryptVerbActivityWithKey', key, activity);\n      }\n\n      return ctx.transform('encryptVerbActivity', key, activity);\n    }\n  },\n\n  encryptAssignActivity: {\n    direction: 'outbound',\n    alias: 'encryptVerbActivityWithKey'\n  },\n\n  encryptCreateActivity: {\n    direction: 'outbound',\n    alias: 'encryptVerbActivity'\n  },\n\n  encryptPostActivity: {\n    direction: 'outbound',\n    alias: 'encryptVerbActivityWithKey'\n  },\n\n  encryptShareActivity: {\n    direction: 'outbound',\n    alias: 'encryptVerbActivityWithKey'\n  },\n\n  encryptCardactionActivity: {\n    direction: 'outbound',\n    alias: 'encryptVerbActivityWithKey'\n  },\n\n  encryptUpdateActivity: {\n    direction: 'outbound',\n    alias: 'encryptVerbActivityWithKey'\n  },\n\n  encryptUpdateKeyActivity: {\n    direction: 'outbound',\n    alias: 'encryptVerbActivity'\n  },\n\n  encryptComment(ctx, key, comment) {\n    return Promise.all([\n      ctx.transform('encryptPropDisplayName', key, comment),\n      ctx.transform('encryptPropContent', key, comment)\n    ]);\n  },\n\n  encryptContent(ctx, key, content) {\n    const promises = content.files.items.map((item) => ctx.transform('encryptObject', key, item));\n\n    promises.push(ctx.transform('encryptPropContent', key, content));\n    promises.push(ctx.transform('encryptPropDisplayName', key, content));\n\n    return Promise.all(promises);\n  },\n\n  encryptFile(ctx, key, file) {\n    if (file.image && !file.image.scr) {\n      return Promise.reject(new Error('`file.image` must have an `scr`'));\n    }\n\n    return Promise.all([\n      ctx.transform('encryptPropScr', key, file),\n      ctx.transform('encryptPropDisplayName', key, file),\n      ctx.transform('encryptPropContent', key, file),\n      file.image && ctx.transform('encryptPropScr', key, file.image)\n    ]);\n  },\n\n  encryptSubmit(ctx, key, submit) {\n    return ctx.transform('encryptPropInputs', key, submit);\n  },\n\n  // TODO is this used for anything other than the now-removed stickies service?\n  encryptImageURI(ctx, key, imageURI) {\n    return ctx.transform('encryptPropLocation', key, imageURI);\n  },\n\n  encryptPropContent: encryptTextProp('content'),\n\n  encryptPropDisplayName: encryptTextProp('displayName'),\n\n  encryptPropInputs: encryptJsonProp('inputs'),\n\n  encryptPropLocation: encryptTextProp('location'),\n\n  encryptPropScr(ctx, key, object) {\n    if (!object.scr) {\n      return Promise.resolve();\n    }\n\n    return ctx.webex.internal.encryption.encryptScr(key, object.scr)\n      .then((scr) => {\n        object.scr = scr;\n      });\n  },\n\n  encryptJsonProp(ctx, name, key, object) {\n    if (!object[name]) {\n      return Promise.resolve();\n    }\n\n    return ctx.webex.internal.encryption.encryptText(key.uri || key, JSON.stringify(object[name]))\n      .then((ciphertext) => {\n        object[name] = ciphertext;\n      });\n  },\n\n  encryptTextProp(ctx, name, key, object) {\n    if (!object[name]) {\n      return Promise.resolve();\n    }\n\n    return ctx.webex.internal.encryption.encryptText(key.uri || key, object[name])\n      .then((ciphertext) => {\n        object[name] = ciphertext;\n      });\n  }\n});\n"]},"metadata":{},"sourceType":"script"}