{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.getQuery = exports.getLoopCounterFailsafe = exports.rootActivityManager = exports.noMoreActivitiesManager = exports.bookendManager = exports.activityManager = exports.getActivityObjectsFromMap = exports.getValue = exports.setValue = exports.batchSizeIncrementCount = exports.fetchLoopCountMax = exports.minBatchSize = exports.defaultMinDisplayableActivities = void 0;\n\nvar _from = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/array/from\"));\n\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/map\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/defineProperty\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/slicedToArray\"));\n\nvar _last2 = _interopRequireDefault(require(\"lodash/last\"));\n\nvar _activities = require(\"./activities\");\n\nvar defaultMinDisplayableActivities = 20;\nexports.defaultMinDisplayableActivities = defaultMinDisplayableActivities;\nvar minBatchSize = 10;\nexports.minBatchSize = minBatchSize;\nvar fetchLoopCountMax = 100;\nexports.fetchLoopCountMax = fetchLoopCountMax;\nvar batchSizeIncrementCount = 10; // use accessors for ease of refactoring underlying implementation\n\n/**\n * @param {Map} destination destination map object for data. Currently a Map, but could be refactored to use any type.\n * @param {string} key\n * @param {any} value\n * @returns {Map}\n */\n\nexports.batchSizeIncrementCount = batchSizeIncrementCount;\n\nvar setValue = function setValue(destination, key, value) {\n  return destination.set(key, value);\n};\n/**\n * @param {Map} source source map object to access. Currently expects a Map, but could be refactored to use any type\n * @param {string} key\n * @returns {Map}\n */\n\n\nexports.setValue = setValue;\n\nvar getValue = function getValue(source, key) {\n  return source.get(key);\n};\n\nexports.getValue = getValue;\n\nvar getActivityObjectsFromMap = function getActivityObjectsFromMap(hashMap) {\n  return (0, _from.default)(hashMap).map(function (_ref) {\n    var _ref2 = (0, _slicedToArray2.default)(_ref, 2),\n        activity = _ref2[1];\n\n    return activity;\n  });\n};\n/**\n * creates maps for various activity types and defines handlers for working with stored activities\n * utilizes revealing module pattern to close over state and only expose certain necessary functions for altering state\n * @function\n * @returns {object}\n * getActivityHandlerByKey(activityType) - accepts a key to map to a defined activity handler\n * getActivityByTypeAndParentId(activityType, parentId) accepts a key and a parent ID to return an activity of that type whose parent is the parentId\n */\n\n\nexports.getActivityObjectsFromMap = getActivityObjectsFromMap;\n\nvar activityManager = function activityManager() {\n  var replyActivityHash = new _map.default();\n  var editActivityHash = new _map.default();\n  var reactionActivityHash = new _map.default();\n  var reactionSelfActivityHash = new _map.default();\n\n  var handleNewReply = function handleNewReply(replyAct) {\n    var replyParentId = (0, _activities.getParentId)(replyAct);\n    var existingReplyHash = getValue(replyActivityHash, replyParentId);\n\n    if (existingReplyHash) {\n      setValue(existingReplyHash, replyAct.id, replyAct);\n    } else {\n      var replyHash = new _map.default();\n      setValue(replyHash, replyAct.id, replyAct);\n      setValue(replyActivityHash, replyParentId, replyHash);\n    }\n  };\n\n  var handleNewEdit = function handleNewEdit(editAct) {\n    var isTombstone = editAct.verb === _activities.ACTIVITY_TYPES.TOMBSTONE; // we can ignore tombstone edits in favor of the newer one\n\n    if (isTombstone) {\n      return;\n    }\n\n    var editParentId = (0, _activities.getParentId)(editAct);\n    var existingEdit = getValue(editActivityHash, editParentId); // edited activity must be newer than what we already have\n\n    if (!existingEdit || (0, _activities.isNewer)(editAct, existingEdit)) {\n      setValue(editActivityHash, editParentId, editAct);\n    }\n  }; // logic is identical between reactions and reaction selfs, so handler simply passes the activity and the correct hash\n\n\n  var reactionHelper = function reactionHelper(reactionAct, hash) {\n    var reactionParentId = (0, _activities.getParentId)(reactionAct);\n    var existingReaction = getValue(hash, reactionParentId); // reaction activity must be newer than what we already have\n\n    if (!existingReaction || (0, _activities.isNewer)(reactionAct, existingReaction)) {\n      setValue(hash, reactionParentId, reactionAct);\n    }\n  };\n\n  var handleNewReaction = function handleNewReaction(reactionAct) {\n    reactionHelper(reactionAct, reactionActivityHash);\n  };\n\n  var handleNewReactionSelf = function handleNewReactionSelf(reactionSelfAct) {\n    reactionHelper(reactionSelfAct, reactionSelfActivityHash);\n  };\n\n  var getActivityHandlerByKey = function getActivityHandlerByKey(key) {\n    var _ACTIVITY_TYPES$REACT;\n\n    return (_ACTIVITY_TYPES$REACT = {}, (0, _defineProperty2.default)(_ACTIVITY_TYPES$REACT, _activities.ACTIVITY_TYPES.REACTION, handleNewReaction), (0, _defineProperty2.default)(_ACTIVITY_TYPES$REACT, _activities.ACTIVITY_TYPES.REACTION_SELF, handleNewReactionSelf), (0, _defineProperty2.default)(_ACTIVITY_TYPES$REACT, _activities.ACTIVITY_TYPES.EDIT, handleNewEdit), (0, _defineProperty2.default)(_ACTIVITY_TYPES$REACT, _activities.ACTIVITY_TYPES.REPLY, handleNewReply), _ACTIVITY_TYPES$REACT)[key];\n  };\n\n  var getActivityByTypeAndParentId = function getActivityByTypeAndParentId(type, id) {\n    var _ACTIVITY_TYPES$EDIT$;\n\n    return (_ACTIVITY_TYPES$EDIT$ = {}, (0, _defineProperty2.default)(_ACTIVITY_TYPES$EDIT$, _activities.ACTIVITY_TYPES.EDIT, getValue(editActivityHash, id)), (0, _defineProperty2.default)(_ACTIVITY_TYPES$EDIT$, _activities.ACTIVITY_TYPES.REPLY, getValue(replyActivityHash, id)), (0, _defineProperty2.default)(_ACTIVITY_TYPES$EDIT$, _activities.ACTIVITY_TYPES.REACTION, getValue(reactionActivityHash, id)), (0, _defineProperty2.default)(_ACTIVITY_TYPES$EDIT$, _activities.ACTIVITY_TYPES.REACTION_SELF, getValue(reactionSelfActivityHash, id)), _ACTIVITY_TYPES$EDIT$)[type];\n  };\n\n  return {\n    getActivityHandlerByKey: getActivityHandlerByKey,\n    getActivityByTypeAndParentId: getActivityByTypeAndParentId\n  };\n};\n/**\n * encapsulates state and logic for managing oldest and newest activities\n * @returns {object} setters and getters for activity state management\n */\n\n\nexports.activityManager = activityManager;\n\nvar bookendManager = function bookendManager() {\n  // keep track of generator state, like what our current oldest & newest activities are\n  var oldestAct;\n  var newestAct;\n\n  var getOldestAct = function getOldestAct() {\n    return oldestAct;\n  };\n\n  var getNewestAct = function getNewestAct() {\n    return newestAct;\n  };\n\n  var setOldestAct = function setOldestAct(act) {\n    if (!oldestAct) {\n      oldestAct = act;\n    } else if ((0, _activities.isNewer)(oldestAct, act)) {\n      oldestAct = act;\n    }\n  };\n\n  var setNewestAct = function setNewestAct(act) {\n    if (!newestAct) {\n      newestAct = act;\n    } else if ((0, _activities.isNewer)(act, newestAct)) {\n      newestAct = act;\n    }\n  };\n\n  var setBookends = function setBookends(activities) {\n    var oldestActsFirst = (0, _activities.sortActivitiesByPublishedDate)(activities);\n    var newestInBatch = (0, _last2.default)(oldestActsFirst);\n    var oldestInBatch = oldestActsFirst[0];\n    setOldestAct(oldestInBatch);\n    setNewestAct(newestInBatch);\n  };\n\n  return {\n    setBookends: setBookends,\n    getNewestAct: getNewestAct,\n    getOldestAct: getOldestAct\n  };\n};\n/**\n * encapsulates state and logic for when there are no more fetchable activities from convo\n * @returns {object} setters and getters for no more activities logic\n */\n\n\nexports.bookendManager = bookendManager;\n\nvar noMoreActivitiesManager = function noMoreActivitiesManager() {\n  // used to determine if we should continue to fetch older activities\n  // must be set per iteration, as querying newer activities is still valid when all end of convo has been reached\n  var noMoreActs = false;\n  var noOlderActs = false;\n  var noNewerActs = false;\n\n  var getNoMoreActs = function getNoMoreActs() {\n    return noMoreActs;\n  };\n\n  var checkAndSetNoOlderActs = function checkAndSetNoOlderActs(act) {\n    if (!noOlderActs && (0, _activities.getActivityType)(act) === _activities.ACTIVITY_TYPES.CREATE) {\n      noOlderActs = true;\n    }\n  };\n\n  var checkAndSetNoNewerActs = function checkAndSetNoNewerActs(activities) {\n    if (!activities || !activities.length) {\n      noNewerActs = true;\n    }\n  };\n\n  var checkAndSetNoMoreActs = function checkAndSetNoMoreActs(queryType, visibleActs, currentBatchSize) {\n    if (queryType === _activities.NEWER && noNewerActs || (queryType === _activities.OLDER || queryType === _activities.INITIAL) && noOlderActs || queryType === _activities.MID && visibleActs < currentBatchSize && noOlderActs) {\n      noMoreActs = true;\n    }\n  };\n\n  return {\n    getNoMoreActs: getNoMoreActs,\n    checkAndSetNoMoreActs: checkAndSetNoMoreActs,\n    checkAndSetNoNewerActs: checkAndSetNoNewerActs,\n    checkAndSetNoOlderActs: checkAndSetNoOlderActs\n  };\n};\n/**\n * encapsulates state and logic for managing root activities\n * @returns {object} setters and getters for activity state management\n */\n\n\nexports.noMoreActivitiesManager = noMoreActivitiesManager;\n\nvar rootActivityManager = function rootActivityManager() {\n  var rootActivityHash = new _map.default();\n\n  var addNewRoot = function addNewRoot(rootAct) {\n    setValue(rootActivityHash, rootAct.id, rootAct);\n  };\n\n  var getRootActivityHash = function getRootActivityHash() {\n    return rootActivityHash;\n  };\n\n  return {\n    addNewRoot: addNewRoot,\n    getRootActivityHash: getRootActivityHash\n  };\n};\n\nexports.rootActivityManager = rootActivityManager;\n\nvar getLoopCounterFailsafe = function getLoopCounterFailsafe() {\n  var fetchLoopCount = 0;\n  return function () {\n    fetchLoopCount += 1;\n\n    if (fetchLoopCount > fetchLoopCountMax) {\n      throw new Error('max fetches reached');\n    }\n  };\n};\n/**\n * creates activity query object\n * @param {string} type type of query to create\n * @param {object} queryOptions options to define query\n * @param {string} [queryOptions.newestPublishedDate] the date of the newest fetched activity\n * @param {string} [queryOptions.oldestPublishedDate] the date of the oldest fetched activity\n * @param {number} [queryOptions.batchSize] the number of activities to query\n * @param {object} [queryOptions.activityToSearch] a server activity to use to build middate query\n * @returns {object}\n */\n\n\nexports.getLoopCounterFailsafe = getLoopCounterFailsafe;\n\nvar getQuery = function getQuery(type, queryOptions) {\n  var newestPublishedDate = queryOptions.newestPublishedDate,\n      oldestPublishedDate = queryOptions.oldestPublishedDate,\n      batchSize = queryOptions.batchSize,\n      _queryOptions$activit = queryOptions.activityToSearch,\n      activityToSearch = _queryOptions$activit === void 0 ? {} : _queryOptions$activit;\n\n  switch (type) {\n    case _activities.NEWER:\n      {\n        var sinceDate = newestPublishedDate + 1;\n        var lastActivityFirst = false;\n        return {\n          sinceDate: sinceDate,\n          lastActivityFirst: lastActivityFirst\n        };\n      }\n\n    case _activities.MID:\n      {\n        var searchType = (0, _activities.getActivityType)(activityToSearch);\n        var midDate;\n\n        if (searchType === _activities.ACTIVITY_TYPES.REPLY || searchType === _activities.ACTIVITY_TYPES.EDIT) {\n          midDate = activityToSearch.parent.published;\n        } else {\n          midDate = activityToSearch.published;\n        }\n\n        return {\n          midDate: midDate,\n          limit: batchSize\n        };\n      }\n\n    case _activities.OLDER:\n      {\n        var maxDate = oldestPublishedDate - 1;\n        return {\n          maxDate: maxDate\n        };\n      }\n\n    case _activities.INITIAL:\n    default:\n      {\n        return {};\n      }\n  }\n};\n\nexports.getQuery = getQuery;","map":{"version":3,"mappings":"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","names":["defaultMinDisplayableActivities","minBatchSize","fetchLoopCountMax","batchSizeIncrementCount","setValue","destination","key","value","set","getValue","source","get","getActivityObjectsFromMap","hashMap","map","activity","activityManager","replyActivityHash","editActivityHash","reactionActivityHash","reactionSelfActivityHash","handleNewReply","replyAct","replyParentId","existingReplyHash","id","replyHash","handleNewEdit","editAct","isTombstone","verb","ACTIVITY_TYPES","TOMBSTONE","editParentId","existingEdit","reactionHelper","reactionAct","hash","reactionParentId","existingReaction","handleNewReaction","handleNewReactionSelf","reactionSelfAct","getActivityHandlerByKey","REACTION","REACTION_SELF","EDIT","REPLY","getActivityByTypeAndParentId","type","bookendManager","oldestAct","newestAct","getOldestAct","getNewestAct","setOldestAct","act","setNewestAct","setBookends","activities","oldestActsFirst","newestInBatch","oldestInBatch","noMoreActivitiesManager","noMoreActs","noOlderActs","noNewerActs","getNoMoreActs","checkAndSetNoOlderActs","CREATE","checkAndSetNoNewerActs","length","checkAndSetNoMoreActs","queryType","visibleActs","currentBatchSize","NEWER","OLDER","INITIAL","MID","rootActivityManager","rootActivityHash","addNewRoot","rootAct","getRootActivityHash","getLoopCounterFailsafe","fetchLoopCount","Error","getQuery","queryOptions","newestPublishedDate","oldestPublishedDate","batchSize","activityToSearch","sinceDate","lastActivityFirst","searchType","midDate","parent","published","limit","maxDate"],"sources":["activity-thread-ordering.js"],"sourcesContent":["import {last} from 'lodash';\n\nimport {\n  ACTIVITY_TYPES,\n  getParentId,\n  isNewer,\n  getActivityType,\n  sortActivitiesByPublishedDate,\n  NEWER,\n  OLDER,\n  INITIAL,\n  MID\n} from './activities';\n\nexport const defaultMinDisplayableActivities = 20;\nexport const minBatchSize = 10;\nexport const fetchLoopCountMax = 100;\nexport const batchSizeIncrementCount = 10;\n\n// use accessors for ease of refactoring underlying implementation\n/**\n * @param {Map} destination destination map object for data. Currently a Map, but could be refactored to use any type.\n * @param {string} key\n * @param {any} value\n * @returns {Map}\n */\nexport const setValue = (destination, key, value) => destination.set(key, value);\n/**\n * @param {Map} source source map object to access. Currently expects a Map, but could be refactored to use any type\n * @param {string} key\n * @returns {Map}\n */\nexport const getValue = (source, key) => source.get(key);\n\nexport const getActivityObjectsFromMap = (hashMap) => Array.from(hashMap).map(([, activity]) => activity);\n/**\n * creates maps for various activity types and defines handlers for working with stored activities\n * utilizes revealing module pattern to close over state and only expose certain necessary functions for altering state\n * @function\n * @returns {object}\n * getActivityHandlerByKey(activityType) - accepts a key to map to a defined activity handler\n * getActivityByTypeAndParentId(activityType, parentId) accepts a key and a parent ID to return an activity of that type whose parent is the parentId\n */\nexport const activityManager = () => {\n  const replyActivityHash = new Map();\n  const editActivityHash = new Map();\n  const reactionActivityHash = new Map();\n  const reactionSelfActivityHash = new Map();\n\n  const handleNewReply = (replyAct) => {\n    const replyParentId = getParentId(replyAct);\n    const existingReplyHash = getValue(replyActivityHash, replyParentId);\n\n    if (existingReplyHash) {\n      setValue(existingReplyHash, replyAct.id, replyAct);\n    }\n    else {\n      const replyHash = new Map();\n\n      setValue(replyHash, replyAct.id, replyAct);\n      setValue(replyActivityHash, replyParentId, replyHash);\n    }\n  };\n\n  const handleNewEdit = (editAct) => {\n    const isTombstone = editAct.verb === ACTIVITY_TYPES.TOMBSTONE;\n\n    // we can ignore tombstone edits in favor of the newer one\n    if (isTombstone) {\n      return;\n    }\n\n    const editParentId = getParentId(editAct);\n    const existingEdit = getValue(editActivityHash, editParentId);\n\n    // edited activity must be newer than what we already have\n    if (!existingEdit || isNewer(editAct, existingEdit)) {\n      setValue(editActivityHash, editParentId, editAct);\n    }\n  };\n\n  // logic is identical between reactions and reaction selfs, so handler simply passes the activity and the correct hash\n  const reactionHelper = (reactionAct, hash) => {\n    const reactionParentId = getParentId(reactionAct);\n    const existingReaction = getValue(hash, reactionParentId);\n\n    // reaction activity must be newer than what we already have\n    if (!existingReaction || isNewer(reactionAct, existingReaction)) {\n      setValue(hash, reactionParentId, reactionAct);\n    }\n  };\n\n  const handleNewReaction = (reactionAct) => {\n    reactionHelper(reactionAct, reactionActivityHash);\n  };\n\n  const handleNewReactionSelf = (reactionSelfAct) => {\n    reactionHelper(reactionSelfAct, reactionSelfActivityHash);\n  };\n\n  const getActivityHandlerByKey = (key) => ({\n    [ACTIVITY_TYPES.REACTION]: handleNewReaction,\n    [ACTIVITY_TYPES.REACTION_SELF]: handleNewReactionSelf,\n    [ACTIVITY_TYPES.EDIT]: handleNewEdit,\n    [ACTIVITY_TYPES.REPLY]: handleNewReply\n  }[key]);\n\n  const getActivityByTypeAndParentId = (type, id) => ({\n    [ACTIVITY_TYPES.EDIT]: getValue(editActivityHash, id),\n    [ACTIVITY_TYPES.REPLY]: getValue(replyActivityHash, id),\n    [ACTIVITY_TYPES.REACTION]: getValue(reactionActivityHash, id),\n    [ACTIVITY_TYPES.REACTION_SELF]: getValue(reactionSelfActivityHash, id)\n  }[type]);\n\n  return {\n    getActivityHandlerByKey,\n    getActivityByTypeAndParentId\n  };\n};\n\n/**\n * encapsulates state and logic for managing oldest and newest activities\n * @returns {object} setters and getters for activity state management\n */\nexport const bookendManager = () => {\n  // keep track of generator state, like what our current oldest & newest activities are\n  let oldestAct;\n  let newestAct;\n\n  const getOldestAct = () => oldestAct;\n  const getNewestAct = () => newestAct;\n\n  const setOldestAct = (act) => {\n    if (!oldestAct) {\n      oldestAct = act;\n    }\n    else if (isNewer(oldestAct, act)) {\n      oldestAct = act;\n    }\n  };\n\n  const setNewestAct = (act) => {\n    if (!newestAct) {\n      newestAct = act;\n    }\n    else if (isNewer(act, newestAct)) {\n      newestAct = act;\n    }\n  };\n\n  const setBookends = (activities) => {\n    const oldestActsFirst = sortActivitiesByPublishedDate(activities);\n\n    const newestInBatch = last(oldestActsFirst);\n    const oldestInBatch = oldestActsFirst[0];\n\n    setOldestAct(oldestInBatch);\n    setNewestAct(newestInBatch);\n  };\n\n  return {\n    setBookends,\n    getNewestAct,\n    getOldestAct\n  };\n};\n\n/**\n * encapsulates state and logic for when there are no more fetchable activities from convo\n * @returns {object} setters and getters for no more activities logic\n */\nexport const noMoreActivitiesManager = () => {\n  // used to determine if we should continue to fetch older activities\n  // must be set per iteration, as querying newer activities is still valid when all end of convo has been reached\n  let noMoreActs = false;\n  let noOlderActs = false;\n  let noNewerActs = false;\n\n  const getNoMoreActs = () => noMoreActs;\n\n  const checkAndSetNoOlderActs = (act) => {\n    if (!noOlderActs && getActivityType(act) === ACTIVITY_TYPES.CREATE) {\n      noOlderActs = true;\n    }\n  };\n\n  const checkAndSetNoNewerActs = (activities) => {\n    if (!activities || !activities.length) {\n      noNewerActs = true;\n    }\n  };\n\n  const checkAndSetNoMoreActs = (queryType, visibleActs, currentBatchSize) => {\n    if (\n      (queryType === NEWER && noNewerActs) ||\n      ((queryType === OLDER || queryType === INITIAL) && noOlderActs) ||\n      (queryType === MID && visibleActs < currentBatchSize && noOlderActs)\n    ) {\n      noMoreActs = true;\n    }\n  };\n\n  return {\n    getNoMoreActs,\n    checkAndSetNoMoreActs,\n    checkAndSetNoNewerActs,\n    checkAndSetNoOlderActs\n  };\n};\n\n/**\n * encapsulates state and logic for managing root activities\n * @returns {object} setters and getters for activity state management\n */\nexport const rootActivityManager = () => {\n  const rootActivityHash = new Map();\n\n  const addNewRoot = (rootAct) => {\n    setValue(rootActivityHash, rootAct.id, rootAct);\n  };\n\n  const getRootActivityHash = () => rootActivityHash;\n\n  return {\n    addNewRoot,\n    getRootActivityHash\n  };\n};\n\nexport const getLoopCounterFailsafe = () => {\n  let fetchLoopCount = 0;\n\n  return () => {\n    fetchLoopCount += 1;\n    if (fetchLoopCount > fetchLoopCountMax) {\n      throw new Error('max fetches reached');\n    }\n  };\n};\n\n/**\n * creates activity query object\n * @param {string} type type of query to create\n * @param {object} queryOptions options to define query\n * @param {string} [queryOptions.newestPublishedDate] the date of the newest fetched activity\n * @param {string} [queryOptions.oldestPublishedDate] the date of the oldest fetched activity\n * @param {number} [queryOptions.batchSize] the number of activities to query\n * @param {object} [queryOptions.activityToSearch] a server activity to use to build middate query\n * @returns {object}\n */\nexport const getQuery = (type, queryOptions) => {\n  const {\n    newestPublishedDate, oldestPublishedDate, batchSize, activityToSearch = {}\n  } = queryOptions;\n\n  switch (type) {\n    case NEWER: {\n      const sinceDate = newestPublishedDate + 1;\n      const lastActivityFirst = false;\n\n      return {sinceDate, lastActivityFirst};\n    }\n    case MID: {\n      const searchType = getActivityType(activityToSearch);\n      let midDate;\n\n      if (searchType === ACTIVITY_TYPES.REPLY || searchType === ACTIVITY_TYPES.EDIT) {\n        midDate = activityToSearch.parent.published;\n      }\n      else {\n        midDate = activityToSearch.published;\n      }\n\n      return {midDate, limit: batchSize};\n    }\n    case OLDER: {\n      const maxDate = oldestPublishedDate - 1;\n\n      return {maxDate};\n    }\n    case INITIAL:\n    default: {\n      return {};\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}