{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = exports.TIMEOUT_SYMBOL = void 0;\n\nvar _symbol = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/symbol\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _commonTimers = require(\"@webex/common-timers\");\n\nvar _webexCore = require(\"@webex/webex-core\");\n\nvar _kmsErrors = require(\"./kms-errors\");\n/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar TIMEOUT_SYMBOL = (0, _symbol.default)('TIMEOUT_SYMBOL');\n/**\n * @class\n */\n\nexports.TIMEOUT_SYMBOL = TIMEOUT_SYMBOL;\n\nvar KmsBatcher = _webexCore.Batcher.extend({\n  namespace: 'Encryption',\n\n  /**\n   * Accepts a kmsMessage event and passes its contents to acceptItem\n   * @param {Object} event\n   * @returns {Promise}\n   */\n  processKmsMessageEvent: function processKmsMessageEvent(event) {\n    var _this = this;\n\n    this.logger.info('kms-batcher: received kms message');\n    return _promise.default.all(event.encryption.kmsMessages.map(function (kmsMessage) {\n      return new _promise.default(function (resolve) {\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production') {\n          _this.logger.info('kms-batcher:', kmsMessage.body);\n        }\n\n        resolve(_this.acceptItem(kmsMessage));\n      });\n    }));\n  },\n\n  /**\n   * Attaches a timeout to the given KMS message\n   * @param {Object} item\n   * @returns {Promise<Object>}\n   */\n  prepareItem: function prepareItem(item) {\n    var _this2 = this;\n\n    return this.getDeferredForRequest(item).then(function (defer) {\n      var timeout = item[TIMEOUT_SYMBOL];\n      /* istanbul ignore if */\n\n      if (!timeout) {\n        throw new Error('timeout is required');\n      }\n\n      var timer = (0, _commonTimers.safeSetTimeout)(function () {\n        _this2.logger.warn(\"kms: request timed out; request id: \".concat(item.requestId, \"; timeout: \").concat(timeout));\n\n        _this2.handleItemFailure(item, new _kmsErrors.KmsTimeoutError({\n          timeout: timeout,\n          request: item\n        }));\n      }, timeout); // Reminder: reassign `promise` is not a viable means of inserting into\n      // the Promise chain\n\n      defer.promise.then(function () {\n        return clearTimeout(timer);\n      });\n      defer.promise.catch(function () {\n        return clearTimeout(timer);\n      });\n      return item;\n    });\n  },\n\n  /**\n   * Attaches the final bits of cluster info to the payload\n   * @param {Array} queue\n   * @returns {Promise<Array>}\n   */\n  prepareRequest: function prepareRequest(queue) {\n    return this.webex.internal.encryption.kms._getKMSCluster().then(function (cluster) {\n      return {\n        destination: cluster,\n        kmsMessages: queue.map(function (req) {\n          return req.wrapped;\n        })\n      };\n    });\n  },\n\n  /**\n   * @param {Object} payload\n   * @returns {Promise<HttpResponseObject>}\n   */\n  submitHttpRequest: function submitHttpRequest(payload) {\n    this.logger.info('kms: batched-request-length', payload.kmsMessages.length);\n    return this.webex.request({\n      method: 'POST',\n      service: 'encryption',\n      resource: '/kms/messages',\n      body: payload\n    });\n  },\n\n  /**\n   * Does nothing; the http response doesn't carry our response data\n   * @returns {Promise}\n   */\n  handleHttpSuccess: function handleHttpSuccess() {\n    return _promise.default.resolve();\n  },\n\n  /**\n   * @param {Object} item\n   * @returns {Promise<boolean>}\n   */\n  didItemFail: function didItemFail(item) {\n    return _promise.default.resolve(item.status >= 400);\n  },\n\n  /**\n   * @param {Object} item\n   * @returns {Promise}\n   */\n  handleItemSuccess: function handleItemSuccess(item) {\n    return this.getDeferredForResponse(item).then(function (defer) {\n      defer.resolve(item.body);\n    });\n  },\n\n  /**\n   * @param {Object} item\n   * @param {KmsError} [reason]\n   * @returns {Promise}\n   */\n  handleItemFailure: function handleItemFailure(item, reason) {\n    return this.getDeferredForResponse(item).then(function (defer) {\n      defer.reject(reason || new _kmsErrors.KmsError(item.body));\n    });\n  },\n\n  /**\n   * @param {Object} item\n   * @returns {Promise}\n   */\n  fingerprintRequest: function fingerprintRequest(item) {\n    return _promise.default.resolve(item.requestId);\n  },\n\n  /**\n   * @param {Object} item\n   * @returns {Promise}\n   */\n  fingerprintResponse: function fingerprintResponse(item) {\n    return _promise.default.resolve(item.requestId);\n  }\n});\n\nvar _default = KmsBatcher;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["TIMEOUT_SYMBOL","KmsBatcher","Batcher","extend","namespace","processKmsMessageEvent","event","logger","info","_promise","all","encryption","kmsMessages","map","kmsMessage","resolve","process","env","NODE_ENV","_this","body","acceptItem","prepareItem","item","getDeferredForRequest","then","defer","timeout","Error","timer","_this2","warn","requestId","handleItemFailure","KmsTimeoutError","request","promise","clearTimeout","catch","prepareRequest","queue","webex","internal","kms","_getKMSCluster","cluster","destination","req","wrapped","submitHttpRequest","payload","length","method","service","resource","handleHttpSuccess","didItemFail","status","handleItemSuccess","getDeferredForResponse","reason","reject","KmsError","fingerprintRequest","fingerprintResponse"],"sources":["kms-batcher.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {safeSetTimeout} from '@webex/common-timers';\nimport {Batcher} from '@webex/webex-core';\n\nimport {KmsError, KmsTimeoutError} from './kms-errors';\n\nexport const TIMEOUT_SYMBOL = Symbol('TIMEOUT_SYMBOL');\n\n/**\n * @class\n */\nconst KmsBatcher = Batcher.extend({\n  namespace: 'Encryption',\n\n  /**\n   * Accepts a kmsMessage event and passes its contents to acceptItem\n   * @param {Object} event\n   * @returns {Promise}\n   */\n  processKmsMessageEvent(event) {\n    this.logger.info('kms-batcher: received kms message');\n\n    return Promise.all(event.encryption.kmsMessages.map((kmsMessage) => new Promise((resolve) => {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.info('kms-batcher:', kmsMessage.body);\n      }\n\n      resolve(this.acceptItem(kmsMessage));\n    })));\n  },\n\n  /**\n   * Attaches a timeout to the given KMS message\n   * @param {Object} item\n   * @returns {Promise<Object>}\n   */\n  prepareItem(item) {\n    return this.getDeferredForRequest(item)\n      .then((defer) => {\n        const timeout = item[TIMEOUT_SYMBOL];\n\n        /* istanbul ignore if */\n        if (!timeout) {\n          throw new Error('timeout is required');\n        }\n\n        const timer = safeSetTimeout(() => {\n          this.logger.warn(`kms: request timed out; request id: ${item.requestId}; timeout: ${timeout}`);\n          this.handleItemFailure(item, new KmsTimeoutError({\n            timeout,\n            request: item\n          }));\n        }, timeout);\n\n        // Reminder: reassign `promise` is not a viable means of inserting into\n        // the Promise chain\n        defer.promise.then(() => clearTimeout(timer));\n        defer.promise.catch(() => clearTimeout(timer));\n\n        return item;\n      });\n  },\n\n  /**\n   * Attaches the final bits of cluster info to the payload\n   * @param {Array} queue\n   * @returns {Promise<Array>}\n   */\n  prepareRequest(queue) {\n    return this.webex.internal.encryption.kms._getKMSCluster()\n      .then((cluster) => ({\n        destination: cluster,\n        kmsMessages: queue.map((req) => req.wrapped)\n      }));\n  },\n\n  /**\n   * @param {Object} payload\n   * @returns {Promise<HttpResponseObject>}\n   */\n  submitHttpRequest(payload) {\n    this.logger.info('kms: batched-request-length', payload.kmsMessages.length);\n\n    return this.webex.request({\n      method: 'POST',\n      service: 'encryption',\n      resource: '/kms/messages',\n      body: payload\n    });\n  },\n\n  /**\n   * Does nothing; the http response doesn't carry our response data\n   * @returns {Promise}\n   */\n  handleHttpSuccess() {\n    return Promise.resolve();\n  },\n\n  /**\n   * @param {Object} item\n   * @returns {Promise<boolean>}\n   */\n  didItemFail(item) {\n    return Promise.resolve(item.status >= 400);\n  },\n\n  /**\n   * @param {Object} item\n   * @returns {Promise}\n   */\n  handleItemSuccess(item) {\n    return this.getDeferredForResponse(item)\n      .then((defer) => {\n        defer.resolve(item.body);\n      });\n  },\n\n  /**\n   * @param {Object} item\n   * @param {KmsError} [reason]\n   * @returns {Promise}\n   */\n  handleItemFailure(item, reason) {\n    return this.getDeferredForResponse(item)\n      .then((defer) => {\n        defer.reject(reason || new KmsError(item.body));\n      });\n  },\n\n  /**\n   * @param {Object} item\n   * @returns {Promise}\n   */\n  fingerprintRequest(item) {\n    return Promise.resolve(item.requestId);\n  },\n\n  /**\n   * @param {Object} item\n   * @returns {Promise}\n   */\n  fingerprintResponse(item) {\n    return Promise.resolve(item.requestId);\n  }\n});\n\nexport default KmsBatcher;\n"]},"metadata":{},"sourceType":"script"}