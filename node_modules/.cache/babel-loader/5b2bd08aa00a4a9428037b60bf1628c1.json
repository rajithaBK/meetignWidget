{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/toConsumableArray\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/array/is-array\"));\n\nrequire(\"@webex/internal-plugin-device\");\n\nvar _webexCore = require(\"@webex/webex-core\");\n\nvar _presenceBatcher = _interopRequireDefault(require(\"./presence-batcher\"));\n\nvar _presenceWorker = _interopRequireDefault(require(\"./presence-worker\"));\n/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar defaultSubscriptionTtl = 600;\nvar USER = 'user';\nvar USER_PRESENCE_ENABLED = 'user-presence-enabled';\n/**\n * @class\n * @extends WebexPlugin\n */\n\nvar Presence = _webexCore.WebexPlugin.extend({\n  namespace: 'Presence',\n  children: {\n    batcher: _presenceBatcher.default\n  },\n  session: {\n    worker: {\n      default: function _default() {\n        return new _presenceWorker.default();\n      },\n      type: 'any'\n    }\n  },\n\n  /**\n   * Initialize the presence worker for client\n   * @returns {undefined}\n   */\n  initialize: function initialize() {\n    var _this = this;\n\n    this.webex.once('ready', function () {\n      if (_this.config.initializeWorker) {\n        _this.worker.initialize(_this.webex);\n      }\n    });\n  },\n\n  /**\n   * Trigger an event.\n   * @param {string} event\n   * @param {string} payload\n   * @returns {undefined}\n   */\n  emitEvent: function emitEvent(event, payload) {\n    if (payload.type && payload.payload) {\n      this.trigger(event, payload);\n    }\n  },\n\n  /**\n   * Enables presence feature\n   * @returns {Promise<boolean>} resolves with true, if successful\n   */\n  enable: function enable() {\n    return this.webex.internal.feature.setFeature(USER, USER_PRESENCE_ENABLED, true).then(function (response) {\n      return response.value;\n    });\n  },\n\n  /**\n   * Disables presence feature\n   * @returns {Promise<boolean>} resolves with false, if successful\n   */\n  disable: function disable() {\n    return this.webex.internal.feature.setFeature(USER, USER_PRESENCE_ENABLED, false).then(function (response) {\n      return response.value;\n    });\n  },\n\n  /**\n   * Returns true if presence is enabled, false otherwise\n   * @returns {Promise<boolean>} resolves with true if presence is enabled\n   */\n  isEnabled: function isEnabled() {\n    return this.webex.internal.feature.getFeature(USER, USER_PRESENCE_ENABLED);\n  },\n\n  /**\n   * The status object\n   * @typedef {Object} PresenceStatusObject\n   * @property {string} url: Public resource identifier for presence\n   * @property {string} subject: User ID for the user the returned composed presence represents\n   * @property {string} status: Current composed presence state\n   * @property {string} statusTime: DateTime in RFC3339 format that the current status began\n   * @property {string} lastActive: DateTime in RFC3339 format that the service last saw activity from the user.\n   * @property {string} expires: DEPRECATED - DateTime in RFC3339 format that represents when the current\n   * status will expire. Will not exist if expiresTTL is -1.\n   * @property {Number} expiresTTL: TTL in seconds until the status will expire. If TTL is -1 the current\n   * status has no known expiration.\n   * @property {string} expiresTime: DateTime in RFC3339 format that the current status will expire. Missing\n   * field means no known expiration.\n   * @property {Object} vectorCounters: Used for packet ordering and tracking.\n   * @property {Boolean} suppressNotifications: Indicates if notification suppresion is recommended for this status.\n   * @property {string} lastSeenDeviceUrl: Resource Identifier of the last device to post presence activity for\n   * this user.\n   */\n\n  /**\n   * Gets the current presence status of a given person id\n   * @param {string} personId\n   * @returns {Promise<PresenceStatusObject>} resolves with status object of person\n   */\n  get: function get(personId) {\n    if (!personId) {\n      return _promise.default.reject(new Error('A person id is required'));\n    }\n\n    return this.webex.request({\n      method: 'GET',\n      service: 'apheleia',\n      resource: \"compositions?userId=\".concat(personId)\n    }).then(function (response) {\n      return response.body;\n    });\n  },\n\n  /**\n  * @typedef {Object} PresenceStatusesObject\n  * @property {Array.<PresenceStatusObject>} statusList\n   */\n\n  /**\n   * Gets the current presence statuses of an array of people ids\n   * @param {Array} personIds\n   * @returns {Promise<PresenceStatusesObject>} resolves with an object with key of `statusList` array\n   */\n  list: function list(personIds) {\n    var _this2 = this;\n\n    if (!personIds || !(0, _isArray.default)(personIds)) {\n      return _promise.default.reject(new Error('An array of person ids is required'));\n    }\n\n    return _promise.default.all(personIds.map(function (id) {\n      return _this2.batcher.request(id);\n    })).then(function (presences) {\n      return {\n        statusList: presences\n      };\n    });\n  },\n\n  /**\n   * Subscribes to a person's presence status updates\n   * Updates are sent via mercury events `apheleia.subscription_update`\n   * @param {string | Array} personIds\n   * @param {number} subscriptionTtl - Requested length of subscriptions in seconds.\n   * @returns {Promise}\n   */\n  subscribe: function subscribe(personIds) {\n    var _this3 = this;\n\n    var subscriptionTtl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultSubscriptionTtl;\n    var subjects;\n    var batches = [];\n    var batchLimit = 50;\n\n    if (!personIds) {\n      return _promise.default.reject(new Error('A person id is required'));\n    }\n\n    if ((0, _isArray.default)(personIds)) {\n      subjects = personIds;\n    } else {\n      subjects = [personIds];\n    } // Limit batches to 50 ids per request\n\n\n    for (var i = 0; i < subjects.length; i += batchLimit) {\n      batches.push(subjects.slice(i, i + batchLimit));\n    }\n\n    return _promise.default.all(batches.map(function (ids) {\n      return _this3.webex.request({\n        method: 'POST',\n        api: 'apheleia',\n        resource: 'subscriptions',\n        body: {\n          subjects: ids,\n          subscriptionTtl: subscriptionTtl,\n          includeStatus: true\n        }\n      }).then(function (response) {\n        return response.body.responses;\n      });\n    })).then(function (idBatches) {\n      var _ref;\n\n      return {\n        responses: (_ref = []).concat.apply(_ref, (0, _toConsumableArray2.default)(idBatches))\n      };\n    });\n  },\n\n  /**\n   * Unsubscribes from a person or group of people's presence subscription\n   * @param {string | Array} personIds\n   * @returns {Promise}\n   */\n  unsubscribe: function unsubscribe(personIds) {\n    var subjects;\n\n    if (!personIds) {\n      return _promise.default.reject(new Error('A person id is required'));\n    }\n\n    if ((0, _isArray.default)(personIds)) {\n      subjects = personIds;\n    } else {\n      subjects = [personIds];\n    }\n\n    return this.webex.request({\n      method: 'POST',\n      api: 'apheleia',\n      resource: 'subscriptions',\n      body: {\n        subjects: subjects,\n        subscriptionTtl: 0,\n        includeStatus: true\n      }\n    });\n  },\n\n  /**\n   * Sets the status of the current user\n   * @param {string} status - active | inactive | ooo | dnd\n   * @param {number} ttl - Time To Live for the event in seconds.\n   * @returns {Promise}\n   */\n  setStatus: function setStatus(status, ttl) {\n    if (!status) {\n      return _promise.default.reject(new Error('A status is required'));\n    }\n\n    return this.webex.request({\n      method: 'POST',\n      api: 'apheleia',\n      resource: 'events',\n      body: {\n        subject: this.webex.internal.device.userId,\n        eventType: status,\n        ttl: ttl\n      }\n    }).then(function (response) {\n      return response.body;\n    });\n  },\n\n  /**\n   * Retrieves and subscribes to a user's presence.\n   * @param {string} id\n   * @returns {undefined}\n   */\n  enqueue: function enqueue(id) {\n    return this.worker.enqueue(id);\n  },\n\n  /**\n   * Retract from subscribing to a user's presence.\n   * @param {string} id\n   * @returns {undefined}\n   */\n  dequeue: function dequeue(id) {\n    return this.worker.dequeue(id);\n  },\n  version: \"1.154.2\"\n});\n\nvar _default2 = Presence;\nexports.default = _default2;","map":{"version":3,"mappings":"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","names":["require","defaultSubscriptionTtl","USER","USER_PRESENCE_ENABLED","Presence","WebexPlugin","extend","namespace","children","batcher","PresenceBatcher","session","worker","default","PresenceWorker","type","initialize","webex","once","_this","config","initializeWorker","emitEvent","event","payload","trigger","enable","internal","feature","setFeature","then","response","value","disable","isEnabled","getFeature","get","personId","_promise","reject","Error","request","method","service","resource","body","list","personIds","all","map","id","_this2","presences","statusList","subscribe","subscriptionTtl","subjects","batches","batchLimit","i","length","push","slice","ids","_this3","api","includeStatus","responses","idBatches","concat","unsubscribe","setStatus","status","ttl","subject","device","userId","eventType","enqueue","dequeue","version"],"sources":["presence.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport '@webex/internal-plugin-device';\n\nimport {WebexPlugin} from '@webex/webex-core';\n\nimport PresenceBatcher from './presence-batcher';\nimport PresenceWorker from './presence-worker';\n\nconst defaultSubscriptionTtl = 600;\nconst USER = 'user';\nconst USER_PRESENCE_ENABLED = 'user-presence-enabled';\n\n/**\n * @class\n * @extends WebexPlugin\n */\nconst Presence = WebexPlugin.extend({\n  namespace: 'Presence',\n\n  children: {\n    batcher: PresenceBatcher\n  },\n\n  session: {\n    worker: {\n      default() {\n        return new PresenceWorker();\n      },\n      type: 'any'\n    }\n  },\n\n  /**\n   * Initialize the presence worker for client\n   * @returns {undefined}\n   */\n  initialize() {\n    this.webex.once('ready', () => {\n      if (this.config.initializeWorker) {\n        this.worker.initialize(this.webex);\n      }\n    });\n  },\n\n  /**\n   * Trigger an event.\n   * @param {string} event\n   * @param {string} payload\n   * @returns {undefined}\n   */\n  emitEvent(event, payload) {\n    if (payload.type && payload.payload) {\n      this.trigger(event, payload);\n    }\n  },\n\n  /**\n   * Enables presence feature\n   * @returns {Promise<boolean>} resolves with true, if successful\n   */\n  enable() {\n    return this.webex.internal.feature.setFeature(USER, USER_PRESENCE_ENABLED, true)\n      .then((response) => response.value);\n  },\n\n  /**\n   * Disables presence feature\n   * @returns {Promise<boolean>} resolves with false, if successful\n   */\n  disable() {\n    return this.webex.internal.feature.setFeature(USER, USER_PRESENCE_ENABLED, false)\n      .then((response) => response.value);\n  },\n\n  /**\n   * Returns true if presence is enabled, false otherwise\n   * @returns {Promise<boolean>} resolves with true if presence is enabled\n   */\n  isEnabled() {\n    return this.webex.internal.feature.getFeature(USER, USER_PRESENCE_ENABLED);\n  },\n\n  /**\n   * The status object\n   * @typedef {Object} PresenceStatusObject\n   * @property {string} url: Public resource identifier for presence\n   * @property {string} subject: User ID for the user the returned composed presence represents\n   * @property {string} status: Current composed presence state\n   * @property {string} statusTime: DateTime in RFC3339 format that the current status began\n   * @property {string} lastActive: DateTime in RFC3339 format that the service last saw activity from the user.\n   * @property {string} expires: DEPRECATED - DateTime in RFC3339 format that represents when the current\n   * status will expire. Will not exist if expiresTTL is -1.\n   * @property {Number} expiresTTL: TTL in seconds until the status will expire. If TTL is -1 the current\n   * status has no known expiration.\n   * @property {string} expiresTime: DateTime in RFC3339 format that the current status will expire. Missing\n   * field means no known expiration.\n   * @property {Object} vectorCounters: Used for packet ordering and tracking.\n   * @property {Boolean} suppressNotifications: Indicates if notification suppresion is recommended for this status.\n   * @property {string} lastSeenDeviceUrl: Resource Identifier of the last device to post presence activity for\n   * this user.\n   */\n\n  /**\n   * Gets the current presence status of a given person id\n   * @param {string} personId\n   * @returns {Promise<PresenceStatusObject>} resolves with status object of person\n   */\n  get(personId) {\n    if (!personId) {\n      return Promise.reject(new Error('A person id is required'));\n    }\n\n    return this.webex.request({\n      method: 'GET',\n      service: 'apheleia',\n      resource: `compositions?userId=${personId}`\n    })\n      .then((response) => response.body);\n  },\n\n  /**\n  * @typedef {Object} PresenceStatusesObject\n  * @property {Array.<PresenceStatusObject>} statusList\n   */\n  /**\n   * Gets the current presence statuses of an array of people ids\n   * @param {Array} personIds\n   * @returns {Promise<PresenceStatusesObject>} resolves with an object with key of `statusList` array\n   */\n  list(personIds) {\n    if (!personIds || !Array.isArray(personIds)) {\n      return Promise.reject(new Error('An array of person ids is required'));\n    }\n\n    return Promise.all(personIds.map((id) =>\n      this.batcher.request(id)))\n      .then((presences) => ({statusList: presences}));\n  },\n\n  /**\n   * Subscribes to a person's presence status updates\n   * Updates are sent via mercury events `apheleia.subscription_update`\n   * @param {string | Array} personIds\n   * @param {number} subscriptionTtl - Requested length of subscriptions in seconds.\n   * @returns {Promise}\n   */\n  subscribe(personIds, subscriptionTtl = defaultSubscriptionTtl) {\n    let subjects;\n    const batches = [];\n    const batchLimit = 50;\n\n    if (!personIds) {\n      return Promise.reject(new Error('A person id is required'));\n    }\n    if (Array.isArray(personIds)) {\n      subjects = personIds;\n    }\n    else {\n      subjects = [personIds];\n    }\n    // Limit batches to 50 ids per request\n    for (let i = 0; i < subjects.length; i += batchLimit) {\n      batches.push(subjects.slice(i, i + batchLimit));\n    }\n\n    return Promise.all(batches.map((ids) =>\n      this.webex.request({\n        method: 'POST',\n        api: 'apheleia',\n        resource: 'subscriptions',\n        body: {\n          subjects: ids,\n          subscriptionTtl,\n          includeStatus: true\n        }\n      })\n        .then((response) => response.body.responses)))\n      .then((idBatches) => ({responses: [].concat(...idBatches)}));\n  },\n\n  /**\n   * Unsubscribes from a person or group of people's presence subscription\n   * @param {string | Array} personIds\n   * @returns {Promise}\n   */\n  unsubscribe(personIds) {\n    let subjects;\n\n    if (!personIds) {\n      return Promise.reject(new Error('A person id is required'));\n    }\n    if (Array.isArray(personIds)) {\n      subjects = personIds;\n    }\n    else {\n      subjects = [personIds];\n    }\n\n    return this.webex.request({\n      method: 'POST',\n      api: 'apheleia',\n      resource: 'subscriptions',\n      body: {\n        subjects,\n        subscriptionTtl: 0,\n        includeStatus: true\n      }\n    });\n  },\n\n  /**\n   * Sets the status of the current user\n   * @param {string} status - active | inactive | ooo | dnd\n   * @param {number} ttl - Time To Live for the event in seconds.\n   * @returns {Promise}\n   */\n  setStatus(status, ttl) {\n    if (!status) {\n      return Promise.reject(new Error('A status is required'));\n    }\n\n    return this.webex.request({\n      method: 'POST',\n      api: 'apheleia',\n      resource: 'events',\n      body: {\n        subject: this.webex.internal.device.userId,\n        eventType: status,\n        ttl\n      }\n    })\n      .then((response) => response.body);\n  },\n\n  /**\n   * Retrieves and subscribes to a user's presence.\n   * @param {string} id\n   * @returns {undefined}\n   */\n  enqueue(id) {\n    return this.worker.enqueue(id);\n  },\n\n  /**\n   * Retract from subscribing to a user's presence.\n   * @param {string} id\n   * @returns {undefined}\n   */\n  dequeue(id) {\n    return this.worker.dequeue(id);\n  }\n});\n\nexport default Presence;\n"]},"metadata":{},"sourceType":"script"}