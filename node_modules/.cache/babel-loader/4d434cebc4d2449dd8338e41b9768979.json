{"ast":null,"code":"import * as asn1js from \"asn1js\";\nimport { getParametersValue, clearProps } from \"pvutils\";\nimport { getCrypto } from \"./common.js\";\nimport AlgorithmIdentifier from \"./AlgorithmIdentifier.js\";\nimport ECPublicKey from \"./ECPublicKey.js\";\nimport RSAPublicKey from \"./RSAPublicKey.js\"; //**************************************************************************************\n\n/**\n * Class from RFC5280\n */\n\nexport default class PublicKeyInfo {\n  //**********************************************************************************\n\n  /**\n   * Constructor for PublicKeyInfo class\n   * @param {Object} [parameters={}]\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    //region Internal properties of the object\n\n    /**\n     * @type {AlgorithmIdentifier}\n     * @desc Algorithm identifier\n     */\n    this.algorithm = getParametersValue(parameters, \"algorithm\", PublicKeyInfo.defaultValues(\"algorithm\"));\n    /**\n     * @type {BitString}\n     * @desc Subject public key value\n     */\n\n    this.subjectPublicKey = getParametersValue(parameters, \"subjectPublicKey\", PublicKeyInfo.defaultValues(\"subjectPublicKey\"));\n    if (\"parsedKey\" in parameters)\n      /**\n       * @type {ECPublicKey|RSAPublicKey}\n       * @desc Parsed public key value\n       */\n      this.parsedKey = getParametersValue(parameters, \"parsedKey\", PublicKeyInfo.defaultValues(\"parsedKey\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n    //region If input argument array contains \"json\" for this object\n\n    if (\"json\" in parameters) this.fromJSON(parameters.json); //endregion\n  } //**********************************************************************************\n\n  /**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"algorithm\":\n        return new AlgorithmIdentifier();\n\n      case \"subjectPublicKey\":\n        return new asn1js.BitString();\n\n      default:\n        throw new Error(`Invalid member name for PublicKeyInfo class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\n   * Return value of pre-defined ASN.1 schema for current class\n   *\n   * ASN.1 schema:\n   * ```asn1\n   * SubjectPublicKeyInfo  ::=  Sequence  {\n   *    algorithm            AlgorithmIdentifier,\n   *    subjectPublicKey     BIT STRING  }\n   * ```\n   *\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n\n\n  static schema() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    /**\n     * @type {Object}\n     * @property {string} [blockName]\n     * @property {string} [algorithm]\n     * @property {string} [subjectPublicKey]\n     */\n    const names = getParametersValue(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [AlgorithmIdentifier.schema(names.algorithm || {}), new asn1js.BitString({\n        name: names.subjectPublicKey || \"\"\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    clearProps(schema, [\"algorithm\", \"subjectPublicKey\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, PublicKeyInfo.schema({\n      names: {\n        algorithm: {\n          names: {\n            blockName: \"algorithm\"\n          }\n        },\n        subjectPublicKey: \"subjectPublicKey\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for PublicKeyInfo\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.algorithm = new AlgorithmIdentifier({\n      schema: asn1.result.algorithm\n    });\n    this.subjectPublicKey = asn1.result.subjectPublicKey;\n\n    switch (this.algorithm.algorithmId) {\n      case \"1.2.840.10045.2.1\":\n        // ECDSA\n        if (\"algorithmParams\" in this.algorithm) {\n          if (this.algorithm.algorithmParams.constructor.blockName() === asn1js.ObjectIdentifier.blockName()) {\n            try {\n              this.parsedKey = new ECPublicKey({\n                namedCurve: this.algorithm.algorithmParams.valueBlock.toString(),\n                schema: this.subjectPublicKey.valueBlock.valueHex\n              });\n            } catch (ex) {} // Could be a problems during recognision of internal public key data here. Let's ignore them.\n\n          }\n        }\n\n        break;\n\n      case \"1.2.840.113549.1.1.1\":\n        // RSA\n        {\n          const publicKeyASN1 = asn1js.fromBER(this.subjectPublicKey.valueBlock.valueHex);\n\n          if (publicKeyASN1.offset !== -1) {\n            try {\n              this.parsedKey = new RSAPublicKey({\n                schema: publicKeyASN1.result\n              });\n            } catch (ex) {} // Could be a problems during recognision of internal public key data here. Let's ignore them.\n\n          }\n        }\n        break;\n\n      default:\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n\n\n  toSchema() {\n    //region Construct and return new ASN.1 schema for this object\n    return new asn1js.Sequence({\n      value: [this.algorithm.toSchema(), this.subjectPublicKey]\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n\n\n  toJSON() {\n    //region Return common value in case we do not have enough info fo making JWK\n    if (\"parsedKey\" in this === false) {\n      return {\n        algorithm: this.algorithm.toJSON(),\n        subjectPublicKey: this.subjectPublicKey.toJSON()\n      };\n    } //endregion\n    //region Making JWK\n\n\n    const jwk = {};\n\n    switch (this.algorithm.algorithmId) {\n      case \"1.2.840.10045.2.1\":\n        // ECDSA\n        jwk.kty = \"EC\";\n        break;\n\n      case \"1.2.840.113549.1.1.1\":\n        // RSA\n        jwk.kty = \"RSA\";\n        break;\n\n      default:\n    }\n\n    const publicKeyJWK = this.parsedKey.toJSON();\n\n    for (const key of Object.keys(publicKeyJWK)) jwk[key] = publicKeyJWK[key];\n\n    return jwk; //endregion\n  } //**********************************************************************************\n\n  /**\n   * Convert JSON value into current object\n   * @param {Object} json\n   */\n\n\n  fromJSON(json) {\n    if (\"kty\" in json) {\n      switch (json.kty.toUpperCase()) {\n        case \"EC\":\n          this.parsedKey = new ECPublicKey({\n            json\n          });\n          this.algorithm = new AlgorithmIdentifier({\n            algorithmId: \"1.2.840.10045.2.1\",\n            algorithmParams: new asn1js.ObjectIdentifier({\n              value: this.parsedKey.namedCurve\n            })\n          });\n          break;\n\n        case \"RSA\":\n          this.parsedKey = new RSAPublicKey({\n            json\n          });\n          this.algorithm = new AlgorithmIdentifier({\n            algorithmId: \"1.2.840.113549.1.1.1\",\n            algorithmParams: new asn1js.Null()\n          });\n          break;\n\n        default:\n          throw new Error(`Invalid value for \"kty\" parameter: ${json.kty}`);\n      }\n\n      this.subjectPublicKey = new asn1js.BitString({\n        valueHex: this.parsedKey.toSchema().toBER(false)\n      });\n    }\n  } //**********************************************************************************\n\n\n  importKey(publicKey) {\n    //region Initial variables\n    let sequence = Promise.resolve();\n\n    const _this = this; //endregion\n    //region Initial check\n\n\n    if (typeof publicKey === \"undefined\") return Promise.reject(\"Need to provide publicKey input parameter\"); //endregion\n    //region Get a \"crypto\" extension\n\n    const crypto = getCrypto();\n    if (typeof crypto === \"undefined\") return Promise.reject(\"Unable to create WebCrypto object\"); //endregion\n    //region Export public key\n\n    sequence = sequence.then(() => crypto.exportKey(\"spki\", publicKey)); //endregion\n    //region Initialize internal variables by parsing exported value\n\n    sequence = sequence.then(\n    /**\n     * @param {ArrayBuffer} exportedKey\n     */\n    exportedKey => {\n      const asn1 = asn1js.fromBER(exportedKey);\n\n      try {\n        _this.fromSchema(asn1.result);\n      } catch (exception) {\n        return Promise.reject(\"Error during initializing object from schema\");\n      }\n\n      return undefined;\n    }, error => Promise.reject(`Error during exporting public key: ${error}`)); //endregion\n\n    return sequence;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************","map":{"version":3,"sources":["C:/Users/rkanthet/Documents/test_window_object/node_modules/pkijs/src/PublicKeyInfo.js"],"names":["asn1js","getParametersValue","clearProps","getCrypto","AlgorithmIdentifier","ECPublicKey","RSAPublicKey","PublicKeyInfo","constructor","parameters","algorithm","defaultValues","subjectPublicKey","parsedKey","fromSchema","schema","fromJSON","json","memberName","BitString","Error","names","Sequence","name","blockName","value","asn1","compareSchema","verified","result","algorithmId","algorithmParams","ObjectIdentifier","namedCurve","valueBlock","toString","valueHex","ex","publicKeyASN1","fromBER","offset","toSchema","toJSON","jwk","kty","publicKeyJWK","key","Object","keys","toUpperCase","Null","toBER","importKey","publicKey","sequence","Promise","resolve","_this","reject","crypto","then","exportKey","exportedKey","exception","undefined","error"],"mappings":"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","sourcesContent":["import * as asn1js from \"asn1js\";\nimport { getParametersValue, clearProps } from \"pvutils\";\nimport { getCrypto } from \"./common.js\";\nimport AlgorithmIdentifier from \"./AlgorithmIdentifier.js\";\nimport ECPublicKey from \"./ECPublicKey.js\";\nimport RSAPublicKey from \"./RSAPublicKey.js\";\n//**************************************************************************************\n/**\n * Class from RFC5280\n */\nexport default class PublicKeyInfo \n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for PublicKeyInfo class\n\t * @param {Object} [parameters={}]\n\t * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\t//region Internal properties of the object\n\t\t/**\n\t\t * @type {AlgorithmIdentifier}\n\t\t * @desc Algorithm identifier\n\t\t */\n\t\tthis.algorithm = getParametersValue(parameters, \"algorithm\", PublicKeyInfo.defaultValues(\"algorithm\"));\n\t\t/**\n\t\t * @type {BitString}\n\t\t * @desc Subject public key value\n\t\t */\n\t\tthis.subjectPublicKey = getParametersValue(parameters, \"subjectPublicKey\", PublicKeyInfo.defaultValues(\"subjectPublicKey\"));\n\t\t\n\t\tif(\"parsedKey\" in parameters)\n\t\t\t/**\n\t\t\t * @type {ECPublicKey|RSAPublicKey}\n\t\t\t * @desc Parsed public key value\n\t\t\t */\n\t\t\tthis.parsedKey = getParametersValue(parameters, \"parsedKey\", PublicKeyInfo.defaultValues(\"parsedKey\"));\n\t\t//endregion\n\t\t\n\t\t//region If input argument array contains \"schema\" for this object\n\t\tif(\"schema\" in parameters)\n\t\t\tthis.fromSchema(parameters.schema);\n\t\t//endregion\n\t\t//region If input argument array contains \"json\" for this object\n\t\tif(\"json\" in parameters)\n\t\t\tthis.fromJSON(parameters.json);\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Return default values for all class members\n\t * @param {string} memberName String name for a class member\n\t */\n\tstatic defaultValues(memberName)\n\t{\n\t\tswitch(memberName)\n\t\t{\n\t\t\tcase \"algorithm\":\n\t\t\t\treturn new AlgorithmIdentifier();\n\t\t\tcase \"subjectPublicKey\":\n\t\t\t\treturn new asn1js.BitString();\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Invalid member name for PublicKeyInfo class: ${memberName}`);\n\t\t}\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Return value of pre-defined ASN.1 schema for current class\n\t *\n\t * ASN.1 schema:\n\t * ```asn1\n\t * SubjectPublicKeyInfo  ::=  Sequence  {\n\t *    algorithm            AlgorithmIdentifier,\n\t *    subjectPublicKey     BIT STRING  }\n\t * ```\n\t *\n\t * @param {Object} parameters Input parameters for the schema\n\t * @returns {Object} asn1js schema object\n\t */\n\tstatic schema(parameters = {})\n\t{\n\t\t/**\n\t\t * @type {Object}\n\t\t * @property {string} [blockName]\n\t\t * @property {string} [algorithm]\n\t\t * @property {string} [subjectPublicKey]\n\t\t */\n\t\tconst names = getParametersValue(parameters, \"names\", {});\n\t\t\n\t\treturn (new asn1js.Sequence({\n\t\t\tname: (names.blockName || \"\"),\n\t\t\tvalue: [\n\t\t\t\tAlgorithmIdentifier.schema(names.algorithm || {}),\n\t\t\t\tnew asn1js.BitString({ name: (names.subjectPublicKey || \"\") })\n\t\t\t]\n\t\t}));\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convert parsed asn1js object into current class\n\t * @param {!Object} schema\n\t */\n\tfromSchema(schema)\n\t{\n\t\t//region Clear input data first\n\t\tclearProps(schema, [\n\t\t\t\"algorithm\",\n\t\t\t\"subjectPublicKey\"\n\t\t]);\n\t\t//endregion\n\t\t\n\t\t//region Check the schema is valid\n\t\tconst asn1 = asn1js.compareSchema(schema,\n\t\t\tschema,\n\t\t\tPublicKeyInfo.schema({\n\t\t\t\tnames: {\n\t\t\t\t\talgorithm: {\n\t\t\t\t\t\tnames: {\n\t\t\t\t\t\t\tblockName: \"algorithm\"\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tsubjectPublicKey: \"subjectPublicKey\"\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t\t\n\t\tif(asn1.verified === false)\n\t\t\tthrow new Error(\"Object's schema was not verified against input data for PublicKeyInfo\");\n\t\t//endregion\n\t\t\n\t\t//region Get internal properties from parsed schema\n\t\tthis.algorithm = new AlgorithmIdentifier({ schema: asn1.result.algorithm });\n\t\tthis.subjectPublicKey = asn1.result.subjectPublicKey;\n\t\t\n\t\tswitch(this.algorithm.algorithmId)\n\t\t{\n\t\t\tcase \"1.2.840.10045.2.1\": // ECDSA\n\t\t\t\tif(\"algorithmParams\" in this.algorithm)\n\t\t\t\t{\n\t\t\t\t\tif(this.algorithm.algorithmParams.constructor.blockName() === asn1js.ObjectIdentifier.blockName())\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.parsedKey = new ECPublicKey({\n\t\t\t\t\t\t\t\tnamedCurve: this.algorithm.algorithmParams.valueBlock.toString(),\n\t\t\t\t\t\t\t\tschema: this.subjectPublicKey.valueBlock.valueHex\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(ex){} // Could be a problems during recognision of internal public key data here. Let's ignore them.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"1.2.840.113549.1.1.1\": // RSA\n\t\t\t\t{\n\t\t\t\t\tconst publicKeyASN1 = asn1js.fromBER(this.subjectPublicKey.valueBlock.valueHex);\n\t\t\t\t\tif(publicKeyASN1.offset !== (-1))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.parsedKey = new RSAPublicKey({ schema: publicKeyASN1.result });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(ex){} // Could be a problems during recognision of internal public key data here. Let's ignore them.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t}\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convert current object to asn1js object and set correct values\n\t * @returns {Object} asn1js object\n\t */\n\ttoSchema()\n\t{\n\t\t//region Construct and return new ASN.1 schema for this object\n\t\treturn (new asn1js.Sequence({\n\t\t\tvalue: [\n\t\t\t\tthis.algorithm.toSchema(),\n\t\t\t\tthis.subjectPublicKey\n\t\t\t]\n\t\t}));\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the class to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\t//region Return common value in case we do not have enough info fo making JWK\n\t\tif((\"parsedKey\" in this) === false)\n\t\t{\n\t\t\treturn {\n\t\t\t\talgorithm: this.algorithm.toJSON(),\n\t\t\t\tsubjectPublicKey: this.subjectPublicKey.toJSON()\n\t\t\t};\n\t\t}\n\t\t//endregion\n\t\t\n\t\t//region Making JWK\n\t\tconst jwk = {};\n\t\t\n\t\tswitch(this.algorithm.algorithmId)\n\t\t{\n\t\t\tcase \"1.2.840.10045.2.1\": // ECDSA\n\t\t\t\tjwk.kty = \"EC\";\n\t\t\t\tbreak;\n\t\t\tcase \"1.2.840.113549.1.1.1\": // RSA\n\t\t\t\tjwk.kty = \"RSA\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t}\n\t\t\n\t\tconst publicKeyJWK = this.parsedKey.toJSON();\n\t\t\n\t\tfor(const key of Object.keys(publicKeyJWK))\n\t\t\tjwk[key] = publicKeyJWK[key];\n\t\t\n\t\treturn jwk;\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convert JSON value into current object\n\t * @param {Object} json\n\t */\n\tfromJSON(json)\n\t{\n\t\tif(\"kty\" in json)\n\t\t{\n\t\t\tswitch(json.kty.toUpperCase())\n\t\t\t{\n\t\t\t\tcase \"EC\":\n\t\t\t\t\tthis.parsedKey = new ECPublicKey({ json });\n\t\t\t\t\t\n\t\t\t\t\tthis.algorithm = new AlgorithmIdentifier({\n\t\t\t\t\t\talgorithmId: \"1.2.840.10045.2.1\",\n\t\t\t\t\t\talgorithmParams: new asn1js.ObjectIdentifier({ value: this.parsedKey.namedCurve })\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"RSA\":\n\t\t\t\t\tthis.parsedKey = new RSAPublicKey({ json });\n\t\t\t\t\t\n\t\t\t\t\tthis.algorithm = new AlgorithmIdentifier({\n\t\t\t\t\t\talgorithmId: \"1.2.840.113549.1.1.1\",\n\t\t\t\t\t\talgorithmParams: new asn1js.Null()\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid value for \"kty\" parameter: ${json.kty}`);\n\t\t\t}\n\t\t\t\n\t\t\tthis.subjectPublicKey = new asn1js.BitString({ valueHex: this.parsedKey.toSchema().toBER(false) });\n\t\t}\n\t}\n\t//**********************************************************************************\n\timportKey(publicKey)\n\t{\n\t\t//region Initial variables\n\t\tlet sequence = Promise.resolve();\n\t\tconst _this = this;\n\t\t//endregion\n\t\t\n\t\t//region Initial check\n\t\tif(typeof publicKey === \"undefined\")\n\t\t\treturn Promise.reject(\"Need to provide publicKey input parameter\");\n\t\t//endregion\n\t\t\n\t\t//region Get a \"crypto\" extension\n\t\tconst crypto = getCrypto();\n\t\tif(typeof crypto === \"undefined\")\n\t\t\treturn Promise.reject(\"Unable to create WebCrypto object\");\n\t\t//endregion\n\t\t\n\t\t//region Export public key\n\t\tsequence = sequence.then(() =>\n\t\t\tcrypto.exportKey(\"spki\", publicKey));\n\t\t//endregion\n\t\t\n\t\t//region Initialize internal variables by parsing exported value\n\t\tsequence = sequence.then(\n\t\t\t/**\n\t\t\t * @param {ArrayBuffer} exportedKey\n\t\t\t */\n\t\t\texportedKey =>\n\t\t\t{\n\t\t\t\tconst asn1 = asn1js.fromBER(exportedKey);\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t_this.fromSchema(asn1.result);\n\t\t\t\t}\n\t\t\t\tcatch(exception)\n\t\t\t\t{\n\t\t\t\t\treturn Promise.reject(\"Error during initializing object from schema\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn undefined;\n\t\t\t},\n\t\t\terror => Promise.reject(`Error during exporting public key: ${error}`)\n\t\t);\n\t\t//endregion\n\t\t\n\t\treturn sequence;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n"]},"metadata":{},"sourceType":"module"}