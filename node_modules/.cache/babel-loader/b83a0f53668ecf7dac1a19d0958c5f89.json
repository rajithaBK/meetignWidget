{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/map\"));\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/keys\"));\n\nvar _errors = require(\"./errors\");\n/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\n/**\n * Binds a namespace\n * @param {string} namespace\n * @param {Object} options\n * @param {Object} options.data\n * @private\n * @returns {Promise<Object>}\n */\n\n\nfunction _bind(namespace) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  options = options || {};\n\n  if (!namespace) {\n    return _promise.default.reject(new Error('`namespace` is required'));\n  }\n\n  if (!options.logger) {\n    return _promise.default.reject(new Error('`options.logger` is required'));\n  }\n\n  var _options = options,\n      logger = _options.logger;\n  var map = new _map.default([['@', {}]]);\n\n  if (options.data) {\n    (0, _keys.default)(options.data).forEach(function (key) {\n      map.set(key, options.data[key]);\n    });\n  }\n\n  logger.debug('memory-store-adapter: returning binding');\n  return _promise.default.resolve({\n    clear: function clear() {\n      logger.debug('memory-store-adapter: clearing the binding');\n      return _promise.default.resolve(map.clear());\n    },\n    del: function del(key) {\n      logger.debug(\"memory-store-adapter: deleting `\".concat(key, \"`\"));\n      return _promise.default.resolve(map.delete(key));\n    },\n    get: function get(key) {\n      logger.debug(\"memory-store-adapter: reading `\".concat(key, \"`\"));\n      var res = map.get(key);\n\n      if (typeof res === 'undefined') {\n        return _promise.default.reject(new _errors.NotFoundError());\n      }\n\n      return _promise.default.resolve(res);\n    },\n    put: function put(key, value) {\n      logger.debug(\"memory-store-adapter: writing `\".concat(key, \"`\"));\n      return _promise.default.resolve(map.set(key, value));\n    }\n  });\n}\n\nvar _default = {\n  bind: _bind,\n  preload: function preload(data) {\n    return {\n      bind: function bind(namespace) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        if (data[namespace]) {\n          options.data = data[namespace];\n        }\n\n        return _bind(namespace, options);\n      }\n    };\n  }\n};\nexports.default = _default;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;AAIA;AAJA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASA,KAAT,CAAeC,SAAf,EAAwC;AAAA,MAAdC,OAAc,uEAAJ,EAAI;AACtCA,SAAO,GAAGA,OAAO,IAAI,EAArBA;;AACA,MAAI,CAACD,SAAL,EAAgB;AACd,WAAOE,iBAAQC,MAAR,CAAe,IAAIC,KAAJ,CAAU,yBAAV,CAAf,CAAP;AACD;;AAED,MAAI,CAACH,OAAO,CAACI,MAAb,EAAqB;AACnB,WAAOH,iBAAQC,MAAR,CAAe,IAAIC,KAAJ,CAAU,8BAAV,CAAf,CAAP;AACD;;AAED,iBAAiBH,OAAjB;AAAA,MAAOI,MAAP,YAAOA,MAAP;AAEA,MAAMC,GAAG,GAAG,iBAAQ,CAAC,CAAC,GAAD,EAAM,EAAN,CAAD,CAAR,CAAZ;;AAEA,MAAIL,OAAO,CAACM,IAAZ,EAAkB;AAChB,uBAAYN,OAAO,CAACM,IAApB,EAA0BC,OAA1B,CAAkC,UAACC,GAAD,EAAS;AACzCH,SAAG,CAACI,GAAJJ,CAAQG,GAARH,EAAaL,OAAO,CAACM,IAARN,CAAaQ,GAAbR,CAAbK;AADF;AAGD;;AAEDD,QAAM,CAACM,KAAPN,CAAa,yCAAbA;AAEA,SAAOH,iBAAQU,OAAR,CAAgB;AACrBC,SADqB,mBACb;AACNR,YAAM,CAACM,KAAPN,CAAa,4CAAbA;AAEA,aAAOH,iBAAQU,OAAR,CAAgBN,GAAG,CAACO,KAAJP,EAAhB,CAAP;AAJmB;AAMrBQ,OANqB,eAMjBL,GANiB,EAMZ;AACPJ,YAAM,CAACM,KAAPN,2CAAiDI,GAAjD;AAEA,aAAOP,iBAAQU,OAAR,CAAgBN,GAAG,CAACS,MAAJT,CAAWG,GAAXH,CAAhB,CAAP;AATmB;AAWrBU,OAXqB,eAWjBP,GAXiB,EAWZ;AACPJ,YAAM,CAACM,KAAPN,0CAAgDI,GAAhD;AACA,UAAMQ,GAAG,GAAGX,GAAG,CAACU,GAAJV,CAAQG,GAARH,CAAZ;;AAEA,UAAI,OAAOW,GAAP,KAAe,WAAnB,EAAgC;AAC9B,eAAOf,iBAAQC,MAAR,CAAe,IAAIe,qBAAJ,EAAf,CAAP;AACD;;AAED,aAAOhB,iBAAQU,OAAR,CAAgBK,GAAhB,CAAP;AAnBmB;AAqBrBE,OArBqB,eAqBjBV,GArBiB,EAqBZW,KArBY,EAqBL;AACdf,YAAM,CAACM,KAAPN,0CAAgDI,GAAhD;AAEA,aAAOP,iBAAQU,OAAR,CAAgBN,GAAG,CAACI,GAAJJ,CAAQG,GAARH,EAAac,KAAbd,CAAhB,CAAP;AACD;AAzBoB,GAAhB,CAAP;AA2BD;;eAEc;AACbe,MAAI,EAAEtB,KADO;AAEbuB,SAFa,mBAELf,IAFK,EAEC;AACZ,WAAO;AACLc,UADK,gBACArB,SADA,EACyB;AAAA,YAAdC,OAAc,uEAAJ,EAAI;;AAC5B,YAAIM,IAAI,CAACP,SAAD,CAAR,EAAqB;AACnBC,iBAAO,CAACM,IAARN,GAAeM,IAAI,CAACP,SAAD,CAAnBC;AACD;;AAED,eAAOF,KAAK,CAACC,SAAD,EAAYC,OAAZ,CAAZ;AACD;AAPI,KAAP;AASD;AAZY","names":["_bind","namespace","options","_promise","reject","Error","logger","map","data","forEach","key","set","debug","resolve","clear","del","delete","get","res","NotFoundError","put","value","bind","preload"],"sources":["memory-store-adapter.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {NotFoundError} from './errors';\n\n/**\n * Binds a namespace\n * @param {string} namespace\n * @param {Object} options\n * @param {Object} options.data\n * @private\n * @returns {Promise<Object>}\n */\nfunction _bind(namespace, options = {}) {\n  options = options || {};\n  if (!namespace) {\n    return Promise.reject(new Error('`namespace` is required'));\n  }\n\n  if (!options.logger) {\n    return Promise.reject(new Error('`options.logger` is required'));\n  }\n\n  const {logger} = options;\n\n  const map = new Map([['@', {}]]);\n\n  if (options.data) {\n    Object.keys(options.data).forEach((key) => {\n      map.set(key, options.data[key]);\n    });\n  }\n\n  logger.debug('memory-store-adapter: returning binding');\n\n  return Promise.resolve({\n    clear() {\n      logger.debug('memory-store-adapter: clearing the binding');\n\n      return Promise.resolve(map.clear());\n    },\n    del(key) {\n      logger.debug(`memory-store-adapter: deleting \\`${key}\\``);\n\n      return Promise.resolve(map.delete(key));\n    },\n    get(key) {\n      logger.debug(`memory-store-adapter: reading \\`${key}\\``);\n      const res = map.get(key);\n\n      if (typeof res === 'undefined') {\n        return Promise.reject(new NotFoundError());\n      }\n\n      return Promise.resolve(res);\n    },\n    put(key, value) {\n      logger.debug(`memory-store-adapter: writing \\`${key}\\``);\n\n      return Promise.resolve(map.set(key, value));\n    }\n  });\n}\n\nexport default {\n  bind: _bind,\n  preload(data) {\n    return {\n      bind(namespace, options = {}) {\n        if (data[namespace]) {\n          options.data = data[namespace];\n        }\n\n        return _bind(namespace, options);\n      }\n    };\n  }\n};\n"]},"metadata":{},"sourceType":"script"}