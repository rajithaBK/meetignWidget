{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = debounce;\n\nvar _apply = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/reflect/apply\"));\n/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\n/**\n * Behaves like debounce, but additionally executes after a number of calls are\n * attempted, rather than just time\n * @param {Function} fn\n * @param {Number} wait\n * @param {Object} options\n * @returns {Function}\n */\n\n\nfunction debounce(fn, wait, options) {\n  /* eslint no-invalid-this: [0] */\n  if (!fn) {\n    throw new Error('`fn` must be a function');\n  }\n\n  if (!wait) {\n    throw new Error('`wait` is required');\n  }\n\n  options = options || {};\n\n  if (!options.maxWait) {\n    throw new Error('`options.maxWait` is required');\n  }\n\n  if (!options.maxCalls) {\n    throw new Error('`options.maxCalls` is required');\n  }\n\n  var _options = options,\n      maxCalls = _options.maxCalls,\n      maxWait = _options.maxWait;\n  var count = 0;\n  var maxWaitTimer, waitTimer;\n  return function wrapper() {\n    count += 1;\n    clearTimeout(waitTimer);\n    waitTimer = setTimeout(function () {\n      return exec();\n    }, wait);\n\n    if (!maxWaitTimer) {\n      maxWaitTimer = setTimeout(function () {\n        return exec();\n      }, maxWait);\n    }\n\n    if (count >= maxCalls) {\n      (0, _apply.default)(exec, this, []);\n    }\n  };\n  /**\n   * @private\n   * @returns {undefined}\n   */\n\n  function exec() {\n    clearTimeout(waitTimer);\n    waitTimer = null;\n    clearTimeout(maxWaitTimer);\n    maxWaitTimer = null;\n    count = 0;\n    (0, _apply.default)(fn, this, []);\n  }\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACe,SAASA,QAAT,CAAkBC,EAAlB,EAAsBC,IAAtB,EAA4BC,OAA5B,EAAqC;AAClD;AAEA,MAAI,CAACF,EAAL,EAAS;AACP,UAAM,IAAIG,KAAJ,CAAU,yBAAV,CAAN;AACD;;AAED,MAAI,CAACF,IAAL,EAAW;AACT,UAAM,IAAIE,KAAJ,CAAU,oBAAV,CAAN;AACD;;AAEDD,SAAO,GAAGA,OAAO,IAAI,EAArBA;;AACA,MAAI,CAACA,OAAO,CAACE,OAAb,EAAsB;AACpB,UAAM,IAAID,KAAJ,CAAU,+BAAV,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAACG,QAAb,EAAuB;AACrB,UAAM,IAAIF,KAAJ,CAAU,gCAAV,CAAN;AACD;;AAED,iBAA4BD,OAA5B;AAAA,MAAOG,QAAP,YAAOA,QAAP;AAAA,MAAiBD,OAAjB,YAAiBA,OAAjB;AACA,MAAIE,KAAK,GAAG,CAAZ;AACA,MAAIC,YAAJ,EAAkBC,SAAlB;AAEA,SAAO,SAASC,OAAT,GAAmB;AACxBH,SAAK,IAAI,CAATA;AAEAI,gBAAY,CAACF,SAAD,CAAZE;AACAF,aAAS,GAAGG,UAAU,CAAC;AAAA,aAAMC,IAAI,EAAV;AAAD,OAAeX,IAAf,CAAtBO;;AAEA,QAAI,CAACD,YAAL,EAAmB;AACjBA,kBAAY,GAAGI,UAAU,CAAC;AAAA,eAAMC,IAAI,EAAV;AAAD,SAAeR,OAAf,CAAzBG;AACD;;AAED,QAAID,KAAK,IAAID,QAAb,EAAuB;AACrB,0BAAcO,IAAd,EAAoB,IAApB,EAA0B,EAA1B;AACD;AAZH;AAeA;AACF;AACA;AACA;;AACE,WAASA,IAAT,GAAgB;AACdF,gBAAY,CAACF,SAAD,CAAZE;AACAF,aAAS,GAAG,IAAZA;AACAE,gBAAY,CAACH,YAAD,CAAZG;AACAH,gBAAY,GAAG,IAAfA;AACAD,SAAK,GAAG,CAARA;AAEA,wBAAcN,EAAd,EAAkB,IAAlB,EAAwB,EAAxB;AACD;AACF","names":["debounce","fn","wait","options","Error","maxWait","maxCalls","count","maxWaitTimer","waitTimer","wrapper","clearTimeout","setTimeout","exec"],"sources":["capped-debounce.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\n/**\n * Behaves like debounce, but additionally executes after a number of calls are\n * attempted, rather than just time\n * @param {Function} fn\n * @param {Number} wait\n * @param {Object} options\n * @returns {Function}\n */\nexport default function debounce(fn, wait, options) {\n  /* eslint no-invalid-this: [0] */\n\n  if (!fn) {\n    throw new Error('`fn` must be a function');\n  }\n\n  if (!wait) {\n    throw new Error('`wait` is required');\n  }\n\n  options = options || {};\n  if (!options.maxWait) {\n    throw new Error('`options.maxWait` is required');\n  }\n  if (!options.maxCalls) {\n    throw new Error('`options.maxCalls` is required');\n  }\n\n  const {maxCalls, maxWait} = options;\n  let count = 0;\n  let maxWaitTimer, waitTimer;\n\n  return function wrapper() {\n    count += 1;\n\n    clearTimeout(waitTimer);\n    waitTimer = setTimeout(() => exec(), wait);\n\n    if (!maxWaitTimer) {\n      maxWaitTimer = setTimeout(() => exec(), maxWait);\n    }\n\n    if (count >= maxCalls) {\n      Reflect.apply(exec, this, []);\n    }\n  };\n\n  /**\n   * @private\n   * @returns {undefined}\n   */\n  function exec() {\n    clearTimeout(waitTimer);\n    waitTimer = null;\n    clearTimeout(maxWaitTimer);\n    maxWaitTimer = null;\n    count = 0;\n\n    Reflect.apply(fn, this, []);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}