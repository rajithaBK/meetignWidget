{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _deleteProperty = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/reflect/delete-property\"));\n\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/json/stringify\"));\n\nvar _assign = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/assign\"));\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/keys\"));\n\nvar _apply = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/reflect/apply\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _now = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/date/now\"));\n\nvar _getOwnPropertyDescriptor = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\"));\n\nvar _applyDecoratedDescriptor2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/applyDecoratedDescriptor\"));\n\nvar _isEmpty2 = _interopRequireDefault(require(\"lodash/isEmpty\"));\n\nvar _isObject2 = _interopRequireDefault(require(\"lodash/isObject\"));\n\nvar _cloneDeep2 = _interopRequireDefault(require(\"lodash/cloneDeep\"));\n\nvar _clone2 = _interopRequireDefault(require(\"lodash/clone\"));\n\nvar _querystring = _interopRequireDefault(require(\"querystring\"));\n\nvar _url = _interopRequireDefault(require(\"url\"));\n\nvar _jsonwebtoken = _interopRequireDefault(require(\"jsonwebtoken\"));\n\nvar _common = require(\"@webex/common\");\n\nvar _commonTimers = require(\"@webex/common-timers\");\n\nvar _webexPlugin = _interopRequireDefault(require(\"../webex-plugin\"));\n\nvar _decorators = require(\"../storage/decorators\");\n\nvar _grantErrors = _interopRequireDefault(require(\"./grant-errors\"));\n\nvar _scope = require(\"./scope\");\n\nvar _token = _interopRequireDefault(require(\"./token\"));\n\nvar _tokenCollection = _interopRequireDefault(require(\"./token-collection\"));\n\nvar _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _obj;\n/**\n * @class\n */\n\n\nvar Credentials = _webexPlugin.default.extend((_dec = (0, _common.oneFlight)({\n  keyFactory: function keyFactory(scope) {\n    return scope;\n  }\n}), _dec2 = (0, _decorators.waitForValue)('@'), _dec3 = (0, _decorators.persist)('@'), _dec4 = (0, _decorators.waitForValue)('@'), _dec5 = (0, _common.whileInFlight)('isRefreshing'), _dec6 = (0, _decorators.waitForValue)('@'), (_obj = {\n  collections: {\n    userTokens: _tokenCollection.default\n  },\n  dataTypes: {\n    token: (0, _common.makeStateDataType)(_token.default, 'token').dataType\n  },\n  derived: {\n    canAuthorize: {\n      deps: ['supertoken', 'supertoken.canAuthorize', 'canRefresh'],\n      fn: function fn() {\n        return Boolean(this.supertoken && this.supertoken.canAuthorize || this.canRefresh);\n      }\n    },\n    canRefresh: {\n      deps: ['supertoken', 'supertoken.canRefresh'],\n      fn: function fn() {\n        // If we're operating in JWT mode, we have to delegate to the consumer\n        if (this.config.jwtRefreshCallback) {\n          return true;\n        }\n\n        return Boolean(this.supertoken && this.supertoken.canRefresh);\n      }\n    }\n  },\n  props: {\n    supertoken: (0, _common.makeStateDataType)(_token.default, 'token').prop\n  },\n  namespace: 'Credentials',\n  session: {\n    isRefreshing: {\n      default: false,\n      type: 'boolean'\n    },\n\n    /**\n     * Becomes `true` once the {@link loaded} event fires.\n     * @see {@link WebexPlugin#ready}\n     * @instance\n     * @memberof Credentials\n     * @type {boolean}\n     */\n    ready: {\n      default: false,\n      type: 'boolean'\n    },\n    refreshTimer: {\n      default: undefined,\n      type: 'any'\n    }\n  },\n\n  /**\n   * Generates an OAuth Login URL. Prefers the api.ciscospark.com proxy if the\n   * instance is initialize with an authorizatUrl, but fallsback to idbroker\n   * as the base otherwise.\n   * @instance\n   * @memberof Credentials\n   * @param {Object} [options={}]\n   * @returns {string}\n   */\n  buildLoginUrl: function buildLoginUrl() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      clientType: 'public'\n    };\n    /* eslint-disable camelcase */\n\n    if (options.state && !(0, _isObject2.default)(options.state)) {\n      throw new Error('if specified, `options.state` must be an object');\n    }\n\n    options.client_id = this.config.client_id;\n    options.redirect_uri = this.config.redirect_uri;\n    options.scope = this.config.scope;\n    options = (0, _cloneDeep2.default)(options);\n\n    if (!options.response_type) {\n      options.response_type = options.clientType === 'public' ? 'token' : 'code';\n    }\n\n    (0, _deleteProperty.default)(options, 'clientType');\n\n    if (options.state) {\n      if (!(0, _isEmpty2.default)(options.state)) {\n        options.state = _common.base64.toBase64Url((0, _stringify.default)(options.state));\n      } else {\n        delete options.state;\n      }\n    }\n\n    return \"\".concat(this.config.authorizeUrl, \"?\").concat(_querystring.default.stringify(options));\n    /* eslint-enable camelcase */\n  },\n\n  /**\n   * Get the determined OrgId.\n   *\n   * @throws {Error} - If the OrgId could not be determined.\n   * @returns {string} - The OrgId.\n   */\n  getOrgId: function getOrgId() {\n    this.logger.info('credentials: attempting to retrieve the OrgId from token');\n\n    try {\n      // Attempt to extract a client-authenticated token's OrgId.\n      this.logger.info('credentials: trying to extract OrgId from JWT');\n      return this.extractOrgIdFromJWT(this.supertoken.access_token);\n    } catch (e) {\n      // Attempt to extract a user token's OrgId.\n      this.logger.info('credentials: could not extract OrgId from JWT');\n      this.logger.info('credentials: attempting to extract OrgId from user token');\n      return this.extractOrgIdFromUserToken(this.supertoken.access_token);\n    }\n  },\n\n  /**\n   * Extract the OrgId [realm] from a provided JWT.\n   *\n   * @private\n   * @param {string} token - The JWT to extract the OrgId from.\n   * @throws {Error} - If the token does not pass JWT general/realm validation.\n   * @returns {string} - The OrgId.\n   */\n  extractOrgIdFromJWT: function extractOrgIdFromJWT() {\n    var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ''; // Decoded the provided token.\n\n    var decodedJWT = _jsonwebtoken.default.decode(token); // Validate that the provided token is a JWT.\n\n\n    if (!decodedJWT) {\n      throw new Error('unable to extract the OrgId from the provided JWT');\n    }\n\n    if (!decodedJWT.realm) {\n      throw new Error('the provided JWT does not contain an OrgId');\n    } // Return the OrgId [realm].\n\n\n    return decodedJWT.realm;\n  },\n\n  /**\n   * Extract the OrgId [realm] from a provided user token.\n   *\n   * @private\n   * @param {string} token - The user token to extract the OrgId from.\n   * @throws {Error} - Will throw an error if the provided token is invalid.\n   * @returns {string} - The OrgId.\n   */\n  extractOrgIdFromUserToken: function extractOrgIdFromUserToken() {\n    var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ''; // Split the provided token into subsections.\n\n    var fields = token.split('_'); // Validate that the provided token has the proper amount of sections.\n\n    if (fields.length !== 3) {\n      throw new Error('the provided token is not a valid format');\n    } // Return the token section that contains the OrgId.\n\n\n    return fields[2];\n  },\n\n  /**\n   * Generates a Logout URL\n   * @instance\n   * @memberof Credentials\n   * @param {Object} [options={}]\n   * @returns {[type]}\n   */\n  buildLogoutUrl: function buildLogoutUrl() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return \"\".concat(this.config.logoutUrl, \"?\").concat(_querystring.default.stringify((0, _assign.default)({\n      cisService: this.config.service,\n      goto: this.config.redirect_uri\n    }, options)));\n  },\n\n  /**\n   * Generates a number between 60% - 90% of expired value\n   * @instance\n   * @memberof Credentials\n   * @param {number} expiration\n   * @private\n   * @returns {number}\n   */\n  calcRefreshTimeout: function calcRefreshTimeout(expiration) {\n    return Math.floor((Math.floor(Math.random() * 4) + 6) / 10 * expiration);\n  },\n  constructor: function constructor() {\n    var _this = this; // HACK to deal with the fact that AmpersandState#dataTypes#set is a pure\n    // function.\n\n\n    this._dataTypes = (0, _cloneDeep2.default)(this._dataTypes);\n    (0, _keys.default)(this._dataTypes).forEach(function (key) {\n      if (_this._dataTypes[key].set) {\n        _this._dataTypes[key].set = _this._dataTypes[key].set.bind(_this);\n      }\n    }); // END HACK\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    (0, _apply.default)(_webexPlugin.default, this, args);\n  },\n\n  /**\n   * Downscopes a token\n   * @instance\n   * @memberof Credentials\n   * @param {string} scope\n   * @private\n   * @returns {Promise<Token>}\n   */\n  downscope: function downscope(scope) {\n    var _this2 = this;\n\n    return this.supertoken.downscope(scope).catch(function (reason) {\n      _this2.logger.trace(\"credentials: failed to downscope supertoken to \".concat(scope), reason);\n\n      _this2.logger.trace(\"credentials: falling back to supertoken for \".concat(scope));\n\n      return _promise.default.resolve(new _token.default((0, _assign.default)({\n        scope: scope\n      }, _this2.supertoken.serialize())), {\n        parent: _this2\n      });\n    });\n  },\n\n  /**\n   * Requests a client credentials grant and returns the token. Given the\n   * limited use for such tokens as this time, this method does not cache its\n   * token.\n   * @instance\n   * @memberof Credentials\n   * @param {Object} options\n   * @returns {Promise<Token>}\n   */\n  getClientToken: function getClientToken() {\n    var _this3 = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.logger.info('credentials: requesting client credentials grant');\n    return this.webex.request({\n      /* eslint-disable camelcase */\n      method: 'POST',\n      uri: options.uri || this.config.tokenUrl,\n      form: {\n        grant_type: 'client_credentials',\n        scope: options.scope || 'webexsquare:admin',\n        self_contained_token: true\n      },\n      auth: {\n        user: this.config.client_id,\n        pass: this.config.client_secret,\n        sendImmediately: true\n      },\n      shouldRefreshAccessToken: false\n      /* eslint-enable camelcase */\n\n    }).then(function (res) {\n      return new _token.default(res.body, {\n        parent: _this3\n      });\n    }).catch(function (res) {\n      if (res.statusCode !== 400) {\n        return _promise.default.reject(res);\n      }\n\n      var ErrorConstructor = _grantErrors.default.select(res.body.error);\n\n      return _promise.default.reject(new ErrorConstructor(res._res || res));\n    });\n  },\n\n  /**\n   * Resolves with a token with the specified scopes. If no scope is specified,\n   * defaults to omit(webex.credentials.scope, 'spark:kms'). If no such token is\n   * available, downscopes the supertoken to that scope.\n   * @instance\n   * @memberof Credentials\n   * @param {string} scope\n   * @returns {Promise<Token>}\n   */\n  getUserToken: function getUserToken(scope) {\n    var _this4 = this;\n\n    return _promise.default.resolve(!this.isRefreshing || new _promise.default(function (resolve) {\n      _this4.logger.info('credentials: token refresh inflight; delaying getUserToken until refresh completes');\n\n      _this4.once('change:isRefreshing', function () {\n        _this4.logger.info('credentials: token refresh complete; reinvoking getUserToken');\n\n        resolve();\n      });\n    })).then(function () {\n      if (!_this4.canAuthorize) {\n        _this4.logger.info('credentials: cannot produce an access token from current state');\n\n        return _promise.default.reject(new Error('Current state cannot produce an access token'));\n      }\n\n      if (!scope) {\n        scope = (0, _scope.filterScope)('spark:kms', _this4.config.scope);\n      }\n\n      scope = (0, _scope.sortScope)(scope);\n\n      if (scope === (0, _scope.sortScope)(_this4.config.scope)) {\n        return _promise.default.resolve(_this4.supertoken);\n      }\n\n      var token = _this4.userTokens.get(scope); // we should also check for the token.access_token since token object does\n      // not get cleared on unsetting while logging out.\n\n\n      if (!token || !token.access_token) {\n        return _this4.downscope(scope).then((0, _common.tap)(function (t) {\n          return _this4.userTokens.add(t);\n        }));\n      }\n\n      return _promise.default.resolve(token);\n    });\n  },\n\n  /**\n   * Initializer\n   * @instance\n   * @memberof Credentials\n   * @param {Object} attrs\n   * @param {Object} options\n   * @private\n   * @returns {Credentials}\n   */\n  initialize: function initialize(attrs, options) {\n    var _this5 = this;\n\n    if (attrs) {\n      if (typeof attrs === 'string') {\n        this.supertoken = attrs;\n      }\n\n      if (attrs.access_token) {\n        this.supertoken = attrs;\n      }\n\n      if (attrs.authorization) {\n        if (attrs.authorization.supertoken) {\n          this.supertoken = attrs.authorization.supertoken;\n        } else {\n          this.supertoken = attrs.authorization;\n        }\n      } // schedule refresh\n\n\n      if (this.supertoken && this.supertoken.expires) {\n        this.scheduleRefresh(this.supertoken.expires);\n      }\n    }\n\n    (0, _apply.default)(_webexPlugin.default.prototype.initialize, this, [attrs, options]);\n    this.listenToOnce(this.parent, 'change:config', function () {\n      if (_this5.config.authorizationString) {\n        var parsed = _url.default.parse(_this5.config.authorizationString, true);\n        /* eslint-disable camelcase */\n\n\n        _this5.config.client_id = parsed.query.client_id;\n        _this5.config.redirect_uri = parsed.query.redirect_uri;\n        _this5.config.scope = parsed.query.scope;\n        _this5.config.authorizeUrl = parsed.href.substr(0, parsed.href.indexOf('?'));\n        /* eslint-enable camelcase */\n      }\n    });\n    this.webex.once('loaded', function () {\n      _this5.ready = true;\n    });\n  },\n\n  /**\n   * Clears all tokens from store them from the stores.\n   *\n   * This is no longer quite the right name for this method, but all of the\n   * alternatives I'm coming up with are already taken.\n   * @instance\n   * @memberof Credentials\n   * @returns {Promise}\n   */\n  invalidate: function invalidate() {\n    this.logger.info('credentials: invalidating tokens'); // clear refresh timer\n\n    if (this.refreshTimer) {\n      clearTimeout(this.refreshTimer);\n      this.unset('refreshTimer');\n    }\n\n    try {\n      this.unset('supertoken');\n    } catch (err) {\n      this.logger.warn('credentials: failed to clear supertoken', err);\n    }\n\n    while (this.userTokens.models.length) {\n      try {\n        this.userTokens.remove(this.userTokens.models[0]);\n      } catch (err) {\n        this.logger.warn('credentials: failed to remove user token', err);\n      }\n    }\n\n    this.logger.info('credentials: finished removing tokens'); // Return a promise to give the storage layer a tick or two to clear\n    // localStorage\n\n    return _promise.default.resolve();\n  },\n\n  /**\n   * Removes the supertoken and child tokens, then refreshes the supertoken;\n   * subsequent calls to {@link Credentials#getUserToken()} will re-downscope\n   * child tokens. Enqueus revocation of previous previousTokens. Yes, that's\n   * the correct number of \"previous\"es.\n   * @instance\n   * @memberof Credentials\n   * @returns {Promise}\n   */\n  refresh: function refresh() {\n    var _this6 = this;\n\n    this.logger.info('credentials: refresh requested');\n    var supertoken = this.supertoken;\n    var tokens = (0, _clone2.default)(this.userTokens.models); // This is kind of a leaky abstraction, since it relies on the authorization\n    // plugin, but the only alternatives I see are\n    // 1. put all JWT support in core\n    // 2. have separate jwt and non-jwt auth plugins\n    // while I like #2 from a code simplicity standpoint, the third-party DX\n    // isn't great\n\n    if (this.config.jwtRefreshCallback) {\n      return this.config.jwtRefreshCallback(this.webex).then(function (jwt) {\n        return _this6.webex.authorization.requestAccessTokenFromJwt({\n          jwt: jwt\n        });\n      });\n    }\n\n    if (this.webex.internal.services) {\n      this.webex.internal.services.updateCredentialsConfig();\n    }\n\n    return supertoken.refresh().then(function (st) {\n      // clear refresh timer\n      if (_this6.refreshTimer) {\n        clearTimeout(_this6.refreshTimer);\n\n        _this6.unset('refreshTimer');\n      }\n\n      _this6.supertoken = st;\n      return _promise.default.all(tokens.map(function (token) {\n        return _this6.downscope(token.scope) // eslint-disable-next-line max-nested-callbacks\n        .then(function (t) {\n          _this6.logger.info(\"credentials: revoking token for \".concat(token.scope));\n\n          return token.revoke().catch(function (err) {\n            _this6.logger.warn('credentials: failed to revoke user token', err);\n          }).then(function () {\n            _this6.userTokens.remove(token.scope);\n\n            _this6.userTokens.add(t);\n          });\n        });\n      }));\n    }).then(function () {\n      _this6.scheduleRefresh(_this6.supertoken.expires);\n    }).catch(function (error) {\n      var InvalidRequestError = _grantErrors.default.InvalidRequestError;\n\n      if (error instanceof InvalidRequestError) {\n        // Error: The refresh token provided is expired, revoked, malformed, or invalid. Hence emit an event to the client, an opportunity to logout.\n        _this6.unset('supertoken');\n\n        while (_this6.userTokens.models.length) {\n          try {\n            _this6.userTokens.remove(_this6.userTokens.models[0]);\n          } catch (err) {\n            _this6.logger.warn('credentials: failed to remove user token', err);\n          }\n        }\n\n        _this6.webex.trigger('client:InvalidRequestError');\n      }\n\n      return _promise.default.reject(error);\n    });\n  },\n\n  /**\n   * Schedules a token refresh or refreshes the token if token has expired\n   * @instance\n   * @memberof Credentials\n   * @param {number} expires\n   * @private\n   * @returns {undefined}\n   */\n  scheduleRefresh: function scheduleRefresh(expires) {\n    var _this7 = this;\n\n    var expiresIn = expires - (0, _now.default)();\n\n    if (expiresIn > 0) {\n      var timeoutLength = this.calcRefreshTimeout(expiresIn);\n      this.refreshTimer = (0, _commonTimers.safeSetTimeout)(function () {\n        return _this7.refresh();\n      }, timeoutLength);\n    } else {\n      this.refresh();\n    }\n  },\n  version: \"1.154.2\"\n}, ((0, _applyDecoratedDescriptor2.default)(_obj, \"getUserToken\", [_dec, _dec2], (0, _getOwnPropertyDescriptor.default)(_obj, \"getUserToken\"), _obj), (0, _applyDecoratedDescriptor2.default)(_obj, \"initialize\", [_dec3], (0, _getOwnPropertyDescriptor.default)(_obj, \"initialize\"), _obj), (0, _applyDecoratedDescriptor2.default)(_obj, \"invalidate\", [_common.oneFlight, _dec4], (0, _getOwnPropertyDescriptor.default)(_obj, \"invalidate\"), _obj), (0, _applyDecoratedDescriptor2.default)(_obj, \"refresh\", [_common.oneFlight, _dec5, _dec6], (0, _getOwnPropertyDescriptor.default)(_obj, \"refresh\"), _obj)), _obj)));\n\nvar _default = Credentials;\nexports.default = _default;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;AACA;;AAEA;;AACA;;AAOA;;AAGA;;AACA;;AAEA;;AACA;;AACA;;AACA;;;AAEA;AACA;AACA;;;AACA,IAAMA,WAAW,GAAGC,qBAAYC,MAAZD,SAmRjB,uBAAU;AAACE,YAAU,EAAE,oBAACC,KAAD;AAAA,WAAWA,KAAX;AAAA;AAAb,CAAV,CAnRiB,UAoRjB,8BAAa,GAAb,CApRiB,UAoUjB,yBAAQ,GAAR,CApUiB,UA4XjB,8BAAa,GAAb,CA5XiB,UAuajB,2BAAc,cAAd,CAvaiB,UAwajB,8BAAa,GAAb,CAxaiB,UAAmB;AACrCC,aAAW,EAAE;AACXC,cAAU,EAAEC;AADD,GADwB;AAKrCC,WAAS,EAAE;AACTC,SAAK,EAAE,+BAAkBC,cAAlB,EAAyB,OAAzB,EAAkCC;AADhC,GAL0B;AASrCC,SAAO,EAAE;AACPC,gBAAY,EAAE;AACZC,UAAI,EAAE,CACJ,YADI,EAEJ,yBAFI,EAGJ,YAHI,CADM;AAMZC,QANY,gBAMP;AACH,eAAOC,OAAO,CAAC,KAAKC,UAAL,IAAmB,KAAKA,UAAL,CAAgBJ,YAAnC,IAAmD,KAAKK,UAAzD,CAAd;AACD;AARW,KADP;AAWPA,cAAU,EAAE;AACVJ,UAAI,EAAE,CACJ,YADI,EAEJ,uBAFI,CADI;AAKVC,QALU,gBAKL;AACH;AACA,YAAI,KAAKI,MAAL,CAAYC,kBAAhB,EAAoC;AAClC,iBAAO,IAAP;AACD;;AAED,eAAOJ,OAAO,CAAC,KAAKC,UAAL,IAAmB,KAAKA,UAAL,CAAgBC,UAApC,CAAd;AACD;AAZS;AAXL,GAT4B;AAoCrCG,OAAK,EAAE;AACLJ,cAAU,EAAE,+BAAkBP,cAAlB,EAAyB,OAAzB,EAAkCY;AADzC,GApC8B;AAwCrCC,WAAS,EAAE,aAxC0B;AA0CrCC,SAAO,EAAE;AACPC,gBAAY,EAAE;AACZC,aAAO,EAAE,KADG;AAEZC,UAAI,EAAE;AAFM,KADP;;AAKP;AACJ;AACA;AACA;AACA;AACA;AACA;AACIC,SAAK,EAAE;AACLF,aAAO,EAAE,KADJ;AAELC,UAAI,EAAE;AAFD,KAZA;AAgBPE,gBAAY,EAAE;AACZH,aAAO,EAAEI,SADG;AAEZH,UAAI,EAAE;AAFM;AAhBP,GA1C4B;;AAgErC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEI,eAzEqC,2BAyEW;AAAA,QAAlCC,OAAkC,uEAAxB;AAACC,gBAAU,EAAE;AAAb,KAAwB;AAC9C;;AACA,QAAID,OAAO,CAACE,KAARF,IAAiB,CAAC,wBAASA,OAAO,CAACE,KAAjB,CAAtB,EAA+C;AAC7C,YAAM,IAAIC,KAAJ,CAAU,iDAAV,CAAN;AACD;;AAEDH,WAAO,CAACI,SAARJ,GAAoB,KAAKb,MAAL,CAAYiB,SAAhCJ;AACAA,WAAO,CAACK,YAARL,GAAuB,KAAKb,MAAL,CAAYkB,YAAnCL;AACAA,WAAO,CAAC5B,KAAR4B,GAAgB,KAAKb,MAAL,CAAYf,KAA5B4B;AAEAA,WAAO,GAAG,yBAAUA,OAAV,CAAVA;;AAEA,QAAI,CAACA,OAAO,CAACM,aAAb,EAA4B;AAC1BN,aAAO,CAACM,aAARN,GAAwBA,OAAO,CAACC,UAARD,KAAuB,QAAvBA,GAAkC,OAAlCA,GAA4C,MAApEA;AACD;;AACD,iCAAuBA,OAAvB,EAAgC,YAAhC;;AAEA,QAAIA,OAAO,CAACE,KAAZ,EAAmB;AACjB,UAAI,CAAC,uBAAQF,OAAO,CAACE,KAAhB,CAAL,EAA6B;AAC3BF,eAAO,CAACE,KAARF,GAAgBO,eAAOC,WAAPD,CAAmB,wBAAeP,OAAO,CAACE,KAAvB,CAAnBK,CAAhBP;AADF,aAGK;AACH,eAAOA,OAAO,CAACE,KAAf;AACD;AACF;;AAED,qBAAU,KAAKf,MAAL,CAAYsB,YAAtB,cAAsCC,qBAAYC,SAAZD,CAAsBV,OAAtBU,CAAtC;AACA;AApGmC;;AAuGrC;AACF;AACA;AACA;AACA;AACA;AACEE,UA7GqC,sBA6G1B;AACT,SAAKC,MAAL,CAAYC,IAAZ,CACE,0DADF;;AAIA,QAAI;AACF;AACA,WAAKD,MAAL,CAAYC,IAAZ,CAAiB,+CAAjB;AAEA,aAAO,KAAKC,mBAAL,CAAyB,KAAK9B,UAAL,CAAgB+B,YAAzC,CAAP;AAJF,MAMA,OAAOC,CAAP,EAAU;AACR;AACA,WAAKJ,MAAL,CAAYC,IAAZ,CAAiB,+CAAjB;AACA,WAAKD,MAAL,CAAYC,IAAZ,CACE,0DADF;AAIA,aAAO,KAAKI,yBAAL,CAA+B,KAAKjC,UAAL,CAAgB+B,YAA/C,CAAP;AACD;AAhIkC;;AAmIrC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACED,qBA3IqC,iCA2IL;AAAA,QAAZtC,KAAY,uEAAJ,EAAI,EAC9B;;AACA,QAAM0C,UAAU,GAAGC,sBAAIC,MAAJD,CAAW3C,KAAX2C,CAAnB,CAF8B,CAI9B;;;AACA,QAAI,CAACD,UAAL,EAAiB;AACf,YAAM,IAAIhB,KAAJ,CAAU,mDAAV,CAAN;AACD;;AAED,QAAI,CAACgB,UAAU,CAACG,KAAhB,EAAuB;AACrB,YAAM,IAAInB,KAAJ,CAAU,4CAAV,CAAN;AAV4B,MAa9B;;;AACA,WAAOgB,UAAU,CAACG,KAAlB;AAzJmC;;AA4JrC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACEJ,2BApKqC,uCAoKC;AAAA,QAAZzC,KAAY,uEAAJ,EAAI,EACpC;;AACA,QAAM8C,MAAM,GAAG9C,KAAK,CAAC+C,KAAN/C,CAAY,GAAZA,CAAf,CAFoC,CAIpC;;AACA,QAAI8C,MAAM,CAACE,MAAPF,KAAkB,CAAtB,EAAyB;AACvB,YAAM,IAAIpB,KAAJ,CAAU,0CAAV,CAAN;AANkC,MASpC;;;AACA,WAAOoB,MAAM,CAAC,CAAD,CAAb;AA9KmC;;AAiLrC;AACF;AACA;AACA;AACA;AACA;AACA;AACEG,gBAxLqC,4BAwLR;AAAA,QAAd1B,OAAc,uEAAJ,EAAI;AAC3B,qBAAU,KAAKb,MAAL,CAAYwC,SAAtB,cAAmCjB,qBAAYC,SAAZD,CAAsB,qBAAc;AACrEkB,gBAAU,EAAE,KAAKzC,MAAL,CAAY0C,OAD6C;AAErEC,UAAI,EAAE,KAAK3C,MAAL,CAAYkB;AAFmD,KAAd,EAGtDL,OAHsD,CAAtBU,CAAnC;AAzLmC;;AA+LrC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACEqB,oBAvMqC,8BAuMlBC,UAvMkB,EAuMN;AAC7B,WAAOC,IAAI,CAACC,KAALD,CAAW,CAACA,IAAI,CAACC,KAALD,CAAWA,IAAI,CAACE,MAALF,KAAgB,CAA3BA,IAAgC,CAAjC,IAAsC,EAAtC,GAA2CD,UAAtDC,CAAP;AAxMmC;AA2MrCG,aA3MqC,yBA2MhB;AAAA,sBACnB;AACA;;;AACA,SAAKC,UAAL,GAAkB,yBAAU,KAAKA,UAAf,CAAlB;AACA,uBAAY,KAAKA,UAAjB,EAA6BC,OAA7B,CAAqC,UAACC,GAAD,EAAS;AAC5C,UAAIC,KAAI,CAACH,UAAL,CAAgBE,GAAhB,EAAqBE,GAAzB,EAA8B;AAC5BD,aAAI,CAACH,UAAL,CAAgBE,GAAhB,EAAqBE,GAArB,GAA2BD,KAAI,CAACH,UAAL,CAAgBE,GAAhB,EAAqBE,GAArB,CAAyBC,IAAzB,CAA8BF,KAA9B,CAA3B;AACD;AAHH,OAJmB,CASnB;;AATmB,sCAANG,IAAM;AAANA,UAAM,MAANA,GAAMC,eAAND;AAAM;;AAUnB,wBAAc1E,oBAAd,EAA2B,IAA3B,EAAiC0E,IAAjC;AArNmC;;AAwNrC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACEE,WAhOqC,qBAgO3BzE,KAhO2B,EAgOpB;AAAA;;AACf,WAAO,KAAKa,UAAL,CAAgB4D,SAAhB,CAA0BzE,KAA1B,EACJ0E,KADI,CACE,UAACC,MAAD,EAAY;AACjBC,YAAI,CAACnC,MAAL,CAAYoC,KAAZ,0DAAoE7E,KAApE,GAA6E2E,MAA7E;;AACAC,YAAI,CAACnC,MAAL,CAAYoC,KAAZ,uDAAiE7E,KAAjE;;AAEA,aAAO8E,iBAAQC,OAAR,CAAgB,IAAIzE,cAAJ,CAAU,qBAAc;AAACN,aAAK,EAALA;AAAD,OAAd,EAAuB4E,MAAI,CAAC/D,UAAL,CAAgBmE,SAAhB,EAAvB,CAAV,CAAhB,EAAgF;AAACC,cAAM,EAAEL;AAAT,OAAhF,CAAP;AALG,MAAP;AAjOmC;;AA0OrC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEM,gBAnPqC,4BAmPR;AAAA;;AAAA,QAAdtD,OAAc,uEAAJ,EAAI;AAC3B,SAAKa,MAAL,CAAYC,IAAZ,CAAiB,kDAAjB;AAEA,WAAO,KAAKyC,KAAL,CAAWC,OAAX,CAAmB;AACxB;AACAC,YAAM,EAAE,MAFgB;AAGxBC,SAAG,EAAE1D,OAAO,CAAC0D,GAAR1D,IAAe,KAAKb,MAAL,CAAYwE,QAHR;AAIxBC,UAAI,EAAE;AACJC,kBAAU,EAAE,oBADR;AAEJzF,aAAK,EAAE4B,OAAO,CAAC5B,KAAR4B,IAAiB,mBAFpB;AAGJ8D,4BAAoB,EAAE;AAHlB,OAJkB;AASxBC,UAAI,EAAE;AACJC,YAAI,EAAE,KAAK7E,MAAL,CAAYiB,SADd;AAEJ6D,YAAI,EAAE,KAAK9E,MAAL,CAAY+E,aAFd;AAGJC,uBAAe,EAAE;AAHb,OATkB;AAcxBC,8BAAwB,EAAE;AAC1B;;AAfwB,KAAnB,EAiBJC,IAjBI,CAiBC,UAACC,GAAD;AAAA,aAAS,IAAI5F,cAAJ,CAAU4F,GAAG,CAACC,IAAd,EAAoB;AAAClB,cAAM,EAAEmB;AAAT,OAApB,CAAT;AAjBD,OAkBJ1B,KAlBI,CAkBE,UAACwB,GAAD,EAAS;AACd,UAAIA,GAAG,CAACG,UAAJH,KAAmB,GAAvB,EAA4B;AAC1B,eAAOpB,iBAAQwB,MAAR,CAAeJ,GAAf,CAAP;AACD;;AAED,UAAMK,gBAAgB,GAAGC,qBAAYC,MAAZD,CAAmBN,GAAG,CAACC,IAAJD,CAASQ,KAA5BF,CAAzB;;AAEA,aAAO1B,iBAAQwB,MAAR,CAAe,IAAIC,gBAAJ,CAAqBL,GAAG,CAACS,IAAJT,IAAYA,GAAjC,CAAf,CAAP;AAzBG,MAAP;AAtPmC;;AAqRrC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEU,cA9RqC,wBA8RxB5G,KA9RwB,EA8RjB;AAAA;;AAClB,WAAO8E,iBAAQC,OAAR,CAAgB,CAAC,KAAK1D,YAAN,IAAsB,qBAAY,UAAC0D,OAAD,EAAa;AACpE8B,YAAI,CAACpE,MAAL,CAAYC,IAAZ,CAAiB,oFAAjB;;AACAmE,YAAI,CAACC,IAAL,CAAU,qBAAV,EAAiC,YAAM;AACrCD,cAAI,CAACpE,MAAL,CAAYC,IAAZ,CAAiB,8DAAjB;;AACAqC,eAAO;AAFT;AAF2C,MAAtC,EAOJkB,IAPI,CAOC,YAAM;AACV,UAAI,CAACY,MAAI,CAACpG,YAAV,EAAwB;AACtBoG,cAAI,CAACpE,MAAL,CAAYC,IAAZ,CAAiB,gEAAjB;;AAEA,eAAOoC,iBAAQwB,MAAR,CAAe,IAAIvE,KAAJ,CAAU,8CAAV,CAAf,CAAP;AACD;;AAED,UAAI,CAAC/B,KAAL,EAAY;AACVA,aAAK,GAAG,wBAAY,WAAZ,EAAyB6G,MAAI,CAAC9F,MAAL,CAAYf,KAArC,CAARA;AACD;;AAEDA,WAAK,GAAG,sBAAUA,KAAV,CAARA;;AAEA,UAAIA,KAAK,KAAK,sBAAU6G,MAAI,CAAC9F,MAAL,CAAYf,KAAtB,CAAd,EAA4C;AAC1C,eAAO8E,iBAAQC,OAAR,CAAgB8B,MAAI,CAAChG,UAArB,CAAP;AACD;;AAED,UAAMR,KAAK,GAAGwG,MAAI,CAAC3G,UAAL,CAAgB6G,GAAhB,CAAoB/G,KAApB,CAAd,CAjBU,CAmBV;AACA;;;AACA,UAAI,CAACK,KAAD,IAAU,CAACA,KAAK,CAACuC,YAArB,EAAmC;AACjC,eAAOiE,MAAI,CAACpC,SAAL,CAAezE,KAAf,EACJiG,IADI,CACC,iBAAI,UAACe,CAAD;AAAA,iBAAOH,MAAI,CAAC3G,UAAL,CAAgB+G,GAAhB,CAAoBD,CAApB,CAAP;AAAJ,UADD,CAAP;AAED;;AAED,aAAOlC,iBAAQC,OAAR,CAAgB1E,KAAhB,CAAP;AAjCG,MAAP;AA/RmC;;AAqUrC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE6G,YA9UqC,sBA8U1BC,KA9U0B,EA8UnBvF,OA9UmB,EA8UV;AAAA;;AACzB,QAAIuF,KAAJ,EAAW;AACT,UAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B,aAAKtG,UAAL,GAAkBsG,KAAlB;AACD;;AAED,UAAIA,KAAK,CAACvE,YAAV,EAAwB;AACtB,aAAK/B,UAAL,GAAkBsG,KAAlB;AACD;;AAED,UAAIA,KAAK,CAACC,aAAV,EAAyB;AACvB,YAAID,KAAK,CAACC,aAAND,CAAoBtG,UAAxB,EAAoC;AAClC,eAAKA,UAAL,GAAkBsG,KAAK,CAACC,aAAND,CAAoBtG,UAAtC;AADF,eAGK;AACH,eAAKA,UAAL,GAAkBsG,KAAK,CAACC,aAAxB;AACD;AAfM,QAkBT;;;AACA,UAAI,KAAKvG,UAAL,IAAmB,KAAKA,UAAL,CAAgBwG,OAAvC,EAAgD;AAC9C,aAAKC,eAAL,CAAqB,KAAKzG,UAAL,CAAgBwG,OAArC;AACD;AACF;;AAED,wBAAcxH,qBAAY0H,SAAZ1H,CAAsBqH,UAApC,EAAgD,IAAhD,EAAsD,CAACC,KAAD,EAAQvF,OAAR,CAAtD;AAEA,SAAK4F,YAAL,CAAkB,KAAKvC,MAAvB,EAA+B,eAA/B,EAAgD,YAAM;AACpD,UAAIwC,MAAI,CAAC1G,MAAL,CAAY2G,mBAAhB,EAAqC;AACnC,YAAMC,MAAM,GAAGC,aAAIC,KAAJD,CAAUH,MAAI,CAAC1G,MAAL,CAAY2G,mBAAtBE,EAA2C,IAA3CA,CAAf;AAEA;;;AACAH,cAAI,CAAC1G,MAAL,CAAYiB,SAAZ,GAAwB2F,MAAM,CAACG,KAAPH,CAAa3F,SAArC;AACAyF,cAAI,CAAC1G,MAAL,CAAYkB,YAAZ,GAA2B0F,MAAM,CAACG,KAAPH,CAAa1F,YAAxC;AACAwF,cAAI,CAAC1G,MAAL,CAAYf,KAAZ,GAAoB2H,MAAM,CAACG,KAAPH,CAAa3H,KAAjC;AACAyH,cAAI,CAAC1G,MAAL,CAAYsB,YAAZ,GAA2BsF,MAAM,CAACI,IAAPJ,CAAYK,MAAZL,CAAmB,CAAnBA,EAAsBA,MAAM,CAACI,IAAPJ,CAAYM,OAAZN,CAAoB,GAApBA,CAAtBA,CAA3B;AACA;AACD;AAVH;AAaA,SAAKxC,KAAL,CAAW2B,IAAX,CAAgB,QAAhB,EAA0B,YAAM;AAC9BW,YAAI,CAACjG,KAAL,GAAa,IAAb;AADF;AAtXmC;;AA6XrC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE0G,YAtYqC,wBAsYxB;AACX,SAAKzF,MAAL,CAAYC,IAAZ,CAAiB,kCAAjB,EADW,CAGX;;AACA,QAAI,KAAKjB,YAAT,EAAuB;AACrB0G,kBAAY,CAAC,KAAK1G,YAAN,CAAZ0G;AACA,WAAKC,KAAL,CAAW,cAAX;AACD;;AAED,QAAI;AACF,WAAKA,KAAL,CAAW,YAAX;AADF,MAGA,OAAOC,GAAP,EAAY;AACV,WAAK5F,MAAL,CAAY6F,IAAZ,CAAiB,yCAAjB,EAA4DD,GAA5D;AACD;;AAED,WAAO,KAAKnI,UAAL,CAAgBqI,MAAhB,CAAuBlF,MAA9B,EAAsC;AACpC,UAAI;AACF,aAAKnD,UAAL,CAAgBsI,MAAhB,CAAuB,KAAKtI,UAAL,CAAgBqI,MAAhB,CAAuB,CAAvB,CAAvB;AADF,QAGA,OAAOF,GAAP,EAAY;AACV,aAAK5F,MAAL,CAAY6F,IAAZ,CAAiB,0CAAjB,EAA6DD,GAA7D;AACD;AACF;;AAED,SAAK5F,MAAL,CAAYC,IAAZ,CAAiB,uCAAjB,EAzBW,CA2BX;AACA;;AACA,WAAOoC,iBAAQC,OAAR,EAAP;AAnamC;;AAyarC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE0D,SAlbqC,qBAkb3B;AAAA;;AACR,SAAKhG,MAAL,CAAYC,IAAZ,CAAiB,gCAAjB;AAEA,QAAO7B,UAAP,GAAqB,KAAdA,UAAP;AACA,QAAM6H,MAAM,GAAG,qBAAM,KAAKxI,UAAL,CAAgBqI,MAAtB,CAAf,CAJQ,CAMR;AACA;AACA;AACA;AACA;AACA;;AACA,QAAI,KAAKxH,MAAL,CAAYC,kBAAhB,EAAoC;AAClC,aAAO,KAAKD,MAAL,CAAYC,kBAAZ,CAA+B,KAAKmE,KAApC,EACJc,IADI,CACC,UAACjD,GAAD;AAAA,eAAS2F,MAAI,CAACxD,KAAL,CAAWiC,aAAX,CAAyBwB,yBAAzB,CAAmD;AAAC5F,aAAG,EAAHA;AAAD,SAAnD,CAAT;AADD,QAAP;AAED;;AAED,QAAI,KAAKmC,KAAL,CAAW0D,QAAX,CAAoBC,QAAxB,EAAkC;AAChC,WAAK3D,KAAL,CAAW0D,QAAX,CAAoBC,QAApB,CAA6BC,uBAA7B;AACD;;AAED,WAAOlI,UAAU,CAAC4H,OAAX5H,GACJoF,IADIpF,CACC,UAACmI,EAAD,EAAQ;AACZ;AACA,UAAIL,MAAI,CAAClH,YAAT,EAAuB;AACrB0G,oBAAY,CAACQ,MAAI,CAAClH,YAAN,CAAZ0G;;AACAQ,cAAI,CAACP,KAAL,CAAW,cAAX;AACD;;AACDO,YAAI,CAAC9H,UAAL,GAAkBmI,EAAlB;AAEA,aAAOlE,iBAAQmE,GAAR,CAAYP,MAAM,CAACQ,GAAPR,CAAW,UAACrI,KAAD;AAAA,eAAWsI,MAAI,CAAClE,SAAL,CAAepE,KAAK,CAACL,KAArB,EACvC;AADuC,SAEtCiG,IAFsC,CAEjC,UAACe,CAAD,EAAO;AACX2B,gBAAI,CAAClG,MAAL,CAAYC,IAAZ,2CAAoDrC,KAAK,CAACL,KAA1D;;AAEA,iBAAOK,KAAK,CAAC8I,MAAN9I,GACJqE,KADIrE,CACE,UAACgI,GAAD,EAAS;AACdM,kBAAI,CAAClG,MAAL,CAAY6F,IAAZ,CAAiB,0CAAjB,EAA6DD,GAA7D;AAFG,aAIJpC,IAJI5F,CAIC,YAAM;AACVsI,kBAAI,CAACzI,UAAL,CAAgBsI,MAAhB,CAAuBnI,KAAK,CAACL,KAA7B;;AACA2I,kBAAI,CAACzI,UAAL,CAAgB+G,GAAhB,CAAoBD,CAApB;AANG,YAAP;AALqC,UAAX;AAAX,QAAZ,CAAP;AATG,OAwBJf,IAxBIpF,CAwBC,YAAM;AACV8H,YAAI,CAACrB,eAAL,CAAqBqB,MAAI,CAAC9H,UAAL,CAAgBwG,OAArC;AAzBG,OA2BJ3C,KA3BI7D,CA2BE,UAAC6F,KAAD,EAAW;AAChB,UAAO0C,mBAAP,GAA8B5C,qBAAvB4C,mBAAP;;AAEA,UAAI1C,KAAK,YAAY0C,mBAArB,EAA0C;AACxC;AACAT,cAAI,CAACP,KAAL,CAAW,YAAX;;AACA,eAAOO,MAAI,CAACzI,UAAL,CAAgBqI,MAAhB,CAAuBlF,MAA9B,EAAsC;AACpC,cAAI;AACFsF,kBAAI,CAACzI,UAAL,CAAgBsI,MAAhB,CAAuBG,MAAI,CAACzI,UAAL,CAAgBqI,MAAhB,CAAuB,CAAvB,CAAvB;AADF,YAGA,OAAOF,GAAP,EAAY;AACVM,kBAAI,CAAClG,MAAL,CAAY6F,IAAZ,CAAiB,0CAAjB,EAA6DD,GAA7D;AACD;AACF;;AACDM,cAAI,CAACxD,KAAL,CAAWkE,OAAX,CAAmB,4BAAnB;AACD;;AAED,aAAOvE,iBAAQwB,MAAR,CAAeI,KAAf,CAAP;AA5CG,MAAP;AAvcmC;;AAufrC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACEY,iBA/fqC,2BA+frBD,OA/fqB,EA+fZ;AAAA;;AACvB,QAAMiC,SAAS,GAAGjC,OAAO,GAAG,mBAA5B;;AAEA,QAAIiC,SAAS,GAAG,CAAhB,EAAmB;AACjB,UAAMC,aAAa,GAAG,KAAK5F,kBAAL,CAAwB2F,SAAxB,CAAtB;AAEA,WAAK7H,YAAL,GAAoB,kCAAe;AAAA,eAAM+H,MAAI,CAACf,OAAL,EAAN;AAAf,SAAqCc,aAArC,CAApB;AAHF,WAKK;AACH,WAAKd,OAAL;AACD;AAzgBkC;AAAAgB;AAAA,CAAnB,0VA2XjBC,iBA3XiB,uIAsajBA,iBAtaiB,yFAApB;;eA8gBe9J","names":["Credentials","WebexPlugin","extend","keyFactory","scope","collections","userTokens","TokenCollection","dataTypes","token","Token","dataType","derived","canAuthorize","deps","fn","Boolean","supertoken","canRefresh","config","jwtRefreshCallback","props","prop","namespace","session","isRefreshing","default","type","ready","refreshTimer","undefined","buildLoginUrl","options","clientType","state","Error","client_id","redirect_uri","response_type","base64","toBase64Url","authorizeUrl","querystring","stringify","getOrgId","logger","info","extractOrgIdFromJWT","access_token","e","extractOrgIdFromUserToken","decodedJWT","jwt","decode","realm","fields","split","length","buildLogoutUrl","logoutUrl","cisService","service","goto","calcRefreshTimeout","expiration","Math","floor","random","constructor","_dataTypes","forEach","key","_this","set","bind","args","arguments","downscope","catch","reason","_this2","trace","_promise","resolve","serialize","parent","getClientToken","webex","request","method","uri","tokenUrl","form","grant_type","self_contained_token","auth","user","pass","client_secret","sendImmediately","shouldRefreshAccessToken","then","res","body","_this3","statusCode","reject","ErrorConstructor","grantErrors","select","error","_res","getUserToken","_this4","once","get","t","add","initialize","attrs","authorization","expires","scheduleRefresh","prototype","listenToOnce","_this5","authorizationString","parsed","url","parse","query","href","substr","indexOf","invalidate","clearTimeout","unset","err","warn","models","remove","refresh","tokens","_this6","requestAccessTokenFromJwt","internal","services","updateCredentialsConfig","st","all","map","revoke","InvalidRequestError","trigger","expiresIn","timeoutLength","_this7","version","oneFlight"],"sources":["credentials.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport querystring from 'querystring';\nimport url from 'url';\n\nimport jwt from 'jsonwebtoken';\nimport {\n  base64,\n  makeStateDataType,\n  oneFlight,\n  tap,\n  whileInFlight\n} from '@webex/common';\nimport {safeSetTimeout} from '@webex/common-timers';\nimport {clone, cloneDeep, isObject, isEmpty} from 'lodash';\n\nimport WebexPlugin from '../webex-plugin';\nimport {persist, waitForValue} from '../storage/decorators';\n\nimport grantErrors from './grant-errors';\nimport {filterScope, sortScope} from './scope';\nimport Token from './token';\nimport TokenCollection from './token-collection';\n\n/**\n * @class\n */\nconst Credentials = WebexPlugin.extend({\n  collections: {\n    userTokens: TokenCollection\n  },\n\n  dataTypes: {\n    token: makeStateDataType(Token, 'token').dataType\n  },\n\n  derived: {\n    canAuthorize: {\n      deps: [\n        'supertoken',\n        'supertoken.canAuthorize',\n        'canRefresh'\n      ],\n      fn() {\n        return Boolean(this.supertoken && this.supertoken.canAuthorize || this.canRefresh);\n      }\n    },\n    canRefresh: {\n      deps: [\n        'supertoken',\n        'supertoken.canRefresh'\n      ],\n      fn() {\n        // If we're operating in JWT mode, we have to delegate to the consumer\n        if (this.config.jwtRefreshCallback) {\n          return true;\n        }\n\n        return Boolean(this.supertoken && this.supertoken.canRefresh);\n      }\n    }\n  },\n\n  props: {\n    supertoken: makeStateDataType(Token, 'token').prop\n  },\n\n  namespace: 'Credentials',\n\n  session: {\n    isRefreshing: {\n      default: false,\n      type: 'boolean'\n    },\n    /**\n     * Becomes `true` once the {@link loaded} event fires.\n     * @see {@link WebexPlugin#ready}\n     * @instance\n     * @memberof Credentials\n     * @type {boolean}\n     */\n    ready: {\n      default: false,\n      type: 'boolean'\n    },\n    refreshTimer: {\n      default: undefined,\n      type: 'any'\n    }\n  },\n\n  /**\n   * Generates an OAuth Login URL. Prefers the api.ciscospark.com proxy if the\n   * instance is initialize with an authorizatUrl, but fallsback to idbroker\n   * as the base otherwise.\n   * @instance\n   * @memberof Credentials\n   * @param {Object} [options={}]\n   * @returns {string}\n   */\n  buildLoginUrl(options = {clientType: 'public'}) {\n    /* eslint-disable camelcase */\n    if (options.state && !isObject(options.state)) {\n      throw new Error('if specified, `options.state` must be an object');\n    }\n\n    options.client_id = this.config.client_id;\n    options.redirect_uri = this.config.redirect_uri;\n    options.scope = this.config.scope;\n\n    options = cloneDeep(options);\n\n    if (!options.response_type) {\n      options.response_type = options.clientType === 'public' ? 'token' : 'code';\n    }\n    Reflect.deleteProperty(options, 'clientType');\n\n    if (options.state) {\n      if (!isEmpty(options.state)) {\n        options.state = base64.toBase64Url(JSON.stringify(options.state));\n      }\n      else {\n        delete options.state;\n      }\n    }\n\n    return `${this.config.authorizeUrl}?${querystring.stringify(options)}`;\n    /* eslint-enable camelcase */\n  },\n\n  /**\n   * Get the determined OrgId.\n   *\n   * @throws {Error} - If the OrgId could not be determined.\n   * @returns {string} - The OrgId.\n   */\n  getOrgId() {\n    this.logger.info(\n      'credentials: attempting to retrieve the OrgId from token'\n    );\n\n    try {\n      // Attempt to extract a client-authenticated token's OrgId.\n      this.logger.info('credentials: trying to extract OrgId from JWT');\n\n      return this.extractOrgIdFromJWT(this.supertoken.access_token);\n    }\n    catch (e) {\n      // Attempt to extract a user token's OrgId.\n      this.logger.info('credentials: could not extract OrgId from JWT');\n      this.logger.info(\n        'credentials: attempting to extract OrgId from user token'\n      );\n\n      return this.extractOrgIdFromUserToken(this.supertoken.access_token);\n    }\n  },\n\n  /**\n   * Extract the OrgId [realm] from a provided JWT.\n   *\n   * @private\n   * @param {string} token - The JWT to extract the OrgId from.\n   * @throws {Error} - If the token does not pass JWT general/realm validation.\n   * @returns {string} - The OrgId.\n   */\n  extractOrgIdFromJWT(token = '') {\n    // Decoded the provided token.\n    const decodedJWT = jwt.decode(token);\n\n    // Validate that the provided token is a JWT.\n    if (!decodedJWT) {\n      throw new Error('unable to extract the OrgId from the provided JWT');\n    }\n\n    if (!decodedJWT.realm) {\n      throw new Error('the provided JWT does not contain an OrgId');\n    }\n\n    // Return the OrgId [realm].\n    return decodedJWT.realm;\n  },\n\n  /**\n   * Extract the OrgId [realm] from a provided user token.\n   *\n   * @private\n   * @param {string} token - The user token to extract the OrgId from.\n   * @throws {Error} - Will throw an error if the provided token is invalid.\n   * @returns {string} - The OrgId.\n   */\n  extractOrgIdFromUserToken(token = '') {\n    // Split the provided token into subsections.\n    const fields = token.split('_');\n\n    // Validate that the provided token has the proper amount of sections.\n    if (fields.length !== 3) {\n      throw new Error('the provided token is not a valid format');\n    }\n\n    // Return the token section that contains the OrgId.\n    return fields[2];\n  },\n\n  /**\n   * Generates a Logout URL\n   * @instance\n   * @memberof Credentials\n   * @param {Object} [options={}]\n   * @returns {[type]}\n   */\n  buildLogoutUrl(options = {}) {\n    return `${this.config.logoutUrl}?${querystring.stringify(Object.assign({\n      cisService: this.config.service,\n      goto: this.config.redirect_uri\n    }, options))}`;\n  },\n\n  /**\n   * Generates a number between 60% - 90% of expired value\n   * @instance\n   * @memberof Credentials\n   * @param {number} expiration\n   * @private\n   * @returns {number}\n   */\n  calcRefreshTimeout(expiration) {\n    return Math.floor((Math.floor(Math.random() * 4) + 6) / 10 * expiration);\n  },\n\n  constructor(...args) {\n    // HACK to deal with the fact that AmpersandState#dataTypes#set is a pure\n    // function.\n    this._dataTypes = cloneDeep(this._dataTypes);\n    Object.keys(this._dataTypes).forEach((key) => {\n      if (this._dataTypes[key].set) {\n        this._dataTypes[key].set = this._dataTypes[key].set.bind(this);\n      }\n    });\n    // END HACK\n    Reflect.apply(WebexPlugin, this, args);\n  },\n\n  /**\n   * Downscopes a token\n   * @instance\n   * @memberof Credentials\n   * @param {string} scope\n   * @private\n   * @returns {Promise<Token>}\n   */\n  downscope(scope) {\n    return this.supertoken.downscope(scope)\n      .catch((reason) => {\n        this.logger.trace(`credentials: failed to downscope supertoken to ${scope}`, reason);\n        this.logger.trace(`credentials: falling back to supertoken for ${scope}`);\n\n        return Promise.resolve(new Token(Object.assign({scope}, this.supertoken.serialize())), {parent: this});\n      });\n  },\n\n  /**\n   * Requests a client credentials grant and returns the token. Given the\n   * limited use for such tokens as this time, this method does not cache its\n   * token.\n   * @instance\n   * @memberof Credentials\n   * @param {Object} options\n   * @returns {Promise<Token>}\n   */\n  getClientToken(options = {}) {\n    this.logger.info('credentials: requesting client credentials grant');\n\n    return this.webex.request({\n      /* eslint-disable camelcase */\n      method: 'POST',\n      uri: options.uri || this.config.tokenUrl,\n      form: {\n        grant_type: 'client_credentials',\n        scope: options.scope || 'webexsquare:admin',\n        self_contained_token: true\n      },\n      auth: {\n        user: this.config.client_id,\n        pass: this.config.client_secret,\n        sendImmediately: true\n      },\n      shouldRefreshAccessToken: false\n      /* eslint-enable camelcase */\n    })\n      .then((res) => new Token(res.body, {parent: this}))\n      .catch((res) => {\n        if (res.statusCode !== 400) {\n          return Promise.reject(res);\n        }\n\n        const ErrorConstructor = grantErrors.select(res.body.error);\n\n        return Promise.reject(new ErrorConstructor(res._res || res));\n      });\n  },\n\n  @oneFlight({keyFactory: (scope) => scope})\n  @waitForValue('@')\n  /**\n   * Resolves with a token with the specified scopes. If no scope is specified,\n   * defaults to omit(webex.credentials.scope, 'spark:kms'). If no such token is\n   * available, downscopes the supertoken to that scope.\n   * @instance\n   * @memberof Credentials\n   * @param {string} scope\n   * @returns {Promise<Token>}\n   */\n  getUserToken(scope) {\n    return Promise.resolve(!this.isRefreshing || new Promise((resolve) => {\n      this.logger.info('credentials: token refresh inflight; delaying getUserToken until refresh completes');\n      this.once('change:isRefreshing', () => {\n        this.logger.info('credentials: token refresh complete; reinvoking getUserToken');\n        resolve();\n      });\n    }))\n      .then(() => {\n        if (!this.canAuthorize) {\n          this.logger.info('credentials: cannot produce an access token from current state');\n\n          return Promise.reject(new Error('Current state cannot produce an access token'));\n        }\n\n        if (!scope) {\n          scope = filterScope('spark:kms', this.config.scope);\n        }\n\n        scope = sortScope(scope);\n\n        if (scope === sortScope(this.config.scope)) {\n          return Promise.resolve(this.supertoken);\n        }\n\n        const token = this.userTokens.get(scope);\n\n        // we should also check for the token.access_token since token object does\n        // not get cleared on unsetting while logging out.\n        if (!token || !token.access_token) {\n          return this.downscope(scope)\n            .then(tap((t) => this.userTokens.add(t)));\n        }\n\n        return Promise.resolve(token);\n      });\n  },\n\n  @persist('@')\n  /**\n   * Initializer\n   * @instance\n   * @memberof Credentials\n   * @param {Object} attrs\n   * @param {Object} options\n   * @private\n   * @returns {Credentials}\n   */\n  initialize(attrs, options) {\n    if (attrs) {\n      if (typeof attrs === 'string') {\n        this.supertoken = attrs;\n      }\n\n      if (attrs.access_token) {\n        this.supertoken = attrs;\n      }\n\n      if (attrs.authorization) {\n        if (attrs.authorization.supertoken) {\n          this.supertoken = attrs.authorization.supertoken;\n        }\n        else {\n          this.supertoken = attrs.authorization;\n        }\n      }\n\n      // schedule refresh\n      if (this.supertoken && this.supertoken.expires) {\n        this.scheduleRefresh(this.supertoken.expires);\n      }\n    }\n\n    Reflect.apply(WebexPlugin.prototype.initialize, this, [attrs, options]);\n\n    this.listenToOnce(this.parent, 'change:config', () => {\n      if (this.config.authorizationString) {\n        const parsed = url.parse(this.config.authorizationString, true);\n\n        /* eslint-disable camelcase */\n        this.config.client_id = parsed.query.client_id;\n        this.config.redirect_uri = parsed.query.redirect_uri;\n        this.config.scope = parsed.query.scope;\n        this.config.authorizeUrl = parsed.href.substr(0, parsed.href.indexOf('?'));\n        /* eslint-enable camelcase */\n      }\n    });\n\n    this.webex.once('loaded', () => {\n      this.ready = true;\n    });\n  },\n\n  @oneFlight\n  @waitForValue('@')\n  /**\n   * Clears all tokens from store them from the stores.\n   *\n   * This is no longer quite the right name for this method, but all of the\n   * alternatives I'm coming up with are already taken.\n   * @instance\n   * @memberof Credentials\n   * @returns {Promise}\n   */\n  invalidate() {\n    this.logger.info('credentials: invalidating tokens');\n\n    // clear refresh timer\n    if (this.refreshTimer) {\n      clearTimeout(this.refreshTimer);\n      this.unset('refreshTimer');\n    }\n\n    try {\n      this.unset('supertoken');\n    }\n    catch (err) {\n      this.logger.warn('credentials: failed to clear supertoken', err);\n    }\n\n    while (this.userTokens.models.length) {\n      try {\n        this.userTokens.remove(this.userTokens.models[0]);\n      }\n      catch (err) {\n        this.logger.warn('credentials: failed to remove user token', err);\n      }\n    }\n\n    this.logger.info('credentials: finished removing tokens');\n\n    // Return a promise to give the storage layer a tick or two to clear\n    // localStorage\n    return Promise.resolve();\n  },\n\n  @oneFlight\n  @whileInFlight('isRefreshing')\n  @waitForValue('@')\n  /**\n   * Removes the supertoken and child tokens, then refreshes the supertoken;\n   * subsequent calls to {@link Credentials#getUserToken()} will re-downscope\n   * child tokens. Enqueus revocation of previous previousTokens. Yes, that's\n   * the correct number of \"previous\"es.\n   * @instance\n   * @memberof Credentials\n   * @returns {Promise}\n   */\n  refresh() {\n    this.logger.info('credentials: refresh requested');\n\n    const {supertoken} = this;\n    const tokens = clone(this.userTokens.models);\n\n    // This is kind of a leaky abstraction, since it relies on the authorization\n    // plugin, but the only alternatives I see are\n    // 1. put all JWT support in core\n    // 2. have separate jwt and non-jwt auth plugins\n    // while I like #2 from a code simplicity standpoint, the third-party DX\n    // isn't great\n    if (this.config.jwtRefreshCallback) {\n      return this.config.jwtRefreshCallback(this.webex)\n        .then((jwt) => this.webex.authorization.requestAccessTokenFromJwt({jwt}));\n    }\n\n    if (this.webex.internal.services) {\n      this.webex.internal.services.updateCredentialsConfig();\n    }\n\n    return supertoken.refresh()\n      .then((st) => {\n        // clear refresh timer\n        if (this.refreshTimer) {\n          clearTimeout(this.refreshTimer);\n          this.unset('refreshTimer');\n        }\n        this.supertoken = st;\n\n        return Promise.all(tokens.map((token) => this.downscope(token.scope)\n          // eslint-disable-next-line max-nested-callbacks\n          .then((t) => {\n            this.logger.info(`credentials: revoking token for ${token.scope}`);\n\n            return token.revoke()\n              .catch((err) => {\n                this.logger.warn('credentials: failed to revoke user token', err);\n              })\n              .then(() => {\n                this.userTokens.remove(token.scope);\n                this.userTokens.add(t);\n              });\n          })));\n      })\n      .then(() => {\n        this.scheduleRefresh(this.supertoken.expires);\n      })\n      .catch((error) => {\n        const {InvalidRequestError} = grantErrors;\n\n        if (error instanceof InvalidRequestError) {\n          // Error: The refresh token provided is expired, revoked, malformed, or invalid. Hence emit an event to the client, an opportunity to logout.\n          this.unset('supertoken');\n          while (this.userTokens.models.length) {\n            try {\n              this.userTokens.remove(this.userTokens.models[0]);\n            }\n            catch (err) {\n              this.logger.warn('credentials: failed to remove user token', err);\n            }\n          }\n          this.webex.trigger('client:InvalidRequestError');\n        }\n\n        return Promise.reject(error);\n      });\n  },\n\n  /**\n   * Schedules a token refresh or refreshes the token if token has expired\n   * @instance\n   * @memberof Credentials\n   * @param {number} expires\n   * @private\n   * @returns {undefined}\n   */\n  scheduleRefresh(expires) {\n    const expiresIn = expires - Date.now();\n\n    if (expiresIn > 0) {\n      const timeoutLength = this.calcRefreshTimeout(expiresIn);\n\n      this.refreshTimer = safeSetTimeout(() => this.refresh(), timeoutLength);\n    }\n    else {\n      this.refresh();\n    }\n  }\n\n});\n\nexport default Credentials;\n"]},"metadata":{},"sourceType":"script"}