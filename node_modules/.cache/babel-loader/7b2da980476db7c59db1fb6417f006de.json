{"ast":null,"code":"\"use strict\";\n\nvar _Object$keys2 = require(\"@babel/runtime-corejs2/core-js/object/keys\");\n\nvar _Object$getOwnPropertySymbols = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\");\n\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\");\n\nvar _Object$getOwnPropertyDescriptors = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\");\n\nvar _Object$defineProperties = require(\"@babel/runtime-corejs2/core-js/object/define-properties\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/toConsumableArray\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/slicedToArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/defineProperty\"));\n\nvar _weakMap = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/weak-map\"));\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/keys\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _url = _interopRequireDefault(require(\"url\"));\n\nvar _sha = _interopRequireDefault(require(\"crypto-js/sha256\"));\n\nvar _webexPlugin = _interopRequireDefault(require(\"../webex-plugin\"));\n\nvar _serviceCatalog = _interopRequireDefault(require(\"./service-catalog\"));\n\nvar _serviceRegistry = _interopRequireDefault(require(\"./service-registry\"));\n\nvar _serviceState = _interopRequireDefault(require(\"./service-state\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = _Object$keys2(object);\n\n  if (_Object$getOwnPropertySymbols) {\n    var symbols = _Object$getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return _Object$getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (_Object$getOwnPropertyDescriptors) {\n      _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar trailingSlashes = /(?:^\\/)|(?:\\/$)/;\n/* eslint-disable no-underscore-dangle */\n\n/**\n * @class\n */\n\nvar Services = _webexPlugin.default.extend({\n  namespace: 'Services',\n\n  /**\n   * The {@link WeakMap} of {@link ServiceRegistry} class instances that are\n   * keyed with WebexCore instances.\n   *\n   * @instance\n   * @type {WeakMap<WebexCore, ServiceRegistry>}\n   * @private\n   * @memberof Services\n   */\n  registries: new _weakMap.default(),\n\n  /**\n   * The {@link WeakMap} of {@link ServiceState} class instances that are\n   * keyed with WebexCore instances.\n   *\n   * @instance\n   * @type {WeakMap<WebexCore, ServiceState>}\n   * @private\n   * @memberof Services\n   */\n  states: new _weakMap.default(),\n  props: {\n    validateDomains: ['boolean', false, true]\n  },\n  _catalogs: new _weakMap.default(),\n  _serviceUrls: null,\n\n  /**\n   * Get the registry associated with this webex instance.\n   *\n   * @private\n   * @memberof Services\n   * @returns {ServiceRegistry} - The associated {@link ServiceRegistry}.\n   */\n  getRegistry: function getRegistry() {\n    return this.registries.get(this.webex);\n  },\n\n  /**\n   * Get the state associated with this webex instance.\n   *\n   * @private\n   * @memberof Services\n   * @returns {ServiceState} - The associated {@link ServiceState}.\n   */\n  getState: function getState() {\n    return this.states.get(this.webex);\n  },\n\n  /**\n   * @private\n   * Get the current catalog based on the assocaited\n   * webex instance.\n   * @returns {ServiceCatalog}\n   */\n  _getCatalog: function _getCatalog() {\n    return this._catalogs.get(this.webex);\n  },\n\n  /**\n   * Get a service url from the current services list by name\n   * from the associated instance catalog.\n   * @param {string} name\n   * @param {boolean} [priorityHost]\n   * @param {string} [serviceGroup]\n   * @returns {string|undefined}\n   */\n  get: function get(name, priorityHost, serviceGroup) {\n    var catalog = this._getCatalog();\n\n    return catalog.get(name, priorityHost, serviceGroup);\n  },\n\n  /**\n   * Determine if the catalog contains a specific service\n   *\n   * @param {string} serviceName - The service name to validate.\n   * @returns {boolean} - True if the service exists.\n   */\n  hasService: function hasService(serviceName) {\n    return !!this.get(serviceName);\n  },\n\n  /**\n   * Determine if a whilelist exists in the service catalog.\n   *\n   * @returns {boolean} - True if a allowed domains list exists.\n   */\n  hasAllowedDomains: function hasAllowedDomains() {\n    var catalog = this._getCatalog();\n\n    return catalog.getAllowedDomains().length > 0;\n  },\n\n  /**\n   * Generate a service catalog as an object from\n   * the associated instance catalog.\n   * @param {boolean} [priorityHost] - use highest priority host if set to `true`\n   * @param {string} [serviceGroup]\n   * @returns {Record<string, string>}\n   */\n  list: function list(priorityHost, serviceGroup) {\n    var catalog = this._getCatalog();\n\n    return catalog.list(priorityHost, serviceGroup);\n  },\n\n  /**\n   * Mark a priority host service url as failed.\n   * This will mark the host associated with the\n   * `ServiceUrl` to be removed from the its\n   * respective host array, and then return the next\n   * viable host from the `ServiceUrls` host array,\n   * or the `ServiceUrls` default url if no other priority\n   * hosts are available, or if `noPriorityHosts` is set to\n   * `true`.\n   * @param {string} url\n   * @param {boolean} noPriorityHosts\n   * @returns {string}\n   */\n  markFailedUrl: function markFailedUrl(url, noPriorityHosts) {\n    var catalog = this._getCatalog();\n\n    return catalog.markFailedUrl(url, noPriorityHosts);\n  },\n\n  /**\n  * saves all the services from the pre and post catalog service\n  * @param {Object} serviceUrls\n  * @returns {void}\n  */\n  _updateServiceUrls: function _updateServiceUrls(serviceUrls) {\n    this._serviceUrls = _objectSpread(_objectSpread({}, this._serviceUrls), serviceUrls);\n  },\n\n  /**\n   * Update a list of `serviceUrls` to the most current\n   * catalog via the defined `discoveryUrl` then returns the current\n   * list of services.\n   * @param {object} [param]\n   * @param {string} [param.from] - This accepts `limited` or `signin`\n   * @param {object} [param.query] - This accepts `email`, `orgId` or `userId` key values\n   * @param {string} [param.query.email] - must be a standard-format email\n   * @param {string} [param.query.orgId] - must be an organization id\n   * @param {string} [param.query.userId] - must be a user id\n   * @param {string} [param.token] - used for signin catalog\n   * @returns {Promise<object>}\n   */\n  updateServices: function updateServices() {\n    var _this = this;\n\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        from = _ref.from,\n        query = _ref.query,\n        token = _ref.token,\n        forceRefresh = _ref.forceRefresh;\n\n    var catalog = this._getCatalog();\n\n    var formattedQuery, serviceGroup; // map catalog name to service group name.\n\n    switch (from) {\n      case 'limited':\n        serviceGroup = 'preauth';\n        break;\n\n      case 'signin':\n        serviceGroup = 'signin';\n        break;\n\n      default:\n        serviceGroup = 'postauth';\n        break;\n    } // confirm catalog update for group is not in progress.\n\n\n    if (catalog.status[serviceGroup].collecting) {\n      return this.waitForCatalog(serviceGroup);\n    }\n\n    catalog.status[serviceGroup].collecting = true;\n\n    if (serviceGroup === 'preauth') {\n      var queryKey = query && (0, _keys.default)(query)[0];\n\n      if (!['email', 'emailhash', 'userId', 'orgId', 'mode'].includes(queryKey)) {\n        return _promise.default.reject(new Error('a query param of email, emailhash, userId, orgId, or mode is required'));\n      }\n    } // encode email when query key is email\n\n\n    if (serviceGroup === 'preauth' || serviceGroup === 'signin') {\n      var _queryKey = (0, _keys.default)(query)[0];\n      formattedQuery = {};\n\n      if (_queryKey === 'email' && query.email) {\n        formattedQuery.emailhash = (0, _sha.default)(query.email.toLowerCase()).toString();\n      } else {\n        formattedQuery[_queryKey] = query[_queryKey];\n      }\n    }\n\n    return this._fetchNewServiceHostmap({\n      from: from,\n      token: token,\n      query: formattedQuery,\n      forceRefresh: forceRefresh\n    }).then(function (serviceHostMap) {\n      catalog.updateServiceUrls(serviceGroup, serviceHostMap);\n\n      _this.updateCredentialsConfig();\n\n      catalog.status[serviceGroup].collecting = false;\n    }).catch(function (error) {\n      catalog.status[serviceGroup].collecting = false;\n      return _promise.default.reject(error);\n    });\n  },\n\n  /**\n   * User validation parameter transfer object for {@link validateUser}.\n   * @param {object} ValidateUserPTO\n   * @property {string} ValidateUserPTO.email - The email of the user.\n   * @property {string} [ValidateUserPTO.reqId] - The activation requester.\n   * @property {object} [ValidateUserPTO.activationOptions] - Extra options to pass when sending the activation\n   * @property {object} [ValidateUserPTO.preloginUserId] - The prelogin user id to set when sending the activation.\n   */\n\n  /**\n   * User validation return transfer object for {@link validateUser}.\n   * @param {object} ValidateUserRTO\n   * @property {boolean} ValidateUserRTO.activated - If the user is activated.\n   * @property {boolean} ValidateUserRTO.exists - If the user exists.\n   * @property {string} ValidateUserRTO.details - A descriptive status message.\n   * @property {object} ValidateUserRTO.user - **License** service user object.\n   */\n\n  /**\n   * Validate if a user is activated and update the service catalogs as needed\n   * based on the user's activation status.\n   *\n   * @param {ValidateUserPTO} - The parameter transfer object.\n   * @returns {ValidateUserRTO} - The return transfer object.\n   */\n  validateUser: function validateUser(_ref2) {\n    var _this2 = this;\n\n    var email = _ref2.email,\n        _ref2$reqId = _ref2.reqId,\n        reqId = _ref2$reqId === void 0 ? 'WEBCLIENT' : _ref2$reqId,\n        _ref2$forceRefresh = _ref2.forceRefresh,\n        forceRefresh = _ref2$forceRefresh === void 0 ? false : _ref2$forceRefresh,\n        _ref2$activationOptio = _ref2.activationOptions,\n        activationOptions = _ref2$activationOptio === void 0 ? {} : _ref2$activationOptio,\n        preloginUserId = _ref2.preloginUserId;\n    this.logger.info('services: validating a user'); // Validate that an email parameter key was provided.\n\n    if (!email) {\n      return _promise.default.reject(new Error('`email` is required'));\n    } // Destructure the credentials object.\n\n\n    var canAuthorize = this.webex.credentials.canAuthorize; // Validate that the user is already authorized.\n\n    if (canAuthorize) {\n      return this.updateServices({\n        forceRefresh: forceRefresh\n      }).then(function () {\n        return _this2.webex.credentials.getUserToken();\n      }).then(function (token) {\n        return _this2.sendUserActivation({\n          email: email,\n          reqId: reqId,\n          token: token.toString(),\n          activationOptions: activationOptions,\n          preloginUserId: preloginUserId\n        });\n      }).then(function (userObj) {\n        return {\n          activated: true,\n          exists: true,\n          details: 'user is authorized via a user token',\n          user: userObj\n        };\n      });\n    } // Destructure the client authorization details.\n\n    /* eslint-disable camelcase */\n\n\n    var _this$webex$credentia = this.webex.credentials.config,\n        client_id = _this$webex$credentia.client_id,\n        client_secret = _this$webex$credentia.client_secret; // Validate that client authentication details exist.\n\n    if (!client_id || !client_secret) {\n      return _promise.default.reject(new Error('client authentication details are not available'));\n    }\n    /* eslint-enable camelcase */\n    // Declare a class-memeber-scoped token for usage within the promise chain.\n\n\n    var token; // Begin client authentication user validation.\n\n    return this.collectPreauthCatalog({\n      email: email\n    }).then(function () {\n      // Retrieve the service url from the updated catalog. This is required\n      // since `WebexCore` is usually not fully initialized at the time this\n      // request completes.\n      var idbrokerService = _this2.get('idbroker', true); // Collect the client auth token.\n\n\n      return _this2.webex.credentials.getClientToken({\n        uri: \"\".concat(idbrokerService, \"idb/oauth2/v1/access_token\"),\n        scope: 'webexsquare:admin webexsquare:get_conversation Identity:SCIM'\n      });\n    }).then(function (tokenObj) {\n      // Generate the token string.\n      token = tokenObj.toString(); // Collect the signin catalog using the client auth information.\n\n      return _this2.collectSigninCatalog({\n        email: email,\n        token: token,\n        forceRefresh: forceRefresh\n      });\n    }) // Validate if collecting the signin catalog failed and populate the RTO\n    // with the appropriate content.\n    .catch(function (error) {\n      return {\n        exists: error.name !== 'NotFound',\n        activated: false,\n        details: error.name !== 'NotFound' ? 'user exists but is not activated' : 'user does not exist and is not activated'\n      };\n    }) // Validate if the previous promise resolved with an RTO and populate the\n    // new RTO accordingly.\n    .then(function (rto) {\n      return _promise.default.all([rto || {\n        activated: true,\n        exists: true,\n        details: 'user exists and is activated'\n      }, _this2.sendUserActivation({\n        email: email,\n        reqId: reqId,\n        token: token,\n        activationOptions: activationOptions,\n        preloginUserId: preloginUserId\n      })]);\n    }).then(function (_ref3) {\n      var _ref4 = (0, _slicedToArray2.default)(_ref3, 2),\n          rto = _ref4[0],\n          user = _ref4[1];\n\n      return _objectSpread(_objectSpread({}, rto), {}, {\n        user: user\n      });\n    }).catch(function (error) {\n      var response = {\n        statusCode: error.statusCode,\n        responseText: error.body && error.body.message,\n        body: error.body\n      };\n      return _promise.default.reject(response);\n    });\n  },\n\n  /**\n   * Fetches client region info such as countryCode and timezone.\n   *\n   * @returns {object} - The region info object.\n   */\n  fetchClientRegionInfo: function fetchClientRegionInfo() {\n    var _this3 = this;\n\n    return this.request({\n      uri: 'https://ds.ciscospark.com/v1/region',\n      addAuthHeader: false,\n      headers: {\n        'spark-user-agent': null\n      }\n    }).then(function (res) {\n      _this3.logger.info('services: received user region info');\n\n      return res.body;\n    }).catch(function (err) {\n      _this3.logger.info('services: was not able to get user region info', err); // resolve successfully even if request failed\n\n    });\n  },\n\n  /**\n   * User activation parameter transfer object for {@link sendUserActivation}.\n   * @typedef {object} SendUserActivationPTO\n   * @property {string} SendUserActivationPTO.email - The email of the user.\n   * @property {string} SendUserActivationPTO.reqId - The activation requester.\n   * @property {string} SendUserActivationPTO.token - The client auth token.\n   * @property {object} SendUserActivationPTO.activationOptions - Extra options to pass when sending the activation.\n   * @property {object} SendUserActivationPTO.preloginUserId - The prelogin user id to set when sending the activation.\n   */\n\n  /**\n   * Send a request to activate a user using a client token.\n   *\n   * @param {SendUserActivationPTO} - The Parameter transfer object.\n   * @returns {LicenseDTO} - The DTO returned from the **License** service.\n   */\n  sendUserActivation: function sendUserActivation(_ref5) {\n    var _this4 = this;\n\n    var email = _ref5.email,\n        reqId = _ref5.reqId,\n        token = _ref5.token,\n        activationOptions = _ref5.activationOptions,\n        preloginUserId = _ref5.preloginUserId;\n    this.logger.info('services: sending user activation request');\n    var countryCode, timezone; // try to fetch client region info first\n\n    return this.fetchClientRegionInfo().then(function (clientRegionInfo) {\n      if (clientRegionInfo) {\n        countryCode = clientRegionInfo.countryCode;\n        timezone = clientRegionInfo.timezone;\n      } // Send the user activation request to the **License** service.\n\n\n      return _this4.request({\n        service: 'license',\n        resource: 'users/activations',\n        method: 'POST',\n        headers: {\n          accept: 'application/json',\n          authorization: token,\n          'x-prelogin-userid': preloginUserId\n        },\n        body: _objectSpread({\n          email: email,\n          reqId: reqId,\n          countryCode: countryCode,\n          timeZone: timezone\n        }, activationOptions),\n        shouldRefreshAccessToken: false\n      });\n    }) // On success, return the **License** user object.\n    .then(function (_ref6) {\n      var body = _ref6.body;\n      return body;\n    }) // On failure, reject with error from **License**.\n    .catch(function (error) {\n      return _promise.default.reject(error);\n    });\n  },\n\n  /**\n   * simplified method to update the preauth catalog via email\n   *\n   * @param {object} query\n   * @param {string} query.email - A standard format email.\n   * @param {string} query.orgId - The user's OrgId.\n   * @param {boolean} forceRefresh - Boolean to bypass u2c cache control header\n   * @returns {Promise<void>}\n   */\n  collectPreauthCatalog: function collectPreauthCatalog(query) {\n    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (!query) {\n      return this.updateServices({\n        from: 'limited',\n        query: {\n          mode: 'DEFAULT_BY_PROXIMITY'\n        },\n        forceRefresh: forceRefresh\n      });\n    }\n\n    return this.updateServices({\n      from: 'limited',\n      query: query,\n      forceRefresh: forceRefresh\n    });\n  },\n\n  /**\n   * simplified method to update the signin catalog via email and token\n   * @param {object} param\n   * @param {string} param.email - must be a standard-format email\n   * @param {string} param.token - must be a client token\n   * @returns {Promise<void>}\n   */\n  collectSigninCatalog: function collectSigninCatalog() {\n    var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        email = _ref7.email,\n        token = _ref7.token,\n        forceRefresh = _ref7.forceRefresh;\n\n    if (!email) {\n      return _promise.default.reject(new Error('`email` is required'));\n    }\n\n    if (!token) {\n      return _promise.default.reject(new Error('`token` is required'));\n    }\n\n    return this.updateServices({\n      from: 'signin',\n      query: {\n        email: email\n      },\n      token: token,\n      forceRefresh: forceRefresh\n    });\n  },\n\n  /**\n   * Updates credentials config to utilize u2c catalog\n   * urls.\n   * @returns {void}\n   */\n  updateCredentialsConfig: function updateCredentialsConfig() {\n    var _this$list = this.list(true),\n        idbroker = _this$list.idbroker,\n        identity = _this$list.identity;\n\n    if (idbroker && identity) {\n      var _this$webex$config$cr = this.webex.config.credentials,\n          authorizationString = _this$webex$config$cr.authorizationString,\n          authorizeUrl = _this$webex$config$cr.authorizeUrl; // This must be set outside of the setConfig method used to assign the\n      // idbroker and identity url values.\n\n      this.webex.config.credentials.authorizeUrl = authorizationString ? authorizeUrl : \"\".concat(idbroker.replace(trailingSlashes, ''), \"/idb/oauth2/v1/authorize\");\n      this.webex.setConfig({\n        credentials: {\n          idbroker: {\n            url: idbroker.replace(trailingSlashes, '') // remove trailing slash\n\n          },\n          identity: {\n            url: identity.replace(trailingSlashes, '') // remove trailing slash\n\n          }\n        }\n      });\n    }\n  },\n\n  /**\n   * Wait until the service catalog is available,\n   * or reject afte ra timeout of 60 seconds.\n   * @param {string} serviceGroup\n   * @param {number} [timeout] - in seconds\n   * @returns {Promise<void>}\n   */\n  waitForCatalog: function waitForCatalog(serviceGroup, timeout) {\n    var catalog = this._getCatalog();\n\n    var supertoken = this.webex.credentials.supertoken;\n\n    if (serviceGroup === 'postauth' && supertoken && supertoken.access_token && !catalog.status.postauth.collecting && !catalog.status.postauth.ready) {\n      if (!catalog.status.preauth.ready) {\n        return this.initServiceCatalogs();\n      }\n\n      return this.updateServices();\n    }\n\n    return catalog.waitForCatalog(serviceGroup, timeout);\n  },\n\n  /**\n   * Service waiting parameter transfer object for {@link waitForService}.\n   *\n   * @typedef {object} WaitForServicePTO\n   * @property {string} [WaitForServicePTO.name] - The service name.\n   * @property {string} [WaitForServicePTO.url] - The service url.\n   * @property {string} [WaitForServicePTO.timeout] - wait duration in seconds.\n   */\n\n  /**\n   * Wait until the service has been ammended to any service catalog. This\n   * method prioritizes the service name over the service url when searching.\n   *\n   * @param {WaitForServicePTO} - The parameter transfer object.\n   * @returns {Promise<string>} - Resolves to the priority host of a service.\n   */\n  waitForService: function waitForService(_ref8) {\n    var _this5 = this;\n\n    var name = _ref8.name,\n        _ref8$timeout = _ref8.timeout,\n        timeout = _ref8$timeout === void 0 ? 5 : _ref8$timeout,\n        url = _ref8.url;\n    var services = this.webex.config.services; // Save memory by grabbing the catalog after there isn't a priortyURL\n\n    var catalog = this._getCatalog();\n\n    var fetchFromServiceUrl = services.servicesNotNeedValidation.find(function (service) {\n      return service === name;\n    });\n\n    if (fetchFromServiceUrl) {\n      return _promise.default.resolve(this._serviceUrls[name]);\n    }\n\n    var priorityUrl = this.get(name, true);\n    var priorityUrlObj = this.getServiceFromUrl(url);\n\n    if (priorityUrl || priorityUrlObj) {\n      return _promise.default.resolve(priorityUrl || priorityUrlObj.priorityUrl);\n    }\n\n    if (catalog.isReady) {\n      return url ? _promise.default.resolve(url) : _promise.default.reject(new Error(\"services: service '\".concat(name, \"' was not found in any of the catalogs\")));\n    }\n\n    return new _promise.default(function (resolve, reject) {\n      var groupsToCheck = ['preauth', 'signin', 'postauth'];\n\n      var checkCatalog = function checkCatalog(catalogGroup) {\n        return catalog.waitForCatalog(catalogGroup, timeout).then(function () {\n          var scopedPriorityUrl = _this5.get(name, true);\n\n          var scopedPrioriryUrlObj = _this5.getServiceFromUrl(url);\n\n          if (scopedPriorityUrl || scopedPrioriryUrlObj) {\n            resolve(scopedPriorityUrl || scopedPrioriryUrlObj.priorityUrl);\n          }\n        }).catch(function () {\n          return undefined;\n        });\n      };\n\n      _promise.default.all(groupsToCheck.map(function (group) {\n        return checkCatalog(group);\n      })).then(function () {\n        reject(new Error(\"services: service '\".concat(name, \"' was not found after waiting\")));\n      });\n    });\n  },\n\n  /**\n   * @private\n   * Organize a received hostmap from a service\n   * catalog endpoint.\n   * @param {object} serviceHostmap\n   * @returns {object}\n   */\n  _formatReceivedHostmap: function _formatReceivedHostmap(serviceHostmap) {\n    // map the host catalog items to a formatted hostmap\n    var formattedHostmap = (0, _keys.default)(serviceHostmap.hostCatalog).reduce(function (accumulator, key) {\n      var _serviceItem$hosts;\n\n      if (serviceHostmap.hostCatalog[key].length === 0) {\n        return accumulator;\n      }\n\n      var serviceName = serviceHostmap.hostCatalog[key][0].id.split(':')[3];\n      var defaultUrl = serviceHostmap.serviceLinks[serviceName];\n      var serviceItem = accumulator.find(function (item) {\n        return item.name === serviceName;\n      });\n\n      if (!serviceItem) {\n        serviceItem = {\n          name: serviceName,\n          defaultUrl: defaultUrl,\n          defaultHost: _url.default.parse(defaultUrl).hostname,\n          hosts: []\n        };\n        accumulator.push(serviceItem);\n      }\n\n      (_serviceItem$hosts = serviceItem.hosts).push.apply(_serviceItem$hosts, [// map the default key as a low priority default for cluster matching\n      {\n        host: key,\n        ttl: -1,\n        priority: 10,\n        id: serviceHostmap.hostCatalog[key][0].id,\n        homeCluster: serviceItem.defaultHost === key\n      }].concat((0, _toConsumableArray2.default)(serviceHostmap.hostCatalog[key].map(function (host) {\n        return _objectSpread(_objectSpread({}, host), {}, {\n          homeCluster: serviceItem.defaultHost === key\n        });\n      }))));\n\n      return accumulator;\n    }, []); // append service links that do not exist in the host catalog\n\n    (0, _keys.default)(serviceHostmap.serviceLinks).forEach(function (key) {\n      var service = formattedHostmap.find(function (item) {\n        return item.name === key;\n      });\n\n      if (!service) {\n        formattedHostmap.push({\n          name: key,\n          defaultUrl: serviceHostmap.serviceLinks[key],\n          defaultHost: _url.default.parse(serviceHostmap.serviceLinks[key]).hostname,\n          hosts: []\n        });\n      }\n    }); // update all the service urls in the host catalog\n\n    this._updateServiceUrls(serviceHostmap.serviceLinks);\n\n    return formattedHostmap;\n  },\n\n  /**\n   * Get the clusterId associated with a URL string.\n   * @param {string} url\n   * @returns {string} - Cluster ID of url provided\n   */\n  getClusterId: function getClusterId(url) {\n    var catalog = this._getCatalog();\n\n    return catalog.findClusterId(url);\n  },\n\n  /**\n   * Get a service value from a provided clusterId. This method will\n   * return an object containing both the name and url of a found service.\n   * @param {object} params\n   * @param {string} params.clusterId - clusterId of found service\n   * @param {boolean} [params.priorityHost] - returns priority host url if true\n   * @param {string} [params.serviceGroup] - specify service group\n   * @returns {object} service\n   * @returns {string} service.name\n   * @returns {string} service.url\n   */\n  getServiceFromClusterId: function getServiceFromClusterId(params) {\n    var catalog = this._getCatalog();\n\n    return catalog.findServiceFromClusterId(params);\n  },\n\n  /**\n   * Get a service object from a service url if the service url exists in the\n   * catalog.\n   *\n   * @param {string} url - The url to be validated.\n   * @returns {object} - Service object.\n   * @returns {object.name} - The name of the service found.\n   * @returns {object.priorityUrl} - The priority url of the found service.\n   * @returns {object.defaultUrl} - The default url of the found service.\n   */\n  getServiceFromUrl: function getServiceFromUrl() {\n    var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n    var service = this._getCatalog().findServiceUrlFromUrl(url);\n\n    if (!service) {\n      return undefined;\n    }\n\n    return {\n      name: service.name,\n      priorityUrl: service.get(true),\n      defaultUrl: service.get()\n    };\n  },\n\n  /**\n   * Verify that a provided url exists in the service\n   * catalog.\n   * @param {string} url\n   * @returns {boolean} - true if exists, false otherwise\n   */\n  isServiceUrl: function isServiceUrl(url) {\n    var catalog = this._getCatalog();\n\n    return !!catalog.findServiceUrlFromUrl(url);\n  },\n\n  /**\n   * Determine if a provided url is in the catalog's allowed domains.\n   *\n   * @param {string} url - The url to match allowed domains against.\n   * @returns {boolean} - True if the url provided is allowed.\n   */\n  isAllowedDomainUrl: function isAllowedDomainUrl(url) {\n    var catalog = this._getCatalog();\n\n    return !!catalog.findAllowedDomain(url);\n  },\n\n  /**\n   * Converts the host portion of the url from default host\n   * to a priority host\n   *\n   * @param {string} url a service url that contains a default host\n   * @returns {string} a service url that contains the top priority host.\n   * @throws if url isn't a service url\n   */\n  convertUrlToPriorityHostUrl: function convertUrlToPriorityHostUrl() {\n    var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var data = this.getServiceFromUrl(url);\n\n    if (!data) {\n      throw Error(\"No service associated with url: [\".concat(url, \"]\"));\n    }\n\n    return url.replace(data.defaultUrl, data.priorityUrl);\n  },\n\n  /**\n   * @private\n   * Simplified method wrapper for sending a request to get\n   * an updated service hostmap.\n   * @param {object} [param]\n   * @param {string} [param.from] - This accepts `limited` or `signin`\n   * @param {object} [param.query] - This accepts `email`, `orgId` or `userId` key values\n   * @param {string} [param.query.email] - must be a standard-format email\n   * @param {string} [param.query.orgId] - must be an organization id\n   * @param {string} [param.query.userId] - must be a user id\n   * @param {string} [param.token] - used for signin catalog\n   * @returns {Promise<object>}\n   */\n  _fetchNewServiceHostmap: function _fetchNewServiceHostmap() {\n    var _this6 = this;\n\n    var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        from = _ref9.from,\n        query = _ref9.query,\n        token = _ref9.token,\n        forceRefresh = _ref9.forceRefresh;\n\n    var service = 'u2c';\n    var resource = from ? \"/\".concat(from, \"/catalog\") : '/catalog';\n\n    var qs = _objectSpread(_objectSpread({}, query), {}, {\n      format: 'hostmap'\n    });\n\n    if (forceRefresh) {\n      qs.timestamp = new Date().getTime();\n    }\n\n    var requestObject = {\n      method: 'GET',\n      service: service,\n      resource: resource,\n      qs: qs\n    };\n\n    if (token) {\n      requestObject.headers = {\n        authorization: token\n      };\n    }\n\n    return this.request(requestObject).then(function (_ref10) {\n      var body = _ref10.body;\n      return _this6._formatReceivedHostmap(body);\n    });\n  },\n\n  /**\n   * Initialize the discovery services and the whitelisted services.\n   *\n   * @returns {void}\n   */\n  initConfig: function initConfig() {\n    // Get the catalog and destructure the services config.\n    var catalog = this._getCatalog();\n\n    var services = this.webex.config.services; // Validate that the services configuration exists.\n\n    if (services) {\n      // Check for discovery services.\n      if (services.discovery) {\n        // Format the discovery configuration into an injectable array.\n        var formattedDiscoveryServices = (0, _keys.default)(services.discovery).map(function (key) {\n          return {\n            name: key,\n            defaultUrl: services.discovery[key]\n          };\n        }); // Inject formatted discovery services into services catalog.\n\n        catalog.updateServiceUrls('discovery', formattedDiscoveryServices);\n      }\n\n      if (services.override) {\n        // Format the override configuration into an injectable array.\n        var formattedOverrideServices = (0, _keys.default)(services.override).map(function (key) {\n          return {\n            name: key,\n            defaultUrl: services.override[key]\n          };\n        }); // Inject formatted override services into services catalog.\n\n        catalog.updateServiceUrls('override', formattedOverrideServices);\n      } // Check for allowed host domains.\n\n\n      if (services.allowedDomains) {\n        // Store the allowed domains as a property of the catalog.\n        catalog.setAllowedDomains(services.allowedDomains);\n      } // Set `validateDomains` property to match configuration\n\n\n      this.validateDomains = services.validateDomains;\n    }\n  },\n\n  /**\n   * Make the initial requests to collect the root catalogs.\n   *\n   * @returns {Promise<void, Error>} - Errors if the token is unavailable.\n   */\n  initServiceCatalogs: function initServiceCatalogs() {\n    var _this7 = this;\n\n    this.logger.info('services: initializing initial service catalogs'); // Destructure the credentials plugin.\n\n    var credentials = this.webex.credentials; // Init a promise chain. Must be done as a Promise.resolve() to allow\n    // credentials#getOrgId() to properly throw.\n\n    return _promise.default.resolve() // Get the user's OrgId.\n    .then(function () {\n      return credentials.getOrgId();\n    }) // Begin collecting the preauth/limited catalog.\n    .then(function (orgId) {\n      return _this7.collectPreauthCatalog({\n        orgId: orgId\n      });\n    }).then(function () {\n      // Validate if the token is authorized.\n      if (credentials.canAuthorize) {\n        // Attempt to collect the postauth catalog.\n        return _this7.updateServices().catch(function () {\n          return _this7.logger.warn('services: cannot retrieve postauth catalog');\n        });\n      } // Return a resolved promise for consistent return value.\n\n\n      return _promise.default.resolve();\n    });\n  },\n\n  /**\n   * Initializer\n   *\n   * @instance\n   * @memberof Services\n   * @returns {Services}\n   */\n  initialize: function initialize() {\n    var _this8 = this;\n\n    var catalog = new _serviceCatalog.default();\n    var registry = new _serviceRegistry.default();\n    var state = new _serviceState.default();\n\n    this._catalogs.set(this.webex, catalog);\n\n    this.registries.set(this.webex, registry);\n    this.states.set(this.webex, state); // Listen for configuration changes once.\n\n    this.listenToOnce(this.webex, 'change:config', function () {\n      _this8.initConfig();\n    }); // wait for webex instance to be ready before attempting\n    // to update the service catalogs\n\n    this.listenToOnce(this.webex, 'ready', function () {\n      var supertoken = _this8.webex.credentials.supertoken; // Validate if the supertoken exists.\n\n      if (supertoken && supertoken.access_token) {\n        _this8.initServiceCatalogs().then(function () {\n          catalog.isReady = true;\n        }).catch(function (error) {\n          return _this8.logger.error(\"services: failed to init initial services, \".concat(error.message));\n        });\n      } else {\n        var email = _this8.webex.config.email;\n\n        _this8.collectPreauthCatalog(email ? {\n          email: email\n        } : undefined);\n      }\n    });\n  },\n  version: \"1.154.2\"\n});\n/* eslint-enable no-underscore-dangle */\n\n\nvar _default = Services;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["trailingSlashes","Services","WebexPlugin","extend","namespace","registries","states","props","validateDomains","_catalogs","_serviceUrls","getRegistry","get","webex","getState","_getCatalog","name","priorityHost","serviceGroup","catalog","hasService","serviceName","hasAllowedDomains","getAllowedDomains","length","list","markFailedUrl","url","noPriorityHosts","_updateServiceUrls","serviceUrls","updateServices","from","query","token","forceRefresh","formattedQuery","status","collecting","waitForCatalog","queryKey","includes","_promise","reject","Error","email","emailhash","toLowerCase","toString","_fetchNewServiceHostmap","then","serviceHostMap","updateServiceUrls","_this","updateCredentialsConfig","catch","error","validateUser","reqId","activationOptions","preloginUserId","logger","info","canAuthorize","credentials","_this2","getUserToken","sendUserActivation","userObj","activated","exists","details","user","config","client_id","client_secret","collectPreauthCatalog","idbrokerService","getClientToken","uri","scope","tokenObj","collectSigninCatalog","rto","all","response","statusCode","responseText","body","message","fetchClientRegionInfo","request","addAuthHeader","headers","res","_this3","err","countryCode","timezone","clientRegionInfo","_this4","service","resource","method","accept","authorization","timeZone","shouldRefreshAccessToken","mode","idbroker","identity","authorizationString","authorizeUrl","replace","setConfig","timeout","supertoken","access_token","postauth","ready","preauth","initServiceCatalogs","waitForService","services","fetchFromServiceUrl","servicesNotNeedValidation","find","resolve","priorityUrl","priorityUrlObj","getServiceFromUrl","isReady","groupsToCheck","checkCatalog","catalogGroup","scopedPriorityUrl","_this5","scopedPrioriryUrlObj","undefined","map","group","_formatReceivedHostmap","serviceHostmap","formattedHostmap","hostCatalog","reduce","accumulator","key","id","split","defaultUrl","serviceLinks","serviceItem","item","defaultHost","Url","parse","hostname","hosts","push","host","ttl","priority","homeCluster","forEach","getClusterId","findClusterId","getServiceFromClusterId","params","findServiceFromClusterId","findServiceUrlFromUrl","isServiceUrl","isAllowedDomainUrl","findAllowedDomain","convertUrlToPriorityHostUrl","data","qs","format","timestamp","Date","getTime","requestObject","_this6","initConfig","discovery","formattedDiscoveryServices","override","formattedOverrideServices","allowedDomains","setAllowedDomains","getOrgId","orgId","_this7","warn","initialize","ServiceCatalog","registry","ServiceRegistry","state","ServiceState","set","listenToOnce","_this8","version"],"sources":["services.js"],"sourcesContent":["import Url from 'url';\n\nimport sha256 from 'crypto-js/sha256';\n\nimport WebexPlugin from '../webex-plugin';\n\nimport ServiceCatalog from './service-catalog';\nimport ServiceRegistry from './service-registry';\nimport ServiceState from './service-state';\n\n\nconst trailingSlashes = /(?:^\\/)|(?:\\/$)/;\n\n/* eslint-disable no-underscore-dangle */\n/**\n * @class\n */\nconst Services = WebexPlugin.extend({\n  namespace: 'Services',\n\n  /**\n   * The {@link WeakMap} of {@link ServiceRegistry} class instances that are\n   * keyed with WebexCore instances.\n   *\n   * @instance\n   * @type {WeakMap<WebexCore, ServiceRegistry>}\n   * @private\n   * @memberof Services\n   */\n  registries: new WeakMap(),\n\n  /**\n   * The {@link WeakMap} of {@link ServiceState} class instances that are\n   * keyed with WebexCore instances.\n   *\n   * @instance\n   * @type {WeakMap<WebexCore, ServiceState>}\n   * @private\n   * @memberof Services\n   */\n  states: new WeakMap(),\n\n  props: {\n    validateDomains: ['boolean', false, true]\n  },\n\n  _catalogs: new WeakMap(),\n\n  _serviceUrls: null,\n\n  /**\n   * Get the registry associated with this webex instance.\n   *\n   * @private\n   * @memberof Services\n   * @returns {ServiceRegistry} - The associated {@link ServiceRegistry}.\n   */\n  getRegistry() {\n    return this.registries.get(this.webex);\n  },\n\n  /**\n   * Get the state associated with this webex instance.\n   *\n   * @private\n   * @memberof Services\n   * @returns {ServiceState} - The associated {@link ServiceState}.\n   */\n  getState() {\n    return this.states.get(this.webex);\n  },\n\n  /**\n   * @private\n   * Get the current catalog based on the assocaited\n   * webex instance.\n   * @returns {ServiceCatalog}\n   */\n  _getCatalog() {\n    return this._catalogs.get(this.webex);\n  },\n\n  /**\n   * Get a service url from the current services list by name\n   * from the associated instance catalog.\n   * @param {string} name\n   * @param {boolean} [priorityHost]\n   * @param {string} [serviceGroup]\n   * @returns {string|undefined}\n   */\n  get(name, priorityHost, serviceGroup) {\n    const catalog = this._getCatalog();\n\n    return catalog.get(name, priorityHost, serviceGroup);\n  },\n\n  /**\n   * Determine if the catalog contains a specific service\n   *\n   * @param {string} serviceName - The service name to validate.\n   * @returns {boolean} - True if the service exists.\n   */\n  hasService(serviceName) {\n    return !!(this.get(serviceName));\n  },\n\n  /**\n   * Determine if a whilelist exists in the service catalog.\n   *\n   * @returns {boolean} - True if a allowed domains list exists.\n   */\n  hasAllowedDomains() {\n    const catalog = this._getCatalog();\n\n    return (catalog.getAllowedDomains().length > 0);\n  },\n\n  /**\n   * Generate a service catalog as an object from\n   * the associated instance catalog.\n   * @param {boolean} [priorityHost] - use highest priority host if set to `true`\n   * @param {string} [serviceGroup]\n   * @returns {Record<string, string>}\n   */\n  list(priorityHost, serviceGroup) {\n    const catalog = this._getCatalog();\n\n    return catalog.list(priorityHost, serviceGroup);\n  },\n\n  /**\n   * Mark a priority host service url as failed.\n   * This will mark the host associated with the\n   * `ServiceUrl` to be removed from the its\n   * respective host array, and then return the next\n   * viable host from the `ServiceUrls` host array,\n   * or the `ServiceUrls` default url if no other priority\n   * hosts are available, or if `noPriorityHosts` is set to\n   * `true`.\n   * @param {string} url\n   * @param {boolean} noPriorityHosts\n   * @returns {string}\n   */\n  markFailedUrl(url, noPriorityHosts) {\n    const catalog = this._getCatalog();\n\n    return catalog.markFailedUrl(url, noPriorityHosts);\n  },\n\n  /**\n * saves all the services from the pre and post catalog service\n * @param {Object} serviceUrls\n * @returns {void}\n */\n  _updateServiceUrls(serviceUrls) {\n    this._serviceUrls = {...this._serviceUrls, ...serviceUrls};\n  },\n\n\n  /**\n   * Update a list of `serviceUrls` to the most current\n   * catalog via the defined `discoveryUrl` then returns the current\n   * list of services.\n   * @param {object} [param]\n   * @param {string} [param.from] - This accepts `limited` or `signin`\n   * @param {object} [param.query] - This accepts `email`, `orgId` or `userId` key values\n   * @param {string} [param.query.email] - must be a standard-format email\n   * @param {string} [param.query.orgId] - must be an organization id\n   * @param {string} [param.query.userId] - must be a user id\n   * @param {string} [param.token] - used for signin catalog\n   * @returns {Promise<object>}\n   */\n  updateServices({\n    from, query, token, forceRefresh\n  } = {}) {\n    const catalog = this._getCatalog();\n    let formattedQuery, serviceGroup;\n\n    // map catalog name to service group name.\n    switch (from) {\n      case 'limited': serviceGroup = 'preauth'; break;\n      case 'signin': serviceGroup = 'signin'; break;\n      default: serviceGroup = 'postauth'; break;\n    }\n\n    // confirm catalog update for group is not in progress.\n    if (catalog.status[serviceGroup].collecting) {\n      return this.waitForCatalog(serviceGroup);\n    }\n\n    catalog.status[serviceGroup].collecting = true;\n\n    if (serviceGroup === 'preauth') {\n      const queryKey = query && Object.keys(query)[0];\n\n      if (!['email', 'emailhash', 'userId', 'orgId', 'mode'].includes(queryKey)) {\n        return Promise.reject(new Error('a query param of email, emailhash, userId, orgId, or mode is required'));\n      }\n    }\n    // encode email when query key is email\n    if (serviceGroup === 'preauth' || serviceGroup === 'signin') {\n      const queryKey = Object.keys(query)[0];\n\n      formattedQuery = {};\n\n      if (queryKey === 'email' && query.email) {\n        formattedQuery.emailhash = sha256(query.email.toLowerCase()).toString();\n      }\n      else {\n        formattedQuery[queryKey] = query[queryKey];\n      }\n    }\n\n    return this._fetchNewServiceHostmap({\n      from,\n      token,\n      query: formattedQuery,\n      forceRefresh\n    })\n      .then((serviceHostMap) => {\n        catalog.updateServiceUrls(serviceGroup, serviceHostMap);\n        this.updateCredentialsConfig();\n        catalog.status[serviceGroup].collecting = false;\n      })\n      .catch((error) => {\n        catalog.status[serviceGroup].collecting = false;\n\n        return Promise.reject(error);\n      });\n  },\n\n  /**\n   * User validation parameter transfer object for {@link validateUser}.\n   * @param {object} ValidateUserPTO\n   * @property {string} ValidateUserPTO.email - The email of the user.\n   * @property {string} [ValidateUserPTO.reqId] - The activation requester.\n   * @property {object} [ValidateUserPTO.activationOptions] - Extra options to pass when sending the activation\n   * @property {object} [ValidateUserPTO.preloginUserId] - The prelogin user id to set when sending the activation.\n   */\n\n  /**\n   * User validation return transfer object for {@link validateUser}.\n   * @param {object} ValidateUserRTO\n   * @property {boolean} ValidateUserRTO.activated - If the user is activated.\n   * @property {boolean} ValidateUserRTO.exists - If the user exists.\n   * @property {string} ValidateUserRTO.details - A descriptive status message.\n   * @property {object} ValidateUserRTO.user - **License** service user object.\n   */\n\n  /**\n   * Validate if a user is activated and update the service catalogs as needed\n   * based on the user's activation status.\n   *\n   * @param {ValidateUserPTO} - The parameter transfer object.\n   * @returns {ValidateUserRTO} - The return transfer object.\n   */\n  validateUser({\n    email,\n    reqId = 'WEBCLIENT',\n    forceRefresh = false,\n    activationOptions = {},\n    preloginUserId\n  }) {\n    this.logger.info('services: validating a user');\n\n    // Validate that an email parameter key was provided.\n    if (!email) {\n      return Promise.reject(new Error('`email` is required'));\n    }\n\n    // Destructure the credentials object.\n    const {canAuthorize} = this.webex.credentials;\n\n    // Validate that the user is already authorized.\n    if (canAuthorize) {\n      return this.updateServices({forceRefresh})\n        .then(() => this.webex.credentials.getUserToken())\n        .then((token) => this.sendUserActivation({\n          email,\n          reqId,\n          token: token.toString(),\n          activationOptions,\n          preloginUserId\n        }))\n        .then((userObj) => ({\n          activated: true,\n          exists: true,\n          details: 'user is authorized via a user token',\n          user: userObj\n        }));\n    }\n\n    // Destructure the client authorization details.\n    /* eslint-disable camelcase */\n    const {client_id, client_secret} = this.webex.credentials.config;\n\n    // Validate that client authentication details exist.\n    if (!client_id || !client_secret) {\n      return Promise.reject(new Error(\n        'client authentication details are not available'\n      ));\n    }\n    /* eslint-enable camelcase */\n\n    // Declare a class-memeber-scoped token for usage within the promise chain.\n    let token;\n\n    // Begin client authentication user validation.\n    return this.collectPreauthCatalog({email})\n      .then(() => {\n        // Retrieve the service url from the updated catalog. This is required\n        // since `WebexCore` is usually not fully initialized at the time this\n        // request completes.\n        const idbrokerService = this.get('idbroker', true);\n\n        // Collect the client auth token.\n        return this.webex.credentials.getClientToken({\n          uri: `${idbrokerService}idb/oauth2/v1/access_token`,\n          scope: 'webexsquare:admin webexsquare:get_conversation Identity:SCIM'\n        });\n      })\n      .then((tokenObj) => {\n        // Generate the token string.\n        token = tokenObj.toString();\n\n        // Collect the signin catalog using the client auth information.\n        return this.collectSigninCatalog({email, token, forceRefresh});\n      })\n      // Validate if collecting the signin catalog failed and populate the RTO\n      // with the appropriate content.\n      .catch((error) => ({\n        exists: (error.name !== 'NotFound'),\n        activated: false,\n        details: (error.name !== 'NotFound') ?\n          'user exists but is not activated' :\n          'user does not exist and is not activated'\n      }))\n      // Validate if the previous promise resolved with an RTO and populate the\n      // new RTO accordingly.\n      .then((rto) => Promise.all([\n        rto || {\n          activated: true,\n          exists: true,\n          details: 'user exists and is activated'\n        },\n        this.sendUserActivation({\n          email,\n          reqId,\n          token,\n          activationOptions,\n          preloginUserId\n        })\n      ]))\n      .then(([rto, user]) => ({...rto, user}))\n      .catch((error) => {\n        const response = {\n          statusCode: error.statusCode,\n          responseText: error.body && error.body.message,\n          body: error.body\n        };\n\n        return Promise.reject(response);\n      });\n  },\n\n  /**\n   * Fetches client region info such as countryCode and timezone.\n   *\n   * @returns {object} - The region info object.\n   */\n  fetchClientRegionInfo() {\n    return this.request({\n      uri: 'https://ds.ciscospark.com/v1/region',\n      addAuthHeader: false,\n      headers: {\n        'spark-user-agent': null\n      }\n    }).then((res) => {\n      this.logger.info('services: received user region info');\n\n      return res.body;\n    }).catch((err) => {\n      this.logger.info('services: was not able to get user region info', err);\n      // resolve successfully even if request failed\n    });\n  },\n\n  /**\n   * User activation parameter transfer object for {@link sendUserActivation}.\n   * @typedef {object} SendUserActivationPTO\n   * @property {string} SendUserActivationPTO.email - The email of the user.\n   * @property {string} SendUserActivationPTO.reqId - The activation requester.\n   * @property {string} SendUserActivationPTO.token - The client auth token.\n   * @property {object} SendUserActivationPTO.activationOptions - Extra options to pass when sending the activation.\n   * @property {object} SendUserActivationPTO.preloginUserId - The prelogin user id to set when sending the activation.\n   */\n\n  /**\n   * Send a request to activate a user using a client token.\n   *\n   * @param {SendUserActivationPTO} - The Parameter transfer object.\n   * @returns {LicenseDTO} - The DTO returned from the **License** service.\n   */\n  sendUserActivation({\n    email,\n    reqId,\n    token,\n    activationOptions,\n    preloginUserId\n  }) {\n    this.logger.info('services: sending user activation request');\n    let countryCode, timezone;\n\n\n    // try to fetch client region info first\n    return this.fetchClientRegionInfo()\n      .then((clientRegionInfo) => {\n        if (clientRegionInfo) {\n          ({countryCode, timezone} = clientRegionInfo);\n        }\n\n        // Send the user activation request to the **License** service.\n        return this.request({\n          service: 'license',\n          resource: 'users/activations',\n          method: 'POST',\n          headers: {\n            accept: 'application/json',\n            authorization: token,\n            'x-prelogin-userid': preloginUserId\n          },\n          body: {\n            email,\n            reqId,\n            countryCode,\n            timeZone: timezone,\n            ...activationOptions\n          },\n          shouldRefreshAccessToken: false\n        });\n      })\n      // On success, return the **License** user object.\n      .then(({body}) => body)\n      // On failure, reject with error from **License**.\n      .catch((error) => Promise.reject(error));\n  },\n\n  /**\n   * simplified method to update the preauth catalog via email\n   *\n   * @param {object} query\n   * @param {string} query.email - A standard format email.\n   * @param {string} query.orgId - The user's OrgId.\n   * @param {boolean} forceRefresh - Boolean to bypass u2c cache control header\n   * @returns {Promise<void>}\n   */\n  collectPreauthCatalog(query, forceRefresh = false) {\n    if (!query) {\n      return this.updateServices({from: 'limited', query: {mode: 'DEFAULT_BY_PROXIMITY'}, forceRefresh});\n    }\n\n    return this.updateServices({from: 'limited', query, forceRefresh});\n  },\n\n  /**\n   * simplified method to update the signin catalog via email and token\n   * @param {object} param\n   * @param {string} param.email - must be a standard-format email\n   * @param {string} param.token - must be a client token\n   * @returns {Promise<void>}\n   */\n  collectSigninCatalog({email, token, forceRefresh} = {}) {\n    if (!email) {\n      return Promise.reject(new Error('`email` is required'));\n    }\n    if (!token) {\n      return Promise.reject(new Error('`token` is required'));\n    }\n\n    return this.updateServices({\n      from: 'signin', query: {email}, token, forceRefresh\n    });\n  },\n\n  /**\n   * Updates credentials config to utilize u2c catalog\n   * urls.\n   * @returns {void}\n   */\n  updateCredentialsConfig() {\n    const {idbroker, identity} = this.list(true);\n\n    if (idbroker && identity) {\n      const {authorizationString, authorizeUrl} = this.webex.config.credentials;\n\n      // This must be set outside of the setConfig method used to assign the\n      // idbroker and identity url values.\n      this.webex.config.credentials.authorizeUrl = authorizationString ?\n        authorizeUrl :\n        `${idbroker.replace(trailingSlashes, '')}/idb/oauth2/v1/authorize`;\n\n\n      this.webex.setConfig({\n        credentials: {\n          idbroker: {\n            url: idbroker.replace(trailingSlashes, '') // remove trailing slash\n          },\n          identity: {\n            url: identity.replace(trailingSlashes, '') // remove trailing slash\n          }\n        }\n      });\n    }\n  },\n\n  /**\n   * Wait until the service catalog is available,\n   * or reject afte ra timeout of 60 seconds.\n   * @param {string} serviceGroup\n   * @param {number} [timeout] - in seconds\n   * @returns {Promise<void>}\n   */\n  waitForCatalog(serviceGroup, timeout) {\n    const catalog = this._getCatalog();\n    const {supertoken} = this.webex.credentials;\n\n    if (\n      serviceGroup === 'postauth' &&\n      supertoken &&\n      supertoken.access_token &&\n      !catalog.status.postauth.collecting &&\n      !catalog.status.postauth.ready\n    ) {\n      if (!catalog.status.preauth.ready) {\n        return this.initServiceCatalogs();\n      }\n\n      return this.updateServices();\n    }\n\n    return catalog.waitForCatalog(serviceGroup, timeout);\n  },\n\n  /**\n   * Service waiting parameter transfer object for {@link waitForService}.\n   *\n   * @typedef {object} WaitForServicePTO\n   * @property {string} [WaitForServicePTO.name] - The service name.\n   * @property {string} [WaitForServicePTO.url] - The service url.\n   * @property {string} [WaitForServicePTO.timeout] - wait duration in seconds.\n   */\n\n  /**\n   * Wait until the service has been ammended to any service catalog. This\n   * method prioritizes the service name over the service url when searching.\n   *\n   * @param {WaitForServicePTO} - The parameter transfer object.\n   * @returns {Promise<string>} - Resolves to the priority host of a service.\n   */\n  waitForService({name, timeout = 5, url}) {\n    const {services} = this.webex.config;\n\n    // Save memory by grabbing the catalog after there isn't a priortyURL\n    const catalog = this._getCatalog();\n\n    const fetchFromServiceUrl = services.servicesNotNeedValidation.find((service) => service === name);\n\n    if (fetchFromServiceUrl) {\n      return Promise.resolve(this._serviceUrls[name]);\n    }\n\n    const priorityUrl = this.get(name, true);\n    const priorityUrlObj = this.getServiceFromUrl(url);\n\n    if (priorityUrl || priorityUrlObj) {\n      return Promise.resolve(priorityUrl || priorityUrlObj.priorityUrl);\n    }\n\n    if (catalog.isReady) {\n      return url ?\n        Promise.resolve(url) :\n        Promise.reject(new Error(\n          `services: service '${name}' was not found in any of the catalogs`\n        ));\n    }\n\n    return new Promise((resolve, reject) => {\n      const groupsToCheck = ['preauth', 'signin', 'postauth'];\n      const checkCatalog = (catalogGroup) =>\n        catalog.waitForCatalog(catalogGroup, timeout)\n          .then(() => {\n            const scopedPriorityUrl = this.get(name, true);\n            const scopedPrioriryUrlObj = this.getServiceFromUrl(url);\n\n            if (scopedPriorityUrl || scopedPrioriryUrlObj) {\n              resolve(scopedPriorityUrl || scopedPrioriryUrlObj.priorityUrl);\n            }\n          })\n          .catch(() => undefined);\n\n      Promise.all(groupsToCheck.map((group) => checkCatalog(group)))\n        .then(() => {\n          reject(new Error(\n            `services: service '${name}' was not found after waiting`\n          ));\n        });\n    });\n  },\n\n  /**\n   * @private\n   * Organize a received hostmap from a service\n   * catalog endpoint.\n   * @param {object} serviceHostmap\n   * @returns {object}\n   */\n  _formatReceivedHostmap(serviceHostmap) {\n    // map the host catalog items to a formatted hostmap\n    const formattedHostmap = Object.keys(serviceHostmap.hostCatalog).reduce(\n      (accumulator, key) => {\n        if (serviceHostmap.hostCatalog[key].length === 0) {\n          return accumulator;\n        }\n\n        const serviceName = serviceHostmap.hostCatalog[key][0].id.split(':')[3];\n        const defaultUrl = serviceHostmap.serviceLinks[serviceName];\n\n        let serviceItem = accumulator.find(\n          (item) => item.name === serviceName\n        );\n\n        if (!serviceItem) {\n          serviceItem = {\n            name: serviceName,\n            defaultUrl,\n            defaultHost: Url.parse(defaultUrl).hostname,\n            hosts: []\n          };\n\n          accumulator.push(serviceItem);\n        }\n\n        serviceItem.hosts.push(\n          // map the default key as a low priority default for cluster matching\n          {\n            host: key,\n            ttl: -1,\n            priority: 10,\n            id: serviceHostmap.hostCatalog[key][0].id,\n            homeCluster: serviceItem.defaultHost === key\n          },\n          // map the rest of the hosts in their proper locations\n          ...serviceHostmap.hostCatalog[key].map(\n            (host) => ({\n              ...host,\n              homeCluster: serviceItem.defaultHost === key\n            })\n          )\n        );\n\n        return accumulator;\n      }, []\n    );\n\n    // append service links that do not exist in the host catalog\n    Object.keys(serviceHostmap.serviceLinks).forEach((key) => {\n      const service = formattedHostmap.find((item) => item.name === key);\n\n      if (!service) {\n        formattedHostmap.push({\n          name: key,\n          defaultUrl: serviceHostmap.serviceLinks[key],\n          defaultHost: Url.parse(serviceHostmap.serviceLinks[key]).hostname,\n          hosts: []\n        });\n      }\n    });\n\n    // update all the service urls in the host catalog\n\n    this._updateServiceUrls(serviceHostmap.serviceLinks);\n\n    return formattedHostmap;\n  },\n\n  /**\n   * Get the clusterId associated with a URL string.\n   * @param {string} url\n   * @returns {string} - Cluster ID of url provided\n   */\n  getClusterId(url) {\n    const catalog = this._getCatalog();\n\n    return catalog.findClusterId(url);\n  },\n\n  /**\n   * Get a service value from a provided clusterId. This method will\n   * return an object containing both the name and url of a found service.\n   * @param {object} params\n   * @param {string} params.clusterId - clusterId of found service\n   * @param {boolean} [params.priorityHost] - returns priority host url if true\n   * @param {string} [params.serviceGroup] - specify service group\n   * @returns {object} service\n   * @returns {string} service.name\n   * @returns {string} service.url\n   */\n  getServiceFromClusterId(params) {\n    const catalog = this._getCatalog();\n\n    return catalog.findServiceFromClusterId(params);\n  },\n\n  /**\n   * Get a service object from a service url if the service url exists in the\n   * catalog.\n   *\n   * @param {string} url - The url to be validated.\n   * @returns {object} - Service object.\n   * @returns {object.name} - The name of the service found.\n   * @returns {object.priorityUrl} - The priority url of the found service.\n   * @returns {object.defaultUrl} - The default url of the found service.\n   */\n  getServiceFromUrl(url = '') {\n    const service = this._getCatalog().findServiceUrlFromUrl(url);\n\n    if (!service) {\n      return undefined;\n    }\n\n    return {\n      name: service.name,\n      priorityUrl: service.get(true),\n      defaultUrl: service.get()\n    };\n  },\n\n  /**\n   * Verify that a provided url exists in the service\n   * catalog.\n   * @param {string} url\n   * @returns {boolean} - true if exists, false otherwise\n   */\n  isServiceUrl(url) {\n    const catalog = this._getCatalog();\n\n    return !!(catalog.findServiceUrlFromUrl(url));\n  },\n\n  /**\n   * Determine if a provided url is in the catalog's allowed domains.\n   *\n   * @param {string} url - The url to match allowed domains against.\n   * @returns {boolean} - True if the url provided is allowed.\n   */\n  isAllowedDomainUrl(url) {\n    const catalog = this._getCatalog();\n\n    return !!(catalog.findAllowedDomain(url));\n  },\n\n  /**\n   * Converts the host portion of the url from default host\n   * to a priority host\n   *\n   * @param {string} url a service url that contains a default host\n   * @returns {string} a service url that contains the top priority host.\n   * @throws if url isn't a service url\n   */\n  convertUrlToPriorityHostUrl(url = '') {\n    const data = this.getServiceFromUrl(url);\n\n    if (!data) {\n      throw Error(`No service associated with url: [${url}]`);\n    }\n\n    return url.replace(data.defaultUrl, data.priorityUrl);\n  },\n\n  /**\n   * @private\n   * Simplified method wrapper for sending a request to get\n   * an updated service hostmap.\n   * @param {object} [param]\n   * @param {string} [param.from] - This accepts `limited` or `signin`\n   * @param {object} [param.query] - This accepts `email`, `orgId` or `userId` key values\n   * @param {string} [param.query.email] - must be a standard-format email\n   * @param {string} [param.query.orgId] - must be an organization id\n   * @param {string} [param.query.userId] - must be a user id\n   * @param {string} [param.token] - used for signin catalog\n   * @returns {Promise<object>}\n   */\n  _fetchNewServiceHostmap({\n    from, query, token, forceRefresh\n  } = {}) {\n    const service = 'u2c';\n    const resource = from ? `/${from}/catalog` : '/catalog';\n    const qs = {...query, format: 'hostmap'};\n\n    if (forceRefresh) {\n      qs.timestamp = new Date().getTime();\n    }\n\n    const requestObject = {\n      method: 'GET', service, resource, qs\n    };\n\n    if (token) {\n      requestObject.headers = {authorization: token};\n    }\n\n    return this.request(requestObject)\n      .then(({body}) => this._formatReceivedHostmap(body));\n  },\n\n  /**\n   * Initialize the discovery services and the whitelisted services.\n   *\n   * @returns {void}\n   */\n  initConfig() {\n    // Get the catalog and destructure the services config.\n    const catalog = this._getCatalog();\n    const {services} = this.webex.config;\n\n    // Validate that the services configuration exists.\n    if (services) {\n      // Check for discovery services.\n      if (services.discovery) {\n        // Format the discovery configuration into an injectable array.\n        const formattedDiscoveryServices = Object.keys(services.discovery)\n          .map((key) => ({\n            name: key,\n            defaultUrl: services.discovery[key]\n          }));\n\n        // Inject formatted discovery services into services catalog.\n        catalog.updateServiceUrls('discovery', formattedDiscoveryServices);\n      }\n\n      if (services.override) {\n        // Format the override configuration into an injectable array.\n        const formattedOverrideServices = Object.keys(services.override)\n          .map((key) => ({\n            name: key,\n            defaultUrl: services.override[key]\n          }));\n\n        // Inject formatted override services into services catalog.\n        catalog.updateServiceUrls('override', formattedOverrideServices);\n      }\n\n      // Check for allowed host domains.\n      if (services.allowedDomains) {\n        // Store the allowed domains as a property of the catalog.\n        catalog.setAllowedDomains(services.allowedDomains);\n      }\n\n      // Set `validateDomains` property to match configuration\n      this.validateDomains = services.validateDomains;\n    }\n  },\n\n  /**\n   * Make the initial requests to collect the root catalogs.\n   *\n   * @returns {Promise<void, Error>} - Errors if the token is unavailable.\n   */\n  initServiceCatalogs() {\n    this.logger.info('services: initializing initial service catalogs');\n\n    // Destructure the credentials plugin.\n    const {credentials} = this.webex;\n\n    // Init a promise chain. Must be done as a Promise.resolve() to allow\n    // credentials#getOrgId() to properly throw.\n    return Promise.resolve()\n      // Get the user's OrgId.\n      .then(() => credentials.getOrgId())\n      // Begin collecting the preauth/limited catalog.\n      .then((orgId) => this.collectPreauthCatalog({orgId}))\n      .then(() => {\n        // Validate if the token is authorized.\n        if (credentials.canAuthorize) {\n          // Attempt to collect the postauth catalog.\n          return this.updateServices()\n            .catch(() => this.logger.warn(\n              'services: cannot retrieve postauth catalog'\n            ));\n        }\n\n        // Return a resolved promise for consistent return value.\n        return Promise.resolve();\n      });\n  },\n\n  /**\n   * Initializer\n   *\n   * @instance\n   * @memberof Services\n   * @returns {Services}\n   */\n  initialize() {\n    const catalog = new ServiceCatalog();\n    const registry = new ServiceRegistry();\n    const state = new ServiceState();\n\n    this._catalogs.set(this.webex, catalog);\n    this.registries.set(this.webex, registry);\n    this.states.set(this.webex, state);\n\n    // Listen for configuration changes once.\n    this.listenToOnce(this.webex, 'change:config', () => {\n      this.initConfig();\n    });\n\n    // wait for webex instance to be ready before attempting\n    // to update the service catalogs\n    this.listenToOnce(this.webex, 'ready', () => {\n      const {supertoken} = this.webex.credentials;\n\n      // Validate if the supertoken exists.\n      if (supertoken && supertoken.access_token) {\n        this.initServiceCatalogs()\n          .then(() => {\n            catalog.isReady = true;\n          })\n          .catch((error) => this.logger.error(\n            `services: failed to init initial services, ${error.message}`\n          ));\n      }\n      else {\n        const {email} = this.webex.config;\n\n        this.collectPreauthCatalog(email ? {email} : undefined);\n      }\n    });\n  }\n});\n/* eslint-enable no-underscore-dangle */\n\nexport default Services;\n"]},"metadata":{},"sourceType":"script"}