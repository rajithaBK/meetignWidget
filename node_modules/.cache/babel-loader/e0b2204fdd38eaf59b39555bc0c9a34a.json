{"ast":null,"code":"'use strict';\n\nexports.stringToBytes = string => [...string].map(character => character.charCodeAt(0));\n/**\nChecks whether the TAR checksum is valid.\n\n@param {Buffer} buffer - The TAR header `[offset ... offset + 512]`.\n@param {number} offset - TAR header offset.\n@returns {boolean} `true` if the TAR checksum is valid, otherwise `false`.\n*/\n\n\nexports.tarHeaderChecksumMatches = function (buffer) {\n  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const readSum = parseInt(buffer.toString('utf8', 148, 154).replace(/\\0.*$/, '').trim(), 8); // Read sum in header\n\n  if (isNaN(readSum)) {\n    return false;\n  }\n\n  let sum = 8 * 0x20; // Initialize signed bit sum\n\n  for (let i = offset; i < offset + 148; i++) {\n    sum += buffer[i];\n  }\n\n  for (let i = offset + 156; i < offset + 512; i++) {\n    sum += buffer[i];\n  }\n\n  return readSum === sum;\n};\n/**\nID3 UINT32 sync-safe tokenizer token.\n28 bits (representing up to 256MB) integer, the msb is 0 to avoid \"false syncsignals\".\n*/\n\n\nexports.uint32SyncSafeToken = {\n  get: (buffer, offset) => {\n    return buffer[offset + 3] & 0x7F | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21;\n  },\n  len: 4\n};","map":{"version":3,"sources":["C:/Users/rkanthet/Documents/test_window_object/node_modules/file-type/util.js"],"names":["exports","stringToBytes","string","map","character","charCodeAt","tarHeaderChecksumMatches","buffer","offset","readSum","parseInt","toString","replace","trim","isNaN","sum","i","uint32SyncSafeToken","get","len"],"mappings":"AAAA;;AAEAA,OAAO,CAACC,aAAR,GAAwBC,MAAM,IAAI,CAAC,GAAGA,MAAJ,EAAYC,GAAZ,CAAgBC,SAAS,IAAIA,SAAS,CAACC,UAAV,CAAqB,CAArB,CAA7B,CAAlC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAL,OAAO,CAACM,wBAAR,GAAmC,UAACC,MAAD,EAAwB;AAAA,MAAfC,MAAe,uEAAN,CAAM;AAC1D,QAAMC,OAAO,GAAGC,QAAQ,CAACH,MAAM,CAACI,QAAP,CAAgB,MAAhB,EAAwB,GAAxB,EAA6B,GAA7B,EAAkCC,OAAlC,CAA0C,OAA1C,EAAmD,EAAnD,EAAuDC,IAAvD,EAAD,EAAgE,CAAhE,CAAxB,CAD0D,CACkC;;AAC5F,MAAIC,KAAK,CAACL,OAAD,CAAT,EAAoB;AACnB,WAAO,KAAP;AACA;;AAED,MAAIM,GAAG,GAAG,IAAI,IAAd,CAN0D,CAMtC;;AAEpB,OAAK,IAAIC,CAAC,GAAGR,MAAb,EAAqBQ,CAAC,GAAGR,MAAM,GAAG,GAAlC,EAAuCQ,CAAC,EAAxC,EAA4C;AAC3CD,IAAAA,GAAG,IAAIR,MAAM,CAACS,CAAD,CAAb;AACA;;AAED,OAAK,IAAIA,CAAC,GAAGR,MAAM,GAAG,GAAtB,EAA2BQ,CAAC,GAAGR,MAAM,GAAG,GAAxC,EAA6CQ,CAAC,EAA9C,EAAkD;AACjDD,IAAAA,GAAG,IAAIR,MAAM,CAACS,CAAD,CAAb;AACA;;AAED,SAAOP,OAAO,KAAKM,GAAnB;AACA,CAjBD;AAmBA;AACA;AACA;AACA;;;AACAf,OAAO,CAACiB,mBAAR,GAA8B;AAC7BC,EAAAA,GAAG,EAAE,CAACX,MAAD,EAASC,MAAT,KAAoB;AACxB,WAAQD,MAAM,CAACC,MAAM,GAAG,CAAV,CAAN,GAAqB,IAAtB,GAAgCD,MAAM,CAACC,MAAM,GAAG,CAAV,CAAP,IAAwB,CAAvD,GAA8DD,MAAM,CAACC,MAAM,GAAG,CAAV,CAAP,IAAwB,EAArF,GAA6FD,MAAM,CAACC,MAAD,CAAP,IAAoB,EAAvH;AACA,GAH4B;AAI7BW,EAAAA,GAAG,EAAE;AAJwB,CAA9B","sourcesContent":["'use strict';\n\nexports.stringToBytes = string => [...string].map(character => character.charCodeAt(0));\n\n/**\nChecks whether the TAR checksum is valid.\n\n@param {Buffer} buffer - The TAR header `[offset ... offset + 512]`.\n@param {number} offset - TAR header offset.\n@returns {boolean} `true` if the TAR checksum is valid, otherwise `false`.\n*/\nexports.tarHeaderChecksumMatches = (buffer, offset = 0) => {\n\tconst readSum = parseInt(buffer.toString('utf8', 148, 154).replace(/\\0.*$/, '').trim(), 8); // Read sum in header\n\tif (isNaN(readSum)) {\n\t\treturn false;\n\t}\n\n\tlet sum = 8 * 0x20; // Initialize signed bit sum\n\n\tfor (let i = offset; i < offset + 148; i++) {\n\t\tsum += buffer[i];\n\t}\n\n\tfor (let i = offset + 156; i < offset + 512; i++) {\n\t\tsum += buffer[i];\n\t}\n\n\treturn readSum === sum;\n};\n\n/**\nID3 UINT32 sync-safe tokenizer token.\n28 bits (representing up to 256MB) integer, the msb is 0 to avoid \"false syncsignals\".\n*/\nexports.uint32SyncSafeToken = {\n\tget: (buffer, offset) => {\n\t\treturn (buffer[offset + 3] & 0x7F) | ((buffer[offset + 2]) << 7) | ((buffer[offset + 1]) << 14) | ((buffer[offset]) << 21);\n\t},\n\tlen: 4\n};\n"]},"metadata":{},"sourceType":"script"}