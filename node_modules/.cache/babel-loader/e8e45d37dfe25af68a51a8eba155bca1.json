{"ast":null,"code":"\"use strict\";\n\nvar _Reflect$construct = require(\"@babel/runtime-corejs2/core-js/reflect/construct\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/createClass\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/getPrototypeOf\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/defineProperty\"));\n\nvar _isEmpty2 = _interopRequireDefault(require(\"lodash/isEmpty\"));\n\nvar _webexCore = require(\"@webex/webex-core\");\n\nvar _constants = require(\"../constants\");\n\nvar _triggerProxy = _interopRequireDefault(require(\"../common/events/trigger-proxy\"));\n\nvar _member = _interopRequireDefault(require(\"../member\"));\n\nvar _loggerProxy = _interopRequireDefault(require(\"../common/logs/logger-proxy\"));\n\nvar _parameter = _interopRequireDefault(require(\"../common/errors/parameter\"));\n\nvar _collection = _interopRequireDefault(require(\"./collection\"));\n\nvar _request = _interopRequireDefault(require(\"./request\"));\n\nvar _util = _interopRequireDefault(require(\"./util\"));\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2.default)(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;\n      result = _Reflect$construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0, _possibleConstructorReturn2.default)(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false;\n  if (_Reflect$construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n   * Members Update Event\n   * Emitted when something in the roster list needs to be updated\n   * @event members:update\n   * @instance\n   * @property {Object} delta the changes to the members list\n   * @property {Array} delta.updated array only the updates, includes removals, as they will have updated status and member properties\n   * @property {Array} delta.added array added members to the meeting\n   * @property {Array} full array the full members collection\n   * @memberof Members\n   */\n\n/**\n   * Members Content Update Event\n   * Emitted when who is sharing changes\n   * @event members:content:update\n   * @instance\n   * @property {String} activeContentSharingId\n   * @property {String} endedContentSharingId\n   * @memberof Members\n   */\n\n/**\n   * Members Host Update Event\n   * Emitted when who is the host changes\n   * @event members:host:update\n   * @instance\n   * @property {String} activeHostId\n   * @property {String} endedHostId\n   * @memberof Members\n   */\n\n/**\n   * Members Self Update Event\n   * Emitted when who is the self changes\n   * @event members:self:update\n   * @instance\n   * @property {String} activeSelfId\n   * @property {String} endedSelfId\n   * @memberof Members\n   */\n\n/**\n * @class Members\n */\n\n\nvar Members = /*#__PURE__*/function (_StatelessWebexPlugin) {\n  (0, _inherits2.default)(Members, _StatelessWebexPlugin);\n\n  var _super = _createSuper(Members);\n  /**\n   *\n   * @param {Object} attrs\n   * @param {Object} options\n   * @memberof Members\n   */\n\n\n  function Members(attrs, options) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, Members);\n    _this = _super.call(this, {}, options);\n    /**\n     * The Members Request object to interact with server\n     * @instance\n     * @type {MembersRequest}\n     * @private\n     * @memberof Members\n    */\n\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), \"namespace\", _constants.MEETINGS);\n    _this.membersRequest = new _request.default({}, options);\n    /**\n     * The Members Collection cache\n     * @instance\n     * @type {MembersCollection}\n     * @private\n     * @memberof Members\n    */\n\n    _this.membersCollection = new _collection.default();\n    /**\n     * The current locus url for the active meeting\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n\n    _this.locusUrl = attrs.locusUrl || null;\n    /**\n     * The current hostId for the meeting\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n\n    _this.hostId = null;\n    /**\n     * The current type for the meeting, could be MEETING or CALL\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n\n    _this.type = null;\n    /**\n     * Locus has a self object, sent individually to the client\n     * i.e., each person in the call gets their own self object from locus.\n     * We need to maintain that self object, because we also get information about all the participants\n     * and differentiate those participants from self.\n     * The self id shouldnt ever change, but it does have properties that will change\n     * and we use values in locus-info, such as to determine if i am admitted to the meeting or not as guest.\n     * The current selfId for the meeting\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n\n    _this.selfId = null;\n    /**\n     * The current mediaShareContentId for the meeting\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n\n    _this.mediaShareContentId = null;\n    /**\n     * The current mediaShareWhiteboardId for the meeting\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n\n    _this.mediaShareWhiteboardId = null;\n    /**\n     * The current recordingId for the meeting, if it exists\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n\n    _this.recordingId = null;\n    return _this;\n  }\n  /**\n   * Internal update the self Id value\n   * @param {Object} payload\n   * @param {Object} payload.newSelf\n   * @param {Object} payload.oldSelf\n   * @returns {undefined}\n   * @private\n   * @memberof Members\n   */\n\n\n  (0, _createClass2.default)(Members, [{\n    key: \"locusSelfUpdate\",\n    value: function locusSelfUpdate(payload) {\n      var newSelfId = null;\n      var oldSelfId = null;\n\n      if (payload) {\n        if (payload.newSelf) {\n          newSelfId = payload.newSelf.id;\n        }\n\n        if (payload.oldSelf) {\n          oldSelfId = payload.oldSelf.id;\n        }\n      }\n\n      if (newSelfId) {\n        var theSelf = this.membersCollection.get(newSelfId);\n\n        if (theSelf) {\n          theSelf.setIsSelf(true);\n        }\n      }\n\n      if (oldSelfId) {\n        var notSelf = this.membersCollection.get(oldSelfId);\n\n        if (notSelf) {\n          notSelf.setIsSelf(false);\n        }\n      }\n\n      this.selfId = newSelfId;\n\n      _triggerProxy.default.trigger(this, {\n        file: 'members',\n        function: 'locusSelfUpdate'\n      }, _constants.EVENT_TRIGGERS.MEMBERS_SELF_UPDATE, {\n        activeSelfId: newSelfId,\n        endedSelfId: oldSelfId\n      });\n    }\n    /**\n     * Internal update the hostId value\n     * @param {Object} payload\n     * @param {Object} payload.newHost\n     * @param {Object} payload.oldHost\n     * @returns {undefined}\n     * @private\n     * @memberof Members\n     */\n\n  }, {\n    key: \"locusHostUpdate\",\n    value: function locusHostUpdate(payload) {\n      var newHostId = null;\n      var oldHostId = null;\n\n      if (payload) {\n        if (payload.newHost) {\n          newHostId = payload.newHost.id;\n        }\n\n        if (payload.oldHost) {\n          oldHostId = payload.oldHost.id;\n        }\n      }\n\n      if (newHostId) {\n        var theHost = this.membersCollection.get(newHostId);\n\n        if (theHost) {\n          theHost.setIsHost(true);\n        }\n      }\n\n      if (oldHostId) {\n        var notHost = this.membersCollection.get(oldHostId);\n\n        if (notHost) {\n          notHost.setIsHost(false);\n        }\n      }\n\n      this.hostId = newHostId;\n\n      _triggerProxy.default.trigger(this, {\n        file: 'members',\n        function: 'locusHostUpdate'\n      }, _constants.EVENT_TRIGGERS.MEMBERS_HOST_UPDATE, {\n        activeHostId: newHostId,\n        endedHostId: oldHostId\n      });\n    }\n    /**\n     * when new participant updates come in, both delta and full participants, update them in members collection\n     * delta object in the event will have {updated, added} and full will be the full membersCollection\n     * @param {Object} payload\n     * @param {Object} payload.participants\n     * @returns {undefined}\n     * @private\n     * @memberof Members\n     */\n\n  }, {\n    key: \"locusParticipantsUpdate\",\n    value: function locusParticipantsUpdate(payload) {\n      if (payload) {\n        var delta = this.handleLocusInfoUpdatedParticipants(payload);\n        var full = this.handleMembersUpdate(delta); // SDK should propagate the full list for both delta and non delta updates\n\n        _triggerProxy.default.trigger(this, {\n          file: 'members',\n          function: 'locusParticipantsUpdate'\n        }, _constants.EVENT_TRIGGERS.MEMBERS_UPDATE, {\n          delta: delta,\n          full: full\n        });\n      }\n    }\n    /**\n     * Internal update the content id\n     * @param {Object} payload\n     * @param {Object} payload.current\n     * @param {Object} payload.previous\n     * @returns {undefined}\n     * @private\n     * @memberof Members\n     */\n\n  }, {\n    key: \"locusMediaSharesUpdate\",\n    value: function locusMediaSharesUpdate(payload) {\n      var _payload$current, _payload$previous, _payload$current2, _payload$previous2;\n\n      var currentContent = (_payload$current = payload.current) === null || _payload$current === void 0 ? void 0 : _payload$current.content;\n      var previousContent = (_payload$previous = payload.previous) === null || _payload$previous === void 0 ? void 0 : _payload$previous.content;\n      var currentWhiteboard = (_payload$current2 = payload.current) === null || _payload$current2 === void 0 ? void 0 : _payload$current2.whiteboard;\n      var previousWhiteboard = (_payload$previous2 = payload.previous) === null || _payload$previous2 === void 0 ? void 0 : _payload$previous2.whiteboard;\n      var whoSharing = null;\n      var whoStopped = null;\n\n      if (currentContent !== null && currentContent !== void 0 && currentContent.beneficiaryId) {\n        if (currentContent.disposition === _constants.FLOOR_ACTION.GRANTED) {\n          whoSharing = currentContent.beneficiaryId;\n          this.mediaShareWhiteboardId = null;\n          this.mediaShareContentId = whoSharing;\n        }\n\n        if ((previousContent === null || previousContent === void 0 ? void 0 : previousContent.disposition) === _constants.FLOOR_ACTION.GRANTED) {\n          if (currentContent.disposition === _constants.FLOOR_ACTION.RELEASED) {\n            whoStopped = currentContent.beneficiaryId;\n            this.mediaShareContentId = null;\n          } else if (currentContent.disposition === _constants.FLOOR_ACTION.GRANTED && currentContent.beneficiaryId !== previousContent.beneficiaryId) {\n            whoStopped = previousContent.beneficiaryId;\n          }\n        }\n      }\n\n      if (currentWhiteboard !== null && currentWhiteboard !== void 0 && currentWhiteboard.beneficiaryId) {\n        if (currentWhiteboard.disposition === _constants.FLOOR_ACTION.GRANTED) {\n          whoSharing = currentWhiteboard.beneficiaryId;\n          this.mediaShareContentId = null;\n          this.mediaShareWhiteboardId = whoSharing;\n        }\n\n        if ((previousWhiteboard === null || previousWhiteboard === void 0 ? void 0 : previousWhiteboard.disposition) === _constants.FLOOR_ACTION.GRANTED) {\n          if (currentWhiteboard.disposition === _constants.FLOOR_ACTION.RELEASED) {\n            whoStopped = currentWhiteboard.beneficiaryId;\n            this.mediaShareWhiteboardId = null;\n          } else if (currentWhiteboard.disposition === _constants.FLOOR_ACTION.GRANTED && currentWhiteboard.beneficiaryId !== previousWhiteboard.beneficiaryId) {\n            whoStopped = previousWhiteboard.beneficiaryId;\n          }\n        }\n      }\n\n      if (whoSharing) {\n        var shareMember = this.membersCollection.get(whoSharing);\n\n        if (shareMember) {\n          shareMember.setIsContentSharing(true);\n        }\n      }\n\n      if (whoStopped) {\n        var stopMember = this.membersCollection.get(whoStopped);\n\n        if (stopMember) {\n          stopMember.setIsContentSharing(false);\n        }\n      }\n\n      _triggerProxy.default.trigger(this, {\n        file: 'members',\n        function: 'locusMediaSharesUpdate'\n      }, _constants.EVENT_TRIGGERS.MEMBERS_CONTENT_UPDATE, {\n        activeSharingId: whoSharing,\n        endedSharingId: whoStopped\n      });\n    }\n    /**\n     * Internal update the locus url value\n     * @param {Object} payload\n     * @param {String} payload.locusUrl\n     * @returns {undefined}\n     * @private\n     * @memberof Members\n     */\n\n  }, {\n    key: \"locusUrlUpdate\",\n    value: function locusUrlUpdate(payload) {\n      if (payload) {\n        this.setLocusUrl(null, payload);\n      }\n    }\n    /**\n     * Internal update the type of meeting\n     * @param {Object} payload\n     * @param {String} payload.type\n     * @returns {undefined}\n     * @private\n     * @memberof Members\n     */\n\n  }, {\n    key: \"locusFullStateTypeUpdate\",\n    value: function locusFullStateTypeUpdate(payload) {\n      // TODO: at some point there could be a timing issue here, for updating each member\n      // ie., if the type changes AND there is no locus update, then each member will not know the type of call\n      // which means they cannot determine isMutable && isRemovable\n      // for now this scenario is impossible to occur since we always get a locus update when the type changes\n      // except for in delta locus meetings, but in that case, the type will always have been set differently\n      // from the outset anyway\n      if (payload) {\n        this.setType(payload);\n      }\n    }\n    /**\n     * sets values in the members collection for updated and added properties from delta\n     * @param {Object} membersUpdate {updated: [], added: []}\n     * @returns {Object} membersCollection\n     * @private\n     * @memberof Members\n     */\n\n  }, {\n    key: \"handleMembersUpdate\",\n    value: function handleMembersUpdate(membersUpdate) {\n      if (membersUpdate) {\n        if (membersUpdate.updated) {\n          this.constructMembers(membersUpdate.updated);\n        }\n\n        if (membersUpdate.added) {\n          this.constructMembers(membersUpdate.added);\n        }\n      }\n\n      return this.membersCollection.getAll();\n    }\n    /**\n     * set members to the member collection from each updated/added lists as passed in\n     * @param {Array} list\n     * @returns {undefined}\n     * @private\n     * @memberof Members\n     */\n\n  }, {\n    key: \"constructMembers\",\n    value: function constructMembers(list) {\n      var _this2 = this;\n\n      list.forEach(function (member) {\n        _this2.membersCollection.set(member.id, member);\n      });\n    }\n    /**\n     * Internal update the participants value\n     * @param {Object} payload\n     * @returns {Object}\n     * @private\n     * @memberof Members\n     */\n\n  }, {\n    key: \"handleLocusInfoUpdatedParticipants\",\n    value: function handleLocusInfoUpdatedParticipants(payload) {\n      this.hostId = payload.hostId || this.hostId;\n      this.selfId = payload.selfId || this.selfId;\n      this.recordingId = payload.recordingId;\n\n      if (!payload.participants) {\n        _loggerProxy.default.logger.warn('Members:index#handleLocusInfoUpdatedParticipants --> participants payload is missing.');\n      }\n\n      var memberUpdate = this.update(payload.participants);\n      return memberUpdate;\n    }\n    /**\n     * Update the locus Url\n     * @param {Object} locus\n     * @param {String} [locusUrl] optional, takes precedence\n     * @throws {ParameterError}\n     * @returns {undefined}\n     * @public\n     * @memberof Members\n     */\n\n  }, {\n    key: \"setLocusUrl\",\n    value: function setLocusUrl(locus) {\n      var locusUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (locusUrl) {\n        this.locusUrl = locusUrl;\n      } else if (locus && (locus.locusUrl || locus.url)) {\n        this.locusUrl = locus.locusUrl || locus.url;\n      } else {\n        throw new _parameter.default('Setting locusUrl for the Members module should be done with a locus object or locusUrl');\n      }\n    }\n    /**\n     * Update the host id\n     * @param {Object} locus\n     * @param {String} [hostId] optional, takes precedence\n     * @throws {ParameterError}\n     * @returns {undefined}\n     * @public\n     * @memberof Members\n     */\n\n  }, {\n    key: \"setHostId\",\n    value: function setHostId(locus) {\n      var hostId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (hostId) {\n        this.hostId = hostId;\n      } else if (locus) {\n        this.hostId = locus && locus.owner && locus.owner.info ? locus.owner.info : null;\n      } else {\n        throw new _parameter.default('Setting hostid for the Members module should be done with a locus object or hostId');\n      }\n    }\n    /**\n     * Update the type\n     * @param {Object} fullState\n     * @param {String} [type] optional, takes precedence\n     * @throws {ParameterError}\n     * @returns {undefined}\n     * @public\n     * @memberof Members\n     */\n\n  }, {\n    key: \"setType\",\n    value: function setType(fullState) {\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (type) {\n        this.type = type;\n      } else if (fullState) {\n        this.type = fullState && fullState.type || null;\n      } else {\n        throw new _parameter.default('Setting type for the Members module should be done with a fullstate object or type string');\n      }\n    }\n    /**\n     * Update the self Id\n     * @param {Object} locus\n     * @param {String} [selfId] optional, takes precedence\n     * @throws {Error}\n     * @returns {undefined}\n     * @memberof Members\n     */\n\n  }, {\n    key: \"setSelfId\",\n    value: function setSelfId(locus) {\n      var selfId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (selfId) {\n        this.selfId = selfId;\n      } else if (locus) {\n        this.selfId = locus && locus.self && locus.self.person && locus.self.person.id ? locus.self.person.id : null;\n      } else {\n        throw new _parameter.default('Setting selfid for the Members module should be done with a locus object or selfId');\n      }\n    }\n    /**\n     * Update the media share content id\n     * @param {Object} locus\n     * @param {String} [contentId] optional, takes precedence\n     * @throws {Error}\n     * @returns {undefined}\n     * @memberof Members\n     */\n\n  }, {\n    key: \"setMediaShareContentId\",\n    value: function setMediaShareContentId(locus, contentId) {\n      if (contentId) {\n        this.mediaShareContentId = contentId;\n      } else if (locus) {\n        var contentMediaShare = locus.mediaShares && locus.mediaShares.length && locus.mediaShares.find(function (mediaShare) {\n          return mediaShare.name === _constants.CONTENT;\n        });\n        this.mediaShareContentId = contentMediaShare && contentMediaShare.floor && contentMediaShare.floor.beneficiary && contentMediaShare.floor.beneficiary.id || null;\n      } else {\n        throw new _parameter.default('Setting hostid for the Members module should be done with a locus object or hostId');\n      }\n    }\n    /**\n     * Update the media share whiteboard id\n     * @param {Object} locus\n     * @param {String} [whiteboardId] optional, takes precedence\n     * @throws {Error}\n     * @returns {undefined}\n     * @memberof Members\n     */\n\n  }, {\n    key: \"setMediaShareWhiteboardId\",\n    value: function setMediaShareWhiteboardId(locus, whiteboardId) {\n      if (whiteboardId) {\n        this.mediaShareWhiteboardId = whiteboardId;\n      } else if (locus) {\n        var whiteboardMediaShare = locus.mediaShares && locus.mediaShares.length && locus.mediaShares.find(function (mediaShare) {\n          return mediaShare.name === _constants.WHITEBOARD;\n        });\n        this.mediaShareWhiteboardId = whiteboardMediaShare && whiteboardMediaShare.floor && whiteboardMediaShare.floor.beneficiary && whiteboardMediaShare.floor.beneficiary.id || null;\n      } else {\n        throw new _parameter.default('Setting hostid for the Members module should be done with a locus object or hostId');\n      }\n    }\n    /**\n     * Find all the updates, and added members\n     * Removed/left members will end up in updates\n     * Each array contains only members\n     * @param {Array} participants the locus participants\n     * @returns {Object} {added: {Array}, updated: {Array}}\n     * @private\n     * @memberof Members\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(participants) {\n      var _this3 = this;\n\n      var membersUpdate = {\n        added: [],\n        updated: []\n      };\n\n      if (participants) {\n        participants.forEach(function (participant) {\n          if (participant.hideInRoster) {\n            return;\n          }\n\n          var existing = _this3.membersCollection.get(participant.id);\n\n          if (existing) {\n            // TODO: compare existing member to new participant coming in properties and determine if updated (this helps for non delta events)\n            // on client re renders, but we will have to determine what values to compare to determine difference, premature optimization\n            membersUpdate.updated.push(new _member.default(participant, {\n              recordingId: _this3.recordingId,\n              selfId: _this3.selfId,\n              hostId: _this3.hostId,\n              contentSharingId: _this3.mediaShareContentId,\n              whiteboardSharingId: _this3.mediaShareWhiteboardId,\n              type: _this3.type\n            }));\n          } else {\n            membersUpdate.added.push(new _member.default(participant, {\n              recordingId: _this3.recordingId,\n              selfId: _this3.selfId,\n              hostId: _this3.hostId,\n              contentSharingId: _this3.mediaShareContentId,\n              whiteboardSharingId: _this3.mediaShareWhiteboardId,\n              type: _this3.type\n            }));\n          }\n        });\n      }\n\n      return membersUpdate;\n    }\n    /**\n     * Adds a guest Member to the associated meeting\n     * @param {String} invitee\n     * @param {Boolean} [alertIfActive]\n     * @returns {Promise}\n     * @memberof Members\n     */\n\n  }, {\n    key: \"addMember\",\n    value: function addMember(invitee, alertIfActive) {\n      if (!this.locusUrl) {\n        return _promise.default.reject(new _parameter.default('The associated locus url for this meeting object must be defined.'));\n      }\n\n      if (_util.default.isInvalidInvitee(invitee)) {\n        return _promise.default.reject(new _parameter.default('The invitee must be defined with either a valid email, emailAddress or phoneNumber property.'));\n      }\n\n      var options = _util.default.generateAddMemberOptions(invitee, this.locusUrl, alertIfActive);\n\n      return this.membersRequest.addMembers(options);\n    }\n    /**\n     * Cancels an outgoing PSTN call to the associated meeting\n     * @param {String} invitee\n     * @returns {Promise}\n     * @memberof Members\n     */\n\n  }, {\n    key: \"cancelPhoneInvite\",\n    value: function cancelPhoneInvite(invitee) {\n      if (!this.locusUrl) {\n        return _promise.default.reject(new _parameter.default('The associated locus url for this meeting object must be defined.'));\n      }\n\n      if (_util.default.isInvalidInvitee(invitee)) {\n        return _promise.default.reject(new _parameter.default('The invitee must be defined with a valid phoneNumber property.'));\n      }\n\n      var options = _util.default.cancelPhoneInviteOptions(invitee, this.locusUrl);\n\n      return this.membersRequest.cancelPhoneInvite(options);\n    }\n    /**\n     * Admits waiting members (invited guests to meeting)\n     * @param {Array} memberIds\n     * @returns {Promise}\n     * @public\n     * @memberof Members\n     */\n\n  }, {\n    key: \"admitMembers\",\n    value: function admitMembers(memberIds) {\n      if ((0, _isEmpty2.default)(memberIds)) {\n        return _promise.default.reject(new _parameter.default('No member ids provided to admit.'));\n      }\n\n      var options = _util.default.generateAdmitMemberOptions(memberIds, this.locusUrl);\n\n      return this.membersRequest.admitMember(options);\n    }\n    /**\n     * Removes a member from the meeting\n     * @param {String} memberId\n     * @returns {Promise}\n     * @public\n     * @memberof Members\n     */\n\n  }, {\n    key: \"removeMember\",\n    value: function removeMember(memberId) {\n      if (!this.locusUrl) {\n        return _promise.default.reject(new _parameter.default('The associated locus url for this meeting object must be defined.'));\n      }\n\n      if (!memberId) {\n        return _promise.default.reject(new _parameter.default('The member id must be defined to remove the member.'));\n      }\n\n      var options = _util.default.generateRemoveMemberOptions(memberId, this.locusUrl);\n\n      return this.membersRequest.removeMember(options);\n    }\n    /**\n     * Audio mutes another member in a meeting\n     * @param {String} memberId\n     * @param {boolean} [mute] default true\n     * @returns {Promise}\n     * @public\n     * @memberof Members\n     */\n\n  }, {\n    key: \"muteMember\",\n    value: function muteMember(memberId) {\n      var mute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (!this.locusUrl) {\n        return _promise.default.reject(new _parameter.default('The associated locus url for this meetings members object must be defined.'));\n      }\n\n      if (!memberId) {\n        return _promise.default.reject(new _parameter.default('The member id must be defined to mute the member.'));\n      }\n\n      var options = _util.default.generateMuteMemberOptions(memberId, mute, this.locusUrl);\n\n      return this.membersRequest.muteMember(options);\n    }\n    /**\n     * Transfers the host to another member\n     * @param {String} memberId\n     * @param {boolean} [moderator] default true\n     * @returns {Promise}\n     * @public\n     * @memberof Members\n     */\n\n  }, {\n    key: \"transferHostToMember\",\n    value: function transferHostToMember(memberId) {\n      var moderator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (!this.locusUrl) {\n        return _promise.default.reject(new _parameter.default('The associated locus url for this meetings members object must be defined.'));\n      }\n\n      if (!memberId) {\n        return _promise.default.reject(new _parameter.default('The member id must be defined to transfer host to the member.'));\n      }\n\n      var options = _util.default.generateTransferHostMemberOptions(memberId, moderator, this.locusUrl);\n\n      return this.membersRequest.transferHostToMember(options);\n    }\n    /**\n     * Sends DTMF tones for the PSTN member of a meeting\n     * @param {String} tones a string of one or more DTMF tones to send\n     * @param {String} memberId member id\n     * @returns {Promise}\n     * @public\n     * @memberof Members\n     */\n\n  }, {\n    key: \"sendDialPadKey\",\n    value: function sendDialPadKey() {\n      var tones = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      var memberId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n      if (!tones && tones !== 0) {\n        return _promise.default.reject(new _parameter.default('DMTF tones must be passed in'));\n      }\n\n      var member = this.membersCollection.get(memberId);\n\n      if (!member) {\n        return _promise.default.reject(new _parameter.default('there is no member associated with that Id'));\n      }\n\n      var locusUrl = this.locusUrl;\n      var deviceArray = member.participant.devices;\n      var device = deviceArray.find(function (_ref) {\n        var deviceType = _ref.deviceType;\n        return deviceType === 'SIP';\n      });\n      var url = device === null || device === void 0 ? void 0 : device.url;\n\n      if (locusUrl && url) {\n        var options = _util.default.genderateSendDTMFOptions(url, tones, memberId, locusUrl);\n\n        return this.membersRequest.sendDialPadKey(options);\n      }\n\n      return _promise.default.reject(new Error('Members:index#sendDialPadKey --> cannot send DTMF, meeting does not have a connection to the \"locus\" call control service.'));\n    }\n  }]);\n  return Members;\n}(_webexCore.StatelessWebexPlugin);\n\nexports.default = Members;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;IACqBA,O;;;;AAGnB;AACF;AACA;AACA;AACA;AACA;;;AACE,mBAAYC,KAAZ,EAAmBC,OAAnB,EAA4B;AAAA;;AAAA;AAC1BC,8BAAM,EAAN,EAAUD,OAAV;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AAR8B,4FARhBE,mBAQgB;AAS1BD,UAAKE,cAAL,GAAsB,IAAIC,gBAAJ,CAAmB,EAAnB,EAAuBJ,OAAvB,CAAtB;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIC,UAAKI,iBAAL,GAAyB,IAAIC,mBAAJ,EAAzB;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIL,UAAKM,QAAL,GAAgBR,KAAK,CAACQ,QAANR,IAAkB,IAAlC;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIE,UAAKO,MAAL,GAAc,IAAd;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIP,UAAKQ,IAAL,GAAY,IAAZ;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACIR,UAAKS,MAAL,GAAc,IAAd;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIT,UAAKU,mBAAL,GAA2B,IAA3B;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIV,UAAKW,sBAAL,GAA8B,IAA9B;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIX,UAAKY,WAAL,GAAmB,IAAnB;AA/E0B;AAgF3B;AAED;AACF;AACA;AACA;AACA;AACA;A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","names":["Members","attrs","options","_this","MEETINGS","membersRequest","MembersRequest","membersCollection","MembersCollection","locusUrl","hostId","type","selfId","mediaShareContentId","mediaShareWhiteboardId","recordingId","payload","newSelfId","oldSelfId","newSelf","id","oldSelf","theSelf","get","setIsSelf","notSelf","Trigger","trigger","file","function","EVENT_TRIGGERS","MEMBERS_SELF_UPDATE","activeSelfId","endedSelfId","newHostId","oldHostId","newHost","oldHost","theHost","setIsHost","notHost","MEMBERS_HOST_UPDATE","activeHostId","endedHostId","delta","handleLocusInfoUpdatedParticipants","full","handleMembersUpdate","MEMBERS_UPDATE","currentContent","current","_payload$current","content","previousContent","previous","_payload$previous","currentWhiteboard","_payload$current2","whiteboard","previousWhiteboard","_payload$previous2","whoSharing","whoStopped","beneficiaryId","disposition","FLOOR_ACTION","GRANTED","RELEASED","shareMember","setIsContentSharing","stopMember","MEMBERS_CONTENT_UPDATE","activeSharingId","endedSharingId","setLocusUrl","setType","membersUpdate","updated","constructMembers","added","getAll","list","forEach","member","_this2","set","participants","LoggerProxy","logger","warn","memberUpdate","update","locus","url","ParameterError","owner","info","fullState","self","person","contentId","contentMediaShare","mediaShares","length","find","mediaShare","name","CONTENT","floor","beneficiary","whiteboardId","whiteboardMediaShare","WHITEBOARD","participant","hideInRoster","existing","_this3","push","Member","contentSharingId","whiteboardSharingId","invitee","alertIfActive","_promise","reject","MembersUtil","isInvalidInvitee","generateAddMemberOptions","addMembers","cancelPhoneInviteOptions","cancelPhoneInvite","memberIds","generateAdmitMemberOptions","admitMember","memberId","generateRemoveMemberOptions","removeMember","mute","generateMuteMemberOptions","muteMember","moderator","generateTransferHostMemberOptions","transferHostToMember","tones","deviceArray","devices","device","deviceType","genderateSendDTMFOptions","sendDialPadKey","Error","StatelessWebexPlugin"],"sources":["index.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\nimport {isEmpty} from 'lodash';\nimport {StatelessWebexPlugin} from '@webex/webex-core';\n\nimport {MEETINGS, EVENT_TRIGGERS, FLOOR_ACTION, CONTENT, WHITEBOARD} from '../constants';\nimport Trigger from '../common/events/trigger-proxy';\nimport Member from '../member';\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport ParameterError from '../common/errors/parameter';\n\nimport MembersCollection from './collection';\nimport MembersRequest from './request';\nimport MembersUtil from './util';\n\n/**\n   * Members Update Event\n   * Emitted when something in the roster list needs to be updated\n   * @event members:update\n   * @instance\n   * @property {Object} delta the changes to the members list\n   * @property {Array} delta.updated array only the updates, includes removals, as they will have updated status and member properties\n   * @property {Array} delta.added array added members to the meeting\n   * @property {Array} full array the full members collection\n   * @memberof Members\n   */\n\n/**\n   * Members Content Update Event\n   * Emitted when who is sharing changes\n   * @event members:content:update\n   * @instance\n   * @property {String} activeContentSharingId\n   * @property {String} endedContentSharingId\n   * @memberof Members\n   */\n\n/**\n   * Members Host Update Event\n   * Emitted when who is the host changes\n   * @event members:host:update\n   * @instance\n   * @property {String} activeHostId\n   * @property {String} endedHostId\n   * @memberof Members\n   */\n\n/**\n   * Members Self Update Event\n   * Emitted when who is the self changes\n   * @event members:self:update\n   * @instance\n   * @property {String} activeSelfId\n   * @property {String} endedSelfId\n   * @memberof Members\n   */\n\n/**\n * @class Members\n */\nexport default class Members extends StatelessWebexPlugin {\n  namespace = MEETINGS;\n\n  /**\n   *\n   * @param {Object} attrs\n   * @param {Object} options\n   * @memberof Members\n   */\n  constructor(attrs, options) {\n    super({}, options);\n    /**\n     * The Members Request object to interact with server\n     * @instance\n     * @type {MembersRequest}\n     * @private\n     * @memberof Members\n    */\n    this.membersRequest = new MembersRequest({}, options);\n    /**\n     * The Members Collection cache\n     * @instance\n     * @type {MembersCollection}\n     * @private\n     * @memberof Members\n    */\n    this.membersCollection = new MembersCollection();\n    /**\n     * The current locus url for the active meeting\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n    this.locusUrl = attrs.locusUrl || null;\n    /**\n     * The current hostId for the meeting\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n    this.hostId = null;\n    /**\n     * The current type for the meeting, could be MEETING or CALL\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n    this.type = null;\n    /**\n     * Locus has a self object, sent individually to the client\n     * i.e., each person in the call gets their own self object from locus.\n     * We need to maintain that self object, because we also get information about all the participants\n     * and differentiate those participants from self.\n     * The self id shouldnt ever change, but it does have properties that will change\n     * and we use values in locus-info, such as to determine if i am admitted to the meeting or not as guest.\n     * The current selfId for the meeting\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n    this.selfId = null;\n    /**\n     * The current mediaShareContentId for the meeting\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n    this.mediaShareContentId = null;\n    /**\n     * The current mediaShareWhiteboardId for the meeting\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n    this.mediaShareWhiteboardId = null;\n    /**\n     * The current recordingId for the meeting, if it exists\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Members\n    */\n    this.recordingId = null;\n  }\n\n  /**\n   * Internal update the self Id value\n   * @param {Object} payload\n   * @param {Object} payload.newSelf\n   * @param {Object} payload.oldSelf\n   * @returns {undefined}\n   * @private\n   * @memberof Members\n   */\n  locusSelfUpdate(payload) {\n    let newSelfId = null;\n    let oldSelfId = null;\n\n    if (payload) {\n      if (payload.newSelf) {\n        newSelfId = payload.newSelf.id;\n      }\n      if (payload.oldSelf) {\n        oldSelfId = payload.oldSelf.id;\n      }\n    }\n    if (newSelfId) {\n      const theSelf = this.membersCollection.get(newSelfId);\n\n      if (theSelf) {\n        theSelf.setIsSelf(true);\n      }\n    }\n    if (oldSelfId) {\n      const notSelf = this.membersCollection.get(oldSelfId);\n\n      if (notSelf) {\n        notSelf.setIsSelf(false);\n      }\n    }\n    this.selfId = newSelfId;\n    Trigger.trigger(\n      this,\n      {\n        file: 'members',\n        function: 'locusSelfUpdate'\n      },\n      EVENT_TRIGGERS.MEMBERS_SELF_UPDATE,\n      {\n        activeSelfId: newSelfId,\n        endedSelfId: oldSelfId\n      }\n    );\n  }\n\n  /**\n   * Internal update the hostId value\n   * @param {Object} payload\n   * @param {Object} payload.newHost\n   * @param {Object} payload.oldHost\n   * @returns {undefined}\n   * @private\n   * @memberof Members\n   */\n  locusHostUpdate(payload) {\n    let newHostId = null;\n    let oldHostId = null;\n\n    if (payload) {\n      if (payload.newHost) {\n        newHostId = payload.newHost.id;\n      }\n      if (payload.oldHost) {\n        oldHostId = payload.oldHost.id;\n      }\n    }\n    if (newHostId) {\n      const theHost = this.membersCollection.get(newHostId);\n\n      if (theHost) {\n        theHost.setIsHost(true);\n      }\n    }\n    if (oldHostId) {\n      const notHost = this.membersCollection.get(oldHostId);\n\n      if (notHost) {\n        notHost.setIsHost(false);\n      }\n    }\n    this.hostId = newHostId;\n    Trigger.trigger(\n      this,\n      {\n        file: 'members',\n        function: 'locusHostUpdate'\n      },\n      EVENT_TRIGGERS.MEMBERS_HOST_UPDATE,\n      {\n        activeHostId: newHostId,\n        endedHostId: oldHostId\n      }\n    );\n  }\n\n  /**\n   * when new participant updates come in, both delta and full participants, update them in members collection\n   * delta object in the event will have {updated, added} and full will be the full membersCollection\n   * @param {Object} payload\n   * @param {Object} payload.participants\n   * @returns {undefined}\n   * @private\n   * @memberof Members\n   */\n  locusParticipantsUpdate(payload) {\n    if (payload) {\n      const delta = this.handleLocusInfoUpdatedParticipants(payload);\n      const full = this.handleMembersUpdate(delta); // SDK should propagate the full list for both delta and non delta updates\n\n      Trigger.trigger(\n        this,\n        {\n          file: 'members',\n          function: 'locusParticipantsUpdate'\n        },\n        EVENT_TRIGGERS.MEMBERS_UPDATE,\n        {\n          delta,\n          full\n        }\n      );\n    }\n  }\n\n  /**\n   * Internal update the content id\n   * @param {Object} payload\n   * @param {Object} payload.current\n   * @param {Object} payload.previous\n   * @returns {undefined}\n   * @private\n   * @memberof Members\n   */\n  locusMediaSharesUpdate(payload) {\n    const currentContent = payload.current?.content;\n    const previousContent = payload.previous?.content;\n    const currentWhiteboard = payload.current?.whiteboard;\n    const previousWhiteboard = payload.previous?.whiteboard;\n    let whoSharing = null;\n    let whoStopped = null;\n\n    if (currentContent?.beneficiaryId) {\n      if (currentContent.disposition === FLOOR_ACTION.GRANTED) {\n        whoSharing = currentContent.beneficiaryId;\n        this.mediaShareWhiteboardId = null;\n        this.mediaShareContentId = whoSharing;\n      }\n\n      if (previousContent?.disposition === FLOOR_ACTION.GRANTED) {\n        if (currentContent.disposition === FLOOR_ACTION.RELEASED) {\n          whoStopped = currentContent.beneficiaryId;\n          this.mediaShareContentId = null;\n        }\n        else if (currentContent.disposition === FLOOR_ACTION.GRANTED && currentContent.beneficiaryId !== previousContent.beneficiaryId) {\n          whoStopped = previousContent.beneficiaryId;\n        }\n      }\n    }\n\n    if (currentWhiteboard?.beneficiaryId) {\n      if (currentWhiteboard.disposition === FLOOR_ACTION.GRANTED) {\n        whoSharing = currentWhiteboard.beneficiaryId;\n        this.mediaShareContentId = null;\n        this.mediaShareWhiteboardId = whoSharing;\n      }\n\n      if (previousWhiteboard?.disposition === FLOOR_ACTION.GRANTED) {\n        if (currentWhiteboard.disposition === FLOOR_ACTION.RELEASED) {\n          whoStopped = currentWhiteboard.beneficiaryId;\n          this.mediaShareWhiteboardId = null;\n        }\n        else if (currentWhiteboard.disposition === FLOOR_ACTION.GRANTED && currentWhiteboard.beneficiaryId !== previousWhiteboard.beneficiaryId) {\n          whoStopped = previousWhiteboard.beneficiaryId;\n        }\n      }\n    }\n\n    if (whoSharing) {\n      const shareMember = this.membersCollection.get(whoSharing);\n\n      if (shareMember) {\n        shareMember.setIsContentSharing(true);\n      }\n    }\n    if (whoStopped) {\n      const stopMember = this.membersCollection.get(whoStopped);\n\n      if (stopMember) {\n        stopMember.setIsContentSharing(false);\n      }\n    }\n\n    Trigger.trigger(\n      this,\n      {\n        file: 'members',\n        function: 'locusMediaSharesUpdate'\n      },\n      EVENT_TRIGGERS.MEMBERS_CONTENT_UPDATE,\n      {\n        activeSharingId: whoSharing,\n        endedSharingId: whoStopped\n      }\n    );\n  }\n\n\n  /**\n   * Internal update the locus url value\n   * @param {Object} payload\n   * @param {String} payload.locusUrl\n   * @returns {undefined}\n   * @private\n   * @memberof Members\n   */\n  locusUrlUpdate(payload) {\n    if (payload) {\n      this.setLocusUrl(null, payload);\n    }\n  }\n\n  /**\n   * Internal update the type of meeting\n   * @param {Object} payload\n   * @param {String} payload.type\n   * @returns {undefined}\n   * @private\n   * @memberof Members\n   */\n  locusFullStateTypeUpdate(payload) {\n    // TODO: at some point there could be a timing issue here, for updating each member\n    // ie., if the type changes AND there is no locus update, then each member will not know the type of call\n    // which means they cannot determine isMutable && isRemovable\n    // for now this scenario is impossible to occur since we always get a locus update when the type changes\n    // except for in delta locus meetings, but in that case, the type will always have been set differently\n    // from the outset anyway\n    if (payload) {\n      this.setType(payload);\n    }\n  }\n\n  /**\n   * sets values in the members collection for updated and added properties from delta\n   * @param {Object} membersUpdate {updated: [], added: []}\n   * @returns {Object} membersCollection\n   * @private\n   * @memberof Members\n   */\n  handleMembersUpdate(membersUpdate) {\n    if (membersUpdate) {\n      if (membersUpdate.updated) {\n        this.constructMembers(membersUpdate.updated);\n      }\n      if (membersUpdate.added) {\n        this.constructMembers(membersUpdate.added);\n      }\n    }\n\n    return this.membersCollection.getAll();\n  }\n\n  /**\n   * set members to the member collection from each updated/added lists as passed in\n   * @param {Array} list\n   * @returns {undefined}\n   * @private\n   * @memberof Members\n   */\n  constructMembers(list) {\n    list.forEach((member) => {\n      this.membersCollection.set(member.id, member);\n    });\n  }\n\n  /**\n   * Internal update the participants value\n   * @param {Object} payload\n   * @returns {Object}\n   * @private\n   * @memberof Members\n   */\n  handleLocusInfoUpdatedParticipants(payload) {\n    this.hostId = payload.hostId || this.hostId;\n    this.selfId = payload.selfId || this.selfId;\n    this.recordingId = payload.recordingId;\n    if (!payload.participants) {\n      LoggerProxy.logger.warn('Members:index#handleLocusInfoUpdatedParticipants --> participants payload is missing.');\n    }\n    const memberUpdate = this.update(payload.participants);\n\n    return memberUpdate;\n  }\n\n  /**\n   * Update the locus Url\n   * @param {Object} locus\n   * @param {String} [locusUrl] optional, takes precedence\n   * @throws {ParameterError}\n   * @returns {undefined}\n   * @public\n   * @memberof Members\n   */\n  setLocusUrl(locus, locusUrl = null) {\n    if (locusUrl) {\n      this.locusUrl = locusUrl;\n    }\n    else if (locus && (locus.locusUrl || locus.url)) {\n      this.locusUrl = locus.locusUrl || locus.url;\n    }\n    else {\n      throw new ParameterError('Setting locusUrl for the Members module should be done with a locus object or locusUrl');\n    }\n  }\n\n  /**\n   * Update the host id\n   * @param {Object} locus\n   * @param {String} [hostId] optional, takes precedence\n   * @throws {ParameterError}\n   * @returns {undefined}\n   * @public\n   * @memberof Members\n   */\n  setHostId(locus, hostId = null) {\n    if (hostId) {\n      this.hostId = hostId;\n    }\n    else if (locus) {\n      this.hostId = locus && locus.owner && locus.owner.info ? locus.owner.info : null;\n    }\n    else {\n      throw new ParameterError('Setting hostid for the Members module should be done with a locus object or hostId');\n    }\n  }\n\n  /**\n   * Update the type\n   * @param {Object} fullState\n   * @param {String} [type] optional, takes precedence\n   * @throws {ParameterError}\n   * @returns {undefined}\n   * @public\n   * @memberof Members\n   */\n  setType(fullState, type = null) {\n    if (type) {\n      this.type = type;\n    }\n    else if (fullState) {\n      this.type = (fullState && fullState.type) || null;\n    }\n    else {\n      throw new ParameterError('Setting type for the Members module should be done with a fullstate object or type string');\n    }\n  }\n\n  /**\n   * Update the self Id\n   * @param {Object} locus\n   * @param {String} [selfId] optional, takes precedence\n   * @throws {Error}\n   * @returns {undefined}\n   * @memberof Members\n   */\n  setSelfId(locus, selfId = null) {\n    if (selfId) {\n      this.selfId = selfId;\n    }\n    else if (locus) {\n      this.selfId = locus && locus.self && locus.self.person && locus.self.person.id ? locus.self.person.id : null;\n    }\n    else {\n      throw new ParameterError('Setting selfid for the Members module should be done with a locus object or selfId');\n    }\n  }\n\n  /**\n   * Update the media share content id\n   * @param {Object} locus\n   * @param {String} [contentId] optional, takes precedence\n   * @throws {Error}\n   * @returns {undefined}\n   * @memberof Members\n   */\n  setMediaShareContentId(locus, contentId) {\n    if (contentId) {\n      this.mediaShareContentId = contentId;\n    }\n    else if (locus) {\n      const contentMediaShare =\n        locus.mediaShares &&\n        locus.mediaShares.length &&\n        locus.mediaShares.find((mediaShare) => mediaShare.name === CONTENT);\n\n      this.mediaShareContentId =\n        (contentMediaShare &&\n          contentMediaShare.floor &&\n          contentMediaShare.floor.beneficiary &&\n          contentMediaShare.floor.beneficiary.id) ||\n        null;\n    }\n    else {\n      throw new ParameterError('Setting hostid for the Members module should be done with a locus object or hostId');\n    }\n  }\n\n  /**\n   * Update the media share whiteboard id\n   * @param {Object} locus\n   * @param {String} [whiteboardId] optional, takes precedence\n   * @throws {Error}\n   * @returns {undefined}\n   * @memberof Members\n   */\n  setMediaShareWhiteboardId(locus, whiteboardId) {\n    if (whiteboardId) {\n      this.mediaShareWhiteboardId = whiteboardId;\n    }\n    else if (locus) {\n      const whiteboardMediaShare =\n        locus.mediaShares &&\n        locus.mediaShares.length &&\n        locus.mediaShares.find((mediaShare) => mediaShare.name === WHITEBOARD);\n\n      this.mediaShareWhiteboardId =\n        (whiteboardMediaShare &&\n          whiteboardMediaShare.floor &&\n          whiteboardMediaShare.floor.beneficiary &&\n          whiteboardMediaShare.floor.beneficiary.id) ||\n        null;\n    }\n    else {\n      throw new ParameterError('Setting hostid for the Members module should be done with a locus object or hostId');\n    }\n  }\n\n  /**\n   * Find all the updates, and added members\n   * Removed/left members will end up in updates\n   * Each array contains only members\n   * @param {Array} participants the locus participants\n   * @returns {Object} {added: {Array}, updated: {Array}}\n   * @private\n   * @memberof Members\n   */\n  update(participants) {\n    const membersUpdate = {added: [], updated: []};\n\n    if (participants) {\n      participants.forEach((participant) => {\n        if (participant.hideInRoster) {\n          return;\n        }\n        const existing = this.membersCollection.get(participant.id);\n\n        if (existing) {\n          // TODO: compare existing member to new participant coming in properties and determine if updated (this helps for non delta events)\n          // on client re renders, but we will have to determine what values to compare to determine difference, premature optimization\n          membersUpdate.updated.push(\n            new Member(participant, {\n              recordingId: this.recordingId,\n              selfId: this.selfId,\n              hostId: this.hostId,\n              contentSharingId: this.mediaShareContentId,\n              whiteboardSharingId: this.mediaShareWhiteboardId,\n              type: this.type\n            })\n          );\n        }\n        else {\n          membersUpdate.added.push(\n            new Member(participant, {\n              recordingId: this.recordingId,\n              selfId: this.selfId,\n              hostId: this.hostId,\n              contentSharingId: this.mediaShareContentId,\n              whiteboardSharingId: this.mediaShareWhiteboardId,\n              type: this.type\n            })\n          );\n        }\n      });\n    }\n\n    return membersUpdate;\n  }\n\n  /**\n   * Adds a guest Member to the associated meeting\n   * @param {String} invitee\n   * @param {Boolean} [alertIfActive]\n   * @returns {Promise}\n   * @memberof Members\n   */\n  addMember(invitee, alertIfActive) {\n    if (!this.locusUrl) {\n      return Promise.reject(new ParameterError('The associated locus url for this meeting object must be defined.'));\n    }\n    if (MembersUtil.isInvalidInvitee(invitee)) {\n      return Promise.reject(\n        new ParameterError('The invitee must be defined with either a valid email, emailAddress or phoneNumber property.')\n      );\n    }\n    const options = MembersUtil.generateAddMemberOptions(invitee, this.locusUrl, alertIfActive);\n\n    return this.membersRequest.addMembers(options);\n  }\n\n  /**\n   * Cancels an outgoing PSTN call to the associated meeting\n   * @param {String} invitee\n   * @returns {Promise}\n   * @memberof Members\n   */\n  cancelPhoneInvite(invitee) {\n    if (!this.locusUrl) {\n      return Promise.reject(new ParameterError('The associated locus url for this meeting object must be defined.'));\n    }\n    if (MembersUtil.isInvalidInvitee(invitee)) {\n      return Promise.reject(\n        new ParameterError('The invitee must be defined with a valid phoneNumber property.')\n      );\n    }\n    const options = MembersUtil.cancelPhoneInviteOptions(invitee, this.locusUrl);\n\n\n    return this.membersRequest.cancelPhoneInvite(options);\n  }\n\n  /**\n   * Admits waiting members (invited guests to meeting)\n   * @param {Array} memberIds\n   * @returns {Promise}\n   * @public\n   * @memberof Members\n   */\n  admitMembers(memberIds) {\n    if (isEmpty(memberIds)) {\n      return Promise.reject(new ParameterError('No member ids provided to admit.'));\n    }\n    const options = MembersUtil.generateAdmitMemberOptions(memberIds, this.locusUrl);\n\n    return this.membersRequest.admitMember(options);\n  }\n\n  /**\n   * Removes a member from the meeting\n   * @param {String} memberId\n   * @returns {Promise}\n   * @public\n   * @memberof Members\n   */\n  removeMember(memberId) {\n    if (!this.locusUrl) {\n      return Promise.reject(new ParameterError('The associated locus url for this meeting object must be defined.'));\n    }\n    if (!memberId) {\n      return Promise.reject(new ParameterError('The member id must be defined to remove the member.'));\n    }\n    const options = MembersUtil.generateRemoveMemberOptions(memberId, this.locusUrl);\n\n    return this.membersRequest.removeMember(options);\n  }\n\n  /**\n   * Audio mutes another member in a meeting\n   * @param {String} memberId\n   * @param {boolean} [mute] default true\n   * @returns {Promise}\n   * @public\n   * @memberof Members\n   */\n  muteMember(memberId, mute = true) {\n    if (!this.locusUrl) {\n      return Promise.reject(new ParameterError('The associated locus url for this meetings members object must be defined.'));\n    }\n    if (!memberId) {\n      return Promise.reject(new ParameterError('The member id must be defined to mute the member.'));\n    }\n    const options = MembersUtil.generateMuteMemberOptions(memberId, mute, this.locusUrl);\n\n    return this.membersRequest.muteMember(options);\n  }\n\n  /**\n   * Transfers the host to another member\n   * @param {String} memberId\n   * @param {boolean} [moderator] default true\n   * @returns {Promise}\n   * @public\n   * @memberof Members\n   */\n  transferHostToMember(memberId, moderator = true) {\n    if (!this.locusUrl) {\n      return Promise.reject(new ParameterError('The associated locus url for this meetings members object must be defined.'));\n    }\n    if (!memberId) {\n      return Promise.reject(new ParameterError('The member id must be defined to transfer host to the member.'));\n    }\n    const options = MembersUtil.generateTransferHostMemberOptions(memberId, moderator, this.locusUrl);\n\n    return this.membersRequest.transferHostToMember(options);\n  }\n\n\n  /**\n   * Sends DTMF tones for the PSTN member of a meeting\n   * @param {String} tones a string of one or more DTMF tones to send\n   * @param {String} memberId member id\n   * @returns {Promise}\n   * @public\n   * @memberof Members\n   */\n  sendDialPadKey(tones = '', memberId = '') {\n    if (!tones && tones !== 0) {\n      return Promise.reject(new ParameterError('DMTF tones must be passed in'));\n    }\n\n    const member = this.membersCollection.get(memberId);\n\n    if (!member) {\n      return Promise.reject(new ParameterError('there is no member associated with that Id'));\n    }\n\n    const {locusUrl} = this;\n\n    const deviceArray = member.participant.devices;\n    const device = deviceArray.find(({deviceType}) => deviceType === 'SIP');\n    const url = device?.url;\n\n    if (locusUrl && url) {\n      const options = MembersUtil.genderateSendDTMFOptions(url, tones, memberId, locusUrl);\n\n      return this.membersRequest.sendDialPadKey(options);\n    }\n\n    return Promise.reject(new Error('Members:index#sendDialPadKey --> cannot send DTMF, meeting does not have a connection to the \"locus\" call control service.'));\n  }\n}\n"]},"metadata":{},"sourceType":"script"}