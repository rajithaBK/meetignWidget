{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = exports.levels = void 0;\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/keys\"));\n\nvar _entries = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/entries\"));\n\nvar _deleteProperty = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/reflect/delete-property\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/toConsumableArray\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/slicedToArray\"));\n\nvar _isString2 = _interopRequireDefault(require(\"lodash/isString\"));\n\nvar _isObject2 = _interopRequireDefault(require(\"lodash/isObject\"));\n\nvar _isArray2 = _interopRequireDefault(require(\"lodash/isArray\"));\n\nvar _has2 = _interopRequireDefault(require(\"lodash/has\"));\n\nvar _cloneDeep2 = _interopRequireDefault(require(\"lodash/cloneDeep\"));\n\nvar _common = require(\"@webex/common\");\n\nvar _webexCore = require(\"@webex/webex-core\");\n/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar precedence = {\n  silent: 0,\n  group: 1,\n  groupEnd: 2,\n  error: 3,\n  warn: 4,\n  log: 5,\n  info: 6,\n  debug: 7,\n  trace: 8\n};\nvar levels = (0, _keys.default)(precedence).filter(function (level) {\n  return level !== 'silent';\n});\nexports.levels = levels;\nvar fallbacks = {\n  error: ['log'],\n  warn: ['error', 'log'],\n  info: ['log'],\n  debug: ['info', 'log'],\n  trace: ['debug', 'info', 'log']\n};\nvar LOG_TYPES = {\n  SDK: 'sdk',\n  CLIENT: 'client'\n};\nvar SDK_LOG_TYPE_NAME = 'wx-js-sdk';\nvar authTokenKeyPattern = /[Aa]uthorization/;\n/**\n * Recursively strips \"authorization\" fields from the specified object\n * @param {Object} object\n * @param {Array<mixed>} [visited]\n * @private\n * @returns {Object}\n */\n\nfunction walkAndFilter(object) {\n  var visited = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  if (visited.includes(object)) {\n    // Prevent circular references\n    return object;\n  }\n\n  visited.push(object);\n\n  if ((0, _isArray2.default)(object)) {\n    return object.map(function (o) {\n      return walkAndFilter(o, visited);\n    });\n  }\n\n  if (!(0, _isObject2.default)(object)) {\n    if ((0, _isString2.default)(object)) {\n      if (_common.patterns.containsEmails.test(object)) {\n        return object.replace(_common.patterns.containsEmails, '[REDACTED]');\n      }\n    }\n\n    return object;\n  }\n\n  for (var _i = 0, _Object$entries = (0, _entries.default)(object); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = (0, _slicedToArray2.default)(_Object$entries[_i], 2),\n        key = _Object$entries$_i[0],\n        value = _Object$entries$_i[1];\n\n    if (authTokenKeyPattern.test(key)) {\n      (0, _deleteProperty.default)(object, key);\n    } else {\n      object[key] = walkAndFilter(value, visited);\n    }\n  }\n\n  return object;\n}\n/**\n * @class\n */\n\n\nvar Logger = _webexCore.WebexPlugin.extend({\n  namespace: 'Logger',\n  derived: {\n    level: {\n      cache: false,\n      fn: function fn() {\n        return this.getCurrentLevel();\n      }\n    },\n    client_level: {\n      cache: false,\n      fn: function fn() {\n        return this.getCurrentClientLevel();\n      }\n    }\n  },\n  session: {\n    // for when configured to use single buffer\n    buffer: {\n      type: 'array',\n      default: function _default() {\n        return [];\n      }\n    },\n    groupLevel: {\n      type: 'number',\n      default: function _default() {\n        return 0;\n      }\n    },\n    // for when configured to use separate buffers\n    sdkBuffer: {\n      type: 'array',\n      default: function _default() {\n        return [];\n      }\n    },\n    clientBuffer: {\n      type: 'array',\n      default: function _default() {\n        return [];\n      }\n    }\n  },\n\n  /**\n   * Ensures auth headers don't get printed in logs\n   * @param {Array<mixed>} args\n   * @private\n   * @memberof Logger\n   * @returns {Array<mixed>}\n   */\n  filter: function filter() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return args.map(function (arg) {\n      // WebexHttpError already ensures auth tokens don't get printed, so, no\n      // need to alter it here.\n      if (arg instanceof Error) {\n        // karma logs won't print subclassed errors correctly, so we need\n        // explicitly call their tostring methods.\n        if (process.env.NODE_ENV === 'test' && _common.inBrowser) {\n          var ret = arg.toString();\n          ret += 'BEGIN STACK';\n          ret += arg.stack;\n          ret += 'END STACK';\n          return ret;\n        }\n\n        return arg;\n      }\n\n      arg = (0, _cloneDeep2.default)(arg);\n      return walkAndFilter(arg);\n    });\n  },\n\n  /**\n   * Determines if the current level allows logs at the specified level to be\n   * printed\n   * @param {string} level\n   * @param {string} type type of log, SDK or client\n   * @private\n   * @memberof Logger\n   * @returns {boolean}\n   */\n  shouldPrint: function shouldPrint(level) {\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : LOG_TYPES.SDK;\n    return precedence[level] <= precedence[type === LOG_TYPES.SDK ? this.getCurrentLevel() : this.getCurrentClientLevel()];\n  },\n\n  /**\n   * Determines if the current level allows logs at the specified level to be\n   * put into the log buffer. We're configuring it omit trace and debug logs\n   * because there are *a lot* of debug logs that really don't provide value at\n   * runtime (they're helpful for debugging locally, but really just pollute the\n   * uploaded logs and push useful info out).\n   * @param {string} level\n   * @param {string} type type of log, SDK or client\n   * @private\n   * @memberof Logger\n   * @returns {boolean}\n   */\n  shouldBuffer: function shouldBuffer(level) {\n    return precedence[level] <= (this.config.bufferLogLevel ? precedence[this.config.bufferLogLevel] : precedence.info);\n  },\n\n  /**\n   * Indicates the current SDK log level based on env vars, feature toggles, and\n   * user type.\n   * @instance\n   * @memberof Logger\n   * @private\n   * @memberof Logger\n   * @returns {string}\n   */\n  // eslint-disable-next-line complexity\n  getCurrentLevel: function getCurrentLevel() {\n    // If a level has been explicitly set via config, alway use it.\n    if (this.config.level) {\n      return this.config.level;\n    }\n\n    if (levels.includes(process.env.WEBEX_LOG_LEVEL)) {\n      return process.env.WEBEX_LOG_LEVEL;\n    } // Always use debug-level logging in test mode;\n\n\n    if (process.env.NODE_ENV === 'test') {\n      return 'trace';\n    } // Use server-side-feature toggles to configure log levels\n\n\n    var level = this.webex.internal.device && this.webex.internal.device.features.developer.get('log-level');\n\n    if (level) {\n      if (levels.includes(level)) {\n        return level;\n      }\n    }\n\n    return 'error';\n  },\n\n  /**\n   * Indicates the current client log level based on config, defaults to SDK level\n   * @instance\n   * @memberof Logger\n   * @private\n   * @memberof Logger\n   * @returns {string}\n   */\n  getCurrentClientLevel: function getCurrentClientLevel() {\n    // If a client log level has been explicitly set via config, alway use it.\n    if (this.config.clientLevel) {\n      return this.config.clientLevel;\n    } // otherwise default to SDK level\n\n\n    return this.getCurrentLevel();\n  },\n\n  /**\n   * Format logs (for upload)\n   *\n   * If separate client, SDK buffers is configured, merge the buffers, if configured\n   *\n   * @instance\n   * @memberof Logger\n   * @public\n   * @memberof Logger\n   * @returns {string} formatted buffer\n   */\n  formatLogs: function formatLogs() {\n    function getDate(log) {\n      return log[1];\n    }\n\n    var buffer = [];\n    var clientIndex = 0;\n    var sdkIndex = 0;\n\n    if (this.config.separateLogBuffers) {\n      // merge the client and sdk buffers\n      // while we have entries in either buffer\n      while (clientIndex < this.clientBuffer.length || sdkIndex < this.sdkBuffer.length) {\n        // if we have remaining entries in the SDK buffer\n        if (sdkIndex < this.sdkBuffer.length && (clientIndex >= this.clientBuffer.length || new Date(getDate(this.sdkBuffer[sdkIndex])) <= new Date(getDate(this.clientBuffer[clientIndex])))) {\n          // then add to the SDK buffer\n          buffer.push(this.sdkBuffer[sdkIndex]);\n          sdkIndex += 1;\n        } // otherwise if we haven't exhausted all the client buffer entries, add client entry, whether it was because\n        // it was the only remaining entries or date was later (the above if)\n        else if (clientIndex < this.clientBuffer.length) {\n          buffer.push(this.clientBuffer[clientIndex]);\n          clientIndex += 1;\n        }\n      }\n    } else {\n      buffer = this.buffer;\n    }\n\n    return buffer.join('\\n');\n  },\n  version: \"1.154.2\"\n});\n/**\n * Creates a logger method\n *\n *\n * @param {string} level level to create (info, error, warn, etc.)\n * @param {string} impl the level to use when writing to console\n * @param {string} type type of log, SDK or client\n * @param {bool} neverPrint function never prints to console\n * @param {bool} alwaysBuffer function always logs to log buffer\n * @instance\n * @memberof Logger\n * @private\n * @memberof Logger\n * @returns {function} logger method with specified params\n */\n\n\nfunction makeLoggerMethod(level, impl, type) {\n  var neverPrint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var alwaysBuffer = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false; // Much of the complexity in the following function is due to a test-mode-only\n  // helper\n\n  return function wrappedConsoleMethod() {\n    // it would be easier to just pass in the name and buffer here, but the config isn't completely initialized\n    // in Ampersand, even if the initialize method is used to set this up.  so we keep the type to achieve\n    // a sort of late binding to allow retrieving a name from config.\n    var logType = type;\n    var clientName = logType === LOG_TYPES.SDK ? SDK_LOG_TYPE_NAME : this.config.clientName || logType;\n    var buffer;\n    var historyLength;\n\n    if (this.config.separateLogBuffers) {\n      historyLength = this.config.clientHistoryLength ? this.config.clientHistoryLength : this.config.historyLength;\n      buffer = logType === LOG_TYPES.SDK ? this.sdkBuffer : this.clientBuffer;\n    } else {\n      buffer = this.buffer;\n      historyLength = this.config.historyLength;\n    }\n\n    try {\n      var shouldPrint = !neverPrint && this.shouldPrint(level, logType);\n      var shouldBuffer = alwaysBuffer || this.shouldBuffer(level);\n\n      if (!shouldBuffer && !shouldPrint) {\n        return;\n      }\n\n      var filtered = [clientName].concat((0, _toConsumableArray2.default)(this.filter.apply(this, arguments)));\n      var stringified = filtered.map(function (item) {\n        if (item instanceof _webexCore.WebexHttpError) {\n          return item.toString();\n        }\n\n        return item;\n      });\n\n      if (shouldPrint) {\n        var _console; // when logging an object in browsers, we tend to get a dynamic\n        // reference, thus going back to look at the logged value doesn't\n        // necessarily show the state at log time, thus we print the stringified\n        // value.\n\n\n        var toPrint = _common.inBrowser ? stringified : filtered;\n        /* istanbul ignore if */\n\n        if (process.env.NODE_ENV === 'test' && (0, _has2.default)(this, 'webex.internal.device.url')) {\n          toPrint.unshift(this.webex.internal.device.url.slice(-3));\n        } // eslint-disable-next-line no-console\n\n\n        (_console = console)[impl].apply(_console, (0, _toConsumableArray2.default)(toPrint));\n      }\n\n      if (shouldBuffer) {\n        var logDate = new Date();\n        stringified.unshift(logDate.toISOString());\n        stringified.unshift('|  '.repeat(this.groupLevel));\n        buffer.push(stringified);\n\n        if (buffer.length > historyLength) {\n          buffer.shift();\n        }\n\n        if (level === 'group') this.groupLevel += 1;\n        if (level === 'groupEnd' && this.groupLevel > 0) this.groupLevel -= 1;\n      }\n    } catch (reason) {\n      if (!neverPrint) {\n        /* istanbul ignore next */\n        // eslint-disable-next-line no-console\n        console.warn(\"failed to execute Logger#\".concat(level), reason);\n      }\n    }\n  };\n}\n\nlevels.forEach(function (level) {\n  var impls = fallbacks[level];\n  var impl = level;\n\n  if (impls) {\n    impls = impls.slice(); // eslint-disable-next-line no-console\n\n    while (!console[impl]) {\n      impl = impls.pop();\n    }\n  } // eslint-disable-next-line complexity\n\n\n  Logger.prototype[\"client_\".concat(level)] = makeLoggerMethod(level, impl, LOG_TYPES.CLIENT);\n  Logger.prototype[level] = makeLoggerMethod(level, impl, LOG_TYPES.SDK);\n});\nLogger.prototype.client_logToBuffer = makeLoggerMethod(levels.info, levels.info, LOG_TYPES.CLIENT, true, true);\nLogger.prototype.logToBuffer = makeLoggerMethod(levels.info, levels.info, LOG_TYPES.SDK, true, true);\nvar _default2 = Logger;\nexports.default = _default2;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;AACA;AALA;AACA;AACA;;;AAeA,IAAMA,UAAU,GAAG;AACjBC,QAAM,EAAE,CADS;AAEjBC,OAAK,EAAE,CAFU;AAGjBC,UAAQ,EAAE,CAHO;AAIjBC,OAAK,EAAE,CAJU;AAKjBC,MAAI,EAAE,CALW;AAMjBC,KAAG,EAAE,CANY;AAOjBC,MAAI,EAAE,CAPW;AAQjBC,OAAK,EAAE,CARU;AASjBC,OAAK,EAAE;AATU,CAAnB;AAYO,IAAMC,MAAM,GAAG,mBAAYV,UAAZ,EAAwBW,MAAxB,CAA+B,UAACC,KAAD;AAAA,SAAWA,KAAK,KAAK,QAArB;AAA/B,EAAf;;AAEP,IAAMC,SAAS,GAAG;AAChBT,OAAK,EAAE,CAAC,KAAD,CADS;AAEhBC,MAAI,EAAE,CAAC,OAAD,EAAU,KAAV,CAFU;AAGhBE,MAAI,EAAE,CAAC,KAAD,CAHU;AAIhBC,OAAK,EAAE,CAAC,MAAD,EAAS,KAAT,CAJS;AAKhBC,OAAK,EAAE,CAAC,OAAD,EAAU,MAAV,EAAkB,KAAlB;AALS,CAAlB;AAQA,IAAMK,SAAS,GAAG;AAChBC,KAAG,EAAE,KADW;AAEhBC,QAAM,EAAE;AAFQ,CAAlB;AAKA,IAAMC,iBAAiB,GAAG,WAA1B;AAEA,IAAMC,mBAAmB,GAAG,kBAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,aAAT,CAAuBC,MAAvB,EAA6C;AAAA,MAAdC,OAAc,uEAAJ,EAAI;;AAC3C,MAAIA,OAAO,CAACC,QAARD,CAAiBD,MAAjBC,CAAJ,EAA8B;AAC5B;AACA,WAAOD,MAAP;AACD;;AAEDC,SAAO,CAACE,IAARF,CAAaD,MAAbC;;AAEA,MAAI,uBAAQD,MAAR,CAAJ,EAAqB;AACnB,WAAOA,MAAM,CAACI,GAAPJ,CAAW,UAACK,CAAD;AAAA,aAAON,aAAa,CAACM,CAAD,EAAIJ,OAAJ,CAApB;AAAX,MAAP;AACD;;AACD,MAAI,CAAC,wBAASD,MAAT,CAAL,EAAuB;AACrB,QAAI,wBAASA,MAAT,CAAJ,EAAsB;AACpB,UAAIM,iBAASC,cAATD,CAAwBE,IAAxBF,CAA6BN,MAA7BM,CAAJ,EAA0C;AACxC,eAAON,MAAM,CAACS,OAAPT,CAAeM,iBAASC,cAAxBP,EAAwC,YAAxCA,CAAP;AACD;AACF;;AAED,WAAOA,MAAP;AACD;;AAED,qCAA2B,sBAAeA,MAAf,CAA3B,qCAAmD;AAA9C;AAAA,QAAOU,GAAP;AAAA,QAAYC,KAAZ;;AACH,QAAIb,mBAAmB,CAACU,IAApBV,CAAyBY,GAAzBZ,CAAJ,EAAmC;AACjC,mCAAuBE,MAAvB,EAA+BU,GAA/B;AADF,WAGK;AACHV,YAAM,CAACU,GAAD,CAANV,GAAcD,aAAa,CAACY,KAAD,EAAQV,OAAR,CAA3BD;AACD;AACF;;AAED,SAAOA,MAAP;AACD;AAED;AACA;AACA;;;AACA,IAAMY,MAAM,GAAGC,uBAAYC,MAAZD,CAAmB;AAChCE,WAAS,EAAE,QADqB;AAGhCC,SAAO,EAAE;AACPxB,SAAK,EAAE;AACLyB,WAAK,EAAE,KADF;AAELC,QAFK,gBAEA;AACH,eAAO,KAAKC,eAAL,EAAP;AACD;AAJI,KADA;AAOPC,gBAAY,EAAE;AACZH,WAAK,EAAE,KADK;AAEZC,QAFY,gBAEP;AACH,eAAO,KAAKG,qBAAL,EAAP;AACD;AAJW;AAPP,GAHuB;AAiBhCC,SAAO,EAAE;AACP;AACAC,UAAM,EAAE;AACNC,UAAI,EAAE,OADA;AAENC,aAFM,sBAEI;AACR,eAAO,EAAP;AACD;AAJK,KAFD;AAQPC,cAAU,EAAE;AACVF,UAAI,EAAE,QADI;AAEVC,aAFU,sBAEA;AACR,eAAO,CAAP;AACD;AAJS,KARL;AAcP;AACAE,aAAS,EAAE;AACTH,UAAI,EAAE,OADG;AAETC,aAFS,sBAEC;AACR,eAAO,EAAP;AACD;AAJQ,KAfJ;AAqBPG,gBAAY,EAAE;AACZJ,UAAI,EAAE,OADM;AAEZC,aAFY,sBAEF;AACR,eAAO,EAAP;AACD;AAJW;AArBP,GAjBuB;;AA8ChC;AACF;AACA;AACA;AACA;AACA;AACA;AACElC,QArDgC,oBAqDhB;AAAA,sCAANsC,IAAM;AAANA,UAAM,MAANA,GAAMC,eAAND;AAAM;;AACd,WAAOA,IAAI,CAACzB,GAALyB,CAAS,UAACE,GAAD,EAAS;AACvB;AACA;AACA,UAAIA,GAAG,YAAYC,KAAnB,EAA0B;AACxB;AACA;AACA,YAAIC,OAAO,CAACC,GAARD,CAAYE,QAAZF,KAAyB,MAAzBA,IAAmCG,iBAAvC,EAAkD;AAChD,cAAIC,GAAG,GAAGN,GAAG,CAACO,QAAJP,EAAV;AAEAM,aAAG,IAAI,aAAPA;AACAA,aAAG,IAAIN,GAAG,CAACQ,KAAXF;AACAA,aAAG,IAAI,WAAPA;AAEA,iBAAOA,GAAP;AACD;;AAED,eAAON,GAAP;AACD;;AAEDA,SAAG,GAAG,yBAAUA,GAAV,CAANA;AAEA,aAAOhC,aAAa,CAACgC,GAAD,CAApB;AArBK,MAAP;AAtD8B;;AA+EhC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACES,aAxFgC,uBAwFpBhD,KAxFoB,EAwFS;AAAA,QAAtBgC,IAAsB,uEAAf9B,SAAS,CAACC,GAAK;AACvC,WAAOf,UAAU,CAACY,KAAD,CAAVZ,IAAqBA,UAAU,CAAC4C,IAAI,KAAK9B,SAAS,CAACC,GAAnB6B,GAAyB,KAAKL,eAAL,EAAzBK,GAAkD,KAAKH,qBAAL,EAAnD,CAAtC;AAzF8B;;AA4FhC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEoB,cAxGgC,wBAwGnBjD,KAxGmB,EAwGZ;AAClB,WAAOZ,UAAU,CAACY,KAAD,CAAVZ,KAAsB,KAAK8D,MAAL,CAAYC,cAAZ,GAA6B/D,UAAU,CAAC,KAAK8D,MAAL,CAAYC,cAAb,CAAvC,GAAsE/D,UAAU,CAACO,IAAvGP,CAAP;AAzG8B;;AA4GhC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE;AACAuC,iBAtHgC,6BAsHd;AAChB;AACA,QAAI,KAAKuB,MAAL,CAAYlD,KAAhB,EAAuB;AACrB,aAAO,KAAKkD,MAAL,CAAYlD,KAAnB;AACD;;AAED,QAAIF,MAAM,CAACY,QAAPZ,CAAgB2C,OAAO,CAACC,GAARD,CAAYW,eAA5BtD,CAAJ,EAAkD;AAChD,aAAO2C,OAAO,CAACC,GAARD,CAAYW,eAAnB;AAPc,MAUhB;;;AACA,QAAIX,OAAO,CAACC,GAARD,CAAYE,QAAZF,KAAyB,MAA7B,EAAqC;AACnC,aAAO,OAAP;AAZc,MAehB;;;AACA,QAAMzC,KAAK,GAAG,KAAKqD,KAAL,CAAWC,QAAX,CAAoBC,MAApB,IAA8B,KAAKF,KAAL,CAAWC,QAAX,CAAoBC,MAApB,CAA2BC,QAA3B,CAAoCC,SAApC,CAA8CC,GAA9C,CAAkD,WAAlD,CAA5C;;AAEA,QAAI1D,KAAJ,EAAW;AACT,UAAIF,MAAM,CAACY,QAAPZ,CAAgBE,KAAhBF,CAAJ,EAA4B;AAC1B,eAAOE,KAAP;AACD;AACF;;AAED,WAAO,OAAP;AA9I8B;;AAiJhC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACE6B,uBAzJgC,mCAyJR;AACtB;AACA,QAAI,KAAKqB,MAAL,CAAYS,WAAhB,EAA6B;AAC3B,aAAO,KAAKT,MAAL,CAAYS,WAAnB;AAHoB,MAMtB;;;AACA,WAAO,KAAKhC,eAAL,EAAP;AAhK8B;;AAmKhC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEiC,YA9KgC,wBA8KnB;AACX,aAASC,OAAT,CAAiBnE,GAAjB,EAAsB;AACpB,aAAOA,GAAG,CAAC,CAAD,CAAV;AACD;;AACD,QAAIqC,MAAM,GAAG,EAAb;AACA,QAAI+B,WAAW,GAAG,CAAlB;AACA,QAAIC,QAAQ,GAAG,CAAf;;AAEA,QAAI,KAAKb,MAAL,CAAYc,kBAAhB,EAAoC;AAClC;AACA;AACA,aAAOF,WAAW,GAAG,KAAK1B,YAAL,CAAkB6B,MAAhCH,IAA0CC,QAAQ,GAAG,KAAK5B,SAAL,CAAe8B,MAA3E,EAAmF;AACnF;AACE,YAAIF,QAAQ,GAAG,KAAK5B,SAAL,CAAe8B,MAA1BF,KAEDD,WAAW,IAAI,KAAK1B,YAAL,CAAkB6B,MAAjCH,IACE,IAAII,IAAJ,CAASL,OAAO,CAAC,KAAK1B,SAAL,CAAe4B,QAAf,CAAD,CAAhB,KAA+C,IAAIG,IAAJ,CAASL,OAAO,CAAC,KAAKzB,YAAL,CAAkB0B,WAAlB,CAAD,CAAhB,CAHhDC,CAAJ,EAGyG;AACvG;AACAhC,gBAAM,CAACpB,IAAPoB,CAAY,KAAKI,SAAL,CAAe4B,QAAf,CAAZhC;AACAgC,kBAAQ,IAAI,CAAZA;AANF,UAQA;AACA;AATA,aAUK,IAAID,WAAW,GAAG,KAAK1B,YAAL,CAAkB6B,MAApC,EAA4C;AAC/ClC,gBAAM,CAACpB,IAAPoB,CAAY,KAAKK,YAAL,CAAkB0B,WAAlB,CAAZ/B;AACA+B,qBAAW,IAAI,CAAfA;AACD;AACF;AAnBH,WAqBK;AACH/B,YAAM,GAAG,KAAKA,MAAdA;AACD;;AAED,WAAOA,MAAM,CAACoC,IAAPpC,CAAY,IAAZA,CAAP;AA/M8B;AAAAqC;AAAA,CAAnB/C,CAAf;AAmNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASgD,gBAAT,CAA0BrE,KAA1B,EAAiCsE,IAAjC,EAAuCtC,IAAvC,EAAuF;AAAA,MAA1CuC,UAA0C,uEAA7B,KAA6B;AAAA,MAAtBC,YAAsB,uEAAP,KAAO,EACrF;AACA;;AACA,SAAO,SAASC,oBAAT,GAAuC;AAC5C;AACA;AACA;AACA,QAAMC,OAAO,GAAG1C,IAAhB;AACA,QAAM2C,UAAU,GAAGD,OAAO,KAAKxE,SAAS,CAACC,GAAtBuE,GAA4BrE,iBAA5BqE,GAAiD,KAAKxB,MAAL,CAAYyB,UAAZ,IAA0BD,OAA9F;AAEA,QAAI3C,MAAJ;AACA,QAAI6C,aAAJ;;AAEA,QAAI,KAAK1B,MAAL,CAAYc,kBAAhB,EAAoC;AAClCY,mBAAa,GAAG,KAAK1B,MAAL,CAAY2B,mBAAZ,GAAkC,KAAK3B,MAAL,CAAY2B,mBAA9C,GAAoE,KAAK3B,MAAL,CAAY0B,aAAhGA;AACA7C,YAAM,GAAG2C,OAAO,KAAKxE,SAAS,CAACC,GAAtBuE,GAA4B,KAAKvC,SAAjCuC,GAA6C,KAAKtC,YAA3DL;AAFF,WAIK;AACHA,YAAM,GAAG,KAAKA,MAAdA;AACA6C,mBAAa,GAAG,KAAK1B,MAAL,CAAY0B,aAA5BA;AACD;;AAED,QAAI;AACF,UAAM5B,WAAW,GAAG,CAACuB,UAAD,IAAe,KAAKvB,WAAL,CAAiBhD,KAAjB,EAAwB0E,OAAxB,CAAnC;AACA,UAAMzB,YAAY,GAAGuB,YAAY,IAAI,KAAKvB,YAAL,CAAkBjD,KAAlB,CAArC;;AAEA,UAAI,CAACiD,YAAD,IAAiB,CAACD,WAAtB,EAAmC;AACjC;AACD;;AAED,UAAM8B,QAAQ,IAAIH,UAAJ,0CAAmB,KAAK5E,MAAL,uBAAnB,EAAd;AACA,UAAMgF,WAAW,GAAGD,QAAQ,CAAClE,GAATkE,CAAa,UAACE,IAAD,EAAU;AACzC,YAAIA,IAAI,YAAYC,yBAApB,EAAoC;AAClC,iBAAOD,IAAI,CAAClC,QAALkC,EAAP;AACD;;AAED,eAAOA,IAAP;AALkB,QAApB;;AAQA,UAAIhC,WAAJ,EAAiB;AAAA,sBACf;AACA;AACA;AACA;;;AACA,YAAMkC,OAAO,GAAGtC,oBAAYmC,WAAZnC,GAA0BkC,QAA1C;AAEA;;AACA,YAAIrC,OAAO,CAACC,GAARD,CAAYE,QAAZF,KAAyB,MAAzBA,IAAmC,mBAAI,IAAJ,EAAU,2BAAV,CAAvC,EAA+E;AAC7EyC,iBAAO,CAACC,OAARD,CAAgB,KAAK7B,KAAL,CAAWC,QAAX,CAAoBC,MAApB,CAA2B6B,GAA3B,CAA+BC,KAA/B,CAAqC,CAAC,CAAtC,CAAhBH;AATa,UAWf;;;AACA,6BAAQZ,IAAR,mDAAiBY,OAAjB;AACD;;AAED,UAAIjC,YAAJ,EAAkB;AAChB,YAAMqC,OAAO,GAAG,IAAIpB,IAAJ,EAAhB;AAEAa,mBAAW,CAACI,OAAZJ,CAAoBO,OAAO,CAACC,WAARD,EAApBP;AACAA,mBAAW,CAACI,OAAZJ,CAAoB,MAAMS,MAAN,CAAa,KAAKtD,UAAlB,CAApB6C;AACAhD,cAAM,CAACpB,IAAPoB,CAAYgD,WAAZhD;;AACA,YAAIA,MAAM,CAACkC,MAAPlC,GAAgB6C,aAApB,EAAmC;AACjC7C,gBAAM,CAAC0D,KAAP1D;AACD;;AACD,YAAI/B,KAAK,KAAK,OAAd,EAAuB,KAAKkC,UAAL,IAAmB,CAAnB;AACvB,YAAIlC,KAAK,KAAK,UAAVA,IAAwB,KAAKkC,UAAL,GAAkB,CAA9C,EAAiD,KAAKA,UAAL,IAAmB,CAAnB;AAClD;AA3CH,MA6CA,OAAOwD,MAAP,EAAe;AACb,UAAI,CAACnB,UAAL,EAAiB;AACf;AACA;AACAoB,eAAO,CAAClG,IAARkG,oCAAyC3F,KAAzC,GAAkD0F,MAAlDC;AACD;AACF;AAtEH;AAwED;;AAED7F,MAAM,CAAC8F,OAAP9F,CAAe,UAACE,KAAD,EAAW;AACxB,MAAI6F,KAAK,GAAG5F,SAAS,CAACD,KAAD,CAArB;AACA,MAAIsE,IAAI,GAAGtE,KAAX;;AAEA,MAAI6F,KAAJ,EAAW;AACTA,SAAK,GAAGA,KAAK,CAACR,KAANQ,EAARA,CADS,CAET;;AACA,WAAO,CAACF,OAAO,CAACrB,IAAD,CAAf,EAAuB;AACrBA,UAAI,GAAGuB,KAAK,CAACC,GAAND,EAAPvB;AACD;AATqB,IAaxB;;;AACAlD,QAAM,CAAC2E,SAAP3E,kBAA2BpB,KAA3B,KAAsCqE,gBAAgB,CAACrE,KAAD,EAAQsE,IAAR,EAAcpE,SAAS,CAACE,MAAxB,CAAtDgB;AACAA,QAAM,CAAC2E,SAAP3E,CAAiBpB,KAAjBoB,IAA0BiD,gBAAgB,CAACrE,KAAD,EAAQsE,IAAR,EAAcpE,SAAS,CAACC,GAAxB,CAA1CiB;AAfF;AAkBAA,MAAM,CAAC2E,SAAP3E,CAAiB4E,kBAAjB5E,GACEiD,gBAAgB,CAACvE,MAAM,CAACH,IAAR,EAAcG,MAAM,CAACH,IAArB,EAA2BO,SAAS,CAACE,MAArC,EAA6C,IAA7C,EAAmD,IAAnD,CADlBgB;AAEAA,MAAM,CAAC2E,SAAP3E,CAAiB6E,WAAjB7E,GAA+BiD,gBAAgB,CAACvE,MAAM,CAACH,IAAR,EAAcG,MAAM,CAACH,IAArB,EAA2BO,SAAS,CAACC,GAArC,EAA0C,IAA1C,EAAgD,IAAhD,CAA/CiB;gBAEeA","names":["precedence","silent","group","groupEnd","error","warn","log","info","debug","trace","levels","filter","level","fallbacks","LOG_TYPES","SDK","CLIENT","SDK_LOG_TYPE_NAME","authTokenKeyPattern","walkAndFilter","object","visited","includes","push","map","o","patterns","containsEmails","test","replace","key","value","Logger","WebexPlugin","extend","namespace","derived","cache","fn","getCurrentLevel","client_level","getCurrentClientLevel","session","buffer","type","default","groupLevel","sdkBuffer","clientBuffer","args","arguments","arg","Error","process","env","NODE_ENV","inBrowser","ret","toString","stack","shouldPrint","shouldBuffer","config","bufferLogLevel","WEBEX_LOG_LEVEL","webex","internal","device","features","developer","get","clientLevel","formatLogs","getDate","clientIndex","sdkIndex","separateLogBuffers","length","Date","join","version","makeLoggerMethod","impl","neverPrint","alwaysBuffer","wrappedConsoleMethod","logType","clientName","historyLength","clientHistoryLength","filtered","stringified","item","WebexHttpError","toPrint","unshift","url","slice","logDate","toISOString","repeat","shift","reason","console","forEach","impls","pop","prototype","client_logToBuffer","logToBuffer"],"sources":["logger.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {inBrowser, patterns} from '@webex/common';\nimport {\n  WebexHttpError,\n  WebexPlugin\n} from '@webex/webex-core';\nimport {\n  cloneDeep,\n  has,\n  isArray,\n  isObject,\n  isString\n} from 'lodash';\n\nconst precedence = {\n  silent: 0,\n  group: 1,\n  groupEnd: 2,\n  error: 3,\n  warn: 4,\n  log: 5,\n  info: 6,\n  debug: 7,\n  trace: 8\n};\n\nexport const levels = Object.keys(precedence).filter((level) => level !== 'silent');\n\nconst fallbacks = {\n  error: ['log'],\n  warn: ['error', 'log'],\n  info: ['log'],\n  debug: ['info', 'log'],\n  trace: ['debug', 'info', 'log']\n};\n\nconst LOG_TYPES = {\n  SDK: 'sdk',\n  CLIENT: 'client'\n};\n\nconst SDK_LOG_TYPE_NAME = 'wx-js-sdk';\n\nconst authTokenKeyPattern = /[Aa]uthorization/;\n\n/**\n * Recursively strips \"authorization\" fields from the specified object\n * @param {Object} object\n * @param {Array<mixed>} [visited]\n * @private\n * @returns {Object}\n */\nfunction walkAndFilter(object, visited = []) {\n  if (visited.includes(object)) {\n    // Prevent circular references\n    return object;\n  }\n\n  visited.push(object);\n\n  if (isArray(object)) {\n    return object.map((o) => walkAndFilter(o, visited));\n  }\n  if (!isObject(object)) {\n    if (isString(object)) {\n      if (patterns.containsEmails.test(object)) {\n        return object.replace(patterns.containsEmails, '[REDACTED]');\n      }\n    }\n\n    return object;\n  }\n\n  for (const [key, value] of Object.entries(object)) {\n    if (authTokenKeyPattern.test(key)) {\n      Reflect.deleteProperty(object, key);\n    }\n    else {\n      object[key] = walkAndFilter(value, visited);\n    }\n  }\n\n  return object;\n}\n\n/**\n * @class\n */\nconst Logger = WebexPlugin.extend({\n  namespace: 'Logger',\n\n  derived: {\n    level: {\n      cache: false,\n      fn() {\n        return this.getCurrentLevel();\n      }\n    },\n    client_level: {\n      cache: false,\n      fn() {\n        return this.getCurrentClientLevel();\n      }\n    }\n  },\n  session: {\n    // for when configured to use single buffer\n    buffer: {\n      type: 'array',\n      default() {\n        return [];\n      }\n    },\n    groupLevel: {\n      type: 'number',\n      default() {\n        return 0;\n      }\n    },\n    // for when configured to use separate buffers\n    sdkBuffer: {\n      type: 'array',\n      default() {\n        return [];\n      }\n    },\n    clientBuffer: {\n      type: 'array',\n      default() {\n        return [];\n      }\n    }\n  },\n\n  /**\n   * Ensures auth headers don't get printed in logs\n   * @param {Array<mixed>} args\n   * @private\n   * @memberof Logger\n   * @returns {Array<mixed>}\n   */\n  filter(...args) {\n    return args.map((arg) => {\n      // WebexHttpError already ensures auth tokens don't get printed, so, no\n      // need to alter it here.\n      if (arg instanceof Error) {\n        // karma logs won't print subclassed errors correctly, so we need\n        // explicitly call their tostring methods.\n        if (process.env.NODE_ENV === 'test' && inBrowser) {\n          let ret = arg.toString();\n\n          ret += 'BEGIN STACK';\n          ret += arg.stack;\n          ret += 'END STACK';\n\n          return ret;\n        }\n\n        return arg;\n      }\n\n      arg = cloneDeep(arg);\n\n      return walkAndFilter(arg);\n    });\n  },\n\n  /**\n   * Determines if the current level allows logs at the specified level to be\n   * printed\n   * @param {string} level\n   * @param {string} type type of log, SDK or client\n   * @private\n   * @memberof Logger\n   * @returns {boolean}\n   */\n  shouldPrint(level, type = LOG_TYPES.SDK) {\n    return precedence[level] <= precedence[type === LOG_TYPES.SDK ? this.getCurrentLevel() : this.getCurrentClientLevel()];\n  },\n\n  /**\n   * Determines if the current level allows logs at the specified level to be\n   * put into the log buffer. We're configuring it omit trace and debug logs\n   * because there are *a lot* of debug logs that really don't provide value at\n   * runtime (they're helpful for debugging locally, but really just pollute the\n   * uploaded logs and push useful info out).\n   * @param {string} level\n   * @param {string} type type of log, SDK or client\n   * @private\n   * @memberof Logger\n   * @returns {boolean}\n   */\n  shouldBuffer(level) {\n    return precedence[level] <= (this.config.bufferLogLevel ? precedence[this.config.bufferLogLevel] : precedence.info);\n  },\n\n  /**\n   * Indicates the current SDK log level based on env vars, feature toggles, and\n   * user type.\n   * @instance\n   * @memberof Logger\n   * @private\n   * @memberof Logger\n   * @returns {string}\n   */\n  // eslint-disable-next-line complexity\n  getCurrentLevel() {\n    // If a level has been explicitly set via config, alway use it.\n    if (this.config.level) {\n      return this.config.level;\n    }\n\n    if (levels.includes(process.env.WEBEX_LOG_LEVEL)) {\n      return process.env.WEBEX_LOG_LEVEL;\n    }\n\n    // Always use debug-level logging in test mode;\n    if (process.env.NODE_ENV === 'test') {\n      return 'trace';\n    }\n\n    // Use server-side-feature toggles to configure log levels\n    const level = this.webex.internal.device && this.webex.internal.device.features.developer.get('log-level');\n\n    if (level) {\n      if (levels.includes(level)) {\n        return level;\n      }\n    }\n\n    return 'error';\n  },\n\n  /**\n   * Indicates the current client log level based on config, defaults to SDK level\n   * @instance\n   * @memberof Logger\n   * @private\n   * @memberof Logger\n   * @returns {string}\n   */\n  getCurrentClientLevel() {\n    // If a client log level has been explicitly set via config, alway use it.\n    if (this.config.clientLevel) {\n      return this.config.clientLevel;\n    }\n\n    // otherwise default to SDK level\n    return this.getCurrentLevel();\n  },\n\n  /**\n   * Format logs (for upload)\n   *\n   * If separate client, SDK buffers is configured, merge the buffers, if configured\n   *\n   * @instance\n   * @memberof Logger\n   * @public\n   * @memberof Logger\n   * @returns {string} formatted buffer\n   */\n  formatLogs() {\n    function getDate(log) {\n      return log[1];\n    }\n    let buffer = [];\n    let clientIndex = 0;\n    let sdkIndex = 0;\n\n    if (this.config.separateLogBuffers) {\n      // merge the client and sdk buffers\n      // while we have entries in either buffer\n      while (clientIndex < this.clientBuffer.length || sdkIndex < this.sdkBuffer.length) {\n      // if we have remaining entries in the SDK buffer\n        if (sdkIndex < this.sdkBuffer.length &&\n          // and we haven't exhausted all the client buffer entries, or SDK date is before client date\n          (clientIndex >= this.clientBuffer.length ||\n            (new Date(getDate(this.sdkBuffer[sdkIndex])) <= new Date(getDate(this.clientBuffer[clientIndex]))))) {\n          // then add to the SDK buffer\n          buffer.push(this.sdkBuffer[sdkIndex]);\n          sdkIndex += 1;\n        }\n        // otherwise if we haven't exhausted all the client buffer entries, add client entry, whether it was because\n        // it was the only remaining entries or date was later (the above if)\n        else if (clientIndex < this.clientBuffer.length) {\n          buffer.push(this.clientBuffer[clientIndex]);\n          clientIndex += 1;\n        }\n      }\n    }\n    else {\n      buffer = this.buffer;\n    }\n\n    return buffer.join('\\n');\n  }\n});\n\n/**\n * Creates a logger method\n *\n *\n * @param {string} level level to create (info, error, warn, etc.)\n * @param {string} impl the level to use when writing to console\n * @param {string} type type of log, SDK or client\n * @param {bool} neverPrint function never prints to console\n * @param {bool} alwaysBuffer function always logs to log buffer\n * @instance\n * @memberof Logger\n * @private\n * @memberof Logger\n * @returns {function} logger method with specified params\n */\nfunction makeLoggerMethod(level, impl, type, neverPrint = false, alwaysBuffer = false) {\n  // Much of the complexity in the following function is due to a test-mode-only\n  // helper\n  return function wrappedConsoleMethod(...args) {\n    // it would be easier to just pass in the name and buffer here, but the config isn't completely initialized\n    // in Ampersand, even if the initialize method is used to set this up.  so we keep the type to achieve\n    // a sort of late binding to allow retrieving a name from config.\n    const logType = type;\n    const clientName = logType === LOG_TYPES.SDK ? SDK_LOG_TYPE_NAME : (this.config.clientName || logType);\n\n    let buffer;\n    let historyLength;\n\n    if (this.config.separateLogBuffers) {\n      historyLength = this.config.clientHistoryLength ? this.config.clientHistoryLength : this.config.historyLength;\n      buffer = logType === LOG_TYPES.SDK ? this.sdkBuffer : this.clientBuffer;\n    }\n    else {\n      buffer = this.buffer;\n      historyLength = this.config.historyLength;\n    }\n\n    try {\n      const shouldPrint = !neverPrint && this.shouldPrint(level, logType);\n      const shouldBuffer = alwaysBuffer || this.shouldBuffer(level);\n\n      if (!shouldBuffer && !shouldPrint) {\n        return;\n      }\n\n      const filtered = [clientName, ...this.filter(...args)];\n      const stringified = filtered.map((item) => {\n        if (item instanceof WebexHttpError) {\n          return item.toString();\n        }\n\n        return item;\n      });\n\n      if (shouldPrint) {\n        // when logging an object in browsers, we tend to get a dynamic\n        // reference, thus going back to look at the logged value doesn't\n        // necessarily show the state at log time, thus we print the stringified\n        // value.\n        const toPrint = inBrowser ? stringified : filtered;\n\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV === 'test' && has(this, 'webex.internal.device.url')) {\n          toPrint.unshift(this.webex.internal.device.url.slice(-3));\n        }\n        // eslint-disable-next-line no-console\n        console[impl](...toPrint);\n      }\n\n      if (shouldBuffer) {\n        const logDate = new Date();\n\n        stringified.unshift(logDate.toISOString());\n        stringified.unshift('|  '.repeat(this.groupLevel));\n        buffer.push(stringified);\n        if (buffer.length > historyLength) {\n          buffer.shift();\n        }\n        if (level === 'group') this.groupLevel += 1;\n        if (level === 'groupEnd' && this.groupLevel > 0) this.groupLevel -= 1;\n      }\n    }\n    catch (reason) {\n      if (!neverPrint) {\n        /* istanbul ignore next */\n        // eslint-disable-next-line no-console\n        console.warn(`failed to execute Logger#${level}`, reason);\n      }\n    }\n  };\n}\n\nlevels.forEach((level) => {\n  let impls = fallbacks[level];\n  let impl = level;\n\n  if (impls) {\n    impls = impls.slice();\n    // eslint-disable-next-line no-console\n    while (!console[impl]) {\n      impl = impls.pop();\n    }\n  }\n\n\n  // eslint-disable-next-line complexity\n  Logger.prototype[`client_${level}`] = makeLoggerMethod(level, impl, LOG_TYPES.CLIENT);\n  Logger.prototype[level] = makeLoggerMethod(level, impl, LOG_TYPES.SDK);\n});\n\nLogger.prototype.client_logToBuffer =\n  makeLoggerMethod(levels.info, levels.info, LOG_TYPES.CLIENT, true, true);\nLogger.prototype.logToBuffer = makeLoggerMethod(levels.info, levels.info, LOG_TYPES.SDK, true, true);\n\nexport default Logger;\n"]},"metadata":{},"sourceType":"script"}