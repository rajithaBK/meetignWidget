{"ast":null,"code":"/* eslint-disable indent */\n\n/*\n * Copyright (c) 2016-2018, Peculiar Ventures\n * All rights reserved.\n *\n * Author 2016-2018, Yury Strozhevsky <www.strozhevsky.com>.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its contributors\n *    may be used to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\n * OF SUCH DAMAGE.\n *\n */\n//**************************************************************************************\nimport { getParametersValue, padNumber, isEqualBuffer, bufferToHexCodes, checkBufferParams, utilToBase, utilFromBase, utilEncodeTC, utilDecodeTC, utilConcatBuf, utilConcatView } from \"pvutils\"; //**************************************************************************************\n//region Other utility functions\n//**************************************************************************************\n\nfunction assertBigInt() {\n  if (typeof BigInt === \"undefined\") {\n    throw new Error(\"BigInt is not defined. Your environment doesn't implement BigInt.\");\n  }\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of global variables\n//**************************************************************************************\n\n\nconst powers2 = [new Uint8Array([1])];\nconst digitsString = \"0123456789\"; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration for \"LocalBaseBlock\" class\n//**************************************************************************************\n\n/**\n * Class used as a base block for all remaining ASN.1 classes\n * @typedef LocalBaseBlock\n * @interface\n * @property {number} blockLength\n * @property {string} error\n * @property {Array.<string>} warnings\n * @property {ArrayBuffer} valueBeforeDecode\n */\n\nclass LocalBaseBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalBaseBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueBeforeDecode]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    /**\n     * @type {number} blockLength\n     */\n    this.blockLength = getParametersValue(parameters, \"blockLength\", 0);\n    /**\n     * @type {string} error\n     */\n\n    this.error = getParametersValue(parameters, \"error\", \"\");\n    /**\n     * @type {Array.<string>} warnings\n     */\n\n    this.warnings = getParametersValue(parameters, \"warnings\", []); //noinspection JSCheckFunctionSignatures\n\n    /**\n     * @type {ArrayBuffer} valueBeforeDecode\n     */\n\n    if (\"valueBeforeDecode\" in parameters) this.valueBeforeDecode = parameters.valueBeforeDecode.slice(0);else this.valueBeforeDecode = new ArrayBuffer(0);\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"baseBlock\";\n  } //**********************************************************************************\n\n  /**\n   * Convertion for the block to JSON object\n   * @returns {{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n   */\n\n\n  toJSON() {\n    return {\n      blockName: this.constructor.blockName(),\n      blockLength: this.blockLength,\n      error: this.error,\n      warnings: this.warnings,\n      valueBeforeDecode: bufferToHexCodes(this.valueBeforeDecode, 0, this.valueBeforeDecode.byteLength)\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Description for \"HexBlock\" class\n//**************************************************************************************\n\n/**\n * Class used as a base block for all remaining ASN.1 classes\n * @extends LocalBaseBlock\n * @typedef HexBlock\n * @property {number} blockLength\n * @property {string} error\n * @property {Array.<string>} warnings\n * @property {ArrayBuffer} valueBeforeDecode\n * @property {boolean} isHexOnly\n * @property {ArrayBuffer} valueHex\n */\n//noinspection JSUnusedLocalSymbols\n\n\nexport const HexBlock = BaseClass => class LocalHexBlockMixin extends BaseClass {\n  //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\n   * Constructor for \"HexBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    /**\n     * @type {boolean}\n     */\n\n    this.isHexOnly = getParametersValue(parameters, \"isHexOnly\", false);\n    /**\n     * @type {ArrayBuffer}\n     */\n\n    if (\"valueHex\" in parameters) this.valueHex = parameters.valueHex.slice(0);else this.valueHex = new ArrayBuffer(0);\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"hexBlock\";\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n    if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n    //region Initial checks\n\n    if (intBuffer.length === 0) {\n      this.warnings.push(\"Zero buffer length\");\n      return inputOffset;\n    } //endregion\n    //region Copy input buffer to internal buffer\n\n\n    this.valueHex = inputBuffer.slice(inputOffset, inputOffset + inputLength); //endregion\n\n    this.blockLength = inputLength;\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n\n  /**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\n\n  toBER() {\n    let sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    if (this.isHexOnly !== true) {\n      this.error = \"Flag \\\"isHexOnly\\\" is not set, abort\";\n      return new ArrayBuffer(0);\n    }\n\n    if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength); //noinspection JSCheckFunctionSignatures\n\n    return this.valueHex.slice(0);\n  } //**********************************************************************************\n\n  /**\n   * Convertion for the block to JSON object\n   * @returns {Object}\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.blockName = this.constructor.blockName();\n    object.isHexOnly = this.isHexOnly;\n    object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n    return object;\n  } //**********************************************************************************\n\n\n}; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of identification block class\n//**************************************************************************************\n\nclass LocalIdentificationBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalBaseBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {Object} [idBlock]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n\n    if (\"idBlock\" in parameters) {\n      //region Properties from hexBlock class\n      this.isHexOnly = getParametersValue(parameters.idBlock, \"isHexOnly\", false);\n      this.valueHex = getParametersValue(parameters.idBlock, \"valueHex\", new ArrayBuffer(0)); //endregion\n\n      this.tagClass = getParametersValue(parameters.idBlock, \"tagClass\", -1);\n      this.tagNumber = getParametersValue(parameters.idBlock, \"tagNumber\", -1);\n      this.isConstructed = getParametersValue(parameters.idBlock, \"isConstructed\", false);\n    } else {\n      this.tagClass = -1;\n      this.tagNumber = -1;\n      this.isConstructed = false;\n    }\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"identificationBlock\";\n  } //**********************************************************************************\n\n  /**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\n\n  toBER() {\n    let sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    //region Initial variables\n    let firstOctet = 0;\n    let retBuf;\n    let retView; //endregion\n\n    switch (this.tagClass) {\n      case 1:\n        firstOctet |= 0x00; // UNIVERSAL\n\n        break;\n\n      case 2:\n        firstOctet |= 0x40; // APPLICATION\n\n        break;\n\n      case 3:\n        firstOctet |= 0x80; // CONTEXT-SPECIFIC\n\n        break;\n\n      case 4:\n        firstOctet |= 0xC0; // PRIVATE\n\n        break;\n\n      default:\n        this.error = \"Unknown tag class\";\n        return new ArrayBuffer(0);\n    }\n\n    if (this.isConstructed) firstOctet |= 0x20;\n\n    if (this.tagNumber < 31 && !this.isHexOnly) {\n      retBuf = new ArrayBuffer(1);\n      retView = new Uint8Array(retBuf);\n\n      if (!sizeOnly) {\n        let number = this.tagNumber;\n        number &= 0x1F;\n        firstOctet |= number;\n        retView[0] = firstOctet;\n      }\n\n      return retBuf;\n    }\n\n    if (this.isHexOnly === false) {\n      const encodedBuf = utilToBase(this.tagNumber, 7);\n      const encodedView = new Uint8Array(encodedBuf);\n      const size = encodedBuf.byteLength;\n      retBuf = new ArrayBuffer(size + 1);\n      retView = new Uint8Array(retBuf);\n      retView[0] = firstOctet | 0x1F;\n\n      if (!sizeOnly) {\n        for (let i = 0; i < size - 1; i++) retView[i + 1] = encodedView[i] | 0x80;\n\n        retView[size] = encodedView[size - 1];\n      }\n\n      return retBuf;\n    }\n\n    retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);\n    retView = new Uint8Array(retBuf);\n    retView[0] = firstOctet | 0x1F;\n\n    if (sizeOnly === false) {\n      const curView = new Uint8Array(this.valueHex);\n\n      for (let i = 0; i < curView.length - 1; i++) retView[i + 1] = curView[i] | 0x80;\n\n      retView[this.valueHex.byteLength] = curView[curView.length - 1];\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number}\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n    if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n    //region Initial checks\n\n    if (intBuffer.length === 0) {\n      this.error = \"Zero buffer length\";\n      return -1;\n    } //endregion\n    //region Find tag class\n\n\n    const tagClassMask = intBuffer[0] & 0xC0;\n\n    switch (tagClassMask) {\n      case 0x00:\n        this.tagClass = 1; // UNIVERSAL\n\n        break;\n\n      case 0x40:\n        this.tagClass = 2; // APPLICATION\n\n        break;\n\n      case 0x80:\n        this.tagClass = 3; // CONTEXT-SPECIFIC\n\n        break;\n\n      case 0xC0:\n        this.tagClass = 4; // PRIVATE\n\n        break;\n\n      default:\n        this.error = \"Unknown tag class\";\n        return -1;\n    } //endregion\n    //region Find it's constructed or not\n\n\n    this.isConstructed = (intBuffer[0] & 0x20) === 0x20; //endregion\n    //region Find tag number\n\n    this.isHexOnly = false;\n    const tagNumberMask = intBuffer[0] & 0x1F; //region Simple case (tag number < 31)\n\n    if (tagNumberMask !== 0x1F) {\n      this.tagNumber = tagNumberMask;\n      this.blockLength = 1;\n    } //endregion\n    //region Tag number bigger or equal to 31\n    else {\n      let count = 1;\n      this.valueHex = new ArrayBuffer(255);\n      let tagNumberBufferMaxLength = 255;\n      let intTagNumberBuffer = new Uint8Array(this.valueHex); //noinspection JSBitwiseOperatorUsage\n\n      while (intBuffer[count] & 0x80) {\n        intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\n        count++;\n\n        if (count >= intBuffer.length) {\n          this.error = \"End of input reached before message was fully decoded\";\n          return -1;\n        } //region In case if tag number length is greater than 255 bytes (rare but possible case)\n\n\n        if (count === tagNumberBufferMaxLength) {\n          tagNumberBufferMaxLength += 255;\n          const tempBuffer = new ArrayBuffer(tagNumberBufferMaxLength);\n          const tempBufferView = new Uint8Array(tempBuffer);\n\n          for (let i = 0; i < intTagNumberBuffer.length; i++) tempBufferView[i] = intTagNumberBuffer[i];\n\n          this.valueHex = new ArrayBuffer(tagNumberBufferMaxLength);\n          intTagNumberBuffer = new Uint8Array(this.valueHex);\n        } //endregion\n\n      }\n\n      this.blockLength = count + 1;\n      intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F; // Write last byte to buffer\n      //region Cut buffer\n\n      const tempBuffer = new ArrayBuffer(count);\n      const tempBufferView = new Uint8Array(tempBuffer);\n\n      for (let i = 0; i < count; i++) tempBufferView[i] = intTagNumberBuffer[i];\n\n      this.valueHex = new ArrayBuffer(count);\n      intTagNumberBuffer = new Uint8Array(this.valueHex);\n      intTagNumberBuffer.set(tempBufferView); //endregion\n      //region Try to convert long tag number to short form\n\n      if (this.blockLength <= 9) this.tagNumber = utilFromBase(intTagNumberBuffer, 7);else {\n        this.isHexOnly = true;\n        this.warnings.push(\"Tag too long, represented as hex-coded\");\n      } //endregion\n    } //endregion\n    //endregion\n    //region Check if constructed encoding was using for primitive type\n\n\n    if (this.tagClass === 1 && this.isConstructed) {\n      switch (this.tagNumber) {\n        case 1: // Boolean\n\n        case 2: // REAL\n\n        case 5: // Null\n\n        case 6: // OBJECT IDENTIFIER\n\n        case 9: // REAL\n\n        case 13: // RELATIVE OBJECT IDENTIFIER\n\n        case 14: // Time\n\n        case 23:\n        case 24:\n        case 31:\n        case 32:\n        case 33:\n        case 34:\n          this.error = \"Constructed encoding used for primitive type\";\n          return -1;\n\n        default:\n      }\n    } //endregion\n\n\n    return inputOffset + this.blockLength; // Return current offset in input buffer\n  } //**********************************************************************************\n\n  /**\n   * Convertion for the block to JSON object\n   * @returns {{blockName: string,\n   *  tagClass: number,\n   *  tagNumber: number,\n   *  isConstructed: boolean,\n   *  isHexOnly: boolean,\n   *  valueHex: ArrayBuffer,\n   *  blockLength: number,\n   *  error: string, warnings: Array.<string>,\n   *  valueBeforeDecode: string}}\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.blockName = this.constructor.blockName();\n    object.tagClass = this.tagClass;\n    object.tagNumber = this.tagNumber;\n    object.isConstructed = this.isConstructed;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of length block class\n//**************************************************************************************\n\n\nclass LocalLengthBlock extends LocalBaseBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalLengthBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {Object} [lenBlock]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n\n    if (\"lenBlock\" in parameters) {\n      this.isIndefiniteForm = getParametersValue(parameters.lenBlock, \"isIndefiniteForm\", false);\n      this.longFormUsed = getParametersValue(parameters.lenBlock, \"longFormUsed\", false);\n      this.length = getParametersValue(parameters.lenBlock, \"length\", 0);\n    } else {\n      this.isIndefiniteForm = false;\n      this.longFormUsed = false;\n      this.length = 0;\n    }\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"lengthBlock\";\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number}\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n    if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n    //region Initial checks\n\n    if (intBuffer.length === 0) {\n      this.error = \"Zero buffer length\";\n      return -1;\n    }\n\n    if (intBuffer[0] === 0xFF) {\n      this.error = \"Length block 0xFF is reserved by standard\";\n      return -1;\n    } //endregion\n    //region Check for length form type\n\n\n    this.isIndefiniteForm = intBuffer[0] === 0x80; //endregion\n    //region Stop working in case of indefinite length form\n\n    if (this.isIndefiniteForm === true) {\n      this.blockLength = 1;\n      return inputOffset + this.blockLength;\n    } //endregion\n    //region Check is long form of length encoding using\n\n\n    this.longFormUsed = !!(intBuffer[0] & 0x80); //endregion\n    //region Stop working in case of short form of length value\n\n    if (this.longFormUsed === false) {\n      this.length = intBuffer[0];\n      this.blockLength = 1;\n      return inputOffset + this.blockLength;\n    } //endregion\n    //region Calculate length value in case of long form\n\n\n    const count = intBuffer[0] & 0x7F;\n\n    if (count > 8) // Too big length value\n      {\n        this.error = \"Too big integer\";\n        return -1;\n      }\n\n    if (count + 1 > intBuffer.length) {\n      this.error = \"End of input reached before message was fully decoded\";\n      return -1;\n    }\n\n    const lengthBufferView = new Uint8Array(count);\n\n    for (let i = 0; i < count; i++) lengthBufferView[i] = intBuffer[i + 1];\n\n    if (lengthBufferView[count - 1] === 0x00) this.warnings.push(\"Needlessly long encoded length\");\n    this.length = utilFromBase(lengthBufferView, 8);\n    if (this.longFormUsed && this.length <= 127) this.warnings.push(\"Unnecessary usage of long length form\");\n    this.blockLength = count + 1; //endregion\n\n    return inputOffset + this.blockLength; // Return current offset in input buffer\n  } //**********************************************************************************\n\n  /**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\n\n  toBER() {\n    let sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    //region Initial variables\n    let retBuf;\n    let retView; //endregion\n\n    if (this.length > 127) this.longFormUsed = true;\n\n    if (this.isIndefiniteForm) {\n      retBuf = new ArrayBuffer(1);\n\n      if (sizeOnly === false) {\n        retView = new Uint8Array(retBuf);\n        retView[0] = 0x80;\n      }\n\n      return retBuf;\n    }\n\n    if (this.longFormUsed === true) {\n      const encodedBuf = utilToBase(this.length, 8);\n\n      if (encodedBuf.byteLength > 127) {\n        this.error = \"Too big length\";\n        return new ArrayBuffer(0);\n      }\n\n      retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);\n      if (sizeOnly === true) return retBuf;\n      const encodedView = new Uint8Array(encodedBuf);\n      retView = new Uint8Array(retBuf);\n      retView[0] = encodedBuf.byteLength | 0x80;\n\n      for (let i = 0; i < encodedBuf.byteLength; i++) retView[i + 1] = encodedView[i];\n\n      return retBuf;\n    }\n\n    retBuf = new ArrayBuffer(1);\n\n    if (sizeOnly === false) {\n      retView = new Uint8Array(retBuf);\n      retView[0] = this.length;\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\n   * Convertion for the block to JSON object\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.blockName = this.constructor.blockName();\n    object.isIndefiniteForm = this.isIndefiniteForm;\n    object.longFormUsed = this.longFormUsed;\n    object.length = this.length;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of value block class\n//**************************************************************************************\n\n\nexport class ValueBlock extends LocalBaseBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"ValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"valueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols,JSUnusedLocalSymbols\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number}\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Throw an exception for a function which needs to be specified in extended classes\n    throw TypeError(\"User need to make a specific function in a class which extends \\\"ValueBlock\\\"\"); //endregion\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols\n\n  /**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\n\n  toBER() {\n    let sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    //region Throw an exception for a function which needs to be specified in extended classes\n    throw TypeError(\"User need to make a specific function in a class which extends \\\"ValueBlock\\\"\"); //endregion\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic ASN.1 block class\n//**************************************************************************************\n\nexport class BaseBlock extends LocalBaseBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"BaseBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {Object} [primitiveSchema]\n   * @property {string} [name]\n   * @property {boolean} [optional]\n   * @param valueBlockType Type of value block\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let valueBlockType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ValueBlock;\n    super(parameters);\n    if (\"name\" in parameters) this.name = parameters.name;\n    if (\"optional\" in parameters) this.optional = parameters.optional;\n    if (\"primitiveSchema\" in parameters) this.primitiveSchema = parameters.primitiveSchema;\n    this.idBlock = new LocalIdentificationBlock(parameters);\n    this.lenBlock = new LocalLengthBlock(parameters);\n    this.valueBlock = new valueBlockType(parameters);\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"BaseBlock\";\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number}\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\n\n  toBER() {\n    let sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let retBuf;\n    const idBlockBuf = this.idBlock.toBER(sizeOnly);\n    const valueBlockSizeBuf = this.valueBlock.toBER(true);\n    this.lenBlock.length = valueBlockSizeBuf.byteLength;\n    const lenBlockBuf = this.lenBlock.toBER(sizeOnly);\n    retBuf = utilConcatBuf(idBlockBuf, lenBlockBuf);\n    let valueBlockBuf;\n    if (sizeOnly === false) valueBlockBuf = this.valueBlock.toBER(sizeOnly);else valueBlockBuf = new ArrayBuffer(this.lenBlock.length);\n    retBuf = utilConcatBuf(retBuf, valueBlockBuf);\n\n    if (this.lenBlock.isIndefiniteForm === true) {\n      const indefBuf = new ArrayBuffer(2);\n\n      if (sizeOnly === false) {\n        const indefView = new Uint8Array(indefBuf);\n        indefView[0] = 0x00;\n        indefView[1] = 0x00;\n      }\n\n      retBuf = utilConcatBuf(retBuf, indefBuf);\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\n   * Convertion for the block to JSON object\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.idBlock = this.idBlock.toJSON();\n    object.lenBlock = this.lenBlock.toJSON();\n    object.valueBlock = this.valueBlock.toJSON();\n    if (\"name\" in this) object.name = this.name;\n    if (\"optional\" in this) object.optional = this.optional;\n    if (\"primitiveSchema\" in this) object.primitiveSchema = this.primitiveSchema.toJSON();\n    return object;\n  } //**********************************************************************************\n\n\n  toString() {\n    return `${this.constructor.blockName()} : ${bufferToHexCodes(this.valueBlock.valueHex)}`;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic block for all PRIMITIVE types\n//**************************************************************************************\n\nclass LocalPrimitiveValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalPrimitiveValueBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueBeforeDecode]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters); //region Variables from \"hexBlock\" class\n\n    if (\"valueHex\" in parameters) this.valueHex = parameters.valueHex.slice(0);else this.valueHex = new ArrayBuffer(0);\n    this.isHexOnly = getParametersValue(parameters, \"isHexOnly\", true); //endregion\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number}\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n    if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n    //region Initial checks\n\n    if (intBuffer.length === 0) {\n      this.warnings.push(\"Zero buffer length\");\n      return inputOffset;\n    } //endregion\n    //region Copy input buffer into internal buffer\n\n\n    this.valueHex = new ArrayBuffer(intBuffer.length);\n    const valueHexView = new Uint8Array(this.valueHex);\n\n    for (let i = 0; i < intBuffer.length; i++) valueHexView[i] = intBuffer[i]; //endregion\n\n\n    this.blockLength = inputLength;\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols\n\n  /**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\n\n  toBER() {\n    let sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return this.valueHex.slice(0);\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"PrimitiveValueBlock\";\n  } //**********************************************************************************\n\n  /**\n   * Convertion for the block to JSON object\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n    object.isHexOnly = this.isHexOnly;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexport class Primitive extends BaseBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Primitive\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters, LocalPrimitiveValueBlock);\n    this.idBlock.isConstructed = false;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"PRIMITIVE\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic block for all CONSTRUCTED types\n//**************************************************************************************\n\nclass LocalConstructedValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalConstructedValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.value = getParametersValue(parameters, \"value\", []);\n    this.isIndefiniteForm = getParametersValue(parameters, \"isIndefiniteForm\", false);\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number}\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Store initial offset and length\n    const initialOffset = inputOffset;\n    const initialLength = inputLength; //endregion\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n\n    if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n    //region Initial checks\n\n    if (intBuffer.length === 0) {\n      this.warnings.push(\"Zero buffer length\");\n      return inputOffset;\n    } //endregion\n    //region Aux function\n\n\n    function checkLen(indefiniteLength, length) {\n      if (indefiniteLength === true) return 1;\n      return length;\n    } //endregion\n\n\n    let currentOffset = inputOffset;\n\n    while (checkLen(this.isIndefiniteForm, inputLength) > 0) {\n      const returnObject = LocalFromBER(inputBuffer, currentOffset, inputLength);\n\n      if (returnObject.offset === -1) {\n        this.error = returnObject.result.error;\n        this.warnings.concat(returnObject.result.warnings);\n        return -1;\n      }\n\n      currentOffset = returnObject.offset;\n      this.blockLength += returnObject.result.blockLength;\n      inputLength -= returnObject.result.blockLength;\n      this.value.push(returnObject.result);\n      if (this.isIndefiniteForm === true && returnObject.result.constructor.blockName() === EndOfContent.blockName()) break;\n    }\n\n    if (this.isIndefiniteForm === true) {\n      if (this.value[this.value.length - 1].constructor.blockName() === EndOfContent.blockName()) this.value.pop();else this.warnings.push(\"No EndOfContent block encoded\");\n    } //region Copy \"inputBuffer\" to \"valueBeforeDecode\"\n\n\n    this.valueBeforeDecode = inputBuffer.slice(initialOffset, initialOffset + initialLength); //endregion\n\n    return currentOffset;\n  } //**********************************************************************************\n\n  /**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\n\n  toBER() {\n    let sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let retBuf = new ArrayBuffer(0);\n\n    for (let i = 0; i < this.value.length; i++) {\n      const valueBuf = this.value[i].toBER(sizeOnly);\n      retBuf = utilConcatBuf(retBuf, valueBuf);\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"ConstructedValueBlock\";\n  } //**********************************************************************************\n\n  /**\n   * Convertion for the block to JSON object\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.isIndefiniteForm = this.isIndefiniteForm;\n    object.value = [];\n\n    for (let i = 0; i < this.value.length; i++) object.value.push(this.value[i].toJSON());\n\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexport class Constructed extends BaseBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Constructed\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters, LocalConstructedValueBlock);\n    this.idBlock.isConstructed = true;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"CONSTRUCTED\";\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number}\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n\n  toString() {\n    const values = [];\n\n    for (const value of this.valueBlock.value) {\n      values.push(value.toString().split(\"\\n\").map(o => `  ${o}`).join(\"\\n\"));\n    }\n\n    const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.blockName();\n    return values.length ? `${blockName} :\\n${values.join(\"\\n\")}` // items\n    : `${blockName} :`; // empty\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 EndOfContent type class\n//**************************************************************************************\n\nclass LocalEndOfContentValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalEndOfContentValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number}\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region There is no \"value block\" for EndOfContent type and we need to return the same offset\n    return inputOffset; //endregion\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols\n\n  /**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\n\n  toBER() {\n    let sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return new ArrayBuffer(0);\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"EndOfContentValueBlock\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexport class EndOfContent extends BaseBlock {\n  //**********************************************************************************\n  constructor() {\n    let paramaters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(paramaters, LocalEndOfContentValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 0; // EndOfContent\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"EndOfContent\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Boolean type class\n//**************************************************************************************\n\nclass LocalBooleanValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalBooleanValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.value = getParametersValue(parameters, \"value\", false);\n    this.isHexOnly = getParametersValue(parameters, \"isHexOnly\", false);\n    if (\"valueHex\" in parameters) this.valueHex = parameters.valueHex.slice(0);else {\n      this.valueHex = new ArrayBuffer(1);\n\n      if (this.value === true) {\n        const view = new Uint8Array(this.valueHex);\n        view[0] = 0xFF;\n      }\n    }\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n    if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n\n    if (inputLength > 1) this.warnings.push(\"Boolean value encoded in more then 1 octet\");\n    this.isHexOnly = true; //region Copy input buffer to internal array\n\n    this.valueHex = new ArrayBuffer(intBuffer.length);\n    const view = new Uint8Array(this.valueHex);\n\n    for (let i = 0; i < intBuffer.length; i++) view[i] = intBuffer[i]; //endregion\n\n\n    if (utilDecodeTC.call(this) !== 0) this.value = true;else this.value = false;\n    this.blockLength = inputLength;\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols\n\n  /**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\n\n  toBER() {\n    let sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return this.valueHex;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"BooleanValueBlock\";\n  } //**********************************************************************************\n\n  /**\n   * Convertion for the block to JSON object\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.value;\n    object.isHexOnly = this.isHexOnly;\n    object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexport class Boolean extends BaseBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Boolean\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters, LocalBooleanValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 1; // Boolean\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"BOOLEAN\";\n  } //**********************************************************************************\n\n\n  toString() {\n    return `${this.constructor.blockName()} : ${this.valueBlock.value}`;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Sequence and Set type classes\n//**************************************************************************************\n\nexport class Sequence extends Constructed {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Sequence\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 16; // Sequence\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"SEQUENCE\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\nexport class Set extends Constructed {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Set\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 17; // Set\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"SET\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Null type class\n//**************************************************************************************\n\nexport class Null extends BaseBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Null\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters, LocalBaseBlock); // We will not have a call to \"Null value block\" because of specified \"fromBER\" and \"toBER\" functions\n\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 5; // Null\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"NULL\";\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    if (this.lenBlock.length > 0) this.warnings.push(\"Non-zero length of value block for Null type\");\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    this.blockLength += inputLength;\n\n    if (inputOffset + inputLength > inputBuffer.byteLength) {\n      this.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\n      return -1;\n    }\n\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n\n  /**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\n\n  toBER() {\n    let sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const retBuf = new ArrayBuffer(2);\n    if (sizeOnly === true) return retBuf;\n    const retView = new Uint8Array(retBuf);\n    retView[0] = 0x05;\n    retView[1] = 0x00;\n    return retBuf;\n  } //**********************************************************************************\n\n\n  toString() {\n    return `${this.constructor.blockName()}`;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 OctetString type class\n//**************************************************************************************\n\nclass LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalOctetStringValueBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.isConstructed = getParametersValue(parameters, \"isConstructed\", false);\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    let resultOffset = 0;\n\n    if (this.isConstructed === true) {\n      this.isHexOnly = false;\n      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n      if (resultOffset === -1) return resultOffset;\n\n      for (let i = 0; i < this.value.length; i++) {\n        const currentBlockName = this.value[i].constructor.blockName();\n\n        if (currentBlockName === EndOfContent.blockName()) {\n          if (this.isIndefiniteForm === true) break;else {\n            this.error = \"EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only\";\n            return -1;\n          }\n        }\n\n        if (currentBlockName !== OctetString.blockName()) {\n          this.error = \"OCTET STRING may consists of OCTET STRINGs only\";\n          return -1;\n        }\n      }\n    } else {\n      this.isHexOnly = true;\n      resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n      this.blockLength = inputLength;\n    }\n\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\n\n  toBER() {\n    let sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.isConstructed === true) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);\n    let retBuf = new ArrayBuffer(this.valueHex.byteLength);\n    if (sizeOnly === true) return retBuf;\n    if (this.valueHex.byteLength === 0) return retBuf;\n    retBuf = this.valueHex.slice(0);\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"OctetStringValueBlock\";\n  } //**********************************************************************************\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.isConstructed = this.isConstructed;\n    object.isHexOnly = this.isHexOnly;\n    object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexport class OctetString extends BaseBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"OctetString\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters, LocalOctetStringValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 4; // OctetString\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    this.valueBlock.isConstructed = this.idBlock.isConstructed;\n    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm; //region Ability to encode empty OCTET STRING\n\n    if (inputLength === 0) {\n      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n      return inputOffset;\n    } //endregion\n\n\n    if (!this.valueBlock.isConstructed) {\n      const buf = inputBuffer.slice(inputOffset, inputOffset + inputLength);\n\n      try {\n        const asn = fromBER(buf);\n\n        if (asn.offset !== -1 && asn.offset === inputLength) {\n          this.valueBlock.value = [asn.result];\n        }\n      } catch (e) {// nothing\n      }\n    }\n\n    return super.fromBER(inputBuffer, inputOffset, inputLength);\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"OCTET STRING\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\n   * Checking that two OCTETSTRINGs are equal\n   * @param {OctetString} octetString\n   */\n\n\n  isEqual(octetString) {\n    //region Check input type\n    if (octetString instanceof OctetString === false) return false; //endregion\n    //region Compare two JSON strings\n\n    if (JSON.stringify(this) !== JSON.stringify(octetString)) return false; //endregion\n\n    return true;\n  } //**********************************************************************************\n\n\n  toString() {\n    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {\n      return Constructed.prototype.toString.call(this);\n    } else {\n      return `${this.constructor.blockName()} : ${bufferToHexCodes(this.valueBlock.valueHex)}`;\n    }\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 BitString type class\n//**************************************************************************************\n\nclass LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalBitStringValueBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.unusedBits = getParametersValue(parameters, \"unusedBits\", 0);\n    this.isConstructed = getParametersValue(parameters, \"isConstructed\", false);\n    this.blockLength = this.valueHex.byteLength;\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Ability to decode zero-length BitString value\n    if (inputLength === 0) return inputOffset; //endregion\n\n    let resultOffset = -1; //region If the BISTRING supposed to be a constructed value\n\n    if (this.isConstructed === true) {\n      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n      if (resultOffset === -1) return resultOffset;\n\n      for (let i = 0; i < this.value.length; i++) {\n        const currentBlockName = this.value[i].constructor.blockName();\n\n        if (currentBlockName === EndOfContent.blockName()) {\n          if (this.isIndefiniteForm === true) break;else {\n            this.error = \"EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only\";\n            return -1;\n          }\n        }\n\n        if (currentBlockName !== BitString.blockName()) {\n          this.error = \"BIT STRING may consists of BIT STRINGs only\";\n          return -1;\n        }\n\n        if (this.unusedBits > 0 && this.value[i].valueBlock.unusedBits > 0) {\n          this.error = \"Using of \\\"unused bits\\\" inside constructive BIT STRING allowed for least one only\";\n          return -1;\n        }\n\n        this.unusedBits = this.value[i].valueBlock.unusedBits;\n\n        if (this.unusedBits > 7) {\n          this.error = \"Unused bits for BitString must be in range 0-7\";\n          return -1;\n        }\n      }\n\n      return resultOffset;\n    } //endregion\n    //region If the BitString supposed to be a primitive value\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n\n\n    if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n    this.unusedBits = intBuffer[0];\n\n    if (this.unusedBits > 7) {\n      this.error = \"Unused bits for BitString must be in range 0-7\";\n      return -1;\n    }\n\n    if (!this.unusedBits) {\n      const buf = inputBuffer.slice(inputOffset + 1, inputOffset + inputLength);\n\n      try {\n        const asn = fromBER(buf);\n\n        if (asn.offset !== -1 && asn.offset === inputLength - 1) {\n          this.value = [asn.result];\n        }\n      } catch (e) {// nothing\n      }\n    } //region Copy input buffer to internal buffer\n\n\n    this.valueHex = new ArrayBuffer(intBuffer.length - 1);\n    const view = new Uint8Array(this.valueHex);\n\n    for (let i = 0; i < inputLength - 1; i++) view[i] = intBuffer[i + 1]; //endregion\n\n\n    this.blockLength = intBuffer.length;\n    return inputOffset + inputLength; //endregion\n  } //**********************************************************************************\n\n  /**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\n\n  toBER() {\n    let sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.isConstructed === true) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);\n    if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength + 1);\n    if (this.valueHex.byteLength === 0) return new ArrayBuffer(0);\n    const curView = new Uint8Array(this.valueHex);\n    const retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);\n    const retView = new Uint8Array(retBuf);\n    retView[0] = this.unusedBits;\n\n    for (let i = 0; i < this.valueHex.byteLength; i++) retView[i + 1] = curView[i];\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"BitStringValueBlock\";\n  } //**********************************************************************************\n\n  /**\n   * Convertion for the block to JSON object\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.unusedBits = this.unusedBits;\n    object.isConstructed = this.isConstructed;\n    object.isHexOnly = this.isHexOnly;\n    object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexport class BitString extends BaseBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"BitString\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters, LocalBitStringValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 3; // BitString\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"BIT STRING\";\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Ability to encode empty BitString\n    if (inputLength === 0) return inputOffset; //endregion\n\n    this.valueBlock.isConstructed = this.idBlock.isConstructed;\n    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n    return super.fromBER(inputBuffer, inputOffset, inputLength);\n  } //**********************************************************************************\n\n  /**\n   * Checking that two BITSTRINGs are equal\n   * @param {BitString} bitString\n   */\n\n\n  isEqual(bitString) {\n    //region Check input type\n    if (bitString instanceof BitString === false) return false; //endregion\n    //region Compare two JSON strings\n\n    if (JSON.stringify(this) !== JSON.stringify(bitString)) return false; //endregion\n\n    return true;\n  } //**********************************************************************************\n\n\n  toString() {\n    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {\n      return Constructed.prototype.toString.call(this);\n    } else {\n      // convert bytes to bits\n      const bits = [];\n      const valueHex = new Uint8Array(this.valueBlock.valueHex);\n\n      for (const byte of valueHex) {\n        bits.push(byte.toString(2).padStart(8, \"0\"));\n      }\n\n      return `${this.constructor.blockName()} : ${bits.join(\"\")}`;\n    }\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Integer type class\n//**************************************************************************************\n\n/**\n * @extends ValueBlock\n */\n\nclass LocalIntegerValueBlock extends HexBlock(ValueBlock) {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalIntegerValueBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    if (\"value\" in parameters) this.valueDec = parameters.value;\n  } //**********************************************************************************\n\n  /**\n   * Setter for \"valueHex\"\n   * @param {ArrayBuffer} _value\n   */\n\n\n  set valueHex(_value) {\n    this._valueHex = _value.slice(0);\n\n    if (_value.byteLength >= 4) {\n      this.warnings.push(\"Too big Integer for decoding, hex only\");\n      this.isHexOnly = true;\n      this._valueDec = 0;\n    } else {\n      this.isHexOnly = false;\n      if (_value.byteLength > 0) this._valueDec = utilDecodeTC.call(this);\n    }\n  } //**********************************************************************************\n\n  /**\n   * Getter for \"valueHex\"\n   * @returns {ArrayBuffer}\n   */\n\n\n  get valueHex() {\n    return this._valueHex;\n  } //**********************************************************************************\n\n  /**\n   * Getter for \"valueDec\"\n   * @param {number} _value\n   */\n\n\n  set valueDec(_value) {\n    this._valueDec = _value;\n    this.isHexOnly = false;\n    this._valueHex = utilEncodeTC(_value);\n  } //**********************************************************************************\n\n  /**\n   * Getter for \"valueDec\"\n   * @returns {number}\n   */\n\n\n  get valueDec() {\n    return this._valueDec;\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from DER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 DER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 DER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @param {number} [expectedLength=0] Expected length of converted \"valueHex\" buffer\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  fromDER(inputBuffer, inputOffset, inputLength) {\n    let expectedLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    const offset = this.fromBER(inputBuffer, inputOffset, inputLength);\n    if (offset === -1) return offset;\n    const view = new Uint8Array(this._valueHex);\n\n    if (view[0] === 0x00 && (view[1] & 0x80) !== 0) {\n      const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);\n      const updatedView = new Uint8Array(updatedValueHex);\n      updatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));\n      this._valueHex = updatedValueHex.slice(0);\n    } else {\n      if (expectedLength !== 0) {\n        if (this._valueHex.byteLength < expectedLength) {\n          if (expectedLength - this._valueHex.byteLength > 1) expectedLength = this._valueHex.byteLength + 1;\n          const updatedValueHex = new ArrayBuffer(expectedLength);\n          const updatedView = new Uint8Array(updatedValueHex);\n          updatedView.set(view, expectedLength - this._valueHex.byteLength);\n          this._valueHex = updatedValueHex.slice(0);\n        }\n      }\n    }\n\n    return offset;\n  } //**********************************************************************************\n\n  /**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (DER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\n\n  toDER() {\n    let sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const view = new Uint8Array(this._valueHex);\n\n    switch (true) {\n      case (view[0] & 0x80) !== 0:\n        {\n          const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength + 1);\n          const updatedView = new Uint8Array(updatedValueHex);\n          updatedView[0] = 0x00;\n          updatedView.set(view, 1);\n          this._valueHex = updatedValueHex.slice(0);\n        }\n        break;\n\n      case view[0] === 0x00 && (view[1] & 0x80) === 0:\n        {\n          const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);\n          const updatedView = new Uint8Array(updatedValueHex);\n          updatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));\n          this._valueHex = updatedValueHex.slice(0);\n        }\n        break;\n\n      default:\n    }\n\n    return this.toBER(sizeOnly);\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n    if (resultOffset === -1) return resultOffset;\n    this.blockLength = inputLength;\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n\n  /**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\n\n  toBER() {\n    let sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    //noinspection JSCheckFunctionSignatures\n    return this.valueHex.slice(0);\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"IntegerValueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\n   * Convertion for the block to JSON object\n   * @returns {Object}\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.valueDec = this.valueDec;\n    return object;\n  } //**********************************************************************************\n\n  /**\n   * Convert current value to decimal string representation\n   */\n\n\n  toString() {\n    //region Aux functions\n    function viewAdd(first, second) {\n      //region Initial variables\n      const c = new Uint8Array([0]);\n      let firstView = new Uint8Array(first);\n      let secondView = new Uint8Array(second);\n      let firstViewCopy = firstView.slice(0);\n      const firstViewCopyLength = firstViewCopy.length - 1;\n      let secondViewCopy = secondView.slice(0);\n      const secondViewCopyLength = secondViewCopy.length - 1;\n      let value = 0;\n      const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;\n      let counter = 0; //endregion\n\n      for (let i = max; i >= 0; i--, counter++) {\n        switch (true) {\n          case counter < secondViewCopy.length:\n            value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];\n            break;\n\n          default:\n            value = firstViewCopy[firstViewCopyLength - counter] + c[0];\n        }\n\n        c[0] = value / 10;\n\n        switch (true) {\n          case counter >= firstViewCopy.length:\n            firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);\n            break;\n\n          default:\n            firstViewCopy[firstViewCopyLength - counter] = value % 10;\n        }\n      }\n\n      if (c[0] > 0) firstViewCopy = utilConcatView(c, firstViewCopy);\n      return firstViewCopy.slice(0);\n    }\n\n    function power2(n) {\n      if (n >= powers2.length) {\n        for (let p = powers2.length; p <= n; p++) {\n          const c = new Uint8Array([0]);\n          let digits = powers2[p - 1].slice(0);\n\n          for (let i = digits.length - 1; i >= 0; i--) {\n            const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);\n            c[0] = newValue[0] / 10;\n            digits[i] = newValue[0] % 10;\n          }\n\n          if (c[0] > 0) digits = utilConcatView(c, digits);\n          powers2.push(digits);\n        }\n      }\n\n      return powers2[n];\n    }\n\n    function viewSub(first, second) {\n      //region Initial variables\n      let b = 0;\n      let firstView = new Uint8Array(first);\n      let secondView = new Uint8Array(second);\n      let firstViewCopy = firstView.slice(0);\n      const firstViewCopyLength = firstViewCopy.length - 1;\n      let secondViewCopy = secondView.slice(0);\n      const secondViewCopyLength = secondViewCopy.length - 1;\n      let value;\n      let counter = 0; //endregion\n\n      for (let i = secondViewCopyLength; i >= 0; i--, counter++) {\n        value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;\n\n        switch (true) {\n          case value < 0:\n            b = 1;\n            firstViewCopy[firstViewCopyLength - counter] = value + 10;\n            break;\n\n          default:\n            b = 0;\n            firstViewCopy[firstViewCopyLength - counter] = value;\n        }\n      }\n\n      if (b > 0) {\n        for (let i = firstViewCopyLength - secondViewCopyLength + 1; i >= 0; i--, counter++) {\n          value = firstViewCopy[firstViewCopyLength - counter] - b;\n\n          if (value < 0) {\n            b = 1;\n            firstViewCopy[firstViewCopyLength - counter] = value + 10;\n          } else {\n            b = 0;\n            firstViewCopy[firstViewCopyLength - counter] = value;\n            break;\n          }\n        }\n      }\n\n      return firstViewCopy.slice();\n    } //endregion\n    //region Initial variables\n\n\n    const firstBit = this._valueHex.byteLength * 8 - 1;\n    let digits = new Uint8Array(this._valueHex.byteLength * 8 / 3);\n    let bitNumber = 0;\n    let currentByte;\n    const asn1View = new Uint8Array(this._valueHex);\n    let result = \"\";\n    let flag = false; //endregion\n    //region Calculate number\n\n    for (let byteNumber = this._valueHex.byteLength - 1; byteNumber >= 0; byteNumber--) {\n      currentByte = asn1View[byteNumber];\n\n      for (let i = 0; i < 8; i++) {\n        if ((currentByte & 1) === 1) {\n          switch (bitNumber) {\n            case firstBit:\n              digits = viewSub(power2(bitNumber), digits);\n              result = \"-\";\n              break;\n\n            default:\n              digits = viewAdd(digits, power2(bitNumber));\n          }\n        }\n\n        bitNumber++;\n        currentByte >>= 1;\n      }\n    } //endregion\n    //region Print number\n\n\n    for (let i = 0; i < digits.length; i++) {\n      if (digits[i]) flag = true;\n      if (flag) result += digitsString.charAt(digits[i]);\n    }\n\n    if (flag === false) result += digitsString.charAt(0); //endregion\n\n    return result;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexport class Integer extends BaseBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Integer\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters, LocalIntegerValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 2; // Integer\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"INTEGER\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\n   * Compare two Integer object, or Integer and ArrayBuffer objects\n   * @param {!Integer|ArrayBuffer} otherValue\n   * @returns {boolean}\n   */\n\n\n  isEqual(otherValue) {\n    if (otherValue instanceof Integer) {\n      if (this.valueBlock.isHexOnly && otherValue.valueBlock.isHexOnly) // Compare two ArrayBuffers\n        return isEqualBuffer(this.valueBlock.valueHex, otherValue.valueBlock.valueHex);\n      if (this.valueBlock.isHexOnly === otherValue.valueBlock.isHexOnly) return this.valueBlock.valueDec === otherValue.valueBlock.valueDec;\n      return false;\n    }\n\n    if (otherValue instanceof ArrayBuffer) return isEqualBuffer(this.valueBlock.valueHex, otherValue);\n    return false;\n  } //**********************************************************************************\n\n  /**\n   * Convert current Integer value from BER into DER format\n   * @returns {Integer}\n   */\n\n\n  convertToDER() {\n    const integer = new Integer({\n      valueHex: this.valueBlock.valueHex\n    });\n    integer.valueBlock.toDER();\n    return integer;\n  } //**********************************************************************************\n\n  /**\n   * Convert current Integer value from DER to BER format\n   * @returns {Integer}\n   */\n\n\n  convertFromDER() {\n    const expectedLength = this.valueBlock.valueHex.byteLength % 2 ? this.valueBlock.valueHex.byteLength + 1 : this.valueBlock.valueHex.byteLength;\n    const integer = new Integer({\n      valueHex: this.valueBlock.valueHex\n    });\n    integer.valueBlock.fromDER(integer.valueBlock.valueHex, 0, integer.valueBlock.valueHex.byteLength, expectedLength);\n    return integer;\n  } //**********************************************************************************\n\n\n  toString() {\n    assertBigInt();\n    const hex = bufferToHexCodes(this.valueBlock.valueHex);\n    const bigInt = BigInt(`0x${hex}`);\n    return `${this.constructor.blockName()} : ${bigInt.toString()}`;\n  }\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Enumerated type class\n//**************************************************************************************\n\nexport class Enumerated extends Integer {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Enumerated\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 10; // Enumerated\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"ENUMERATED\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 ObjectIdentifier type class\n//**************************************************************************************\n\nclass LocalSidValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalSidValueBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {number} [valueDec]\n   * @property {boolean} [isFirstSid]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.valueDec = getParametersValue(parameters, \"valueDec\", -1);\n    this.isFirstSid = getParametersValue(parameters, \"isFirstSid\", false);\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"sidBlock\";\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    if (inputLength === 0) return inputOffset; //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n\n    if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n    this.valueHex = new ArrayBuffer(inputLength);\n    let view = new Uint8Array(this.valueHex);\n\n    for (let i = 0; i < inputLength; i++) {\n      view[i] = intBuffer[i] & 0x7F;\n      this.blockLength++;\n      if ((intBuffer[i] & 0x80) === 0x00) break;\n    } //region Ajust size of valueHex buffer\n\n\n    const tempValueHex = new ArrayBuffer(this.blockLength);\n    const tempView = new Uint8Array(tempValueHex);\n\n    for (let i = 0; i < this.blockLength; i++) tempView[i] = view[i]; //noinspection JSCheckFunctionSignatures\n\n\n    this.valueHex = tempValueHex.slice(0);\n    view = new Uint8Array(this.valueHex); //endregion\n\n    if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\n      this.error = \"End of input reached before message was fully decoded\";\n      return -1;\n    }\n\n    if (view[0] === 0x00) this.warnings.push(\"Needlessly long format of SID encoding\");\n    if (this.blockLength <= 8) this.valueDec = utilFromBase(view, 7);else {\n      this.isHexOnly = true;\n      this.warnings.push(\"Too big SID for decoding, hex only\");\n    }\n    return inputOffset + this.blockLength;\n  } //**********************************************************************************\n\n  /**\n   * Save a BigInt value immediately as an array of octects.\n   */\n\n\n  set valueBigInt(value) {\n    assertBigInt();\n    let bits = BigInt(value).toString(2);\n\n    while (bits.length % 7) {\n      bits = '0' + bits;\n    }\n\n    const bytes = new Uint8Array(bits.length / 7);\n\n    for (let i = 0; i < bytes.length; i++) {\n      bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 0x80 : 0);\n    }\n\n    this.fromBER(bytes.buffer, 0, bytes.length);\n  } //**********************************************************************************\n\n  /**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\n\n  toBER() {\n    let sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    //region Initial variables\n    let retBuf;\n    let retView; //endregion\n\n    if (this.isHexOnly) {\n      if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength);\n      const curView = new Uint8Array(this.valueHex);\n      retBuf = new ArrayBuffer(this.blockLength);\n      retView = new Uint8Array(retBuf);\n\n      for (let i = 0; i < this.blockLength - 1; i++) retView[i] = curView[i] | 0x80;\n\n      retView[this.blockLength - 1] = curView[this.blockLength - 1];\n      return retBuf;\n    }\n\n    const encodedBuf = utilToBase(this.valueDec, 7);\n\n    if (encodedBuf.byteLength === 0) {\n      this.error = \"Error during encoding SID value\";\n      return new ArrayBuffer(0);\n    }\n\n    retBuf = new ArrayBuffer(encodedBuf.byteLength);\n\n    if (sizeOnly === false) {\n      const encodedView = new Uint8Array(encodedBuf);\n      retView = new Uint8Array(retBuf);\n\n      for (let i = 0; i < encodedBuf.byteLength - 1; i++) retView[i] = encodedView[i] | 0x80;\n\n      retView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\n   * Create string representation of current SID block\n   * @returns {string}\n   */\n\n\n  toString() {\n    let result = \"\";\n    if (this.isHexOnly === true) result = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);else {\n      if (this.isFirstSid) {\n        let sidValue = this.valueDec;\n        if (this.valueDec <= 39) result = \"0.\";else {\n          if (this.valueDec <= 79) {\n            result = \"1.\";\n            sidValue -= 40;\n          } else {\n            result = \"2.\";\n            sidValue -= 80;\n          }\n        }\n        result += sidValue.toString();\n      } else result = this.valueDec.toString();\n    }\n    return result;\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\n   * Convertion for the block to JSON object\n   * @returns {Object}\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.valueDec = this.valueDec;\n    object.isFirstSid = this.isFirstSid;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass LocalObjectIdentifierValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalObjectIdentifierValueBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.fromString(getParametersValue(parameters, \"value\", \"\"));\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    let resultOffset = inputOffset;\n\n    while (inputLength > 0) {\n      const sidBlock = new LocalSidValueBlock();\n      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n\n      if (resultOffset === -1) {\n        this.blockLength = 0;\n        this.error = sidBlock.error;\n        return resultOffset;\n      }\n\n      if (this.value.length === 0) sidBlock.isFirstSid = true;\n      this.blockLength += sidBlock.blockLength;\n      inputLength -= sidBlock.blockLength;\n      this.value.push(sidBlock);\n    }\n\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\n\n  toBER() {\n    let sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let retBuf = new ArrayBuffer(0);\n\n    for (let i = 0; i < this.value.length; i++) {\n      const valueBuf = this.value[i].toBER(sizeOnly);\n\n      if (valueBuf.byteLength === 0) {\n        this.error = this.value[i].error;\n        return new ArrayBuffer(0);\n      }\n\n      retBuf = utilConcatBuf(retBuf, valueBuf);\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\n   * Create \"LocalObjectIdentifierValueBlock\" class from string\n   * @param {string} string Input string to convert from\n   * @returns {boolean}\n   */\n\n\n  fromString(string) {\n    this.value = []; // Clear existing SID values\n\n    let pos1 = 0;\n    let pos2 = 0;\n    let sid = \"\";\n    let flag = false;\n\n    do {\n      pos2 = string.indexOf(\".\", pos1);\n      if (pos2 === -1) sid = string.substr(pos1);else sid = string.substr(pos1, pos2 - pos1);\n      pos1 = pos2 + 1;\n\n      if (flag) {\n        const sidBlock = this.value[0];\n        let plus = 0;\n\n        switch (sidBlock.valueDec) {\n          case 0:\n            break;\n\n          case 1:\n            plus = 40;\n            break;\n\n          case 2:\n            plus = 80;\n            break;\n\n          default:\n            this.value = []; // clear SID array\n\n            return false;\n          // ???\n        }\n\n        const parsedSID = parseInt(sid, 10);\n        if (isNaN(parsedSID)) return true;\n        sidBlock.valueDec = parsedSID + plus;\n        flag = false;\n      } else {\n        const sidBlock = new LocalSidValueBlock();\n\n        if (sid > Number.MAX_SAFE_INTEGER) {\n          assertBigInt();\n          const sidValue = BigInt(sid);\n          sidBlock.valueBigInt = sidValue;\n        } else {\n          sidBlock.valueDec = parseInt(sid, 10);\n          if (isNaN(sidBlock.valueDec)) return true;\n        }\n\n        if (this.value.length === 0) {\n          sidBlock.isFirstSid = true;\n          flag = true;\n        }\n\n        this.value.push(sidBlock);\n      }\n    } while (pos2 !== -1);\n\n    return true;\n  } //**********************************************************************************\n\n  /**\n   * Converts \"LocalObjectIdentifierValueBlock\" class to string\n   * @returns {string}\n   */\n\n\n  toString() {\n    let result = \"\";\n    let isHexOnly = false;\n\n    for (let i = 0; i < this.value.length; i++) {\n      isHexOnly = this.value[i].isHexOnly;\n      let sidStr = this.value[i].toString();\n      if (i !== 0) result = `${result}.`;\n\n      if (isHexOnly) {\n        sidStr = `{${sidStr}}`;\n        if (this.value[i].isFirstSid) result = `2.{${sidStr} - 80}`;else result += sidStr;\n      } else result += sidStr;\n    }\n\n    return result;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"ObjectIdentifierValueBlock\";\n  } //**********************************************************************************\n\n  /**\n   * Convertion for the block to JSON object\n   * @returns {Object}\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.toString();\n    object.sidArray = [];\n\n    for (let i = 0; i < this.value.length; i++) object.sidArray.push(this.value[i].toJSON());\n\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\n * @extends BaseBlock\n */\n\n\nexport class ObjectIdentifier extends BaseBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"ObjectIdentifier\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters, LocalObjectIdentifierValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 6; // OBJECT IDENTIFIER\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"OBJECT IDENTIFIER\";\n  } //**********************************************************************************\n\n\n  toString() {\n    return `${this.constructor.blockName()} : ${this.valueBlock.toString()}`;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of all string's classes\n//**************************************************************************************\n\nclass LocalUtf8StringValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\n   * Constructor for \"LocalUtf8StringValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.isHexOnly = true;\n    this.value = \"\"; // String representation of decoded ArrayBuffer\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"Utf8StringValueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\n   * Convertion for the block to JSON object\n   * @returns {Object}\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.value;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\n * @extends BaseBlock\n */\n\n\nexport class Utf8String extends BaseBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Utf8String\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters, LocalUtf8StringValueBlock);\n    if (\"value\" in parameters) this.fromString(parameters.value);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 12; // Utf8String\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"UTF8String\";\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\n   * Function converting ArrayBuffer into ASN.1 internal string\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   */\n\n\n  fromBuffer(inputBuffer) {\n    this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));\n\n    try {\n      //noinspection JSDeprecatedSymbols\n      this.valueBlock.value = decodeURIComponent(escape(this.valueBlock.value));\n    } catch (ex) {\n      this.warnings.push(`Error during \"decodeURIComponent\": ${ex}, using raw string`);\n    }\n  } //**********************************************************************************\n\n  /**\n   * Function converting JavaScript string into ASN.1 internal class\n   * @param {!string} inputString ASN.1 BER encoded array\n   */\n\n\n  fromString(inputString) {\n    //noinspection JSDeprecatedSymbols\n    const str = unescape(encodeURIComponent(inputString));\n    const strLen = str.length;\n    this.valueBlock.valueHex = new ArrayBuffer(strLen);\n    const view = new Uint8Array(this.valueBlock.valueHex);\n\n    for (let i = 0; i < strLen; i++) view[i] = str.charCodeAt(i);\n\n    this.valueBlock.value = inputString;\n  } //**********************************************************************************\n\n\n  toString() {\n    return `${this.constructor.blockName()} : ${this.valueBlock.value}`;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//region Declaration of ASN.1 RelativeObjectIdentifier type class\n//**************************************************************************************\n\nclass LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalRelativeSidValueBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {number} [valueDec]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.valueDec = getParametersValue(parameters, \"valueDec\", -1);\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"relativeSidBlock\";\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    if (inputLength === 0) return inputOffset; //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n\n    if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n    this.valueHex = new ArrayBuffer(inputLength);\n    let view = new Uint8Array(this.valueHex);\n\n    for (let i = 0; i < inputLength; i++) {\n      view[i] = intBuffer[i] & 0x7F;\n      this.blockLength++;\n      if ((intBuffer[i] & 0x80) === 0x00) break;\n    } //region Ajust size of valueHex buffer\n\n\n    const tempValueHex = new ArrayBuffer(this.blockLength);\n    const tempView = new Uint8Array(tempValueHex);\n\n    for (let i = 0; i < this.blockLength; i++) tempView[i] = view[i]; //noinspection JSCheckFunctionSignatures\n\n\n    this.valueHex = tempValueHex.slice(0);\n    view = new Uint8Array(this.valueHex); //endregion\n\n    if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\n      this.error = \"End of input reached before message was fully decoded\";\n      return -1;\n    }\n\n    if (view[0] === 0x00) this.warnings.push(\"Needlessly long format of SID encoding\");\n    if (this.blockLength <= 8) this.valueDec = utilFromBase(view, 7);else {\n      this.isHexOnly = true;\n      this.warnings.push(\"Too big SID for decoding, hex only\");\n    }\n    return inputOffset + this.blockLength;\n  } //**********************************************************************************\n\n  /**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\n\n  toBER() {\n    let sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    //region Initial variables\n    let retBuf;\n    let retView; //endregion\n\n    if (this.isHexOnly) {\n      if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength);\n      const curView = new Uint8Array(this.valueHex);\n      retBuf = new ArrayBuffer(this.blockLength);\n      retView = new Uint8Array(retBuf);\n\n      for (let i = 0; i < this.blockLength - 1; i++) retView[i] = curView[i] | 0x80;\n\n      retView[this.blockLength - 1] = curView[this.blockLength - 1];\n      return retBuf;\n    }\n\n    const encodedBuf = utilToBase(this.valueDec, 7);\n\n    if (encodedBuf.byteLength === 0) {\n      this.error = \"Error during encoding SID value\";\n      return new ArrayBuffer(0);\n    }\n\n    retBuf = new ArrayBuffer(encodedBuf.byteLength);\n\n    if (sizeOnly === false) {\n      const encodedView = new Uint8Array(encodedBuf);\n      retView = new Uint8Array(retBuf);\n\n      for (let i = 0; i < encodedBuf.byteLength - 1; i++) retView[i] = encodedView[i] | 0x80;\n\n      retView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\n   * Create string representation of current SID block\n   * @returns {string}\n   */\n\n\n  toString() {\n    let result = \"\";\n    if (this.isHexOnly === true) result = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);else {\n      result = this.valueDec.toString();\n    }\n    return result;\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\n   * Convertion for the block to JSON object\n   * @returns {Object}\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.valueDec = this.valueDec;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass LocalRelativeObjectIdentifierValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalRelativeObjectIdentifierValueBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.fromString(getParametersValue(parameters, \"value\", \"\"));\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    let resultOffset = inputOffset;\n\n    while (inputLength > 0) {\n      const sidBlock = new LocalRelativeSidValueBlock();\n      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n\n      if (resultOffset === -1) {\n        this.blockLength = 0;\n        this.error = sidBlock.error;\n        return resultOffset;\n      }\n\n      this.blockLength += sidBlock.blockLength;\n      inputLength -= sidBlock.blockLength;\n      this.value.push(sidBlock);\n    }\n\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\n\n  toBER() {\n    let sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let retBuf = new ArrayBuffer(0);\n\n    for (let i = 0; i < this.value.length; i++) {\n      const valueBuf = this.value[i].toBER(sizeOnly);\n\n      if (valueBuf.byteLength === 0) {\n        this.error = this.value[i].error;\n        return new ArrayBuffer(0);\n      }\n\n      retBuf = utilConcatBuf(retBuf, valueBuf);\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\n   * Create \"LocalRelativeObjectIdentifierValueBlock\" class from string\n   * @param {string} string Input string to convert from\n   * @returns {boolean}\n   */\n\n\n  fromString(string) {\n    this.value = []; // Clear existing SID values\n\n    let pos1 = 0;\n    let pos2 = 0;\n    let sid = \"\";\n\n    do {\n      pos2 = string.indexOf(\".\", pos1);\n      if (pos2 === -1) sid = string.substr(pos1);else sid = string.substr(pos1, pos2 - pos1);\n      pos1 = pos2 + 1;\n      const sidBlock = new LocalRelativeSidValueBlock();\n      sidBlock.valueDec = parseInt(sid, 10);\n      if (isNaN(sidBlock.valueDec)) return true;\n      this.value.push(sidBlock);\n    } while (pos2 !== -1);\n\n    return true;\n  } //**********************************************************************************\n\n  /**\n   * Converts \"LocalRelativeObjectIdentifierValueBlock\" class to string\n   * @returns {string}\n   */\n\n\n  toString() {\n    let result = \"\";\n    let isHexOnly = false;\n\n    for (let i = 0; i < this.value.length; i++) {\n      isHexOnly = this.value[i].isHexOnly;\n      let sidStr = this.value[i].toString();\n      if (i !== 0) result = `${result}.`;\n\n      if (isHexOnly) {\n        sidStr = `{${sidStr}}`;\n        result += sidStr;\n      } else result += sidStr;\n    }\n\n    return result;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"RelativeObjectIdentifierValueBlock\";\n  } //**********************************************************************************\n\n  /**\n   * Convertion for the block to JSON object\n   * @returns {Object}\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.toString();\n    object.sidArray = [];\n\n    for (let i = 0; i < this.value.length; i++) object.sidArray.push(this.value[i].toJSON());\n\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\n * @extends BaseBlock\n */\n\n\nexport class RelativeObjectIdentifier extends BaseBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"RelativeObjectIdentifier\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters, LocalRelativeObjectIdentifierValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 13; // RELATIVE OBJECT IDENTIFIER\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"RelativeObjectIdentifier\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n\n/**\n * @extends LocalBaseBlock\n * @extends HexBlock\n */\n\nclass LocalBmpStringValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalBmpStringValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.isHexOnly = true;\n    this.value = \"\";\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"BmpStringValueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\n   * Convertion for the block to JSON object\n   * @returns {Object}\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.value;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\n * @extends BaseBlock\n */\n\n\nexport class BmpString extends BaseBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"BmpString\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters, LocalBmpStringValueBlock);\n    if (\"value\" in parameters) this.fromString(parameters.value);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 30; // BmpString\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"BMPString\";\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\n   * Function converting ArrayBuffer into ASN.1 internal string\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   */\n\n\n  fromBuffer(inputBuffer) {\n    //noinspection JSCheckFunctionSignatures\n    const copyBuffer = inputBuffer.slice(0);\n    const valueView = new Uint8Array(copyBuffer);\n\n    for (let i = 0; i < valueView.length; i += 2) {\n      const temp = valueView[i];\n      valueView[i] = valueView[i + 1];\n      valueView[i + 1] = temp;\n    }\n\n    this.valueBlock.value = String.fromCharCode.apply(null, new Uint16Array(copyBuffer));\n  } //**********************************************************************************\n\n  /**\n   * Function converting JavaScript string into ASN.1 internal class\n   * @param {!string} inputString ASN.1 BER encoded array\n   */\n\n\n  fromString(inputString) {\n    const strLength = inputString.length;\n    this.valueBlock.valueHex = new ArrayBuffer(strLength * 2);\n    const valueHexView = new Uint8Array(this.valueBlock.valueHex);\n\n    for (let i = 0; i < strLength; i++) {\n      const codeBuf = utilToBase(inputString.charCodeAt(i), 8);\n      const codeView = new Uint8Array(codeBuf);\n      if (codeView.length > 2) continue;\n      const dif = 2 - codeView.length;\n\n      for (let j = codeView.length - 1; j >= 0; j--) valueHexView[i * 2 + j + dif] = codeView[j];\n    }\n\n    this.valueBlock.value = inputString;\n  } //**********************************************************************************\n\n\n  toString() {\n    return `${this.constructor.blockName()} : ${this.valueBlock.value}`;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\nclass LocalUniversalStringValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalUniversalStringValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.isHexOnly = true;\n    this.value = \"\";\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"UniversalStringValueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\n   * Convertion for the block to JSON object\n   * @returns {Object}\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.value;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\n * @extends BaseBlock\n */\n\n\nexport class UniversalString extends BaseBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"UniversalString\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters, LocalUniversalStringValueBlock);\n    if (\"value\" in parameters) this.fromString(parameters.value);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 28; // UniversalString\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"UniversalString\";\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\n   * Function converting ArrayBuffer into ASN.1 internal string\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   */\n\n\n  fromBuffer(inputBuffer) {\n    //noinspection JSCheckFunctionSignatures\n    const copyBuffer = inputBuffer.slice(0);\n    const valueView = new Uint8Array(copyBuffer);\n\n    for (let i = 0; i < valueView.length; i += 4) {\n      valueView[i] = valueView[i + 3];\n      valueView[i + 1] = valueView[i + 2];\n      valueView[i + 2] = 0x00;\n      valueView[i + 3] = 0x00;\n    }\n\n    this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));\n  } //**********************************************************************************\n\n  /**\n   * Function converting JavaScript string into ASN.1 internal class\n   * @param {!string} inputString ASN.1 BER encoded array\n   */\n\n\n  fromString(inputString) {\n    const strLength = inputString.length;\n    this.valueBlock.valueHex = new ArrayBuffer(strLength * 4);\n    const valueHexView = new Uint8Array(this.valueBlock.valueHex);\n\n    for (let i = 0; i < strLength; i++) {\n      const codeBuf = utilToBase(inputString.charCodeAt(i), 8);\n      const codeView = new Uint8Array(codeBuf);\n      if (codeView.length > 4) continue;\n      const dif = 4 - codeView.length;\n\n      for (let j = codeView.length - 1; j >= 0; j--) valueHexView[i * 4 + j + dif] = codeView[j];\n    }\n\n    this.valueBlock.value = inputString;\n  } //**********************************************************************************\n\n\n  toString() {\n    return `${this.constructor.blockName()} : ${this.valueBlock.value}`;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\nclass LocalSimpleStringValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalSimpleStringValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.value = \"\";\n    this.isHexOnly = true;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"SimpleStringValueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\n   * Convertion for the block to JSON object\n   * @returns {Object}\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.value;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\n * @extends BaseBlock\n */\n\n\nclass LocalSimpleStringBlock extends BaseBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalSimpleStringBlock\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters, LocalSimpleStringValueBlock);\n    if (\"value\" in parameters) this.fromString(parameters.value);\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"SIMPLESTRING\";\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\n   * Function converting ArrayBuffer into ASN.1 internal string\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   */\n\n\n  fromBuffer(inputBuffer) {\n    this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));\n  } //**********************************************************************************\n\n  /**\n   * Function converting JavaScript string into ASN.1 internal class\n   * @param {!string} inputString ASN.1 BER encoded array\n   */\n\n\n  fromString(inputString) {\n    const strLen = inputString.length;\n    this.valueBlock.valueHex = new ArrayBuffer(strLen);\n    const view = new Uint8Array(this.valueBlock.valueHex);\n\n    for (let i = 0; i < strLen; i++) view[i] = inputString.charCodeAt(i);\n\n    this.valueBlock.value = inputString;\n  } //**********************************************************************************\n\n\n  toString() {\n    return `${this.constructor.blockName()} : ${this.valueBlock.value}`;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\n * @extends LocalSimpleStringBlock\n */\n\n\nexport class NumericString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"NumericString\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 18; // NumericString\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"NumericString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\n * @extends LocalSimpleStringBlock\n */\n\nexport class PrintableString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"PrintableString\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 19; // PrintableString\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"PrintableString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\n * @extends LocalSimpleStringBlock\n */\n\nexport class TeletexString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"TeletexString\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 20; // TeletexString\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"TeletexString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\n * @extends LocalSimpleStringBlock\n */\n\nexport class VideotexString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"VideotexString\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 21; // VideotexString\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"VideotexString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\n * @extends LocalSimpleStringBlock\n */\n\nexport class IA5String extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"IA5String\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 22; // IA5String\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"IA5String\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\n * @extends LocalSimpleStringBlock\n */\n\nexport class GraphicString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"GraphicString\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 25; // GraphicString\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"GraphicString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\n * @extends LocalSimpleStringBlock\n */\n\nexport class VisibleString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"VisibleString\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 26; // VisibleString\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"VisibleString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\n * @extends LocalSimpleStringBlock\n */\n\nexport class GeneralString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"GeneralString\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 27; // GeneralString\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"GeneralString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\n * @extends LocalSimpleStringBlock\n */\n\nexport class CharacterString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"CharacterString\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 29; // CharacterString\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"CharacterString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of all date and time classes\n//**************************************************************************************\n\n/**\n * @extends VisibleString\n */\n\nexport class UTCTime extends VisibleString {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"UTCTime\" class\n   * @param {Object} [parameters={}]\n   * @property {string} [value] String representatio of the date\n   * @property {Date} [valueDate] JavaScript \"Date\" object\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.year = 0;\n    this.month = 0;\n    this.day = 0;\n    this.hour = 0;\n    this.minute = 0;\n    this.second = 0; //region Create UTCTime from ASN.1 UTC string value\n\n    if (\"value\" in parameters) {\n      this.fromString(parameters.value);\n      this.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);\n      const view = new Uint8Array(this.valueBlock.valueHex);\n\n      for (let i = 0; i < parameters.value.length; i++) view[i] = parameters.value.charCodeAt(i);\n    } //endregion\n    //region Create GeneralizedTime from JavaScript Date type\n\n\n    if (\"valueDate\" in parameters) {\n      this.fromDate(parameters.valueDate);\n      this.valueBlock.valueHex = this.toBuffer();\n    } //endregion\n\n\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 23; // UTCTime\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\n   * Function converting ArrayBuffer into ASN.1 internal string\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   */\n\n\n  fromBuffer(inputBuffer) {\n    this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));\n  } //**********************************************************************************\n\n  /**\n   * Function converting ASN.1 internal string into ArrayBuffer\n   * @returns {ArrayBuffer}\n   */\n\n\n  toBuffer() {\n    const str = this.toString();\n    const buffer = new ArrayBuffer(str.length);\n    const view = new Uint8Array(buffer);\n\n    for (let i = 0; i < str.length; i++) view[i] = str.charCodeAt(i);\n\n    return buffer;\n  } //**********************************************************************************\n\n  /**\n   * Function converting \"Date\" object into ASN.1 internal string\n   * @param {!Date} inputDate JavaScript \"Date\" object\n   */\n\n\n  fromDate(inputDate) {\n    this.year = inputDate.getUTCFullYear();\n    this.month = inputDate.getUTCMonth() + 1;\n    this.day = inputDate.getUTCDate();\n    this.hour = inputDate.getUTCHours();\n    this.minute = inputDate.getUTCMinutes();\n    this.second = inputDate.getUTCSeconds();\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\n   * Function converting ASN.1 internal string into \"Date\" object\n   * @returns {Date}\n   */\n\n\n  toDate() {\n    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));\n  } //**********************************************************************************\n\n  /**\n   * Function converting JavaScript string into ASN.1 internal class\n   * @param {!string} inputString ASN.1 BER encoded array\n   */\n\n\n  fromString(inputString) {\n    //region Parse input string\n    const parser = /(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z/ig;\n    const parserArray = parser.exec(inputString);\n\n    if (parserArray === null) {\n      this.error = \"Wrong input string for convertion\";\n      return;\n    } //endregion\n    //region Store parsed values\n\n\n    const year = parseInt(parserArray[1], 10);\n    if (year >= 50) this.year = 1900 + year;else this.year = 2000 + year;\n    this.month = parseInt(parserArray[2], 10);\n    this.day = parseInt(parserArray[3], 10);\n    this.hour = parseInt(parserArray[4], 10);\n    this.minute = parseInt(parserArray[5], 10);\n    this.second = parseInt(parserArray[6], 10); //endregion\n  } //**********************************************************************************\n\n  /**\n   * Function converting ASN.1 internal class into JavaScript string\n   * @returns {string}\n   */\n\n\n  toString() {\n    const outputArray = new Array(7);\n    outputArray[0] = padNumber(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);\n    outputArray[1] = padNumber(this.month, 2);\n    outputArray[2] = padNumber(this.day, 2);\n    outputArray[3] = padNumber(this.hour, 2);\n    outputArray[4] = padNumber(this.minute, 2);\n    outputArray[5] = padNumber(this.second, 2);\n    outputArray[6] = \"Z\";\n    return outputArray.join(\"\");\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"UTCTime\";\n  } //**********************************************************************************\n\n  /**\n   * Convertion for the block to JSON object\n   * @returns {Object}\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.year = this.year;\n    object.month = this.month;\n    object.day = this.day;\n    object.hour = this.hour;\n    object.minute = this.minute;\n    object.second = this.second;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\n * @extends VisibleString\n */\n\nexport class GeneralizedTime extends VisibleString {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"GeneralizedTime\" class\n   * @param {Object} [parameters={}]\n   * @property {string} [value] String representatio of the date\n   * @property {Date} [valueDate] JavaScript \"Date\" object\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.year = 0;\n    this.month = 0;\n    this.day = 0;\n    this.hour = 0;\n    this.minute = 0;\n    this.second = 0;\n    this.millisecond = 0; //region Create UTCTime from ASN.1 UTC string value\n\n    if (\"value\" in parameters) {\n      this.fromString(parameters.value);\n      this.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);\n      const view = new Uint8Array(this.valueBlock.valueHex);\n\n      for (let i = 0; i < parameters.value.length; i++) view[i] = parameters.value.charCodeAt(i);\n    } //endregion\n    //region Create GeneralizedTime from JavaScript Date type\n\n\n    if (\"valueDate\" in parameters) {\n      this.fromDate(parameters.valueDate);\n      this.valueBlock.valueHex = this.toBuffer();\n    } //endregion\n\n\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 24; // GeneralizedTime\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\n   * Function converting ArrayBuffer into ASN.1 internal string\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   */\n\n\n  fromBuffer(inputBuffer) {\n    this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));\n  } //**********************************************************************************\n\n  /**\n   * Function converting ASN.1 internal string into ArrayBuffer\n   * @returns {ArrayBuffer}\n   */\n\n\n  toBuffer() {\n    const str = this.toString();\n    const buffer = new ArrayBuffer(str.length);\n    const view = new Uint8Array(buffer);\n\n    for (let i = 0; i < str.length; i++) view[i] = str.charCodeAt(i);\n\n    return buffer;\n  } //**********************************************************************************\n\n  /**\n   * Function converting \"Date\" object into ASN.1 internal string\n   * @param {!Date} inputDate JavaScript \"Date\" object\n   */\n\n\n  fromDate(inputDate) {\n    this.year = inputDate.getUTCFullYear();\n    this.month = inputDate.getUTCMonth() + 1;\n    this.day = inputDate.getUTCDate();\n    this.hour = inputDate.getUTCHours();\n    this.minute = inputDate.getUTCMinutes();\n    this.second = inputDate.getUTCSeconds();\n    this.millisecond = inputDate.getUTCMilliseconds();\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\n   * Function converting ASN.1 internal string into \"Date\" object\n   * @returns {Date}\n   */\n\n\n  toDate() {\n    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));\n  } //**********************************************************************************\n\n  /**\n   * Function converting JavaScript string into ASN.1 internal class\n   * @param {!string} inputString ASN.1 BER encoded array\n   */\n\n\n  fromString(inputString) {\n    //region Initial variables\n    let isUTC = false;\n    let timeString = \"\";\n    let dateTimeString = \"\";\n    let fractionPart = 0;\n    let parser;\n    let hourDifference = 0;\n    let minuteDifference = 0; //endregion\n    //region Convert as UTC time\n\n    if (inputString[inputString.length - 1] === \"Z\") {\n      timeString = inputString.substr(0, inputString.length - 1);\n      isUTC = true;\n    } //endregion\n    //region Convert as local time\n    else {\n      //noinspection JSPrimitiveTypeWrapperUsage\n      const number = new Number(inputString[inputString.length - 1]);\n      if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for convertion\");\n      timeString = inputString;\n    } //endregion\n    //region Check that we do not have a \"+\" and \"-\" symbols inside UTC time\n\n\n    if (isUTC) {\n      if (timeString.indexOf(\"+\") !== -1) throw new Error(\"Wrong input string for convertion\");\n      if (timeString.indexOf(\"-\") !== -1) throw new Error(\"Wrong input string for convertion\");\n    } //endregion\n    //region Get \"UTC time difference\" in case of local time\n    else {\n      let multiplier = 1;\n      let differencePosition = timeString.indexOf(\"+\");\n      let differenceString = \"\";\n\n      if (differencePosition === -1) {\n        differencePosition = timeString.indexOf(\"-\");\n        multiplier = -1;\n      }\n\n      if (differencePosition !== -1) {\n        differenceString = timeString.substr(differencePosition + 1);\n        timeString = timeString.substr(0, differencePosition);\n        if (differenceString.length !== 2 && differenceString.length !== 4) throw new Error(\"Wrong input string for convertion\"); //noinspection JSPrimitiveTypeWrapperUsage\n\n        let number = new Number(differenceString.substr(0, 2));\n        if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for convertion\");\n        hourDifference = multiplier * number;\n\n        if (differenceString.length === 4) {\n          //noinspection JSPrimitiveTypeWrapperUsage\n          number = new Number(differenceString.substr(2, 2));\n          if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for convertion\");\n          minuteDifference = multiplier * number;\n        }\n      }\n    } //endregion\n    //region Get position of fraction point\n\n\n    let fractionPointPosition = timeString.indexOf(\".\"); // Check for \"full stop\" symbol\n\n    if (fractionPointPosition === -1) fractionPointPosition = timeString.indexOf(\",\"); // Check for \"comma\" symbol\n    //endregion\n    //region Get fraction part\n\n    if (fractionPointPosition !== -1) {\n      //noinspection JSPrimitiveTypeWrapperUsage\n      const fractionPartCheck = new Number(`0${timeString.substr(fractionPointPosition)}`);\n      if (isNaN(fractionPartCheck.valueOf())) throw new Error(\"Wrong input string for convertion\");\n      fractionPart = fractionPartCheck.valueOf();\n      dateTimeString = timeString.substr(0, fractionPointPosition);\n    } else dateTimeString = timeString; //endregion\n    //region Parse internal date\n\n\n    switch (true) {\n      case dateTimeString.length === 8:\n        // \"YYYYMMDD\"\n        parser = /(\\d{4})(\\d{2})(\\d{2})/ig;\n        if (fractionPointPosition !== -1) throw new Error(\"Wrong input string for convertion\"); // Here we should not have a \"fraction point\"\n\n        break;\n\n      case dateTimeString.length === 10:\n        // \"YYYYMMDDHH\"\n        parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n        if (fractionPointPosition !== -1) {\n          let fractionResult = 60 * fractionPart;\n          this.minute = Math.floor(fractionResult);\n          fractionResult = 60 * (fractionResult - this.minute);\n          this.second = Math.floor(fractionResult);\n          fractionResult = 1000 * (fractionResult - this.second);\n          this.millisecond = Math.floor(fractionResult);\n        }\n\n        break;\n\n      case dateTimeString.length === 12:\n        // \"YYYYMMDDHHMM\"\n        parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n        if (fractionPointPosition !== -1) {\n          let fractionResult = 60 * fractionPart;\n          this.second = Math.floor(fractionResult);\n          fractionResult = 1000 * (fractionResult - this.second);\n          this.millisecond = Math.floor(fractionResult);\n        }\n\n        break;\n\n      case dateTimeString.length === 14:\n        // \"YYYYMMDDHHMMSS\"\n        parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n        if (fractionPointPosition !== -1) {\n          const fractionResult = 1000 * fractionPart;\n          this.millisecond = Math.floor(fractionResult);\n        }\n\n        break;\n\n      default:\n        throw new Error(\"Wrong input string for convertion\");\n    } //endregion\n    //region Put parsed values at right places\n\n\n    const parserArray = parser.exec(dateTimeString);\n    if (parserArray === null) throw new Error(\"Wrong input string for convertion\");\n\n    for (let j = 1; j < parserArray.length; j++) {\n      switch (j) {\n        case 1:\n          this.year = parseInt(parserArray[j], 10);\n          break;\n\n        case 2:\n          this.month = parseInt(parserArray[j], 10);\n          break;\n\n        case 3:\n          this.day = parseInt(parserArray[j], 10);\n          break;\n\n        case 4:\n          this.hour = parseInt(parserArray[j], 10) + hourDifference;\n          break;\n\n        case 5:\n          this.minute = parseInt(parserArray[j], 10) + minuteDifference;\n          break;\n\n        case 6:\n          this.second = parseInt(parserArray[j], 10);\n          break;\n\n        default:\n          throw new Error(\"Wrong input string for convertion\");\n      }\n    } //endregion\n    //region Get final date\n\n\n    if (isUTC === false) {\n      const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\n      this.year = tempDate.getUTCFullYear();\n      this.month = tempDate.getUTCMonth();\n      this.day = tempDate.getUTCDay();\n      this.hour = tempDate.getUTCHours();\n      this.minute = tempDate.getUTCMinutes();\n      this.second = tempDate.getUTCSeconds();\n      this.millisecond = tempDate.getUTCMilliseconds();\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\n   * Function converting ASN.1 internal class into JavaScript string\n   * @returns {string}\n   */\n\n\n  toString() {\n    const outputArray = [];\n    outputArray.push(padNumber(this.year, 4));\n    outputArray.push(padNumber(this.month, 2));\n    outputArray.push(padNumber(this.day, 2));\n    outputArray.push(padNumber(this.hour, 2));\n    outputArray.push(padNumber(this.minute, 2));\n    outputArray.push(padNumber(this.second, 2));\n\n    if (this.millisecond !== 0) {\n      outputArray.push(\".\");\n      outputArray.push(padNumber(this.millisecond, 3));\n    }\n\n    outputArray.push(\"Z\");\n    return outputArray.join(\"\");\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"GeneralizedTime\";\n  } //**********************************************************************************\n\n  /**\n   * Convertion for the block to JSON object\n   * @returns {Object}\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.year = this.year;\n    object.month = this.month;\n    object.day = this.day;\n    object.hour = this.hour;\n    object.minute = this.minute;\n    object.second = this.second;\n    object.millisecond = this.millisecond;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\n * @extends Utf8String\n */\n\nexport class DATE extends Utf8String {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"DATE\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 31; // DATE\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"DATE\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\n * @extends Utf8String\n */\n\nexport class TimeOfDay extends Utf8String {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"TimeOfDay\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 32; // TimeOfDay\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"TimeOfDay\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\n * @extends Utf8String\n */\n\nexport class DateTime extends Utf8String {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"DateTime\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 33; // DateTime\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"DateTime\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\n * @extends Utf8String\n */\n\nexport class Duration extends Utf8String {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Duration\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 34; // Duration\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"Duration\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\n * @extends Utf8String\n */\n\nexport class TIME extends Utf8String {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Time\" class\n   * @param {Object} [parameters={}]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 14; // Time\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  static blockName() {\n    return \"TIME\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Choice\n//**************************************************************************************\n\nexport class Choice {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Choice\" class\n   * @param {Object} [parameters={}]\n   * @property {Array} [value] Array of ASN.1 types for make a choice from\n   * @property {boolean} [optional]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.value = getParametersValue(parameters, \"value\", []);\n    this.optional = getParametersValue(parameters, \"optional\", false);\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Any\n//**************************************************************************************\n\nexport class Any {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Any\" class\n   * @param {Object} [parameters={}]\n   * @property {string} [name]\n   * @property {boolean} [optional]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.name = getParametersValue(parameters, \"name\", \"\");\n    this.optional = getParametersValue(parameters, \"optional\", false);\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Repeated\n//**************************************************************************************\n\nexport class Repeated {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Repeated\" class\n   * @param {Object} [parameters={}]\n   * @property {string} [name]\n   * @property {boolean} [optional]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.name = getParametersValue(parameters, \"name\", \"\");\n    this.optional = getParametersValue(parameters, \"optional\", false);\n    this.value = getParametersValue(parameters, \"value\", new Any());\n    this.local = getParametersValue(parameters, \"local\", false); // Could local or global array to store elements\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type RawData\n//**************************************************************************************\n\n/**\n * @description Special class providing ability to have \"toBER/fromBER\" for raw ArrayBuffer\n */\n\nexport class RawData {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Repeated\" class\n   * @param {Object} [parameters={}]\n   * @property {string} [name]\n   * @property {boolean} [optional]\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.data = getParametersValue(parameters, \"data\", new ArrayBuffer(0));\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    this.data = inputBuffer.slice(inputOffset, inputLength);\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n\n  /**\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n   * @returns {ArrayBuffer}\n   */\n\n\n  toBER() {\n    let sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return this.data;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major ASN.1 BER decoding function\n//**************************************************************************************\n\n/**\n * Internal library function for decoding ASN.1 BER\n * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n * @returns {{offset: number, result: Object}}\n */\n\nfunction LocalFromBER(inputBuffer, inputOffset, inputLength) {\n  const incomingOffset = inputOffset; // Need to store initial offset since \"inputOffset\" is changing in the function\n  //region Local function changing a type for ASN.1 classes\n\n  function localChangeType(inputObject, newType) {\n    if (inputObject instanceof newType) return inputObject;\n    const newObject = new newType();\n    newObject.idBlock = inputObject.idBlock;\n    newObject.lenBlock = inputObject.lenBlock;\n    newObject.warnings = inputObject.warnings; //noinspection JSCheckFunctionSignatures\n\n    newObject.valueBeforeDecode = inputObject.valueBeforeDecode.slice(0);\n    return newObject;\n  } //endregion\n  //region Create a basic ASN.1 type since we need to return errors and warnings from the function\n\n\n  let returnObject = new BaseBlock({}, Object); //endregion\n  //region Basic check for parameters\n\n  const baseBlock = new LocalBaseBlock();\n\n  if (checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) === false) {\n    returnObject.error = baseBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  } //endregion\n  //region Getting Uint8Array from ArrayBuffer\n\n\n  const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n  //region Initial checks\n\n  if (intBuffer.length === 0) {\n    returnObject.error = \"Zero buffer length\";\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  } //endregion\n  //region Decode indentifcation block of ASN.1 BER structure\n\n\n  let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);\n  returnObject.warnings.concat(returnObject.idBlock.warnings);\n\n  if (resultOffset === -1) {\n    returnObject.error = returnObject.idBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n\n  inputOffset = resultOffset;\n  inputLength -= returnObject.idBlock.blockLength; //endregion\n  //region Decode length block of ASN.1 BER structure\n\n  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);\n  returnObject.warnings.concat(returnObject.lenBlock.warnings);\n\n  if (resultOffset === -1) {\n    returnObject.error = returnObject.lenBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n\n  inputOffset = resultOffset;\n  inputLength -= returnObject.lenBlock.blockLength; //endregion\n  //region Check for usign indefinite length form in encoding for primitive types\n\n  if (returnObject.idBlock.isConstructed === false && returnObject.lenBlock.isIndefiniteForm === true) {\n    returnObject.error = \"Indefinite length form used for primitive encoding form\";\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  } //endregion\n  //region Switch ASN.1 block type\n\n\n  let newASN1Type = BaseBlock;\n\n  switch (returnObject.idBlock.tagClass) {\n    //region UNIVERSAL\n    case 1:\n      //region Check for reserved tag numbers\n      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {\n        returnObject.error = \"UNIVERSAL 37 and upper tags are reserved by ASN.1 standard\";\n        return {\n          offset: -1,\n          result: returnObject\n        };\n      } //endregion\n\n\n      switch (returnObject.idBlock.tagNumber) {\n        //region EndOfContent type\n        case 0:\n          //region Check for EndOfContent type\n          if (returnObject.idBlock.isConstructed === true && returnObject.lenBlock.length > 0) {\n            returnObject.error = \"Type [UNIVERSAL 0] is reserved\";\n            return {\n              offset: -1,\n              result: returnObject\n            };\n          } //endregion\n\n\n          newASN1Type = EndOfContent;\n          break;\n        //endregion\n        //region Boolean type\n\n        case 1:\n          newASN1Type = Boolean;\n          break;\n        //endregion\n        //region Integer type\n\n        case 2:\n          newASN1Type = Integer;\n          break;\n        //endregion\n        //region BitString type\n\n        case 3:\n          newASN1Type = BitString;\n          break;\n        //endregion\n        //region OctetString type\n\n        case 4:\n          newASN1Type = OctetString;\n          break;\n        //endregion\n        //region Null type\n\n        case 5:\n          newASN1Type = Null;\n          break;\n        //endregion\n        //region OBJECT IDENTIFIER type\n\n        case 6:\n          newASN1Type = ObjectIdentifier;\n          break;\n        //endregion\n        //region Enumerated type\n\n        case 10:\n          newASN1Type = Enumerated;\n          break;\n        //endregion\n        //region Utf8String type\n\n        case 12:\n          newASN1Type = Utf8String;\n          break;\n        //endregion\n        //region Time type\n        //region RELATIVE OBJECT IDENTIFIER type\n\n        case 13:\n          newASN1Type = RelativeObjectIdentifier;\n          break;\n        //endregion\n\n        case 14:\n          newASN1Type = TIME;\n          break;\n        //endregion\n        //region ASN.1 reserved type\n\n        case 15:\n          returnObject.error = \"[UNIVERSAL 15] is reserved by ASN.1 standard\";\n          return {\n            offset: -1,\n            result: returnObject\n          };\n        //endregion\n        //region Sequence type\n\n        case 16:\n          newASN1Type = Sequence;\n          break;\n        //endregion\n        //region Set type\n\n        case 17:\n          newASN1Type = Set;\n          break;\n        //endregion\n        //region NumericString type\n\n        case 18:\n          newASN1Type = NumericString;\n          break;\n        //endregion\n        //region PrintableString type\n\n        case 19:\n          newASN1Type = PrintableString;\n          break;\n        //endregion\n        //region TeletexString type\n\n        case 20:\n          newASN1Type = TeletexString;\n          break;\n        //endregion\n        //region VideotexString type\n\n        case 21:\n          newASN1Type = VideotexString;\n          break;\n        //endregion\n        //region IA5String type\n\n        case 22:\n          newASN1Type = IA5String;\n          break;\n        //endregion\n        //region UTCTime type\n\n        case 23:\n          newASN1Type = UTCTime;\n          break;\n        //endregion\n        //region GeneralizedTime type\n\n        case 24:\n          newASN1Type = GeneralizedTime;\n          break;\n        //endregion\n        //region GraphicString type\n\n        case 25:\n          newASN1Type = GraphicString;\n          break;\n        //endregion\n        //region VisibleString type\n\n        case 26:\n          newASN1Type = VisibleString;\n          break;\n        //endregion\n        //region GeneralString type\n\n        case 27:\n          newASN1Type = GeneralString;\n          break;\n        //endregion\n        //region UniversalString type\n\n        case 28:\n          newASN1Type = UniversalString;\n          break;\n        //endregion\n        //region CharacterString type\n\n        case 29:\n          newASN1Type = CharacterString;\n          break;\n        //endregion\n        //region BmpString type\n\n        case 30:\n          newASN1Type = BmpString;\n          break;\n        //endregion\n        //region DATE type\n\n        case 31:\n          newASN1Type = DATE;\n          break;\n        //endregion\n        //region TimeOfDay type\n\n        case 32:\n          newASN1Type = TimeOfDay;\n          break;\n        //endregion\n        //region Date-Time type\n\n        case 33:\n          newASN1Type = DateTime;\n          break;\n        //endregion\n        //region Duration type\n\n        case 34:\n          newASN1Type = Duration;\n          break;\n        //endregion\n        //region default\n\n        default:\n          {\n            let newObject;\n            if (returnObject.idBlock.isConstructed === true) newObject = new Constructed();else newObject = new Primitive();\n            newObject.idBlock = returnObject.idBlock;\n            newObject.lenBlock = returnObject.lenBlock;\n            newObject.warnings = returnObject.warnings;\n            returnObject = newObject;\n          }\n        //endregion\n      }\n\n      break;\n    //endregion\n    //region All other tag classes\n\n    case 2: // APPLICATION\n\n    case 3: // CONTEXT-SPECIFIC\n\n    case 4: // PRIVATE\n\n    default:\n      {\n        if (returnObject.idBlock.isConstructed === true) newASN1Type = Constructed;else newASN1Type = Primitive;\n      }\n    //endregion\n  } //endregion\n  //region Change type and perform BER decoding\n\n\n  returnObject = localChangeType(returnObject, newASN1Type);\n  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm === true ? inputLength : returnObject.lenBlock.length); //endregion\n  //region Coping incoming buffer for entire ASN.1 block\n\n  returnObject.valueBeforeDecode = inputBuffer.slice(incomingOffset, incomingOffset + returnObject.blockLength); //endregion\n\n  return {\n    offset: resultOffset,\n    result: returnObject\n  };\n} //**************************************************************************************\n\n/**\n * Major function for decoding ASN.1 BER array into internal library structuries\n * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array of bytes\n */\n\n\nexport function fromBER(inputBuffer) {\n  if (inputBuffer.byteLength === 0) {\n    const result = new BaseBlock({}, Object);\n    result.error = \"Input buffer has zero length\";\n    return {\n      offset: -1,\n      result\n    };\n  }\n\n  return LocalFromBER(inputBuffer, 0, inputBuffer.byteLength);\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major scheme verification function\n//**************************************************************************************\n\n/**\n * Compare of two ASN.1 object trees\n * @param {!Object} root Root of input ASN.1 object tree\n * @param {!Object} inputData Input ASN.1 object tree\n * @param {!Object} inputSchema Input ASN.1 schema to compare with\n * @return {{verified: boolean}|{verified:boolean, result: Object}}\n */\n\nexport function compareSchema(root, inputData, inputSchema) {\n  //region Special case for Choice schema element type\n  if (inputSchema instanceof Choice) {\n    const choiceResult = false;\n\n    for (let j = 0; j < inputSchema.value.length; j++) {\n      const result = compareSchema(root, inputData, inputSchema.value[j]);\n\n      if (result.verified === true) {\n        return {\n          verified: true,\n          result: root\n        };\n      }\n    }\n\n    if (choiceResult === false) {\n      const _result = {\n        verified: false,\n        result: {\n          error: \"Wrong values for Choice type\"\n        }\n      };\n      if (inputSchema.hasOwnProperty(\"name\")) _result.name = inputSchema.name;\n      return _result;\n    }\n  } //endregion\n  //region Special case for Any schema element type\n\n\n  if (inputSchema instanceof Any) {\n    //region Add named component of ASN.1 schema\n    if (inputSchema.hasOwnProperty(\"name\")) root[inputSchema.name] = inputData; //endregion\n\n    return {\n      verified: true,\n      result: root\n    };\n  } //endregion\n  //region Initial check\n\n\n  if (root instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong root object\"\n      }\n    };\n  }\n\n  if (inputData instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 data\"\n      }\n    };\n  }\n\n  if (inputSchema instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (\"idBlock\" in inputSchema === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  } //endregion\n  //region Comparing idBlock properties in ASN.1 data and ASN.1 schema\n  //region Encode and decode ASN.1 schema idBlock\n  /// <remarks>This encoding/decoding is neccessary because could be an errors in schema definition</remarks>\n\n\n  if (\"fromBER\" in inputSchema.idBlock === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (\"toBER\" in inputSchema.idBlock === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  const encodedId = inputSchema.idBlock.toBER(false);\n\n  if (encodedId.byteLength === 0) {\n    return {\n      verified: false,\n      result: {\n        error: \"Error encoding idBlock for ASN.1 schema\"\n      }\n    };\n  }\n\n  const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);\n\n  if (decodedOffset === -1) {\n    return {\n      verified: false,\n      result: {\n        error: \"Error decoding idBlock for ASN.1 schema\"\n      }\n    };\n  } //endregion\n  //region tagClass\n\n\n  if (inputSchema.idBlock.hasOwnProperty(\"tagClass\") === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {\n    return {\n      verified: false,\n      result: root\n    };\n  } //endregion\n  //region tagNumber\n\n\n  if (inputSchema.idBlock.hasOwnProperty(\"tagNumber\") === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {\n    return {\n      verified: false,\n      result: root\n    };\n  } //endregion\n  //region isConstructed\n\n\n  if (inputSchema.idBlock.hasOwnProperty(\"isConstructed\") === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {\n    return {\n      verified: false,\n      result: root\n    };\n  } //endregion\n  //region isHexOnly\n\n\n  if (\"isHexOnly\" in inputSchema.idBlock === false) // Since 'isHexOnly' is an inhirited property\n    {\n      return {\n        verified: false,\n        result: {\n          error: \"Wrong ASN.1 schema\"\n        }\n      };\n    }\n\n  if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {\n    return {\n      verified: false,\n      result: root\n    };\n  } //endregion\n  //region valueHex\n\n\n  if (inputSchema.idBlock.isHexOnly === true) {\n    if (\"valueHex\" in inputSchema.idBlock === false) // Since 'valueHex' is an inhirited property\n      {\n        return {\n          verified: false,\n          result: {\n            error: \"Wrong ASN.1 schema\"\n          }\n        };\n      }\n\n    const schemaView = new Uint8Array(inputSchema.idBlock.valueHex);\n    const asn1View = new Uint8Array(inputData.idBlock.valueHex);\n\n    if (schemaView.length !== asn1View.length) {\n      return {\n        verified: false,\n        result: root\n      };\n    }\n\n    for (let i = 0; i < schemaView.length; i++) {\n      if (schemaView[i] !== asn1View[1]) {\n        return {\n          verified: false,\n          result: root\n        };\n      }\n    }\n  } //endregion\n  //endregion\n  //region Add named component of ASN.1 schema\n\n\n  if (inputSchema.hasOwnProperty(\"name\")) {\n    inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n    if (inputSchema.name !== \"\") root[inputSchema.name] = inputData;\n  } //endregion\n  //region Getting next ASN.1 block for comparition\n\n\n  if (inputSchema.idBlock.isConstructed === true) {\n    let admission = 0;\n    let result = {\n      verified: false\n    };\n    let maxLength = inputSchema.valueBlock.value.length;\n\n    if (maxLength > 0) {\n      if (inputSchema.valueBlock.value[0] instanceof Repeated) maxLength = inputData.valueBlock.value.length;\n    } //region Special case when constructive value has no elements\n\n\n    if (maxLength === 0) {\n      return {\n        verified: true,\n        result: root\n      };\n    } //endregion\n    //region Special case when \"inputData\" has no values and \"inputSchema\" has all optional values\n\n\n    if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {\n      let _optional = true;\n\n      for (let i = 0; i < inputSchema.valueBlock.value.length; i++) _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);\n\n      if (_optional === true) {\n        return {\n          verified: true,\n          result: root\n        };\n      } //region Delete early added name of block\n\n\n      if (inputSchema.hasOwnProperty(\"name\")) {\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n        if (inputSchema.name !== \"\") delete root[inputSchema.name];\n      } //endregion\n\n\n      root.error = \"Inconsistent object length\";\n      return {\n        verified: false,\n        result: root\n      };\n    } //endregion\n\n\n    for (let i = 0; i < maxLength; i++) {\n      //region Special case when there is an \"optional\" element of ASN.1 schema at the end\n      if (i - admission >= inputData.valueBlock.value.length) {\n        if (inputSchema.valueBlock.value[i].optional === false) {\n          const _result = {\n            verified: false,\n            result: root\n          };\n          root.error = \"Inconsistent length between ASN.1 data and schema\"; //region Delete early added name of block\n\n          if (inputSchema.hasOwnProperty(\"name\")) {\n            inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\n            if (inputSchema.name !== \"\") {\n              delete root[inputSchema.name];\n              _result.name = inputSchema.name;\n            }\n          } //endregion\n\n\n          return _result;\n        }\n      } //endregion\n      else {\n        //region Special case for Repeated type of ASN.1 schema element\n        if (inputSchema.valueBlock.value[0] instanceof Repeated) {\n          result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);\n\n          if (result.verified === false) {\n            if (inputSchema.valueBlock.value[0].optional === true) admission++;else {\n              //region Delete early added name of block\n              if (inputSchema.hasOwnProperty(\"name\")) {\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n                if (inputSchema.name !== \"\") delete root[inputSchema.name];\n              } //endregion\n\n\n              return result;\n            }\n          }\n\n          if (\"name\" in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {\n            let arrayRoot = {};\n            if (\"local\" in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local === true) arrayRoot = inputData;else arrayRoot = root;\n            if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === \"undefined\") arrayRoot[inputSchema.valueBlock.value[0].name] = [];\n            arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);\n          }\n        } //endregion\n        else {\n          result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);\n\n          if (result.verified === false) {\n            if (inputSchema.valueBlock.value[i].optional === true) admission++;else {\n              //region Delete early added name of block\n              if (inputSchema.hasOwnProperty(\"name\")) {\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n                if (inputSchema.name !== \"\") delete root[inputSchema.name];\n              } //endregion\n\n\n              return result;\n            }\n          }\n        }\n      }\n    }\n\n    if (result.verified === false) // The situation may take place if last element is \"optional\" and verification failed\n      {\n        const _result = {\n          verified: false,\n          result: root\n        }; //region Delete early added name of block\n\n        if (inputSchema.hasOwnProperty(\"name\")) {\n          inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\n          if (inputSchema.name !== \"\") {\n            delete root[inputSchema.name];\n            _result.name = inputSchema.name;\n          }\n        } //endregion\n\n\n        return _result;\n      }\n\n    return {\n      verified: true,\n      result: root\n    };\n  } //endregion\n  //region Ability to parse internal value for primitive-encoded value (value of OctetString, for example)\n\n\n  if (\"primitiveSchema\" in inputSchema && \"valueHex\" in inputData.valueBlock) {\n    //region Decoding of raw ASN.1 data\n    const asn1 = fromBER(inputData.valueBlock.valueHex);\n\n    if (asn1.offset === -1) {\n      const _result = {\n        verified: false,\n        result: asn1.result\n      }; //region Delete early added name of block\n\n      if (inputSchema.hasOwnProperty(\"name\")) {\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\n        if (inputSchema.name !== \"\") {\n          delete root[inputSchema.name];\n          _result.name = inputSchema.name;\n        }\n      } //endregion\n\n\n      return _result;\n    } //endregion\n\n\n    return compareSchema(root, asn1.result, inputSchema.primitiveSchema);\n  }\n\n  return {\n    verified: true,\n    result: root\n  }; //endregion\n} //**************************************************************************************\n//noinspection JSUnusedGlobalSymbols\n\n/**\n * ASN.1 schema verification for ArrayBuffer data\n * @param {!ArrayBuffer} inputBuffer Input BER-encoded ASN.1 data\n * @param {!Object} inputSchema Input ASN.1 schema to verify against to\n * @return {{verified: boolean}|{verified:boolean, result: Object}}\n */\n\nexport function verifySchema(inputBuffer, inputSchema) {\n  //region Initial check\n  if (inputSchema instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema type\"\n      }\n    };\n  } //endregion\n  //region Decoding of raw ASN.1 data\n\n\n  const asn1 = fromBER(inputBuffer);\n\n  if (asn1.offset === -1) {\n    return {\n      verified: false,\n      result: asn1.result\n    };\n  } //endregion\n  //region Compare ASN.1 struct with input schema\n\n\n  return compareSchema(asn1.result, asn1.result, inputSchema); //endregion\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major function converting JSON to ASN.1 objects\n//**************************************************************************************\n//noinspection JSUnusedGlobalSymbols\n\n/**\n * Converting from JSON to ASN.1 objects\n * @param {string|Object} json JSON string or object to convert to ASN.1 objects\n */\n\nexport function fromJSON(json) {// TODO Implement\n} //**************************************************************************************\n//endregion\n//**************************************************************************************","map":{"version":3,"sources":["C:/Users/rkanthet/Documents/test_window_object/node_modules/asn1js/src/asn1.js"],"names":["getParametersValue","padNumber","isEqualBuffer","bufferToHexCodes","checkBufferParams","utilToBase","utilFromBase","utilEncodeTC","utilDecodeTC","utilConcatBuf","utilConcatView","assertBigInt","BigInt","Error","powers2","Uint8Array","digitsString","LocalBaseBlock","constructor","parameters","blockLength","error","warnings","valueBeforeDecode","slice","ArrayBuffer","blockName","toJSON","byteLength","HexBlock","BaseClass","LocalHexBlockMixin","isHexOnly","valueHex","fromBER","inputBuffer","inputOffset","inputLength","intBuffer","length","push","toBER","sizeOnly","object","ex","LocalIdentificationBlock","idBlock","tagClass","tagNumber","isConstructed","firstOctet","retBuf","retView","number","encodedBuf","encodedView","size","i","curView","tagClassMask","tagNumberMask","count","tagNumberBufferMaxLength","intTagNumberBuffer","tempBuffer","tempBufferView","set","LocalLengthBlock","isIndefiniteForm","lenBlock","longFormUsed","lengthBufferView","ValueBlock","TypeError","BaseBlock","valueBlockType","name","optional","primitiveSchema","valueBlock","resultOffset","idBlockBuf","valueBlockSizeBuf","lenBlockBuf","valueBlockBuf","indefBuf","indefView","toString","LocalPrimitiveValueBlock","valueHexView","Primitive","LocalConstructedValueBlock","value","initialOffset","initialLength","checkLen","indefiniteLength","currentOffset","returnObject","LocalFromBER","offset","result","concat","EndOfContent","pop","valueBuf","Constructed","values","split","map","o","join","LocalEndOfContentValueBlock","paramaters","LocalBooleanValueBlock","view","call","Boolean","Sequence","Set","Null","LocalOctetStringValueBlock","prototype","currentBlockName","OctetString","buf","asn","e","isEqual","octetString","JSON","stringify","LocalBitStringValueBlock","unusedBits","BitString","bitString","bits","byte","padStart","LocalIntegerValueBlock","valueDec","_value","_valueHex","_valueDec","fromDER","expectedLength","updatedValueHex","updatedView","toDER","viewAdd","first","second","c","firstView","secondView","firstViewCopy","firstViewCopyLength","secondViewCopy","secondViewCopyLength","max","counter","power2","n","p","digits","newValue","viewSub","b","firstBit","bitNumber","currentByte","asn1View","flag","byteNumber","charAt","Integer","otherValue","convertToDER","integer","convertFromDER","hex","bigInt","Enumerated","LocalSidValueBlock","isFirstSid","tempValueHex","tempView","valueBigInt","bytes","parseInt","buffer","sidValue","LocalObjectIdentifierValueBlock","fromString","sidBlock","string","pos1","pos2","sid","indexOf","substr","plus","parsedSID","isNaN","Number","MAX_SAFE_INTEGER","sidStr","sidArray","ObjectIdentifier","LocalUtf8StringValueBlock","Utf8String","fromBuffer","String","fromCharCode","apply","decodeURIComponent","escape","inputString","str","unescape","encodeURIComponent","strLen","charCodeAt","LocalRelativeSidValueBlock","LocalRelativeObjectIdentifierValueBlock","RelativeObjectIdentifier","LocalBmpStringValueBlock","BmpString","copyBuffer","valueView","temp","Uint16Array","strLength","codeBuf","codeView","dif","j","LocalUniversalStringValueBlock","UniversalString","Uint32Array","LocalSimpleStringValueBlock","LocalSimpleStringBlock","NumericString","PrintableString","TeletexString","VideotexString","IA5String","GraphicString","VisibleString","GeneralString","CharacterString","UTCTime","year","month","day","hour","minute","fromDate","valueDate","toBuffer","inputDate","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","toDate","Date","UTC","parser","parserArray","exec","outputArray","Array","GeneralizedTime","millisecond","getUTCMilliseconds","isUTC","timeString","dateTimeString","fractionPart","hourDifference","minuteDifference","valueOf","multiplier","differencePosition","differenceString","fractionPointPosition","fractionPartCheck","fractionResult","Math","floor","tempDate","getUTCDay","DATE","TimeOfDay","DateTime","Duration","TIME","Choice","Any","Repeated","local","RawData","data","incomingOffset","localChangeType","inputObject","newType","newObject","Object","baseBlock","newASN1Type","compareSchema","root","inputData","inputSchema","choiceResult","verified","_result","hasOwnProperty","encodedId","decodedOffset","schemaView","replace","admission","maxLength","_optional","arrayRoot","asn1","verifySchema","fromJSON","json"],"mappings":"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","sourcesContent":["/* eslint-disable indent */\n/*\n * Copyright (c) 2016-2018, Peculiar Ventures\n * All rights reserved.\n *\n * Author 2016-2018, Yury Strozhevsky <www.strozhevsky.com>.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its contributors\n *    may be used to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\n * OF SUCH DAMAGE.\n *\n */\n//**************************************************************************************\nimport { getParametersValue, padNumber, isEqualBuffer, bufferToHexCodes, checkBufferParams, utilToBase, utilFromBase, utilEncodeTC, utilDecodeTC, utilConcatBuf, utilConcatView } from \"pvutils\";\n//**************************************************************************************\n//region Other utility functions\n//**************************************************************************************\nfunction assertBigInt() {\n  if (typeof BigInt === \"undefined\") {\n    throw new Error(\"BigInt is not defined. Your environment doesn't implement BigInt.\")\n  }\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of global variables\n//**************************************************************************************\nconst powers2 = [new Uint8Array([1])];\nconst digitsString = \"0123456789\";\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration for \"LocalBaseBlock\" class\n//**************************************************************************************\n/**\n * Class used as a base block for all remaining ASN.1 classes\n * @typedef LocalBaseBlock\n * @interface\n * @property {number} blockLength\n * @property {string} error\n * @property {Array.<string>} warnings\n * @property {ArrayBuffer} valueBeforeDecode\n */\nclass LocalBaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalBaseBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueBeforeDecode]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\t/**\n\t\t * @type {number} blockLength\n\t\t */\n\t\tthis.blockLength = getParametersValue(parameters, \"blockLength\", 0);\n\t\t/**\n\t\t * @type {string} error\n\t\t */\n\t\tthis.error = getParametersValue(parameters, \"error\", \"\");\n\t\t/**\n\t\t * @type {Array.<string>} warnings\n\t\t */\n\t\tthis.warnings = getParametersValue(parameters, \"warnings\", []);\n\t\t//noinspection JSCheckFunctionSignatures\n\t\t/**\n\t\t * @type {ArrayBuffer} valueBeforeDecode\n\t\t */\n\t\tif(\"valueBeforeDecode\" in parameters)\n\t\t\tthis.valueBeforeDecode = parameters.valueBeforeDecode.slice(0);\n\t\telse\n\t\t\tthis.valueBeforeDecode = new ArrayBuffer(0);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"baseBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n\t */\n\ttoJSON()\n\t{\n\t\treturn {\n\t\t\tblockName: this.constructor.blockName(),\n\t\t\tblockLength: this.blockLength,\n\t\t\terror: this.error,\n\t\t\twarnings: this.warnings,\n\t\t\tvalueBeforeDecode: bufferToHexCodes(this.valueBeforeDecode, 0, this.valueBeforeDecode.byteLength)\n\t\t};\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Description for \"HexBlock\" class\n//**************************************************************************************\n/**\n * Class used as a base block for all remaining ASN.1 classes\n * @extends LocalBaseBlock\n * @typedef HexBlock\n * @property {number} blockLength\n * @property {string} error\n * @property {Array.<string>} warnings\n * @property {ArrayBuffer} valueBeforeDecode\n * @property {boolean} isHexOnly\n * @property {ArrayBuffer} valueHex\n */\n//noinspection JSUnusedLocalSymbols\nexport const HexBlock = BaseClass => class LocalHexBlockMixin extends BaseClass\n{\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Constructor for \"HexBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueHex]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\t/**\n\t\t * @type {boolean}\n\t\t */\n\t\tthis.isHexOnly = getParametersValue(parameters, \"isHexOnly\", false);\n\t\t/**\n\t\t * @type {ArrayBuffer}\n\t\t */\n\t\tif(\"valueHex\" in parameters)\n\t\t\tthis.valueHex = parameters.valueHex.slice(0);\n\t\telse\n\t\t\tthis.valueHex = new ArrayBuffer(0);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"hexBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\n\t\t\treturn (-1);\n\t\t//endregion\n\n\t\t//region Getting Uint8Array from ArrayBuffer\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t//endregion\n\n\t\t//region Initial checks\n\t\tif(intBuffer.length === 0)\n\t\t{\n\t\t\tthis.warnings.push(\"Zero buffer length\");\n\t\t\treturn inputOffset;\n\t\t}\n\t\t//endregion\n\n\t\t//region Copy input buffer to internal buffer\n\t\tthis.valueHex = inputBuffer.slice(inputOffset, inputOffset + inputLength);\n\t\t//endregion\n\n\t\tthis.blockLength = inputLength;\n\n\t\treturn (inputOffset + inputLength);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\tif(this.isHexOnly !== true)\n\t\t{\n\t\t\tthis.error = \"Flag \\\"isHexOnly\\\" is not set, abort\";\n\t\t\treturn new ArrayBuffer(0);\n\t\t}\n\n\t\tif(sizeOnly === true)\n\t\t\treturn new ArrayBuffer(this.valueHex.byteLength);\n\n\t\t//noinspection JSCheckFunctionSignatures\n\t\treturn this.valueHex.slice(0);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.blockName = this.constructor.blockName();\n\t\tobject.isHexOnly = this.isHexOnly;\n\t\tobject.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n};\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of identification block class\n//**************************************************************************************\nclass LocalIdentificationBlock extends HexBlock(LocalBaseBlock)\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalBaseBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {Object} [idBlock]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper();\n\n\t\tif(\"idBlock\" in parameters)\n\t\t{\n\t\t\t//region Properties from hexBlock class\n\t\t\tthis.isHexOnly = getParametersValue(parameters.idBlock, \"isHexOnly\", false);\n\t\t\tthis.valueHex = getParametersValue(parameters.idBlock, \"valueHex\", new ArrayBuffer(0));\n\t\t\t//endregion\n\n\t\t\tthis.tagClass = getParametersValue(parameters.idBlock, \"tagClass\", (-1));\n\t\t\tthis.tagNumber = getParametersValue(parameters.idBlock, \"tagNumber\", (-1));\n\t\t\tthis.isConstructed = getParametersValue(parameters.idBlock, \"isConstructed\", false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.tagClass = (-1);\n\t\t\tthis.tagNumber = (-1);\n\t\t\tthis.isConstructed = false;\n\t\t}\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"identificationBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\t//region Initial variables\n\t\tlet firstOctet = 0;\n\t\tlet retBuf;\n\t\tlet retView;\n\t\t//endregion\n\n\t\tswitch(this.tagClass)\n\t\t{\n\t\t\tcase 1:\n\t\t\t\tfirstOctet |= 0x00; // UNIVERSAL\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tfirstOctet |= 0x40; // APPLICATION\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfirstOctet |= 0x80; // CONTEXT-SPECIFIC\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tfirstOctet |= 0xC0; // PRIVATE\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.error = \"Unknown tag class\";\n\t\t\t\treturn (new ArrayBuffer(0));\n\t\t}\n\n\t\tif(this.isConstructed)\n\t\t\tfirstOctet |= 0x20;\n\n\t\tif((this.tagNumber < 31) && (!this.isHexOnly))\n\t\t{\n\t\t\tretBuf = new ArrayBuffer(1);\n\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\tif(!sizeOnly)\n\t\t\t{\n\t\t\t\tlet number = this.tagNumber;\n\t\t\t\tnumber &= 0x1F;\n\t\t\t\tfirstOctet |= number;\n\n\t\t\t\tretView[0] = firstOctet;\n\t\t\t}\n\n\t\t\treturn retBuf;\n\t\t}\n\n\t\tif(this.isHexOnly === false)\n\t\t{\n\t\t\tconst encodedBuf = utilToBase(this.tagNumber, 7);\n\t\t\tconst encodedView = new Uint8Array(encodedBuf);\n\t\t\tconst size = encodedBuf.byteLength;\n\n\t\t\tretBuf = new ArrayBuffer(size + 1);\n\t\t\tretView = new Uint8Array(retBuf);\n\t\t\tretView[0] = (firstOctet | 0x1F);\n\n\t\t\tif(!sizeOnly)\n\t\t\t{\n\t\t\t\tfor(let i = 0; i < (size - 1); i++)\n\t\t\t\t\tretView[i + 1] = encodedView[i] | 0x80;\n\n\t\t\t\tretView[size] = encodedView[size - 1];\n\t\t\t}\n\n\t\t\treturn retBuf;\n\t\t}\n\n\t\tretBuf = new ArrayBuffer(this.valueHex.byteLength + 1);\n\t\tretView = new Uint8Array(retBuf);\n\n\t\tretView[0] = (firstOctet | 0x1F);\n\n\t\tif(sizeOnly === false)\n\t\t{\n\t\t\tconst curView = new Uint8Array(this.valueHex);\n\n\t\t\tfor(let i = 0; i < (curView.length - 1); i++)\n\t\t\t\tretView[i + 1] = curView[i] | 0x80;\n\n\t\t\tretView[this.valueHex.byteLength] = curView[curView.length - 1];\n\t\t}\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number}\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\n\t\t\treturn (-1);\n\t\t//endregion\n\n\t\t//region Getting Uint8Array from ArrayBuffer\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t//endregion\n\n\t\t//region Initial checks\n\t\tif(intBuffer.length === 0)\n\t\t{\n\t\t\tthis.error = \"Zero buffer length\";\n\t\t\treturn (-1);\n\t\t}\n\t\t//endregion\n\n\t\t//region Find tag class\n\t\tconst tagClassMask = intBuffer[0] & 0xC0;\n\n\t\tswitch(tagClassMask)\n\t\t{\n\t\t\tcase 0x00:\n\t\t\t\tthis.tagClass = (1); // UNIVERSAL\n\t\t\t\tbreak;\n\t\t\tcase 0x40:\n\t\t\t\tthis.tagClass = (2); // APPLICATION\n\t\t\t\tbreak;\n\t\t\tcase 0x80:\n\t\t\t\tthis.tagClass = (3); // CONTEXT-SPECIFIC\n\t\t\t\tbreak;\n\t\t\tcase 0xC0:\n\t\t\t\tthis.tagClass = (4); // PRIVATE\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.error = \"Unknown tag class\";\n\t\t\t\treturn (-1);\n\t\t}\n\t\t//endregion\n\n\t\t//region Find it's constructed or not\n\t\tthis.isConstructed = (intBuffer[0] & 0x20) === 0x20;\n\t\t//endregion\n\n\t\t//region Find tag number\n\t\tthis.isHexOnly = false;\n\n\t\tconst tagNumberMask = intBuffer[0] & 0x1F;\n\n\t\t//region Simple case (tag number < 31)\n\t\tif(tagNumberMask !== 0x1F)\n\t\t{\n\t\t\tthis.tagNumber = (tagNumberMask);\n\t\t\tthis.blockLength = 1;\n\t\t}\n\t\t//endregion\n\t\t//region Tag number bigger or equal to 31\n\t\telse\n\t\t{\n\t\t\tlet count = 1;\n\n\t\t\tthis.valueHex = new ArrayBuffer(255);\n\t\t\tlet tagNumberBufferMaxLength = 255;\n\t\t\tlet intTagNumberBuffer = new Uint8Array(this.valueHex);\n\n\t\t\t//noinspection JSBitwiseOperatorUsage\n\t\t\twhile(intBuffer[count] & 0x80)\n\t\t\t{\n\t\t\t\tintTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\n\t\t\t\tcount++;\n\n\t\t\t\tif(count >= intBuffer.length)\n\t\t\t\t{\n\t\t\t\t\tthis.error = \"End of input reached before message was fully decoded\";\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\n\t\t\t\t//region In case if tag number length is greater than 255 bytes (rare but possible case)\n\t\t\t\tif(count === tagNumberBufferMaxLength)\n\t\t\t\t{\n\t\t\t\t\ttagNumberBufferMaxLength += 255;\n\n\t\t\t\t\tconst tempBuffer = new ArrayBuffer(tagNumberBufferMaxLength);\n\t\t\t\t\tconst tempBufferView = new Uint8Array(tempBuffer);\n\n\t\t\t\t\tfor(let i = 0; i < intTagNumberBuffer.length; i++)\n\t\t\t\t\t\ttempBufferView[i] = intTagNumberBuffer[i];\n\n\t\t\t\t\tthis.valueHex = new ArrayBuffer(tagNumberBufferMaxLength);\n\t\t\t\t\tintTagNumberBuffer = new Uint8Array(this.valueHex);\n\t\t\t\t}\n\t\t\t\t//endregion\n\t\t\t}\n\n\t\t\tthis.blockLength = (count + 1);\n\t\t\tintTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F; // Write last byte to buffer\n\n\t\t\t//region Cut buffer\n\t\t\tconst tempBuffer = new ArrayBuffer(count);\n\t\t\tconst tempBufferView = new Uint8Array(tempBuffer);\n\n\t\t\tfor(let i = 0; i < count; i++)\n\t\t\t\ttempBufferView[i] = intTagNumberBuffer[i];\n\n\t\t\tthis.valueHex = new ArrayBuffer(count);\n\t\t\tintTagNumberBuffer = new Uint8Array(this.valueHex);\n\t\t\tintTagNumberBuffer.set(tempBufferView);\n\t\t\t//endregion\n\n\t\t\t//region Try to convert long tag number to short form\n\t\t\tif(this.blockLength <= 9)\n\t\t\t\tthis.tagNumber = utilFromBase(intTagNumberBuffer, 7);\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.isHexOnly = true;\n\t\t\t\tthis.warnings.push(\"Tag too long, represented as hex-coded\");\n\t\t\t}\n\t\t\t//endregion\n\t\t}\n\t\t//endregion\n\t\t//endregion\n\n\t\t//region Check if constructed encoding was using for primitive type\n\t\tif(((this.tagClass === 1)) &&\n\t\t\t(this.isConstructed))\n\t\t{\n\t\t\tswitch(this.tagNumber)\n\t\t\t{\n\t\t\t\tcase 1:  // Boolean\n\t\t\t\tcase 2:  // REAL\n\t\t\t\tcase 5:  // Null\n\t\t\t\tcase 6:  // OBJECT IDENTIFIER\n\t\t\t\tcase 9:  // REAL\n\t\t\t\tcase 13: // RELATIVE OBJECT IDENTIFIER\n\t\t\t\tcase 14: // Time\n\t\t\t\tcase 23:\n\t\t\t\tcase 24:\n\t\t\t\tcase 31:\n\t\t\t\tcase 32:\n\t\t\t\tcase 33:\n\t\t\t\tcase 34:\n\t\t\t\t\tthis.error = \"Constructed encoding used for primitive type\";\n\t\t\t\t\treturn (-1);\n\t\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t\t//endregion\n\n\t\treturn (inputOffset + this.blockLength); // Return current offset in input buffer\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {{blockName: string,\n\t *  tagClass: number,\n\t *  tagNumber: number,\n\t *  isConstructed: boolean,\n\t *  isHexOnly: boolean,\n\t *  valueHex: ArrayBuffer,\n\t *  blockLength: number,\n\t *  error: string, warnings: Array.<string>,\n\t *  valueBeforeDecode: string}}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.blockName = this.constructor.blockName();\n\t\tobject.tagClass = this.tagClass;\n\t\tobject.tagNumber = this.tagNumber;\n\t\tobject.isConstructed = this.isConstructed;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of length block class\n//**************************************************************************************\nclass LocalLengthBlock extends LocalBaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalLengthBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {Object} [lenBlock]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper();\n\n\t\tif(\"lenBlock\" in parameters)\n\t\t{\n\t\t\tthis.isIndefiniteForm = getParametersValue(parameters.lenBlock, \"isIndefiniteForm\", false);\n\t\t\tthis.longFormUsed = getParametersValue(parameters.lenBlock, \"longFormUsed\", false);\n\t\t\tthis.length = getParametersValue(parameters.lenBlock, \"length\", 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.isIndefiniteForm = false;\n\t\t\tthis.longFormUsed = false;\n\t\t\tthis.length = 0;\n\t\t}\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"lengthBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number}\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\n\t\t\treturn (-1);\n\t\t//endregion\n\n\t\t//region Getting Uint8Array from ArrayBuffer\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t//endregion\n\n\t\t//region Initial checks\n\t\tif(intBuffer.length === 0)\n\t\t{\n\t\t\tthis.error = \"Zero buffer length\";\n\t\t\treturn (-1);\n\t\t}\n\n\t\tif(intBuffer[0] === 0xFF)\n\t\t{\n\t\t\tthis.error = \"Length block 0xFF is reserved by standard\";\n\t\t\treturn (-1);\n\t\t}\n\t\t//endregion\n\n\t\t//region Check for length form type\n\t\tthis.isIndefiniteForm = intBuffer[0] === 0x80;\n\t\t//endregion\n\n\t\t//region Stop working in case of indefinite length form\n\t\tif(this.isIndefiniteForm === true)\n\t\t{\n\t\t\tthis.blockLength = 1;\n\t\t\treturn (inputOffset + this.blockLength);\n\t\t}\n\t\t//endregion\n\n\t\t//region Check is long form of length encoding using\n\t\tthis.longFormUsed = !!(intBuffer[0] & 0x80);\n\t\t//endregion\n\n\t\t//region Stop working in case of short form of length value\n\t\tif(this.longFormUsed === false)\n\t\t{\n\t\t\tthis.length = (intBuffer[0]);\n\t\t\tthis.blockLength = 1;\n\t\t\treturn (inputOffset + this.blockLength);\n\t\t}\n\t\t//endregion\n\n\t\t//region Calculate length value in case of long form\n\t\tconst count = intBuffer[0] & 0x7F;\n\n\t\tif(count > 8) // Too big length value\n\t\t{\n\t\t\tthis.error = \"Too big integer\";\n\t\t\treturn (-1);\n\t\t}\n\n\t\tif((count + 1) > intBuffer.length)\n\t\t{\n\t\t\tthis.error = \"End of input reached before message was fully decoded\";\n\t\t\treturn (-1);\n\t\t}\n\n\t\tconst lengthBufferView = new Uint8Array(count);\n\n\t\tfor(let i = 0; i < count; i++)\n\t\t\tlengthBufferView[i] = intBuffer[i + 1];\n\n\t\tif(lengthBufferView[count - 1] === 0x00)\n\t\t\tthis.warnings.push(\"Needlessly long encoded length\");\n\n\t\tthis.length = utilFromBase(lengthBufferView, 8);\n\n\t\tif(this.longFormUsed && (this.length <= 127))\n\t\t\tthis.warnings.push(\"Unnecessary usage of long length form\");\n\n\t\tthis.blockLength = count + 1;\n\t\t//endregion\n\n\t\treturn (inputOffset + this.blockLength); // Return current offset in input buffer\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\t//region Initial variables\n\t\tlet retBuf;\n\t\tlet retView;\n\t\t//endregion\n\n\t\tif(this.length > 127)\n\t\t\tthis.longFormUsed = true;\n\n\t\tif(this.isIndefiniteForm)\n\t\t{\n\t\t\tretBuf = new ArrayBuffer(1);\n\n\t\t\tif(sizeOnly === false)\n\t\t\t{\n\t\t\t\tretView = new Uint8Array(retBuf);\n\t\t\t\tretView[0] = 0x80;\n\t\t\t}\n\n\t\t\treturn retBuf;\n\t\t}\n\n\t\tif(this.longFormUsed === true)\n\t\t{\n\t\t\tconst encodedBuf = utilToBase(this.length, 8);\n\n\t\t\tif(encodedBuf.byteLength > 127)\n\t\t\t{\n\t\t\t\tthis.error = \"Too big length\";\n\t\t\t\treturn (new ArrayBuffer(0));\n\t\t\t}\n\n\t\t\tretBuf = new ArrayBuffer(encodedBuf.byteLength + 1);\n\n\t\t\tif(sizeOnly === true)\n\t\t\t\treturn retBuf;\n\n\t\t\tconst encodedView = new Uint8Array(encodedBuf);\n\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\tretView[0] = encodedBuf.byteLength | 0x80;\n\n\t\t\tfor(let i = 0; i < encodedBuf.byteLength; i++)\n\t\t\t\tretView[i + 1] = encodedView[i];\n\n\t\t\treturn retBuf;\n\t\t}\n\n\t\tretBuf = new ArrayBuffer(1);\n\n\t\tif(sizeOnly === false)\n\t\t{\n\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\tretView[0] = this.length;\n\t\t}\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.blockName = this.constructor.blockName();\n\t\tobject.isIndefiniteForm = this.isIndefiniteForm;\n\t\tobject.longFormUsed = this.longFormUsed;\n\t\tobject.length = this.length;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of value block class\n//**************************************************************************************\nexport class ValueBlock extends LocalBaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"ValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"valueBlock\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols,JSUnusedLocalSymbols\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number}\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\t//region Throw an exception for a function which needs to be specified in extended classes\n\t\tthrow TypeError(\"User need to make a specific function in a class which extends \\\"ValueBlock\\\"\");\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedLocalSymbols\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\t//region Throw an exception for a function which needs to be specified in extended classes\n\t\tthrow TypeError(\"User need to make a specific function in a class which extends \\\"ValueBlock\\\"\");\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic ASN.1 block class\n//**************************************************************************************\nexport class BaseBlock extends LocalBaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"BaseBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {Object} [primitiveSchema]\n\t * @property {string} [name]\n\t * @property {boolean} [optional]\n\t * @param valueBlockType Type of value block\n\t */\n\tconstructor(parameters = {}, valueBlockType = ValueBlock)\n\t{\n\t\tsuper(parameters);\n\n\t\tif(\"name\" in parameters)\n\t\t\tthis.name = parameters.name;\n\t\tif(\"optional\" in parameters)\n\t\t\tthis.optional = parameters.optional;\n\t\tif(\"primitiveSchema\" in parameters)\n\t\t\tthis.primitiveSchema = parameters.primitiveSchema;\n\n\t\tthis.idBlock = new LocalIdentificationBlock(parameters);\n\t\tthis.lenBlock = new LocalLengthBlock(parameters);\n\t\tthis.valueBlock = new valueBlockType(parameters);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"BaseBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number}\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\n\t\tif(resultOffset === (-1))\n\t\t{\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tif(this.idBlock.error.length === 0)\n\t\t\tthis.blockLength += this.idBlock.blockLength;\n\n\t\tif(this.lenBlock.error.length === 0)\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\n\n\t\tif(this.valueBlock.error.length === 0)\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\tlet retBuf;\n\n\t\tconst idBlockBuf = this.idBlock.toBER(sizeOnly);\n\t\tconst valueBlockSizeBuf = this.valueBlock.toBER(true);\n\n\t\tthis.lenBlock.length = valueBlockSizeBuf.byteLength;\n\t\tconst lenBlockBuf = this.lenBlock.toBER(sizeOnly);\n\n\t\tretBuf = utilConcatBuf(idBlockBuf, lenBlockBuf);\n\n\t\tlet valueBlockBuf;\n\n\t\tif(sizeOnly === false)\n\t\t\tvalueBlockBuf = this.valueBlock.toBER(sizeOnly);\n\t\telse\n\t\t\tvalueBlockBuf = new ArrayBuffer(this.lenBlock.length);\n\n\t\tretBuf = utilConcatBuf(retBuf, valueBlockBuf);\n\n\t\tif(this.lenBlock.isIndefiniteForm === true)\n\t\t{\n\t\t\tconst indefBuf = new ArrayBuffer(2);\n\n\t\t\tif(sizeOnly === false)\n\t\t\t{\n\t\t\t\tconst indefView = new Uint8Array(indefBuf);\n\n\t\t\t\tindefView[0] = 0x00;\n\t\t\t\tindefView[1] = 0x00;\n\t\t\t}\n\n\t\t\tretBuf = utilConcatBuf(retBuf, indefBuf);\n\t\t}\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.idBlock = this.idBlock.toJSON();\n\t\tobject.lenBlock = this.lenBlock.toJSON();\n\t\tobject.valueBlock = this.valueBlock.toJSON();\n\n\t\tif(\"name\" in this)\n\t\t\tobject.name = this.name;\n\t\tif(\"optional\" in this)\n\t\t\tobject.optional = this.optional;\n\t\tif(\"primitiveSchema\" in this)\n\t\t\tobject.primitiveSchema = this.primitiveSchema.toJSON();\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\treturn `${this.constructor.blockName()} : ${bufferToHexCodes(this.valueBlock.valueHex)}`;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic block for all PRIMITIVE types\n//**************************************************************************************\nclass LocalPrimitiveValueBlock extends ValueBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalPrimitiveValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueBeforeDecode]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\t//region Variables from \"hexBlock\" class\n\t\tif(\"valueHex\" in parameters)\n\t\t\tthis.valueHex = parameters.valueHex.slice(0);\n\t\telse\n\t\t\tthis.valueHex = new ArrayBuffer(0);\n\n\t\tthis.isHexOnly = getParametersValue(parameters, \"isHexOnly\", true);\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number}\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\n\t\t\treturn (-1);\n\t\t//endregion\n\n\t\t//region Getting Uint8Array from ArrayBuffer\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t//endregion\n\n\t\t//region Initial checks\n\t\tif(intBuffer.length === 0)\n\t\t{\n\t\t\tthis.warnings.push(\"Zero buffer length\");\n\t\t\treturn inputOffset;\n\t\t}\n\t\t//endregion\n\n\t\t//region Copy input buffer into internal buffer\n\t\tthis.valueHex = new ArrayBuffer(intBuffer.length);\n\t\tconst valueHexView = new Uint8Array(this.valueHex);\n\n\t\tfor(let i = 0; i < intBuffer.length; i++)\n\t\t\tvalueHexView[i] = intBuffer[i];\n\t\t//endregion\n\n\t\tthis.blockLength = inputLength;\n\n\t\treturn (inputOffset + inputLength);\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedLocalSymbols\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\treturn this.valueHex.slice(0);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"PrimitiveValueBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n\t\tobject.isHexOnly = this.isHexOnly;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nexport class Primitive extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Primitive\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueHex]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalPrimitiveValueBlock);\n\n\t\tthis.idBlock.isConstructed = false;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"PRIMITIVE\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic block for all CONSTRUCTED types\n//**************************************************************************************\nclass LocalConstructedValueBlock extends ValueBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalConstructedValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.value = getParametersValue(parameters, \"value\", []);\n\t\tthis.isIndefiniteForm = getParametersValue(parameters, \"isIndefiniteForm\", false);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number}\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\t//region Store initial offset and length\n\t\tconst initialOffset = inputOffset;\n\t\tconst initialLength = inputLength;\n\t\t//endregion\n\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\n\t\t\treturn (-1);\n\t\t//endregion\n\n\t\t//region Getting Uint8Array from ArrayBuffer\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t//endregion\n\n\t\t//region Initial checks\n\t\tif(intBuffer.length === 0)\n\t\t{\n\t\t\tthis.warnings.push(\"Zero buffer length\");\n\t\t\treturn inputOffset;\n\t\t}\n\t\t//endregion\n\n\t\t//region Aux function\n\t\tfunction checkLen(indefiniteLength, length)\n\t\t{\n\t\t\tif(indefiniteLength === true)\n\t\t\t\treturn 1;\n\n\t\t\treturn length;\n\t\t}\n\t\t//endregion\n\n\t\tlet currentOffset = inputOffset;\n\n\t\twhile(checkLen(this.isIndefiniteForm, inputLength) > 0)\n\t\t{\n\t\t\tconst returnObject = LocalFromBER(inputBuffer, currentOffset, inputLength);\n\t\t\tif(returnObject.offset === (-1))\n\t\t\t{\n\t\t\t\tthis.error = returnObject.result.error;\n\t\t\t\tthis.warnings.concat(returnObject.result.warnings);\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\tcurrentOffset = returnObject.offset;\n\n\t\t\tthis.blockLength += returnObject.result.blockLength;\n\t\t\tinputLength -= returnObject.result.blockLength;\n\n\t\t\tthis.value.push(returnObject.result);\n\n\t\t\tif((this.isIndefiniteForm === true) && (returnObject.result.constructor.blockName() === EndOfContent.blockName()))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif(this.isIndefiniteForm === true)\n\t\t{\n\t\t\tif(this.value[this.value.length - 1].constructor.blockName() === EndOfContent.blockName())\n\t\t\t\tthis.value.pop();\n\t\t\telse\n\t\t\t\tthis.warnings.push(\"No EndOfContent block encoded\");\n\t\t}\n\n\t\t//region Copy \"inputBuffer\" to \"valueBeforeDecode\"\n\t\tthis.valueBeforeDecode = inputBuffer.slice(initialOffset, initialOffset + initialLength);\n\t\t//endregion\n\n\t\treturn currentOffset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\tlet retBuf = new ArrayBuffer(0);\n\n\t\tfor(let i = 0; i < this.value.length; i++)\n\t\t{\n\t\t\tconst valueBuf = this.value[i].toBER(sizeOnly);\n\t\t\tretBuf = utilConcatBuf(retBuf, valueBuf);\n\t\t}\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"ConstructedValueBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.isIndefiniteForm = this.isIndefiniteForm;\n\t\tobject.value = [];\n\t\tfor(let i = 0; i < this.value.length; i++)\n\t\t\tobject.value.push(this.value[i].toJSON());\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nexport class Constructed extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Constructed\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalConstructedValueBlock);\n\n\t\tthis.idBlock.isConstructed = true;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"CONSTRUCTED\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number}\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tthis.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\n\t\tif(resultOffset === (-1))\n\t\t{\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tif(this.idBlock.error.length === 0)\n\t\t\tthis.blockLength += this.idBlock.blockLength;\n\n\t\tif(this.lenBlock.error.length === 0)\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\n\n\t\tif(this.valueBlock.error.length === 0)\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\tconst values = [];\n\t\tfor (const value of this.valueBlock.value) {\n\t\t\tvalues.push(value.toString().split(\"\\n\").map(o => `  ${o}`).join(\"\\n\"));\n\t\t}\n\t\tconst blockName = this.idBlock.tagClass === 3\n\t\t\t? `[${this.idBlock.tagNumber}]`\n\t\t\t: this.constructor.blockName();\n\t\treturn values.length \n\t\t\t? `${blockName} :\\n${values.join(\"\\n\")}` // items\n\t\t\t: `${blockName} :`; // empty\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 EndOfContent type class\n//**************************************************************************************\nclass LocalEndOfContentValueBlock extends ValueBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalEndOfContentValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number}\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\t//region There is no \"value block\" for EndOfContent type and we need to return the same offset\n\t\treturn inputOffset;\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedLocalSymbols\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\treturn new ArrayBuffer(0);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"EndOfContentValueBlock\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nexport class EndOfContent extends BaseBlock\n{\n\t//**********************************************************************************\n\tconstructor(paramaters = {})\n\t{\n\t\tsuper(paramaters, LocalEndOfContentValueBlock);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 0; // EndOfContent\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"EndOfContent\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Boolean type class\n//**************************************************************************************\nclass LocalBooleanValueBlock extends ValueBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalBooleanValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\t\t\n\t\tthis.value = getParametersValue(parameters, \"value\", false);\n\t\tthis.isHexOnly = getParametersValue(parameters, \"isHexOnly\", false);\n\t\t\n\t\tif(\"valueHex\" in parameters)\n\t\t\tthis.valueHex = parameters.valueHex.slice(0);\n\t\telse\n\t\t{\n\t\t\tthis.valueHex = new ArrayBuffer(1);\n\t\t\tif(this.value === true)\n\t\t\t{\n\t\t\t\tconst view = new Uint8Array(this.valueHex);\n\t\t\t\tview[0] = 0xFF;\n\t\t\t}\n\t\t}\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\n\t\t\treturn (-1);\n\t\t//endregion\n\n\t\t//region Getting Uint8Array from ArrayBuffer\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t//endregion\n\n\t\tif(inputLength > 1)\n\t\t\tthis.warnings.push(\"Boolean value encoded in more then 1 octet\");\n\n\t\tthis.isHexOnly = true;\n\n\t\t//region Copy input buffer to internal array\n\t\tthis.valueHex = new ArrayBuffer(intBuffer.length);\n\t\tconst view = new Uint8Array(this.valueHex);\n\n\t\tfor(let i = 0; i < intBuffer.length; i++)\n\t\t\tview[i] = intBuffer[i];\n\t\t//endregion\n\t\t\n\t\tif(utilDecodeTC.call(this) !== 0 )\n\t\t\tthis.value = true;\n\t\telse\n\t\t\tthis.value = false;\n\n\t\tthis.blockLength = inputLength;\n\n\t\treturn (inputOffset + inputLength);\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedLocalSymbols\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\treturn this.valueHex;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"BooleanValueBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.value = this.value;\n\t\tobject.isHexOnly = this.isHexOnly;\n\t\tobject.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nexport class Boolean extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Boolean\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalBooleanValueBlock);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 1; // Boolean\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"BOOLEAN\";\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\treturn `${this.constructor.blockName()} : ${this.valueBlock.value}`;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Sequence and Set type classes\n//**************************************************************************************\nexport class Sequence extends Constructed\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Sequence\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 16; // Sequence\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"SEQUENCE\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nexport class Set extends Constructed\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Set\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 17; // Set\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"SET\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Null type class\n//**************************************************************************************\nexport class Null extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Null\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalBaseBlock); // We will not have a call to \"Null value block\" because of specified \"fromBER\" and \"toBER\" functions\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 5; // Null\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"NULL\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedLocalSymbols\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tif(this.lenBlock.length > 0)\n\t\t\tthis.warnings.push(\"Non-zero length of value block for Null type\");\n\n\t\tif(this.idBlock.error.length === 0)\n\t\t\tthis.blockLength += this.idBlock.blockLength;\n\n\t\tif(this.lenBlock.error.length === 0)\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\n\t\t\n\t\tthis.blockLength += inputLength;\n\t\t\n\t\tif((inputOffset + inputLength) > inputBuffer.byteLength)\n\t\t{\n\t\t\tthis.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\n\t\t\treturn (-1);\n\t\t}\n\t\t\n\t\treturn (inputOffset + inputLength);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\tconst retBuf = new ArrayBuffer(2);\n\n\t\tif(sizeOnly === true)\n\t\t\treturn retBuf;\n\n\t\tconst retView = new Uint8Array(retBuf);\n\t\tretView[0] = 0x05;\n\t\tretView[1] = 0x00;\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\treturn `${this.constructor.blockName()}`;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 OctetString type class\n//**************************************************************************************\nclass LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock)\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalOctetStringValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueHex]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.isConstructed = getParametersValue(parameters, \"isConstructed\", false);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tlet resultOffset = 0;\n\n\t\tif(this.isConstructed === true)\n\t\t{\n\t\t\tthis.isHexOnly = false;\n\n\t\t\tresultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n\t\t\tif(resultOffset === (-1))\n\t\t\t\treturn resultOffset;\n\n\t\t\tfor(let i = 0; i < this.value.length; i++)\n\t\t\t{\n\t\t\t\tconst currentBlockName = this.value[i].constructor.blockName();\n\n\t\t\t\tif(currentBlockName === EndOfContent.blockName())\n\t\t\t\t{\n\t\t\t\t\tif(this.isIndefiniteForm === true)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.error = \"EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only\";\n\t\t\t\t\t\treturn (-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(currentBlockName !== OctetString.blockName())\n\t\t\t\t{\n\t\t\t\t\tthis.error = \"OCTET STRING may consists of OCTET STRINGs only\";\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.isHexOnly = true;\n\n\t\t\tresultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n\t\t\tthis.blockLength = inputLength;\n\t\t}\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\tif(this.isConstructed === true)\n\t\t\treturn LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);\n\n\t\tlet retBuf = new ArrayBuffer(this.valueHex.byteLength);\n\n\t\tif(sizeOnly === true)\n\t\t\treturn retBuf;\n\n\t\tif(this.valueHex.byteLength === 0)\n\t\t\treturn retBuf;\n\n\t\tretBuf = this.valueHex.slice(0);\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"OctetStringValueBlock\";\n\t}\n\t//**********************************************************************************\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.isConstructed = this.isConstructed;\n\t\tobject.isHexOnly = this.isHexOnly;\n\t\tobject.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nexport class OctetString extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"OctetString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalOctetStringValueBlock);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 4; // OctetString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tthis.valueBlock.isConstructed = this.idBlock.isConstructed;\n\t\tthis.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n\n\t\t//region Ability to encode empty OCTET STRING\n\t\tif(inputLength === 0)\n\t\t{\n\t\t\tif(this.idBlock.error.length === 0)\n\t\t\t\tthis.blockLength += this.idBlock.blockLength;\n\n\t\t\tif(this.lenBlock.error.length === 0)\n\t\t\t\tthis.blockLength += this.lenBlock.blockLength;\n\n\t\t\treturn inputOffset;\n\t\t}\n\t\t//endregion\n\n\t\tif (!this.valueBlock.isConstructed) {\n\t\t\tconst buf = inputBuffer.slice(inputOffset, inputOffset + inputLength);\n\t\t\ttry {\n\t\t\t\tconst asn = fromBER(buf);\n\t\t\t\tif (asn.offset !== -1 && asn.offset === inputLength) {\n\t\t\t\t\tthis.valueBlock.value = [asn.result];\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// nothing\n\t\t\t}\n\t\t}\n\n\t\treturn super.fromBER(inputBuffer, inputOffset, inputLength);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"OCTET STRING\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Checking that two OCTETSTRINGs are equal\n\t * @param {OctetString} octetString\n\t */\n\tisEqual(octetString)\n\t{\n\t\t//region Check input type\n\t\tif((octetString instanceof OctetString) === false)\n\t\t\treturn false;\n\t\t//endregion\n\n\t\t//region Compare two JSON strings\n\t\tif(JSON.stringify(this) !== JSON.stringify(octetString))\n\t\t\treturn false;\n\t\t//endregion\n\n\t\treturn true;\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\tif (this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length)) {\n\t\t\treturn Constructed.prototype.toString.call(this);\n\t\t} else {\n\t\t\treturn `${this.constructor.blockName()} : ${bufferToHexCodes(this.valueBlock.valueHex)}`;\n\t\t}\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 BitString type class\n//**************************************************************************************\nclass LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock)\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalBitStringValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueHex]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.unusedBits = getParametersValue(parameters, \"unusedBits\", 0);\n\t\tthis.isConstructed = getParametersValue(parameters, \"isConstructed\", false);\n\t\tthis.blockLength = this.valueHex.byteLength;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\t//region Ability to decode zero-length BitString value\n\t\tif(inputLength === 0)\n\t\t\treturn inputOffset;\n\t\t//endregion\n\n\t\tlet resultOffset = (-1);\n\n\t\t//region If the BISTRING supposed to be a constructed value\n\t\tif(this.isConstructed === true)\n\t\t{\n\t\t\tresultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n\t\t\tif(resultOffset === (-1))\n\t\t\t\treturn resultOffset;\n\n\t\t\tfor(let i = 0; i < this.value.length; i++)\n\t\t\t{\n\t\t\t\tconst currentBlockName = this.value[i].constructor.blockName();\n\n\t\t\t\tif(currentBlockName === EndOfContent.blockName())\n\t\t\t\t{\n\t\t\t\t\tif(this.isIndefiniteForm === true)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.error = \"EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only\";\n\t\t\t\t\t\treturn (-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(currentBlockName !== BitString.blockName())\n\t\t\t\t{\n\t\t\t\t\tthis.error = \"BIT STRING may consists of BIT STRINGs only\";\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\n\t\t\t\tif((this.unusedBits > 0) && (this.value[i].valueBlock.unusedBits > 0))\n\t\t\t\t{\n\t\t\t\t\tthis.error = \"Using of \\\"unused bits\\\" inside constructive BIT STRING allowed for least one only\";\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\n\t\t\t\tthis.unusedBits = this.value[i].valueBlock.unusedBits;\n\t\t\t\tif(this.unusedBits > 7)\n\t\t\t\t{\n\t\t\t\t\tthis.error = \"Unused bits for BitString must be in range 0-7\";\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn resultOffset;\n\t\t}\n\t\t//endregion\n\t\t//region If the BitString supposed to be a primitive value\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\n\t\t\treturn (-1);\n\t\t//endregion\n\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\n\t\tthis.unusedBits = intBuffer[0];\n\t\t\n\t\tif(this.unusedBits > 7)\n\t\t{\n\t\t\tthis.error = \"Unused bits for BitString must be in range 0-7\";\n\t\t\treturn (-1);\n\t\t}\n\n\t\tif (!this.unusedBits) {\n\t\t\tconst buf = inputBuffer.slice(inputOffset + 1, inputOffset + inputLength);\n\t\t\ttry {\n\t\t\t\tconst asn = fromBER(buf);\n\t\t\t\tif (asn.offset !== -1 && asn.offset === (inputLength - 1)) {\n\t\t\t\t\tthis.value = [asn.result];\n\t\t\t\t}\n\t\t\t} catch(e) {\n\t\t\t\t// nothing\n\t\t\t}\n\t\t}\n\n\t\t//region Copy input buffer to internal buffer\n\t\tthis.valueHex = new ArrayBuffer(intBuffer.length - 1);\n\t\tconst view = new Uint8Array(this.valueHex);\n\t\tfor(let i = 0; i < (inputLength - 1); i++)\n\t\t\tview[i] = intBuffer[i + 1];\n\t\t//endregion\n\n\t\tthis.blockLength = intBuffer.length;\n\n\t\treturn (inputOffset + inputLength);\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\tif(this.isConstructed === true)\n\t\t\treturn LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);\n\n\t\tif(sizeOnly === true)\n\t\t\treturn (new ArrayBuffer(this.valueHex.byteLength + 1));\n\n\t\tif(this.valueHex.byteLength === 0)\n\t\t\treturn (new ArrayBuffer(0));\n\n\t\tconst curView = new Uint8Array(this.valueHex);\n\n\t\tconst retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);\n\t\tconst retView = new Uint8Array(retBuf);\n\n\t\tretView[0] = this.unusedBits;\n\n\t\tfor(let i = 0; i < this.valueHex.byteLength; i++)\n\t\t\tretView[i + 1] = curView[i];\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"BitStringValueBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.unusedBits = this.unusedBits;\n\t\tobject.isConstructed = this.isConstructed;\n\t\tobject.isHexOnly = this.isHexOnly;\n\t\tobject.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nexport class BitString extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"BitString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalBitStringValueBlock);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 3; // BitString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"BIT STRING\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\t//region Ability to encode empty BitString\n\t\tif(inputLength === 0)\n\t\t\treturn inputOffset;\n\t\t//endregion\n\n\t\tthis.valueBlock.isConstructed = this.idBlock.isConstructed;\n\t\tthis.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n\n\t\treturn super.fromBER(inputBuffer, inputOffset, inputLength);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Checking that two BITSTRINGs are equal\n\t * @param {BitString} bitString\n\t */\n\tisEqual(bitString)\n\t{\n\t\t//region Check input type\n\t\tif((bitString instanceof BitString) === false)\n\t\t\treturn false;\n\t\t//endregion\n\n\t\t//region Compare two JSON strings\n\t\tif(JSON.stringify(this) !== JSON.stringify(bitString))\n\t\t\treturn false;\n\t\t//endregion\n\n\t\treturn true;\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\tif (this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length)) {\n\t\t\treturn Constructed.prototype.toString.call(this);\n\t\t} else {\n\t\t\t// convert bytes to bits\n\t\t\tconst bits = [];\n\t\t\tconst valueHex = new Uint8Array(this.valueBlock.valueHex);\n\t\t\tfor (const byte of valueHex) {\n\t\t\t\tbits.push(byte.toString(2).padStart(8, \"0\"));\n\t\t\t}\n\t\t\treturn `${this.constructor.blockName()} : ${bits.join(\"\")}`;\n\t\t}\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Integer type class\n//**************************************************************************************\n/**\n * @extends ValueBlock\n */\nclass LocalIntegerValueBlock extends HexBlock(ValueBlock)\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalIntegerValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueHex]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tif(\"value\" in parameters)\n\t\t\tthis.valueDec = parameters.value;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Setter for \"valueHex\"\n\t * @param {ArrayBuffer} _value\n\t */\n\tset valueHex(_value)\n\t{\n\t\tthis._valueHex = _value.slice(0);\n\n\t\tif(_value.byteLength >= 4)\n\t\t{\n\t\t\tthis.warnings.push(\"Too big Integer for decoding, hex only\");\n\t\t\tthis.isHexOnly = true;\n\t\t\tthis._valueDec = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.isHexOnly = false;\n\n\t\t\tif(_value.byteLength > 0)\n\t\t\t\tthis._valueDec = utilDecodeTC.call(this);\n\t\t}\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Getter for \"valueHex\"\n\t * @returns {ArrayBuffer}\n\t */\n\tget valueHex()\n\t{\n\t\treturn this._valueHex;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Getter for \"valueDec\"\n\t * @param {number} _value\n\t */\n\tset valueDec(_value)\n\t{\n\t\tthis._valueDec = _value;\n\n\t\tthis.isHexOnly = false;\n\t\tthis._valueHex = utilEncodeTC(_value);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Getter for \"valueDec\"\n\t * @returns {number}\n\t */\n\tget valueDec()\n\t{\n\t\treturn this._valueDec;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from DER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 DER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 DER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @param {number} [expectedLength=0] Expected length of converted \"valueHex\" buffer\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0)\n\t{\n\t\tconst offset = this.fromBER(inputBuffer, inputOffset, inputLength);\n\t\tif(offset === (-1))\n\t\t\treturn offset;\n\n\t\tconst view = new Uint8Array(this._valueHex);\n\n\t\tif((view[0] === 0x00) && ((view[1] & 0x80) !== 0))\n\t\t{\n\t\t\tconst updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);\n\t\t\tconst updatedView = new Uint8Array(updatedValueHex);\n\n\t\t\tupdatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));\n\n\t\t\tthis._valueHex = updatedValueHex.slice(0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(expectedLength !== 0)\n\t\t\t{\n\t\t\t\tif(this._valueHex.byteLength < expectedLength)\n\t\t\t\t{\n\t\t\t\t\tif((expectedLength - this._valueHex.byteLength) > 1)\n\t\t\t\t\t\texpectedLength = this._valueHex.byteLength + 1;\n\t\t\t\t\t\n\t\t\t\t\tconst updatedValueHex = new ArrayBuffer(expectedLength);\n\t\t\t\t\tconst updatedView = new Uint8Array(updatedValueHex);\n\n\t\t\t\t\tupdatedView.set(view, expectedLength - this._valueHex.byteLength);\n\n\t\t\t\t\tthis._valueHex = updatedValueHex.slice(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn offset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (DER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoDER(sizeOnly = false)\n\t{\n\t\tconst view = new Uint8Array(this._valueHex);\n\n\t\tswitch(true)\n\t\t{\n\t\t\tcase ((view[0] & 0x80) !== 0):\n\t\t\t\t{\n\t\t\t\t\tconst updatedValueHex = new ArrayBuffer(this._valueHex.byteLength + 1);\n\t\t\t\t\tconst updatedView = new Uint8Array(updatedValueHex);\n\n\t\t\t\t\tupdatedView[0] = 0x00;\n\t\t\t\t\tupdatedView.set(view, 1);\n\n\t\t\t\t\tthis._valueHex = updatedValueHex.slice(0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ((view[0] === 0x00) && ((view[1] & 0x80) === 0)):\n\t\t\t\t{\n\t\t\t\t\tconst updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);\n\t\t\t\t\tconst updatedView = new Uint8Array(updatedValueHex);\n\n\t\t\t\t\tupdatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));\n\n\t\t\t\t\tthis._valueHex = updatedValueHex.slice(0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t}\n\n\t\treturn this.toBER(sizeOnly);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tconst resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n\t\tif(resultOffset === (-1))\n\t\t\treturn resultOffset;\n\n\t\tthis.blockLength = inputLength;\n\n\t\treturn (inputOffset + inputLength);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\t//noinspection JSCheckFunctionSignatures\n\t\treturn this.valueHex.slice(0);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"IntegerValueBlock\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.valueDec = this.valueDec;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convert current value to decimal string representation\n\t */\n\ttoString()\n\t{\n\t\t//region Aux functions\n\t\tfunction viewAdd(first, second)\n\t\t{\n\t\t\t//region Initial variables\n\t\t\tconst c = new Uint8Array([0]);\n\t\t\t\n\t\t\tlet firstView = new Uint8Array(first);\n\t\t\tlet secondView = new Uint8Array(second);\n\t\t\t\n\t\t\tlet firstViewCopy = firstView.slice(0);\n\t\t\tconst firstViewCopyLength = firstViewCopy.length - 1;\n\t\t\tlet secondViewCopy = secondView.slice(0);\n\t\t\tconst secondViewCopyLength = secondViewCopy.length - 1;\n\t\t\t\n\t\t\tlet value = 0;\n\t\t\t\n\t\t\tconst max = (secondViewCopyLength < firstViewCopyLength) ? firstViewCopyLength : secondViewCopyLength;\n\t\t\t\n\t\t\tlet counter = 0;\n\t\t\t//endregion\n\t\t\t\n\t\t\tfor(let i = max; i >= 0; i--, counter++)\n\t\t\t{\n\t\t\t\tswitch(true)\n\t\t\t\t{\n\t\t\t\t\tcase (counter < secondViewCopy.length):\n\t\t\t\t\t\tvalue = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tvalue = firstViewCopy[firstViewCopyLength - counter] + c[0];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tc[0] = value / 10;\n\t\t\t\t\n\t\t\t\tswitch(true)\n\t\t\t\t{\n\t\t\t\t\tcase (counter >= firstViewCopy.length):\n\t\t\t\t\t\tfirstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value % 10;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(c[0] > 0)\n\t\t\t\tfirstViewCopy = utilConcatView(c, firstViewCopy);\n\t\t\t\n\t\t\treturn firstViewCopy.slice(0);\n\t\t}\n\t\t\n\t\tfunction power2(n)\n\t\t{\n\t\t\tif(n >= powers2.length)\n\t\t\t{\n\t\t\t\tfor(let p = powers2.length; p <= n; p++)\n\t\t\t\t{\n\t\t\t\t\tconst c = new Uint8Array([0]);\n\t\t\t\t\tlet digits = (powers2[p - 1]).slice(0);\n\t\t\t\t\t\n\t\t\t\t\tfor(let i = (digits.length - 1); i >=0; i--)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst newValue = new Uint8Array([(digits[i] << 1) + c[0]]);\n\t\t\t\t\t\tc[0] = newValue[0] / 10;\n\t\t\t\t\t\tdigits[i] = newValue[0] % 10;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (c[0] > 0)\n\t\t\t\t\t\tdigits = utilConcatView(c, digits);\n\t\t\t\t\t\n\t\t\t\t\tpowers2.push(digits);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn powers2[n];\n\t\t}\n\t\t\n\t\tfunction viewSub(first, second)\n\t\t{\n\t\t\t//region Initial variables\n\t\t\tlet b = 0;\n\t\t\t\n\t\t\tlet firstView = new Uint8Array(first);\n\t\t\tlet secondView = new Uint8Array(second);\n\t\t\t\n\t\t\tlet firstViewCopy = firstView.slice(0);\n\t\t\tconst firstViewCopyLength = firstViewCopy.length - 1;\n\t\t\tlet secondViewCopy = secondView.slice(0);\n\t\t\tconst secondViewCopyLength = secondViewCopy.length - 1;\n\t\t\t\n\t\t\tlet value;\n\t\t\t\n\t\t\tlet counter = 0;\n\t\t\t//endregion\n\t\t\t\n\t\t\tfor(let i = secondViewCopyLength; i >= 0; i--, counter++)\n\t\t\t{\n\t\t\t\tvalue = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;\n\t\t\t\t\n\t\t\t\tswitch(true)\n\t\t\t\t{\n\t\t\t\t\tcase (value < 0):\n\t\t\t\t\t\tb = 1;\n\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value + 10;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(b > 0)\n\t\t\t{\n\t\t\t\tfor(let i = (firstViewCopyLength - secondViewCopyLength + 1); i >= 0; i--, counter++)\n\t\t\t\t{\n\t\t\t\t\tvalue = firstViewCopy[firstViewCopyLength - counter] - b;\n\t\t\t\t\t\n\t\t\t\t\tif(value < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tb = 1;\n\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value + 10;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn firstViewCopy.slice();\n\t\t}\n\t\t//endregion\n\t\t\n\t\t//region Initial variables\n\t\tconst firstBit = (this._valueHex.byteLength * 8) - 1;\n\t\t\n\t\tlet digits = new Uint8Array((this._valueHex.byteLength * 8) / 3);\n\t\tlet bitNumber = 0;\n\t\tlet currentByte;\n\t\t\n\t\tconst asn1View = new Uint8Array(this._valueHex);\n\t\t\n\t\tlet result = \"\";\n\t\t\n\t\tlet flag = false;\n\t\t//endregion\n\t\t\n\t\t//region Calculate number\n\t\tfor(let byteNumber = (this._valueHex.byteLength - 1); byteNumber >= 0; byteNumber--)\n\t\t{\n\t\t\tcurrentByte = asn1View[byteNumber];\n\t\t\t\n\t\t\tfor(let i = 0; i < 8; i++)\n\t\t\t{\n\t\t\t\tif((currentByte & 1) === 1)\n\t\t\t\t{\n\t\t\t\t\tswitch(bitNumber)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase firstBit:\n\t\t\t\t\t\t\tdigits = viewSub(power2(bitNumber), digits);\n\t\t\t\t\t\t\tresult = \"-\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tdigits = viewAdd(digits, power2(bitNumber));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbitNumber++;\n\t\t\t\tcurrentByte >>= 1;\n\t\t\t}\n\t\t}\n\t\t//endregion\n\t\t\n\t\t//region Print number\n\t\tfor(let i = 0; i < digits.length; i++)\n\t\t{\n\t\t\tif(digits[i])\n\t\t\t\tflag = true;\n\t\t\t\n\t\t\tif(flag)\n\t\t\t\tresult += digitsString.charAt(digits[i]);\n\t\t}\n\t\t\n\t\tif(flag === false)\n\t\t\tresult += digitsString.charAt(0);\n\t\t//endregion\n\t\t\n\t\treturn result;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nexport class Integer extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Integer\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalIntegerValueBlock);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 2; // Integer\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"INTEGER\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Compare two Integer object, or Integer and ArrayBuffer objects\n\t * @param {!Integer|ArrayBuffer} otherValue\n\t * @returns {boolean}\n\t */\n\tisEqual(otherValue)\n\t{\n\t\tif(otherValue instanceof Integer)\n\t\t{\n\t\t\tif(this.valueBlock.isHexOnly && otherValue.valueBlock.isHexOnly) // Compare two ArrayBuffers\n\t\t\t\treturn isEqualBuffer(this.valueBlock.valueHex, otherValue.valueBlock.valueHex);\n\n\t\t\tif(this.valueBlock.isHexOnly === otherValue.valueBlock.isHexOnly)\n\t\t\t\treturn (this.valueBlock.valueDec === otherValue.valueBlock.valueDec);\n\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(otherValue instanceof ArrayBuffer)\n\t\t\treturn isEqualBuffer(this.valueBlock.valueHex, otherValue);\n\n\t\treturn false;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convert current Integer value from BER into DER format\n\t * @returns {Integer}\n\t */\n\tconvertToDER()\n\t{\n\t\tconst integer = new Integer({ valueHex: this.valueBlock.valueHex });\n\t\tinteger.valueBlock.toDER();\n\n\t\treturn integer;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convert current Integer value from DER to BER format\n\t * @returns {Integer}\n\t */\n\tconvertFromDER()\n\t{\n\t\tconst expectedLength = (this.valueBlock.valueHex.byteLength % 2) ? (this.valueBlock.valueHex.byteLength + 1) : this.valueBlock.valueHex.byteLength;\n\t\tconst integer = new Integer({ valueHex: this.valueBlock.valueHex });\n\t\tinteger.valueBlock.fromDER(integer.valueBlock.valueHex, 0, integer.valueBlock.valueHex.byteLength, expectedLength);\n\t\t\n\t\treturn integer;\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\tassertBigInt();\n\t\tconst hex = bufferToHexCodes(this.valueBlock.valueHex);\n\t\tconst bigInt = BigInt(`0x${hex}`);\n\t\treturn `${this.constructor.blockName()} : ${bigInt.toString()}`;\n\t}\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Enumerated type class\n//**************************************************************************************\nexport class Enumerated extends Integer\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Enumerated\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 10; // Enumerated\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"ENUMERATED\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 ObjectIdentifier type class\n//**************************************************************************************\nclass LocalSidValueBlock extends HexBlock(LocalBaseBlock)\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalSidValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {number} [valueDec]\n\t * @property {boolean} [isFirstSid]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.valueDec = getParametersValue(parameters, \"valueDec\", -1);\n\t\tthis.isFirstSid = getParametersValue(parameters, \"isFirstSid\", false);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"sidBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tif(inputLength === 0)\n\t\t\treturn inputOffset;\n\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\n\t\t\treturn (-1);\n\t\t//endregion\n\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\n\t\tthis.valueHex = new ArrayBuffer(inputLength);\n\t\tlet view = new Uint8Array(this.valueHex);\n\n\t\tfor(let i = 0; i < inputLength; i++)\n\t\t{\n\t\t\tview[i] = intBuffer[i] & 0x7F;\n\n\t\t\tthis.blockLength++;\n\n\t\t\tif((intBuffer[i] & 0x80) === 0x00)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t//region Ajust size of valueHex buffer\n\t\tconst tempValueHex = new ArrayBuffer(this.blockLength);\n\t\tconst tempView = new Uint8Array(tempValueHex);\n\n\t\tfor(let i = 0; i < this.blockLength; i++)\n\t\t\ttempView[i] = view[i];\n\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tthis.valueHex = tempValueHex.slice(0);\n\t\tview = new Uint8Array(this.valueHex);\n\t\t//endregion\n\n\t\tif((intBuffer[this.blockLength - 1] & 0x80) !== 0x00)\n\t\t{\n\t\t\tthis.error = \"End of input reached before message was fully decoded\";\n\t\t\treturn (-1);\n\t\t}\n\n\t\tif(view[0] === 0x00)\n\t\t\tthis.warnings.push(\"Needlessly long format of SID encoding\");\n\n\t\tif(this.blockLength <= 8)\n\t\t\tthis.valueDec = utilFromBase(view, 7);\n\t\telse\n\t\t{\n\t\t\tthis.isHexOnly = true;\n\t\t\tthis.warnings.push(\"Too big SID for decoding, hex only\");\n\t\t}\n\n\t\treturn (inputOffset + this.blockLength);\n\t}\n//**********************************************************************************\n\t/**\n\t * Save a BigInt value immediately as an array of octects.\n\t */\n set valueBigInt(value) {\n\n\tassertBigInt();\n\n\tlet bits = BigInt(value).toString(2);\n\twhile (bits.length % 7) {\n\t\tbits = '0' + bits\n\t}\n\tconst bytes = new Uint8Array(bits.length / 7)\n\tfor (let i = 0; i < bytes.length; i++) {\n\t\tbytes[i] = parseInt(bits.slice(i*7, i*7 + 7), 2) + (i + 1 < bytes.length ? 0x80 : 0)\n\t}\n\tthis.fromBER(bytes.buffer, 0, bytes.length)\n}\n//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\t//region Initial variables\n\t\tlet retBuf;\n\t\tlet retView;\n\t\t//endregion\n\n\t\tif(this.isHexOnly)\n\t\t{\n\t\t\tif(sizeOnly === true)\n\t\t\t\treturn (new ArrayBuffer(this.valueHex.byteLength));\n\n\t\t\tconst curView = new Uint8Array(this.valueHex);\n\n\t\t\tretBuf = new ArrayBuffer(this.blockLength);\n\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\tfor(let i = 0; i < (this.blockLength - 1); i++)\n\t\t\t\tretView[i] = curView[i] | 0x80;\n\n\t\t\tretView[this.blockLength - 1] = curView[this.blockLength - 1];\n\n\t\t\treturn retBuf;\n\t\t}\n\n\t\tconst encodedBuf = utilToBase(this.valueDec, 7);\n\t\tif(encodedBuf.byteLength === 0)\n\t\t{\n\t\t\tthis.error = \"Error during encoding SID value\";\n\t\t\treturn (new ArrayBuffer(0));\n\t\t}\n\n\t\tretBuf = new ArrayBuffer(encodedBuf.byteLength);\n\n\t\tif(sizeOnly === false)\n\t\t{\n\t\t\tconst encodedView = new Uint8Array(encodedBuf);\n\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\tfor(let i = 0; i < (encodedBuf.byteLength - 1); i++)\n\t\t\t\tretView[i] = encodedView[i] | 0x80;\n\n\t\t\tretView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];\n\t\t}\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Create string representation of current SID block\n\t * @returns {string}\n\t */\n\ttoString()\n\t{\n\t\tlet result = \"\";\n\n\t\tif(this.isHexOnly === true)\n\t\t\tresult = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n\t\telse\n\t\t{\n\t\t\tif(this.isFirstSid)\n\t\t\t{\n\t\t\t\tlet sidValue = this.valueDec;\n\n\t\t\t\tif(this.valueDec <= 39)\n\t\t\t\t\tresult = \"0.\";\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(this.valueDec <= 79)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = \"1.\";\n\t\t\t\t\t\tsidValue -= 40;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = \"2.\";\n\t\t\t\t\t\tsidValue -= 80;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresult += sidValue.toString();\n\t\t\t}\n\t\t\telse\n\t\t\t\tresult = this.valueDec.toString();\n\t\t}\n\n\t\treturn result;\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.valueDec = this.valueDec;\n\t\tobject.isFirstSid = this.isFirstSid;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nclass LocalObjectIdentifierValueBlock extends ValueBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalObjectIdentifierValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueHex]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.fromString(getParametersValue(parameters, \"value\", \"\"));\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tlet resultOffset = inputOffset;\n\n\t\twhile(inputLength > 0)\n\t\t{\n\t\t\tconst sidBlock = new LocalSidValueBlock();\n\t\t\tresultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n\t\t\tif(resultOffset === (-1))\n\t\t\t{\n\t\t\t\tthis.blockLength = 0;\n\t\t\t\tthis.error = sidBlock.error;\n\t\t\t\treturn resultOffset;\n\t\t\t}\n\n\t\t\tif(this.value.length === 0)\n\t\t\t\tsidBlock.isFirstSid = true;\n\n\t\t\tthis.blockLength += sidBlock.blockLength;\n\t\t\tinputLength -= sidBlock.blockLength;\n\n\t\t\tthis.value.push(sidBlock);\n\t\t}\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\tlet retBuf = new ArrayBuffer(0);\n\n\t\tfor(let i = 0; i < this.value.length; i++)\n\t\t{\n\t\t\tconst valueBuf = this.value[i].toBER(sizeOnly);\n\t\t\tif(valueBuf.byteLength === 0)\n\t\t\t{\n\t\t\t\tthis.error = this.value[i].error;\n\t\t\t\treturn (new ArrayBuffer(0));\n\t\t\t}\n\n\t\t\tretBuf = utilConcatBuf(retBuf, valueBuf);\n\t\t}\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Create \"LocalObjectIdentifierValueBlock\" class from string\n\t * @param {string} string Input string to convert from\n\t * @returns {boolean}\n\t */\n\tfromString(string)\n\t{\n\t\tthis.value = []; // Clear existing SID values\n\n\t\tlet pos1 = 0;\n\t\tlet pos2 = 0;\n\n\t\tlet sid = \"\";\n\n\t\tlet flag = false;\n\n\t\tdo\n\t\t{\n\t\t\tpos2 = string.indexOf(\".\", pos1);\n\t\t\tif(pos2 === (-1))\n\t\t\t\tsid = string.substr(pos1);\n\t\t\telse\n\t\t\t\tsid = string.substr(pos1, pos2 - pos1);\n\n\t\t\tpos1 = pos2 + 1;\n\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\tconst sidBlock = this.value[0];\n\n\t\t\t\tlet plus = 0;\n\n\t\t\t\tswitch(sidBlock.valueDec)\n\t\t\t\t{\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tplus = 40;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tplus = 80;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthis.value = []; // clear SID array\n\t\t\t\t\t\treturn false; // ???\n\t\t\t\t}\n\n\t\t\t\tconst parsedSID = parseInt(sid, 10);\n\t\t\t\tif(isNaN(parsedSID))\n\t\t\t\t\treturn true;\n\n\t\t\t\tsidBlock.valueDec = parsedSID + plus;\n\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconst sidBlock = new LocalSidValueBlock();\n        if (sid > Number.MAX_SAFE_INTEGER) {\n\t\t\t\t\tassertBigInt();\n\t\t\t\t\tconst sidValue = BigInt(sid);\n          sidBlock.valueBigInt = sidValue\n        } else {\n          sidBlock.valueDec = parseInt(sid, 10);\n          if (isNaN(sidBlock.valueDec)) return true;  \n        }\n\n\t\t\t\tif(this.value.length === 0)\n\t\t\t\t{\n\t\t\t\t\tsidBlock.isFirstSid = true;\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\n\t\t\t\tthis.value.push(sidBlock);\n\t\t\t}\n\t\t} while(pos2 !== (-1));\n\n\t\treturn true;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Converts \"LocalObjectIdentifierValueBlock\" class to string\n\t * @returns {string}\n\t */\n\ttoString()\n\t{\n\t\tlet result = \"\";\n\t\tlet isHexOnly = false;\n\n\t\tfor(let i = 0; i < this.value.length; i++)\n\t\t{\n\t\t\tisHexOnly = this.value[i].isHexOnly;\n\n\t\t\tlet sidStr = this.value[i].toString();\n\n\t\t\tif(i !== 0)\n\t\t\t\tresult = `${result}.`;\n\n\t\t\tif(isHexOnly)\n\t\t\t{\n\t\t\t\tsidStr = `{${sidStr}}`;\n\n\t\t\t\tif(this.value[i].isFirstSid)\n\t\t\t\t\tresult = `2.{${sidStr} - 80}`;\n\t\t\t\telse\n\t\t\t\t\tresult += sidStr;\n\t\t\t}\n\t\t\telse\n\t\t\t\tresult += sidStr;\n\t\t}\n\n\t\treturn result;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"ObjectIdentifierValueBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.value = this.toString();\n\t\tobject.sidArray = [];\n\t\tfor(let i = 0; i < this.value.length; i++)\n\t\t\tobject.sidArray.push(this.value[i].toJSON());\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends BaseBlock\n */\nexport class ObjectIdentifier extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"ObjectIdentifier\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueHex]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalObjectIdentifierValueBlock);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 6; // OBJECT IDENTIFIER\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"OBJECT IDENTIFIER\";\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\treturn `${this.constructor.blockName()} : ${this.valueBlock.toString()}`;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of all string's classes\n//**************************************************************************************\nclass LocalUtf8StringValueBlock extends HexBlock(LocalBaseBlock)\n{\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Constructor for \"LocalUtf8StringValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.isHexOnly = true;\n\t\tthis.value = \"\"; // String representation of decoded ArrayBuffer\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"Utf8StringValueBlock\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.value = this.value;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends BaseBlock\n */\nexport class Utf8String extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Utf8String\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueHex]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalUtf8StringValueBlock);\n\n\t\tif(\"value\" in parameters)\n\t\t\tthis.fromString(parameters.value);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 12; // Utf8String\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"UTF8String\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\n\t\tif(resultOffset === (-1))\n\t\t{\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\tif(this.idBlock.error.length === 0)\n\t\t\tthis.blockLength += this.idBlock.blockLength;\n\n\t\tif(this.lenBlock.error.length === 0)\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\n\n\t\tif(this.valueBlock.error.length === 0)\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting ArrayBuffer into ASN.1 internal string\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t */\n\tfromBuffer(inputBuffer)\n\t{\n\t\tthis.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));\n\n\t\ttry\n\t\t{\n\t\t\t//noinspection JSDeprecatedSymbols\n\t\t\tthis.valueBlock.value = decodeURIComponent(escape(this.valueBlock.value));\n\t\t}\n\t\tcatch(ex)\n\t\t{\n\t\t\tthis.warnings.push(`Error during \"decodeURIComponent\": ${ex}, using raw string`);\n\t\t}\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting JavaScript string into ASN.1 internal class\n\t * @param {!string} inputString ASN.1 BER encoded array\n\t */\n\tfromString(inputString)\n\t{\n\t\t//noinspection JSDeprecatedSymbols\n\t\tconst str = unescape(encodeURIComponent(inputString));\n\t\tconst strLen = str.length;\n\n\t\tthis.valueBlock.valueHex = new ArrayBuffer(strLen);\n\t\tconst view = new Uint8Array(this.valueBlock.valueHex);\n\n\t\tfor(let i = 0; i < strLen; i++)\n\t\t\tview[i] = str.charCodeAt(i);\n\n\t\tthis.valueBlock.value = inputString;\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\treturn `${this.constructor.blockName()} : ${this.valueBlock.value}`;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//region Declaration of ASN.1 RelativeObjectIdentifier type class\n//**************************************************************************************\nclass LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock)\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalRelativeSidValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {number} [valueDec]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.valueDec = getParametersValue(parameters, \"valueDec\", -1);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"relativeSidBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tif (inputLength === 0)\n\t\t\treturn inputOffset;\n\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\n\t\t\treturn (-1);\n\t\t//endregion\n\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\n\t\tthis.valueHex = new ArrayBuffer(inputLength);\n\t\tlet view = new Uint8Array(this.valueHex);\n\n\t\tfor (let i = 0; i < inputLength; i++)\n\t\t{\n\t\t\tview[i] = intBuffer[i] & 0x7F;\n\n\t\t\tthis.blockLength++;\n\n\t\t\tif ((intBuffer[i] & 0x80) === 0x00)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t//region Ajust size of valueHex buffer\n\t\tconst tempValueHex = new ArrayBuffer(this.blockLength);\n\t\tconst tempView = new Uint8Array(tempValueHex);\n\n\t\tfor (let i = 0; i < this.blockLength; i++)\n\t\t\ttempView[i] = view[i];\n\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tthis.valueHex = tempValueHex.slice(0);\n\t\tview = new Uint8Array(this.valueHex);\n\t\t//endregion\n\n\t\tif ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00)\n\t\t{\n\t\t\tthis.error = \"End of input reached before message was fully decoded\";\n\t\t\treturn (-1);\n\t\t}\n\n\t\tif (view[0] === 0x00)\n\t\t\tthis.warnings.push(\"Needlessly long format of SID encoding\");\n\n\t\tif (this.blockLength <= 8)\n\t\t\tthis.valueDec = utilFromBase(view, 7);\n\t\telse\n\t\t{\n\t\t\tthis.isHexOnly = true;\n\t\t\tthis.warnings.push(\"Too big SID for decoding, hex only\");\n\t\t}\n\n\t\treturn (inputOffset + this.blockLength);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\t//region Initial variables\n\t\tlet retBuf;\n\t\tlet retView;\n\t\t//endregion\n\n\t\tif (this.isHexOnly)\n\t\t{\n\t\t\tif (sizeOnly === true)\n\t\t\t\treturn (new ArrayBuffer(this.valueHex.byteLength));\n\n\t\t\tconst curView = new Uint8Array(this.valueHex);\n\n\t\t\tretBuf = new ArrayBuffer(this.blockLength);\n\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\tfor (let i = 0; i < (this.blockLength - 1); i++)\n\t\t\t\tretView[i] = curView[i] | 0x80;\n\n\t\t\tretView[this.blockLength - 1] = curView[this.blockLength - 1];\n\n\t\t\treturn retBuf;\n\t\t}\n\n\t\tconst encodedBuf = utilToBase(this.valueDec, 7);\n\t\tif (encodedBuf.byteLength === 0)\n\t\t{\n\t\t\tthis.error = \"Error during encoding SID value\";\n\t\t\treturn (new ArrayBuffer(0));\n\t\t}\n\n\t\tretBuf = new ArrayBuffer(encodedBuf.byteLength);\n\n\t\tif (sizeOnly === false)\n\t\t{\n\t\t\tconst encodedView = new Uint8Array(encodedBuf);\n\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\tfor (let i = 0; i < (encodedBuf.byteLength - 1); i++)\n\t\t\t\tretView[i] = encodedView[i] | 0x80;\n\n\t\t\tretView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];\n\t\t}\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Create string representation of current SID block\n\t * @returns {string}\n\t */\n\ttoString()\n\t{\n\t\tlet result = \"\";\n\n\t\tif (this.isHexOnly === true)\n\t\t\tresult = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n\t\telse {\n\t\t\tresult = this.valueDec.toString();\n\t\t}\n\n\t\treturn result;\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry {\n\t\t\tobject = super.toJSON();\n\t\t} catch (ex) {}\n\t\t//endregion\n\n\t\tobject.valueDec = this.valueDec;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nclass LocalRelativeObjectIdentifierValueBlock extends ValueBlock {\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalRelativeObjectIdentifierValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueHex]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.fromString(getParametersValue(parameters, \"value\", \"\"));\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tlet resultOffset = inputOffset;\n\n\t\twhile (inputLength > 0)\n\t\t{\n\t\t\tconst sidBlock = new LocalRelativeSidValueBlock();\n\t\t\tresultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n\t\t\tif (resultOffset === (-1))\n\t\t\t{\n\t\t\t\tthis.blockLength = 0;\n\t\t\t\tthis.error = sidBlock.error;\n\t\t\t\treturn resultOffset;\n\t\t\t}\n\n\t\t\tthis.blockLength += sidBlock.blockLength;\n\t\t\tinputLength -= sidBlock.blockLength;\n\n\t\t\tthis.value.push(sidBlock);\n\t\t}\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\tlet retBuf = new ArrayBuffer(0);\n\n\t\tfor (let i = 0; i < this.value.length; i++)\n\t\t{\n\t\t\tconst valueBuf = this.value[i].toBER(sizeOnly);\n\t\t\tif (valueBuf.byteLength === 0)\n\t\t\t{\n\t\t\t\tthis.error = this.value[i].error;\n\t\t\t\treturn (new ArrayBuffer(0));\n\t\t\t}\n\n\t\t\tretBuf = utilConcatBuf(retBuf, valueBuf);\n\t\t}\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Create \"LocalRelativeObjectIdentifierValueBlock\" class from string\n\t * @param {string} string Input string to convert from\n\t * @returns {boolean}\n\t */\n\tfromString(string)\n\t{\n\t\tthis.value = []; // Clear existing SID values\n\n\t\tlet pos1 = 0;\n\t\tlet pos2 = 0;\n\n\t\tlet sid = \"\";\n\n\t\tdo\n\t\t{\n\t\t\tpos2 = string.indexOf(\".\", pos1);\n\t\t\tif (pos2 === (-1))\n\t\t\t\tsid = string.substr(pos1);\n\t\t\telse\n\t\t\t\tsid = string.substr(pos1, pos2 - pos1);\n\n\t\t\tpos1 = pos2 + 1;\n\n\t\t\tconst sidBlock = new LocalRelativeSidValueBlock();\n\t\t\tsidBlock.valueDec = parseInt(sid, 10);\n\t\t\tif (isNaN(sidBlock.valueDec))\n\t\t\t\treturn true;\n\n\t\t\tthis.value.push(sidBlock);\n\n\t\t} while (pos2 !== (-1));\n\n\t\treturn true;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Converts \"LocalRelativeObjectIdentifierValueBlock\" class to string\n\t * @returns {string}\n\t */\n\ttoString()\n\t{\n\t\tlet result = \"\";\n\t\tlet isHexOnly = false;\n\n\t\tfor (let i = 0; i < this.value.length; i++)\n\t\t{\n\t\t\tisHexOnly = this.value[i].isHexOnly;\n\n\t\t\tlet sidStr = this.value[i].toString();\n\n\t\t\tif (i !== 0)\n\t\t\t\tresult = `${result}.`;\n\n\t\t\tif (isHexOnly)\n\t\t\t{\n\t\t\t\tsidStr = `{${sidStr}}`;\n\t\t\t\tresult += sidStr;\n\t\t\t} else\n\t\t\t\tresult += sidStr;\n\t\t}\n\n\t\treturn result;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"RelativeObjectIdentifierValueBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t} catch (ex) {}\n\t\t//endregion\n\n\t\tobject.value = this.toString();\n\t\tobject.sidArray = [];\n\t\tfor (let i = 0; i < this.value.length; i++)\n\t\t\tobject.sidArray.push(this.value[i].toJSON());\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends BaseBlock\n */\nexport class RelativeObjectIdentifier extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"RelativeObjectIdentifier\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueHex]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalRelativeObjectIdentifierValueBlock);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 13; // RELATIVE OBJECT IDENTIFIER\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"RelativeObjectIdentifier\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n/**\n * @extends LocalBaseBlock\n * @extends HexBlock\n */\nclass LocalBmpStringValueBlock extends HexBlock(LocalBaseBlock)\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalBmpStringValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.isHexOnly = true;\n\t\tthis.value = \"\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"BmpStringValueBlock\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.value = this.value;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends BaseBlock\n */\nexport class BmpString extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"BmpString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalBmpStringValueBlock);\n\n\t\tif(\"value\" in parameters)\n\t\t\tthis.fromString(parameters.value);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 30; // BmpString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"BMPString\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\n\t\tif(resultOffset === (-1))\n\t\t{\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\tif(this.idBlock.error.length === 0)\n\t\t\tthis.blockLength += this.idBlock.blockLength;\n\n\t\tif(this.lenBlock.error.length === 0)\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\n\n\t\tif(this.valueBlock.error.length === 0)\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting ArrayBuffer into ASN.1 internal string\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t */\n\tfromBuffer(inputBuffer)\n\t{\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tconst copyBuffer = inputBuffer.slice(0);\n\t\tconst valueView = new Uint8Array(copyBuffer);\n\n\t\tfor(let i = 0; i < valueView.length; i += 2)\n\t\t{\n\t\t\tconst temp = valueView[i];\n\n\t\t\tvalueView[i] = valueView[i + 1];\n\t\t\tvalueView[i + 1] = temp;\n\t\t}\n\n\t\tthis.valueBlock.value = String.fromCharCode.apply(null, new Uint16Array(copyBuffer));\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting JavaScript string into ASN.1 internal class\n\t * @param {!string} inputString ASN.1 BER encoded array\n\t */\n\tfromString(inputString)\n\t{\n\t\tconst strLength = inputString.length;\n\n\t\tthis.valueBlock.valueHex = new ArrayBuffer(strLength * 2);\n\t\tconst valueHexView = new Uint8Array(this.valueBlock.valueHex);\n\n\t\tfor(let i = 0; i < strLength; i++)\n\t\t{\n\t\t\tconst codeBuf = utilToBase(inputString.charCodeAt(i), 8);\n\t\t\tconst codeView = new Uint8Array(codeBuf);\n\t\t\tif(codeView.length > 2)\n\t\t\t\tcontinue;\n\n\t\t\tconst dif = 2 - codeView.length;\n\n\t\t\tfor(let j = (codeView.length - 1); j >= 0; j--)\n\t\t\t\tvalueHexView[i * 2 + j + dif] = codeView[j];\n\t\t}\n\n\t\tthis.valueBlock.value = inputString;\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\treturn `${this.constructor.blockName()} : ${this.valueBlock.value}`;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nclass LocalUniversalStringValueBlock extends HexBlock(LocalBaseBlock)\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalUniversalStringValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.isHexOnly = true;\n\t\tthis.value = \"\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"UniversalStringValueBlock\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.value = this.value;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends BaseBlock\n */\nexport class UniversalString extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"UniversalString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalUniversalStringValueBlock);\n\n\t\tif(\"value\" in parameters)\n\t\t\tthis.fromString(parameters.value);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 28; // UniversalString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"UniversalString\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\n\t\tif(resultOffset === (-1))\n\t\t{\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\tif(this.idBlock.error.length === 0)\n\t\t\tthis.blockLength += this.idBlock.blockLength;\n\n\t\tif(this.lenBlock.error.length === 0)\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\n\n\t\tif(this.valueBlock.error.length === 0)\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting ArrayBuffer into ASN.1 internal string\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t */\n\tfromBuffer(inputBuffer)\n\t{\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tconst copyBuffer = inputBuffer.slice(0);\n\t\tconst valueView = new Uint8Array(copyBuffer);\n\n\t\tfor(let i = 0; i < valueView.length; i += 4)\n\t\t{\n\t\t\tvalueView[i] = valueView[i + 3];\n\t\t\tvalueView[i + 1] = valueView[i + 2];\n\t\t\tvalueView[i + 2] = 0x00;\n\t\t\tvalueView[i + 3] = 0x00;\n\t\t}\n\n\t\tthis.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting JavaScript string into ASN.1 internal class\n\t * @param {!string} inputString ASN.1 BER encoded array\n\t */\n\tfromString(inputString)\n\t{\n\t\tconst strLength = inputString.length;\n\n\t\tthis.valueBlock.valueHex = new ArrayBuffer(strLength * 4);\n\t\tconst valueHexView = new Uint8Array(this.valueBlock.valueHex);\n\n\t\tfor(let i = 0; i < strLength; i++)\n\t\t{\n\t\t\tconst codeBuf = utilToBase(inputString.charCodeAt(i), 8);\n\t\t\tconst codeView = new Uint8Array(codeBuf);\n\t\t\tif(codeView.length > 4)\n\t\t\t\tcontinue;\n\n\t\t\tconst dif = 4 - codeView.length;\n\n\t\t\tfor(let j = (codeView.length - 1); j >= 0; j--)\n\t\t\t\tvalueHexView[i * 4 + j + dif] = codeView[j];\n\t\t}\n\n\t\tthis.valueBlock.value = inputString;\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\treturn `${this.constructor.blockName()} : ${this.valueBlock.value}`;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nclass LocalSimpleStringValueBlock extends HexBlock(LocalBaseBlock)\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalSimpleStringValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.value = \"\";\n\t\tthis.isHexOnly = true;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"SimpleStringValueBlock\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.value = this.value;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends BaseBlock\n */\nclass LocalSimpleStringBlock extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalSimpleStringBlock\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalSimpleStringValueBlock);\n\n\t\tif(\"value\" in parameters)\n\t\t\tthis.fromString(parameters.value);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"SIMPLESTRING\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\n\t\tif(resultOffset === (-1))\n\t\t{\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\tif(this.idBlock.error.length === 0)\n\t\t\tthis.blockLength += this.idBlock.blockLength;\n\n\t\tif(this.lenBlock.error.length === 0)\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\n\n\t\tif(this.valueBlock.error.length === 0)\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting ArrayBuffer into ASN.1 internal string\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t */\n\tfromBuffer(inputBuffer)\n\t{\n\t\tthis.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting JavaScript string into ASN.1 internal class\n\t * @param {!string} inputString ASN.1 BER encoded array\n\t */\n\tfromString(inputString)\n\t{\n\t\tconst strLen = inputString.length;\n\n\t\tthis.valueBlock.valueHex = new ArrayBuffer(strLen);\n\t\tconst view = new Uint8Array(this.valueBlock.valueHex);\n\n\t\tfor(let i = 0; i < strLen; i++)\n\t\t\tview[i] = inputString.charCodeAt(i);\n\n\t\tthis.valueBlock.value = inputString;\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\treturn `${this.constructor.blockName()} : ${this.valueBlock.value}`;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends LocalSimpleStringBlock\n */\nexport class NumericString extends LocalSimpleStringBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"NumericString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 18; // NumericString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"NumericString\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends LocalSimpleStringBlock\n */\nexport class PrintableString extends LocalSimpleStringBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"PrintableString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 19; // PrintableString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"PrintableString\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends LocalSimpleStringBlock\n */\nexport class TeletexString extends LocalSimpleStringBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"TeletexString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 20; // TeletexString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"TeletexString\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends LocalSimpleStringBlock\n */\nexport class VideotexString extends LocalSimpleStringBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"VideotexString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 21; // VideotexString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"VideotexString\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends LocalSimpleStringBlock\n */\nexport class IA5String extends LocalSimpleStringBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"IA5String\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 22; // IA5String\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"IA5String\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends LocalSimpleStringBlock\n */\nexport class GraphicString extends LocalSimpleStringBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"GraphicString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 25; // GraphicString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"GraphicString\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends LocalSimpleStringBlock\n */\nexport class VisibleString extends LocalSimpleStringBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"VisibleString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 26; // VisibleString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"VisibleString\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends LocalSimpleStringBlock\n */\nexport class GeneralString extends LocalSimpleStringBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"GeneralString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 27; // GeneralString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"GeneralString\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends LocalSimpleStringBlock\n */\nexport class CharacterString extends LocalSimpleStringBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"CharacterString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 29; // CharacterString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"CharacterString\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of all date and time classes\n//**************************************************************************************\n/**\n * @extends VisibleString\n */\nexport class UTCTime extends VisibleString\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"UTCTime\" class\n\t * @param {Object} [parameters={}]\n\t * @property {string} [value] String representatio of the date\n\t * @property {Date} [valueDate] JavaScript \"Date\" object\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.year = 0;\n\t\tthis.month = 0;\n\t\tthis.day = 0;\n\t\tthis.hour = 0;\n\t\tthis.minute = 0;\n\t\tthis.second = 0;\n\n\t\t//region Create UTCTime from ASN.1 UTC string value\n\t\tif(\"value\" in parameters)\n\t\t{\n\t\t\tthis.fromString(parameters.value);\n\n\t\t\tthis.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);\n\t\t\tconst view = new Uint8Array(this.valueBlock.valueHex);\n\n\t\t\tfor(let i = 0; i < parameters.value.length; i++)\n\t\t\t\tview[i] = parameters.value.charCodeAt(i);\n\t\t}\n\t\t//endregion\n\t\t//region Create GeneralizedTime from JavaScript Date type\n\t\tif(\"valueDate\" in parameters)\n\t\t{\n\t\t\tthis.fromDate(parameters.valueDate);\n\t\t\tthis.valueBlock.valueHex = this.toBuffer();\n\t\t}\n\t\t//endregion\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 23; // UTCTime\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\n\t\tif(resultOffset === (-1))\n\t\t{\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\tif(this.idBlock.error.length === 0)\n\t\t\tthis.blockLength += this.idBlock.blockLength;\n\n\t\tif(this.lenBlock.error.length === 0)\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\n\n\t\tif(this.valueBlock.error.length === 0)\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting ArrayBuffer into ASN.1 internal string\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t */\n\tfromBuffer(inputBuffer)\n\t{\n\t\tthis.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting ASN.1 internal string into ArrayBuffer\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBuffer()\n\t{\n\t\tconst str = this.toString();\n\n\t\tconst buffer = new ArrayBuffer(str.length);\n\t\tconst view = new Uint8Array(buffer);\n\n\t\tfor(let i = 0; i < str.length; i++)\n\t\t\tview[i] = str.charCodeAt(i);\n\n\t\treturn buffer;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting \"Date\" object into ASN.1 internal string\n\t * @param {!Date} inputDate JavaScript \"Date\" object\n\t */\n\tfromDate(inputDate)\n\t{\n\t\tthis.year = inputDate.getUTCFullYear();\n\t\tthis.month = inputDate.getUTCMonth() + 1;\n\t\tthis.day = inputDate.getUTCDate();\n\t\tthis.hour = inputDate.getUTCHours();\n\t\tthis.minute = inputDate.getUTCMinutes();\n\t\tthis.second = inputDate.getUTCSeconds();\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Function converting ASN.1 internal string into \"Date\" object\n\t * @returns {Date}\n\t */\n\ttoDate()\n\t{\n\t\treturn (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second)));\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting JavaScript string into ASN.1 internal class\n\t * @param {!string} inputString ASN.1 BER encoded array\n\t */\n\tfromString(inputString)\n\t{\n\t\t//region Parse input string\n\t\tconst parser = /(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z/ig;\n\t\tconst parserArray = parser.exec(inputString);\n\t\tif(parserArray === null)\n\t\t{\n\t\t\tthis.error = \"Wrong input string for convertion\";\n\t\t\treturn;\n\t\t}\n\t\t//endregion\n\n\t\t//region Store parsed values\n\t\tconst year = parseInt(parserArray[1], 10);\n\t\tif(year >= 50)\n\t\t\tthis.year = 1900 + year;\n\t\telse\n\t\t\tthis.year = 2000 + year;\n\n\t\tthis.month = parseInt(parserArray[2], 10);\n\t\tthis.day = parseInt(parserArray[3], 10);\n\t\tthis.hour = parseInt(parserArray[4], 10);\n\t\tthis.minute = parseInt(parserArray[5], 10);\n\t\tthis.second = parseInt(parserArray[6], 10);\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting ASN.1 internal class into JavaScript string\n\t * @returns {string}\n\t */\n\ttoString()\n\t{\n\t\tconst outputArray = new Array(7);\n\n\t\toutputArray[0] = padNumber(((this.year < 2000) ? (this.year - 1900) : (this.year - 2000)), 2);\n\t\toutputArray[1] = padNumber(this.month, 2);\n\t\toutputArray[2] = padNumber(this.day, 2);\n\t\toutputArray[3] = padNumber(this.hour, 2);\n\t\toutputArray[4] = padNumber(this.minute, 2);\n\t\toutputArray[5] = padNumber(this.second, 2);\n\t\toutputArray[6] = \"Z\";\n\n\t\treturn outputArray.join(\"\");\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"UTCTime\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.year = this.year;\n\t\tobject.month = this.month;\n\t\tobject.day = this.day;\n\t\tobject.hour = this.hour;\n\t\tobject.minute = this.minute;\n\t\tobject.second = this.second;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends VisibleString\n */\nexport class GeneralizedTime extends VisibleString\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"GeneralizedTime\" class\n\t * @param {Object} [parameters={}]\n\t * @property {string} [value] String representatio of the date\n\t * @property {Date} [valueDate] JavaScript \"Date\" object\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.year = 0;\n\t\tthis.month = 0;\n\t\tthis.day = 0;\n\t\tthis.hour = 0;\n\t\tthis.minute = 0;\n\t\tthis.second = 0;\n\t\tthis.millisecond = 0;\n\n\t\t//region Create UTCTime from ASN.1 UTC string value\n\t\tif(\"value\" in parameters)\n\t\t{\n\t\t\tthis.fromString(parameters.value);\n\n\t\t\tthis.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);\n\t\t\tconst view = new Uint8Array(this.valueBlock.valueHex);\n\n\t\t\tfor(let i = 0; i < parameters.value.length; i++)\n\t\t\t\tview[i] = parameters.value.charCodeAt(i);\n\t\t}\n\t\t//endregion\n\t\t//region Create GeneralizedTime from JavaScript Date type\n\t\tif(\"valueDate\" in parameters)\n\t\t{\n\t\t\tthis.fromDate(parameters.valueDate);\n\t\t\tthis.valueBlock.valueHex = this.toBuffer();\n\t\t}\n\t\t//endregion\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 24; // GeneralizedTime\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\n\t\tif(resultOffset === (-1))\n\t\t{\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\tif(this.idBlock.error.length === 0)\n\t\t\tthis.blockLength += this.idBlock.blockLength;\n\n\t\tif(this.lenBlock.error.length === 0)\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\n\n\t\tif(this.valueBlock.error.length === 0)\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting ArrayBuffer into ASN.1 internal string\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t */\n\tfromBuffer(inputBuffer)\n\t{\n\t\tthis.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting ASN.1 internal string into ArrayBuffer\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBuffer()\n\t{\n\t\tconst str = this.toString();\n\n\t\tconst buffer = new ArrayBuffer(str.length);\n\t\tconst view = new Uint8Array(buffer);\n\n\t\tfor(let i = 0; i < str.length; i++)\n\t\t\tview[i] = str.charCodeAt(i);\n\n\t\treturn buffer;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting \"Date\" object into ASN.1 internal string\n\t * @param {!Date} inputDate JavaScript \"Date\" object\n\t */\n\tfromDate(inputDate)\n\t{\n\t\tthis.year = inputDate.getUTCFullYear();\n\t\tthis.month = inputDate.getUTCMonth() + 1;\n\t\tthis.day = inputDate.getUTCDate();\n\t\tthis.hour = inputDate.getUTCHours();\n\t\tthis.minute = inputDate.getUTCMinutes();\n\t\tthis.second = inputDate.getUTCSeconds();\n\t\tthis.millisecond = inputDate.getUTCMilliseconds();\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Function converting ASN.1 internal string into \"Date\" object\n\t * @returns {Date}\n\t */\n\ttoDate()\n\t{\n\t\treturn (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)));\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting JavaScript string into ASN.1 internal class\n\t * @param {!string} inputString ASN.1 BER encoded array\n\t */\n\tfromString(inputString)\n\t{\n\t\t//region Initial variables\n\t\tlet isUTC = false;\n\n\t\tlet timeString = \"\";\n\t\tlet dateTimeString = \"\";\n\t\tlet fractionPart = 0;\n\n\t\tlet parser;\n\n\t\tlet hourDifference = 0;\n\t\tlet minuteDifference = 0;\n\t\t//endregion\n\n\t\t//region Convert as UTC time\n\t\tif(inputString[inputString.length - 1] === \"Z\")\n\t\t{\n\t\t\ttimeString = inputString.substr(0, inputString.length - 1);\n\n\t\t\tisUTC = true;\n\t\t}\n\t\t//endregion\n\t\t//region Convert as local time\n\t\telse\n\t\t{\n\t\t\t//noinspection JSPrimitiveTypeWrapperUsage\n\t\t\tconst number = new Number(inputString[inputString.length - 1]);\n\n\t\t\tif(isNaN(number.valueOf()))\n\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\n\t\t\ttimeString = inputString;\n\t\t}\n\t\t//endregion\n\n\t\t//region Check that we do not have a \"+\" and \"-\" symbols inside UTC time\n\t\tif(isUTC)\n\t\t{\n\t\t\tif(timeString.indexOf(\"+\") !== (-1))\n\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\n\t\t\tif(timeString.indexOf(\"-\") !== (-1))\n\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\t\t}\n\t\t//endregion\n\t\t//region Get \"UTC time difference\" in case of local time\n\t\telse\n\t\t{\n\t\t\tlet multiplier = 1;\n\t\t\tlet differencePosition = timeString.indexOf(\"+\");\n\t\t\tlet differenceString = \"\";\n\n\t\t\tif(differencePosition === (-1))\n\t\t\t{\n\t\t\t\tdifferencePosition = timeString.indexOf(\"-\");\n\t\t\t\tmultiplier = (-1);\n\t\t\t}\n\n\t\t\tif(differencePosition !== (-1))\n\t\t\t{\n\t\t\t\tdifferenceString = timeString.substr(differencePosition + 1);\n\t\t\t\ttimeString = timeString.substr(0, differencePosition);\n\n\t\t\t\tif((differenceString.length !== 2) && (differenceString.length !== 4))\n\t\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\n\t\t\t\t//noinspection JSPrimitiveTypeWrapperUsage\n\t\t\t\tlet number = new Number(differenceString.substr(0, 2));\n\n\t\t\t\tif(isNaN(number.valueOf()))\n\t\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\n\t\t\t\thourDifference = multiplier * number;\n\n\t\t\t\tif(differenceString.length === 4)\n\t\t\t\t{\n\t\t\t\t\t//noinspection JSPrimitiveTypeWrapperUsage\n\t\t\t\t\tnumber = new Number(differenceString.substr(2, 2));\n\n\t\t\t\t\tif(isNaN(number.valueOf()))\n\t\t\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\n\t\t\t\t\tminuteDifference = multiplier * number;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//endregion\n\n\t\t//region Get position of fraction point\n\t\tlet fractionPointPosition = timeString.indexOf(\".\"); // Check for \"full stop\" symbol\n\t\tif(fractionPointPosition === (-1))\n\t\t\tfractionPointPosition = timeString.indexOf(\",\"); // Check for \"comma\" symbol\n\t\t//endregion\n\n\t\t//region Get fraction part\n\t\tif(fractionPointPosition !== (-1))\n\t\t{\n\t\t\t//noinspection JSPrimitiveTypeWrapperUsage\n\t\t\tconst fractionPartCheck = new Number(`0${timeString.substr(fractionPointPosition)}`);\n\n\t\t\tif(isNaN(fractionPartCheck.valueOf()))\n\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\n\t\t\tfractionPart = fractionPartCheck.valueOf();\n\n\t\t\tdateTimeString = timeString.substr(0, fractionPointPosition);\n\t\t}\n\t\telse\n\t\t\tdateTimeString = timeString;\n\t\t//endregion\n\n\t\t//region Parse internal date\n\t\tswitch(true)\n\t\t{\n\t\t\tcase (dateTimeString.length === 8): // \"YYYYMMDD\"\n\t\t\t\tparser = /(\\d{4})(\\d{2})(\\d{2})/ig;\n\t\t\t\tif(fractionPointPosition !== (-1))\n\t\t\t\t\tthrow new Error(\"Wrong input string for convertion\"); // Here we should not have a \"fraction point\"\n\t\t\t\tbreak;\n\t\t\tcase (dateTimeString.length === 10): // \"YYYYMMDDHH\"\n\t\t\t\tparser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n\t\t\t\tif(fractionPointPosition !== (-1))\n\t\t\t\t{\n\t\t\t\t\tlet fractionResult = 60 * fractionPart;\n\t\t\t\t\tthis.minute = Math.floor(fractionResult);\n\n\t\t\t\t\tfractionResult = 60 * (fractionResult - this.minute);\n\t\t\t\t\tthis.second = Math.floor(fractionResult);\n\n\t\t\t\t\tfractionResult = 1000 * (fractionResult - this.second);\n\t\t\t\t\tthis.millisecond = Math.floor(fractionResult);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase (dateTimeString.length === 12): // \"YYYYMMDDHHMM\"\n\t\t\t\tparser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n\t\t\t\tif(fractionPointPosition !== (-1))\n\t\t\t\t{\n\t\t\t\t\tlet fractionResult = 60 * fractionPart;\n\t\t\t\t\tthis.second = Math.floor(fractionResult);\n\n\t\t\t\t\tfractionResult = 1000 * (fractionResult - this.second);\n\t\t\t\t\tthis.millisecond = Math.floor(fractionResult);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase (dateTimeString.length === 14): // \"YYYYMMDDHHMMSS\"\n\t\t\t\tparser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n\t\t\t\tif(fractionPointPosition !== (-1))\n\t\t\t\t{\n\t\t\t\t\tconst fractionResult = 1000 * fractionPart;\n\t\t\t\t\tthis.millisecond = Math.floor(fractionResult);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\t\t}\n\t\t//endregion\n\n\t\t//region Put parsed values at right places\n\t\tconst parserArray = parser.exec(dateTimeString);\n\t\tif(parserArray === null)\n\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\n\t\tfor(let j = 1; j < parserArray.length; j++)\n\t\t{\n\t\t\tswitch(j)\n\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\tthis.year = parseInt(parserArray[j], 10);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tthis.month = parseInt(parserArray[j], 10);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tthis.day = parseInt(parserArray[j], 10);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tthis.hour = parseInt(parserArray[j], 10) + hourDifference;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tthis.minute = parseInt(parserArray[j], 10) + minuteDifference;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tthis.second = parseInt(parserArray[j], 10);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\t\t\t}\n\t\t}\n\t\t//endregion\n\n\t\t//region Get final date\n\t\tif(isUTC === false)\n\t\t{\n\t\t\tconst tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\n\n\t\t\tthis.year = tempDate.getUTCFullYear();\n\t\t\tthis.month = tempDate.getUTCMonth();\n\t\t\tthis.day = tempDate.getUTCDay();\n\t\t\tthis.hour = tempDate.getUTCHours();\n\t\t\tthis.minute = tempDate.getUTCMinutes();\n\t\t\tthis.second = tempDate.getUTCSeconds();\n\t\t\tthis.millisecond = tempDate.getUTCMilliseconds();\n\t\t}\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting ASN.1 internal class into JavaScript string\n\t * @returns {string}\n\t */\n\ttoString()\n\t{\n\t\tconst outputArray = [];\n\n\t\toutputArray.push(padNumber(this.year, 4));\n\t\toutputArray.push(padNumber(this.month, 2));\n\t\toutputArray.push(padNumber(this.day, 2));\n\t\toutputArray.push(padNumber(this.hour, 2));\n\t\toutputArray.push(padNumber(this.minute, 2));\n\t\toutputArray.push(padNumber(this.second, 2));\n\t\tif(this.millisecond !== 0)\n\t\t{\n\t\t\toutputArray.push(\".\");\n\t\t\toutputArray.push(padNumber(this.millisecond, 3));\n\t\t}\n\t\toutputArray.push(\"Z\");\n\n\t\treturn outputArray.join(\"\");\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"GeneralizedTime\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.year = this.year;\n\t\tobject.month = this.month;\n\t\tobject.day = this.day;\n\t\tobject.hour = this.hour;\n\t\tobject.minute = this.minute;\n\t\tobject.second = this.second;\n\t\tobject.millisecond = this.millisecond;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends Utf8String\n */\nexport class DATE extends Utf8String\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"DATE\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 31; // DATE\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"DATE\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends Utf8String\n */\nexport class TimeOfDay extends Utf8String\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"TimeOfDay\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 32; // TimeOfDay\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"TimeOfDay\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends Utf8String\n */\nexport class DateTime extends Utf8String\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"DateTime\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 33; // DateTime\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"DateTime\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends Utf8String\n */\nexport class Duration extends Utf8String\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Duration\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 34; // Duration\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"Duration\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends Utf8String\n */\nexport class TIME extends Utf8String\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Time\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 14; // Time\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"TIME\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Choice\n//**************************************************************************************\nexport class Choice\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Choice\" class\n\t * @param {Object} [parameters={}]\n\t * @property {Array} [value] Array of ASN.1 types for make a choice from\n\t * @property {boolean} [optional]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tthis.value = getParametersValue(parameters, \"value\", []);\n\t\tthis.optional = getParametersValue(parameters, \"optional\", false);\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Any\n//**************************************************************************************\nexport class Any\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Any\" class\n\t * @param {Object} [parameters={}]\n\t * @property {string} [name]\n\t * @property {boolean} [optional]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tthis.name = getParametersValue(parameters, \"name\", \"\");\n\t\tthis.optional = getParametersValue(parameters, \"optional\", false);\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Repeated\n//**************************************************************************************\nexport class Repeated\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Repeated\" class\n\t * @param {Object} [parameters={}]\n\t * @property {string} [name]\n\t * @property {boolean} [optional]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tthis.name = getParametersValue(parameters, \"name\", \"\");\n\t\tthis.optional = getParametersValue(parameters, \"optional\", false);\n\t\tthis.value = getParametersValue(parameters, \"value\", new Any());\n\t\tthis.local = getParametersValue(parameters, \"local\", false); // Could local or global array to store elements\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type RawData\n//**************************************************************************************\n/**\n * @description Special class providing ability to have \"toBER/fromBER\" for raw ArrayBuffer\n */\nexport class RawData\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Repeated\" class\n\t * @param {Object} [parameters={}]\n\t * @property {string} [name]\n\t * @property {boolean} [optional]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tthis.data = getParametersValue(parameters, \"data\", new ArrayBuffer(0));\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tthis.data = inputBuffer.slice(inputOffset, inputLength);\n\t\treturn (inputOffset + inputLength);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\treturn this.data;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major ASN.1 BER decoding function\n//**************************************************************************************\n/**\n * Internal library function for decoding ASN.1 BER\n * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n * @returns {{offset: number, result: Object}}\n */\nfunction LocalFromBER(inputBuffer, inputOffset, inputLength)\n{\n\tconst incomingOffset = inputOffset; // Need to store initial offset since \"inputOffset\" is changing in the function\n\n\t//region Local function changing a type for ASN.1 classes\n\tfunction localChangeType(inputObject, newType)\n\t{\n\t\tif(inputObject instanceof newType)\n\t\t\treturn inputObject;\n\n\t\tconst newObject = new newType();\n\t\tnewObject.idBlock = inputObject.idBlock;\n\t\tnewObject.lenBlock = inputObject.lenBlock;\n\t\tnewObject.warnings = inputObject.warnings;\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tnewObject.valueBeforeDecode = inputObject.valueBeforeDecode.slice(0);\n\n\t\treturn newObject;\n\t}\n\t//endregion\n\n\t//region Create a basic ASN.1 type since we need to return errors and warnings from the function\n\tlet returnObject = new BaseBlock({}, Object);\n\t//endregion\n\n\t//region Basic check for parameters\n\tconst baseBlock = new LocalBaseBlock();\n\tif(checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) === false)\n\t{\n\t\treturnObject.error = baseBlock.error;\n\t\treturn {\n\t\t\toffset: (-1),\n\t\t\tresult: returnObject\n\t\t};\n\t}\n\t//endregion\n\n\t//region Getting Uint8Array from ArrayBuffer\n\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t//endregion\n\n\t//region Initial checks\n\tif(intBuffer.length === 0)\n\t{\n\t\treturnObject.error = \"Zero buffer length\";\n\t\treturn {\n\t\t\toffset: (-1),\n\t\t\tresult: returnObject\n\t\t};\n\t}\n\t//endregion\n\n\t//region Decode indentifcation block of ASN.1 BER structure\n\tlet resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);\n\treturnObject.warnings.concat(returnObject.idBlock.warnings);\n\tif(resultOffset === (-1))\n\t{\n\t\treturnObject.error = returnObject.idBlock.error;\n\t\treturn {\n\t\t\toffset: (-1),\n\t\t\tresult: returnObject\n\t\t};\n\t}\n\n\tinputOffset = resultOffset;\n\tinputLength -= returnObject.idBlock.blockLength;\n\t//endregion\n\n\t//region Decode length block of ASN.1 BER structure\n\tresultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);\n\treturnObject.warnings.concat(returnObject.lenBlock.warnings);\n\tif(resultOffset === (-1))\n\t{\n\t\treturnObject.error = returnObject.lenBlock.error;\n\t\treturn {\n\t\t\toffset: (-1),\n\t\t\tresult: returnObject\n\t\t};\n\t}\n\n\tinputOffset = resultOffset;\n\tinputLength -= returnObject.lenBlock.blockLength;\n\t//endregion\n\n\t//region Check for usign indefinite length form in encoding for primitive types\n\tif((returnObject.idBlock.isConstructed === false) &&\n\t\t(returnObject.lenBlock.isIndefiniteForm === true))\n\t{\n\t\treturnObject.error = \"Indefinite length form used for primitive encoding form\";\n\t\treturn {\n\t\t\toffset: (-1),\n\t\t\tresult: returnObject\n\t\t};\n\t}\n\t//endregion\n\n\t//region Switch ASN.1 block type\n\tlet newASN1Type = BaseBlock;\n\n\tswitch(returnObject.idBlock.tagClass)\n\t{\n\t\t//region UNIVERSAL\n\t\tcase 1:\n\t\t\t//region Check for reserved tag numbers\n\t\t\tif((returnObject.idBlock.tagNumber >= 37) &&\n\t\t\t\t(returnObject.idBlock.isHexOnly === false))\n\t\t\t{\n\t\t\t\treturnObject.error = \"UNIVERSAL 37 and upper tags are reserved by ASN.1 standard\";\n\t\t\t\treturn {\n\t\t\t\t\toffset: (-1),\n\t\t\t\t\tresult: returnObject\n\t\t\t\t};\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\tswitch(returnObject.idBlock.tagNumber)\n\t\t\t{\n\t\t\t\t//region EndOfContent type\n\t\t\t\tcase 0:\n\t\t\t\t\t//region Check for EndOfContent type\n\t\t\t\t\tif((returnObject.idBlock.isConstructed === true) &&\n\t\t\t\t\t\t(returnObject.lenBlock.length > 0))\n\t\t\t\t\t{\n\t\t\t\t\t\treturnObject.error = \"Type [UNIVERSAL 0] is reserved\";\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\toffset: (-1),\n\t\t\t\t\t\t\tresult: returnObject\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\t//endregion\n\n\t\t\t\t\tnewASN1Type = EndOfContent;\n\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Boolean type\n\t\t\t\tcase 1:\n\t\t\t\t\tnewASN1Type = Boolean;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Integer type\n\t\t\t\tcase 2:\n\t\t\t\t\tnewASN1Type = Integer;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region BitString type\n\t\t\t\tcase 3:\n\t\t\t\t\tnewASN1Type = BitString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region OctetString type\n\t\t\t\tcase 4:\n\t\t\t\t\tnewASN1Type = OctetString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Null type\n\t\t\t\tcase 5:\n\t\t\t\t\tnewASN1Type = Null;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region OBJECT IDENTIFIER type\n\t\t\t\tcase 6:\n\t\t\t\t\tnewASN1Type = ObjectIdentifier;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Enumerated type\n\t\t\t\tcase 10:\n\t\t\t\t\tnewASN1Type = Enumerated;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Utf8String type\n\t\t\t\tcase 12:\n\t\t\t\t\tnewASN1Type = Utf8String;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Time type\n\t\t\t\t//region RELATIVE OBJECT IDENTIFIER type\n\t\t\t\tcase 13:\n\t\t\t\t\tnewASN1Type = RelativeObjectIdentifier;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\tcase 14:\n\t\t\t\t\tnewASN1Type = TIME;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region ASN.1 reserved type\n\t\t\t\tcase 15:\n\t\t\t\t\treturnObject.error = \"[UNIVERSAL 15] is reserved by ASN.1 standard\";\n\t\t\t\t\treturn {\n\t\t\t\t\t\toffset: (-1),\n\t\t\t\t\t\tresult: returnObject\n\t\t\t\t\t};\n\t\t\t\t//endregion\n\t\t\t\t//region Sequence type\n\t\t\t\tcase 16:\n\t\t\t\t\tnewASN1Type = Sequence;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Set type\n\t\t\t\tcase 17:\n\t\t\t\t\tnewASN1Type = Set;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region NumericString type\n\t\t\t\tcase 18:\n\t\t\t\t\tnewASN1Type = NumericString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region PrintableString type\n\t\t\t\tcase 19:\n\t\t\t\t\tnewASN1Type = PrintableString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region TeletexString type\n\t\t\t\tcase 20:\n\t\t\t\t\tnewASN1Type = TeletexString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region VideotexString type\n\t\t\t\tcase 21:\n\t\t\t\t\tnewASN1Type = VideotexString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region IA5String type\n\t\t\t\tcase 22:\n\t\t\t\t\tnewASN1Type = IA5String;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region UTCTime type\n\t\t\t\tcase 23:\n\t\t\t\t\tnewASN1Type = UTCTime;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region GeneralizedTime type\n\t\t\t\tcase 24:\n\t\t\t\t\tnewASN1Type = GeneralizedTime;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region GraphicString type\n\t\t\t\tcase 25:\n\t\t\t\t\tnewASN1Type = GraphicString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region VisibleString type\n\t\t\t\tcase 26:\n\t\t\t\t\tnewASN1Type = VisibleString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region GeneralString type\n\t\t\t\tcase 27:\n\t\t\t\t\tnewASN1Type = GeneralString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region UniversalString type\n\t\t\t\tcase 28:\n\t\t\t\t\tnewASN1Type = UniversalString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region CharacterString type\n\t\t\t\tcase 29:\n\t\t\t\t\tnewASN1Type = CharacterString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region BmpString type\n\t\t\t\tcase 30:\n\t\t\t\t\tnewASN1Type = BmpString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region DATE type\n\t\t\t\tcase 31:\n\t\t\t\t\tnewASN1Type = DATE;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region TimeOfDay type\n\t\t\t\tcase 32:\n\t\t\t\t\tnewASN1Type = TimeOfDay;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Date-Time type\n\t\t\t\tcase 33:\n\t\t\t\t\tnewASN1Type = DateTime;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Duration type\n\t\t\t\tcase 34:\n\t\t\t\t\tnewASN1Type = Duration;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region default\n\t\t\t\tdefault:\n\t\t\t\t\t{\n\t\t\t\t\t\tlet newObject;\n\n\t\t\t\t\t\tif(returnObject.idBlock.isConstructed === true)\n\t\t\t\t\t\t\tnewObject = new Constructed();\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnewObject = new Primitive();\n\n\t\t\t\t\t\tnewObject.idBlock = returnObject.idBlock;\n\t\t\t\t\t\tnewObject.lenBlock = returnObject.lenBlock;\n\t\t\t\t\t\tnewObject.warnings = returnObject.warnings;\n\n\t\t\t\t\t\treturnObject = newObject;\n\t\t\t\t\t}\n\t\t\t\t//endregion\n\t\t\t}\n\t\t\tbreak;\n\t\t//endregion\n\t\t//region All other tag classes\n\t\tcase 2: // APPLICATION\n\t\tcase 3: // CONTEXT-SPECIFIC\n\t\tcase 4: // PRIVATE\n\t\tdefault:\n\t\t\t{\n\t\t\t\tif(returnObject.idBlock.isConstructed === true)\n\t\t\t\t\tnewASN1Type = Constructed;\n\t\t\t\telse\n\t\t\t\t\tnewASN1Type = Primitive;\n\t\t\t}\n\t\t//endregion\n\t}\n\t//endregion\n\n\t//region Change type and perform BER decoding\n\treturnObject = localChangeType(returnObject, newASN1Type);\n\tresultOffset = returnObject.fromBER(inputBuffer, inputOffset, (returnObject.lenBlock.isIndefiniteForm === true) ? inputLength : returnObject.lenBlock.length);\n\t//endregion\n\n\t//region Coping incoming buffer for entire ASN.1 block\n\treturnObject.valueBeforeDecode = inputBuffer.slice(incomingOffset, incomingOffset + returnObject.blockLength);\n\t//endregion\n\n\treturn {\n\t\toffset: resultOffset,\n\t\tresult: returnObject\n\t};\n}\n//**************************************************************************************\n/**\n * Major function for decoding ASN.1 BER array into internal library structuries\n * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array of bytes\n */\nexport function fromBER(inputBuffer)\n{\n\tif(inputBuffer.byteLength === 0)\n\t{\n\t\tconst result = new BaseBlock({}, Object);\n\t\tresult.error = \"Input buffer has zero length\";\n\n\t\treturn {\n\t\t\toffset: (-1),\n\t\t\tresult\n\t\t};\n\t}\n\n\treturn LocalFromBER(inputBuffer, 0, inputBuffer.byteLength);\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major scheme verification function\n//**************************************************************************************\n/**\n * Compare of two ASN.1 object trees\n * @param {!Object} root Root of input ASN.1 object tree\n * @param {!Object} inputData Input ASN.1 object tree\n * @param {!Object} inputSchema Input ASN.1 schema to compare with\n * @return {{verified: boolean}|{verified:boolean, result: Object}}\n */\nexport function compareSchema(root, inputData, inputSchema)\n{\n\t//region Special case for Choice schema element type\n\tif(inputSchema instanceof Choice)\n\t{\n\t\tconst choiceResult = false;\n\n\t\tfor(let j = 0; j < inputSchema.value.length; j++)\n\t\t{\n\t\t\tconst result = compareSchema(root, inputData, inputSchema.value[j]);\n\t\t\tif(result.verified === true)\n\t\t\t{\n\t\t\t\treturn {\n\t\t\t\t\tverified: true,\n\t\t\t\t\tresult: root\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif(choiceResult === false)\n\t\t{\n\t\t\tconst _result = {\n\t\t\t\tverified: false,\n\t\t\t\tresult: {\n\t\t\t\t\terror: \"Wrong values for Choice type\"\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif(inputSchema.hasOwnProperty(\"name\"))\n\t\t\t\t_result.name = inputSchema.name;\n\n\t\t\treturn _result;\n\t\t}\n\t}\n\t//endregion\n\n\t//region Special case for Any schema element type\n\tif(inputSchema instanceof Any)\n\t{\n\t\t//region Add named component of ASN.1 schema\n\t\tif(inputSchema.hasOwnProperty(\"name\"))\n\t\t\troot[inputSchema.name] = inputData;\n\t\t//endregion\n\n\t\treturn {\n\t\t\tverified: true,\n\t\t\tresult: root\n\t\t};\n\t}\n\t//endregion\n\n\t//region Initial check\n\tif((root instanceof Object) === false)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong root object\" }\n\t\t};\n\t}\n\n\tif((inputData instanceof Object) === false)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 data\" }\n\t\t};\n\t}\n\n\tif((inputSchema instanceof Object) === false)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t};\n\t}\n\n\tif((\"idBlock\" in inputSchema) === false)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t};\n\t}\n\t//endregion\n\n\t//region Comparing idBlock properties in ASN.1 data and ASN.1 schema\n\t//region Encode and decode ASN.1 schema idBlock\n\t/// <remarks>This encoding/decoding is neccessary because could be an errors in schema definition</remarks>\n\tif((\"fromBER\" in inputSchema.idBlock) === false)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t};\n\t}\n\n\tif((\"toBER\" in inputSchema.idBlock) === false)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t};\n\t}\n\n\tconst encodedId = inputSchema.idBlock.toBER(false);\n\tif(encodedId.byteLength === 0)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Error encoding idBlock for ASN.1 schema\" }\n\t\t};\n\t}\n\n\tconst decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);\n\tif(decodedOffset === (-1))\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Error decoding idBlock for ASN.1 schema\" }\n\t\t};\n\t}\n\t//endregion\n\n\t//region tagClass\n\tif(inputSchema.idBlock.hasOwnProperty(\"tagClass\") === false)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t};\n\t}\n\n\tif(inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: root\n\t\t};\n\t}\n\t//endregion\n\t//region tagNumber\n\tif(inputSchema.idBlock.hasOwnProperty(\"tagNumber\") === false)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t};\n\t}\n\n\tif(inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: root\n\t\t};\n\t}\n\t//endregion\n\t//region isConstructed\n\tif(inputSchema.idBlock.hasOwnProperty(\"isConstructed\") === false)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t};\n\t}\n\n\tif(inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: root\n\t\t};\n\t}\n\t//endregion\n\t//region isHexOnly\n\tif((\"isHexOnly\" in inputSchema.idBlock) === false) // Since 'isHexOnly' is an inhirited property\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t};\n\t}\n\n\tif(inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: root\n\t\t};\n\t}\n\t//endregion\n\t//region valueHex\n\tif(inputSchema.idBlock.isHexOnly === true)\n\t{\n\t\tif((\"valueHex\" in inputSchema.idBlock) === false) // Since 'valueHex' is an inhirited property\n\t\t{\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t\t};\n\t\t}\n\n\t\tconst schemaView = new Uint8Array(inputSchema.idBlock.valueHex);\n\t\tconst asn1View = new Uint8Array(inputData.idBlock.valueHex);\n\n\t\tif(schemaView.length !== asn1View.length)\n\t\t{\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: root\n\t\t\t};\n\t\t}\n\n\t\tfor(let i = 0; i < schemaView.length; i++)\n\t\t{\n\t\t\tif(schemaView[i] !== asn1View[1])\n\t\t\t{\n\t\t\t\treturn {\n\t\t\t\t\tverified: false,\n\t\t\t\t\tresult: root\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\t//endregion\n\t//endregion\n\n\t//region Add named component of ASN.1 schema\n\tif(inputSchema.hasOwnProperty(\"name\"))\n\t{\n\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\tif(inputSchema.name !== \"\")\n\t\t\troot[inputSchema.name] = inputData;\n\t}\n\t//endregion\n\n\t//region Getting next ASN.1 block for comparition\n\tif(inputSchema.idBlock.isConstructed === true)\n\t{\n\t\tlet admission = 0;\n\t\tlet result = { verified: false };\n\n\t\tlet maxLength = inputSchema.valueBlock.value.length;\n\n\t\tif(maxLength > 0)\n\t\t{\n\t\t\tif(inputSchema.valueBlock.value[0] instanceof Repeated)\n\t\t\t\tmaxLength = inputData.valueBlock.value.length;\n\t\t}\n\n\t\t//region Special case when constructive value has no elements\n\t\tif(maxLength === 0)\n\t\t{\n\t\t\treturn {\n\t\t\t\tverified: true,\n\t\t\t\tresult: root\n\t\t\t};\n\t\t}\n\t\t//endregion\n\n\t\t//region Special case when \"inputData\" has no values and \"inputSchema\" has all optional values\n\t\tif((inputData.valueBlock.value.length === 0) &&\n\t\t\t(inputSchema.valueBlock.value.length !== 0))\n\t\t{\n\t\t\tlet _optional = true;\n\n\t\t\tfor(let i = 0; i < inputSchema.valueBlock.value.length; i++)\n\t\t\t\t_optional = _optional && (inputSchema.valueBlock.value[i].optional || false);\n\n\t\t\tif(_optional === true)\n\t\t\t{\n\t\t\t\treturn {\n\t\t\t\t\tverified: true,\n\t\t\t\t\tresult: root\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t//region Delete early added name of block\n\t\t\tif(inputSchema.hasOwnProperty(\"name\"))\n\t\t\t{\n\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\tif(inputSchema.name !== \"\")\n\t\t\t\t\tdelete root[inputSchema.name];\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\troot.error = \"Inconsistent object length\";\n\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: root\n\t\t\t};\n\t\t}\n\t\t//endregion\n\n\t\tfor(let i = 0; i < maxLength; i++)\n\t\t{\n\t\t\t//region Special case when there is an \"optional\" element of ASN.1 schema at the end\n\t\t\tif((i - admission) >= inputData.valueBlock.value.length)\n\t\t\t{\n\t\t\t\tif(inputSchema.valueBlock.value[i].optional === false)\n\t\t\t\t{\n\t\t\t\t\tconst _result = {\n\t\t\t\t\t\tverified: false,\n\t\t\t\t\t\tresult: root\n\t\t\t\t\t};\n\n\t\t\t\t\troot.error = \"Inconsistent length between ASN.1 data and schema\";\n\n\t\t\t\t\t//region Delete early added name of block\n\t\t\t\t\tif(inputSchema.hasOwnProperty(\"name\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\t\t\tif(inputSchema.name !== \"\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdelete root[inputSchema.name];\n\t\t\t\t\t\t\t_result.name = inputSchema.name;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//endregion\n\n\t\t\t\t\treturn _result;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\t\t\telse\n\t\t\t{\n\t\t\t\t//region Special case for Repeated type of ASN.1 schema element\n\t\t\t\tif(inputSchema.valueBlock.value[0] instanceof Repeated)\n\t\t\t\t{\n\t\t\t\t\tresult = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);\n\t\t\t\t\tif(result.verified === false)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(inputSchema.valueBlock.value[0].optional === true)\n\t\t\t\t\t\t\tadmission++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//region Delete early added name of block\n\t\t\t\t\t\t\tif(inputSchema.hasOwnProperty(\"name\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\t\t\t\t\tif(inputSchema.name !== \"\")\n\t\t\t\t\t\t\t\t\tdelete root[inputSchema.name];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//endregion\n\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif((\"name\" in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].name.length > 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tlet arrayRoot = {};\n\n\t\t\t\t\t\tif((\"local\" in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].local === true))\n\t\t\t\t\t\t\tarrayRoot = inputData;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tarrayRoot = root;\n\n\t\t\t\t\t\tif(typeof arrayRoot[inputSchema.valueBlock.value[0].name] === \"undefined\")\n\t\t\t\t\t\t\tarrayRoot[inputSchema.valueBlock.value[0].name] = [];\n\n\t\t\t\t\t\tarrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//endregion\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresult = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);\n\t\t\t\t\tif(result.verified === false)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(inputSchema.valueBlock.value[i].optional === true)\n\t\t\t\t\t\t\tadmission++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//region Delete early added name of block\n\t\t\t\t\t\t\tif(inputSchema.hasOwnProperty(\"name\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\t\t\t\t\tif(inputSchema.name !== \"\")\n\t\t\t\t\t\t\t\t\tdelete root[inputSchema.name];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//endregion\n\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(result.verified === false) // The situation may take place if last element is \"optional\" and verification failed\n\t\t{\n\t\t\tconst _result = {\n\t\t\t\tverified: false,\n\t\t\t\tresult: root\n\t\t\t};\n\n\t\t\t//region Delete early added name of block\n\t\t\tif(inputSchema.hasOwnProperty(\"name\"))\n\t\t\t{\n\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\tif(inputSchema.name !== \"\")\n\t\t\t\t{\n\t\t\t\t\tdelete root[inputSchema.name];\n\t\t\t\t\t_result.name = inputSchema.name;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\treturn _result;\n\t\t}\n\n\t\treturn {\n\t\t\tverified: true,\n\t\t\tresult: root\n\t\t};\n\t}\n\t//endregion\n\t//region Ability to parse internal value for primitive-encoded value (value of OctetString, for example)\n\tif((\"primitiveSchema\" in inputSchema) &&\n\t\t(\"valueHex\" in inputData.valueBlock))\n\t{\n\t\t//region Decoding of raw ASN.1 data\n\t\tconst asn1 = fromBER(inputData.valueBlock.valueHex);\n\t\tif(asn1.offset === (-1))\n\t\t{\n\t\t\tconst _result = {\n\t\t\t\tverified: false,\n\t\t\t\tresult: asn1.result\n\t\t\t};\n\n\t\t\t//region Delete early added name of block\n\t\t\tif(inputSchema.hasOwnProperty(\"name\"))\n\t\t\t{\n\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\tif(inputSchema.name !== \"\")\n\t\t\t\t{\n\t\t\t\t\tdelete root[inputSchema.name];\n\t\t\t\t\t_result.name = inputSchema.name;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\treturn _result;\n\t\t}\n\t\t//endregion\n\n\t\treturn compareSchema(root, asn1.result, inputSchema.primitiveSchema);\n\t}\n\n\treturn {\n\t\tverified: true,\n\t\tresult: root\n\t};\n\t//endregion\n}\n//**************************************************************************************\n//noinspection JSUnusedGlobalSymbols\n/**\n * ASN.1 schema verification for ArrayBuffer data\n * @param {!ArrayBuffer} inputBuffer Input BER-encoded ASN.1 data\n * @param {!Object} inputSchema Input ASN.1 schema to verify against to\n * @return {{verified: boolean}|{verified:boolean, result: Object}}\n */\nexport function verifySchema(inputBuffer, inputSchema)\n{\n\t//region Initial check\n\tif((inputSchema instanceof Object) === false)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema type\" }\n\t\t};\n\t}\n\t//endregion\n\n\t//region Decoding of raw ASN.1 data\n\tconst asn1 = fromBER(inputBuffer);\n\tif(asn1.offset === (-1))\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: asn1.result\n\t\t};\n\t}\n\t//endregion\n\n\t//region Compare ASN.1 struct with input schema\n\treturn compareSchema(asn1.result, asn1.result, inputSchema);\n\t//endregion\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major function converting JSON to ASN.1 objects\n//**************************************************************************************\n//noinspection JSUnusedGlobalSymbols\n/**\n * Converting from JSON to ASN.1 objects\n * @param {string|Object} json JSON string or object to convert to ASN.1 objects\n */\nexport function fromJSON(json)\n{\n\t// TODO Implement\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n"]},"metadata":{},"sourceType":"module"}