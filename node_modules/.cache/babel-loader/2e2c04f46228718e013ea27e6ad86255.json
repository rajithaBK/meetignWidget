{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime-corejs2/regenerator\"));\n\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/json/stringify\"));\n\nvar _now = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/date/now\"));\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/keys\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/toConsumableArray\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/createClass\"));\n\nvar _uniq2 = _interopRequireDefault(require(\"lodash/uniq\"));\n\nvar _loggerProxy = _interopRequireDefault(require(\"../common/logs/logger-proxy\"));\n\nvar _constants = require(\"../constants\");\n\nvar _request = _interopRequireDefault(require(\"./request\"));\n/**\n * @class Reachability\n * @export\n */\n\n\nvar Reachability = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of Reachability.\n   * @param {object} webex\n   * @memberof Reachability\n   */\n  function Reachability(webex) {\n    (0, _classCallCheck2.default)(this, Reachability);\n    this.webex = webex;\n    /**\n     * internal request object for the server\n     * @instance\n     * @type {Array}\n     * @private\n     * @memberof Reachability\n     */\n\n    this.reachabilityRequest = new _request.default(this.webex);\n    /**\n     * internal object of clusters latency results\n     * @instance\n     * @type {object}\n     * @private\n     * @memberof Reachability\n     */\n\n    this.clusterLatencyResults = {};\n  }\n  /**\n   * fetches reachability data\n   * @returns {Object} reachability data\n   * @public\n   * @async\n   * @memberof Reachability\n   */\n\n\n  (0, _createClass2.default)(Reachability, [{\n    key: \"gatherReachability\",\n    value: function () {\n      var _gatherReachability = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {\n        var _window, _window$localStorage;\n\n        var clusters, results;\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.setup(); // Remove stored reachability results to ensure no stale data\n\n                if (!((_window = window) !== null && _window !== void 0 && (_window$localStorage = _window.localStorage) !== null && _window$localStorage !== void 0 && _window$localStorage.removeItem)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                window.localStorage.removeItem(_constants.REACHABILITY.localStorage);\n                _context.next = 7;\n                break;\n\n              case 5:\n                _loggerProxy.default.logger.error('Reachability:index#gatherReachability --> Error in accessing LocalStorage.');\n\n                return _context.abrupt(\"return\", {});\n\n              case 7:\n                _context.prev = 7;\n                _context.next = 10;\n                return this.reachabilityRequest.getClusters();\n\n              case 10:\n                clusters = _context.sent;\n                _context.next = 13;\n                return this.performReachabilityCheck(clusters);\n\n              case 13:\n                results = _context.sent;\n                window.localStorage.setItem(_constants.REACHABILITY.localStorage, (0, _stringify.default)(results));\n                return _context.abrupt(\"return\", results);\n\n              case 18:\n                _context.prev = 18;\n                _context.t0 = _context[\"catch\"](7);\n\n                _loggerProxy.default.logger.error(\"Reachability:index#gatherReachability --> Error in calling getClusters(): \".concat(_context.t0));\n\n                return _context.abrupt(\"return\", {});\n\n              case 22:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[7, 18]]);\n      }));\n\n      function gatherReachability() {\n        return _gatherReachability.apply(this, arguments);\n      }\n\n      return gatherReachability;\n    }()\n    /**\n     * Generate peerConnection config settings\n     * @param {object} cluster\n     * @returns {object} peerConnectionConfig\n     * @private\n     * @memberof Reachability\n     */\n\n  }, {\n    key: \"buildPeerConnectionConfig\",\n    value: function buildPeerConnectionConfig(cluster) {\n      var iceServers = (0, _uniq2.default)([].concat((0, _toConsumableArray2.default)(cluster.udp), (0, _toConsumableArray2.default)(cluster.tcp))).map(function (url) {\n        return {\n          username: '',\n          credential: '',\n          urls: [url]\n        };\n      });\n      return {\n        iceServers: (0, _toConsumableArray2.default)(iceServers),\n        iceCandidatePoolSize: '0',\n        iceTransportPolicy: 'all'\n      };\n    }\n    /**\n     * Creates an RTCPeerConnection\n     * @param {object} cluster\n     * @returns {RTCPeerConnection} peerConnection\n     * @private\n     * @memberof Reachability\n     */\n\n  }, {\n    key: \"createPeerConnection\",\n    value: function createPeerConnection(cluster) {\n      var key = cluster.key,\n          config = cluster.config;\n\n      try {\n        var peerConnection = new window.RTCPeerConnection(config);\n        peerConnection.key = key;\n        return peerConnection;\n      } catch (peerConnectionError) {\n        _loggerProxy.default.logger.log(\"Reachability:index#getLocalSDPForClusters --> Error creating peerConnection: \".concat(peerConnectionError));\n\n        return null;\n      }\n    }\n    /**\n     * Gets total elapsed time\n     * @param {RTCPeerConnection} peerConnection\n     * @returns {Number} Milliseconds\n     * @private\n     * @memberof Reachability\n     */\n\n  }, {\n    key: \"getElapsedTime\",\n    value: function getElapsedTime(peerConnection) {\n      var startTime = peerConnection.begin;\n      delete peerConnection.begin;\n      return (0, _now.default)() - startTime;\n    }\n    /**\n     * creates offer and generates localSDP\n     * @param {object} clusterList cluster List\n     * @returns {Promise} Reachability latency results\n     * @private\n     * @memberof Reachability\n     */\n\n  }, {\n    key: \"getLocalSDPForClusters\",\n    value: function getLocalSDPForClusters(clusterList) {\n      var _this = this;\n\n      var clusters = (0, _toConsumableArray2.default)((0, _keys.default)(clusterList));\n      clusters = clusters.map( /*#__PURE__*/function () {\n        var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(key) {\n          var cluster, config, peerConnection, description;\n          return _regenerator.default.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  cluster = clusterList[key];\n                  config = _this.buildPeerConnectionConfig(cluster);\n                  peerConnection = _this.createPeerConnection({\n                    key: key,\n                    config: config\n                  });\n                  _context2.next = 5;\n                  return peerConnection.createOffer({\n                    offerToReceiveAudio: true\n                  });\n\n                case 5:\n                  description = _context2.sent;\n                  peerConnection.begin = (0, _now.default)();\n                  peerConnection.setLocalDescription(description);\n                  return _context2.abrupt(\"return\", _this.iceGatheringState(peerConnection).catch(function (iceGatheringStateError) {\n                    _loggerProxy.default.logger.log(\"Reachability:index#getLocalSDPForClusters --> Error in getLocalSDP : \".concat(iceGatheringStateError));\n                  }));\n\n                case 9:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      return _promise.default.all(clusters).then(this.parseIceResultsToReachabilityResults).then(function (reachabilityLatencyResults) {\n        _this.logUnreachableClusters(); // return results\n\n\n        return reachabilityLatencyResults;\n      });\n    }\n    /**\n     * Get list of all unreachable clusters\n     * @returns {array} Unreachable clusters\n     * @private\n     * @memberof Reachability\n     */\n\n  }, {\n    key: \"getUnreachablClusters\",\n    value: function getUnreachablClusters() {\n      var unreachableList = [];\n      var clusters = this.clusterLatencyResults;\n      (0, _keys.default)(clusters).forEach(function (key) {\n        var cluster = clusters[key];\n\n        if (cluster.unreachable && !cluster.reachable) {\n          unreachableList.push(key);\n        }\n      });\n      return unreachableList;\n    }\n    /**\n     * Attach an event handler for the icegatheringstatechange\n     * event and measure latency.\n     * @param {RTCPeerConnection} peerConnection\n     * @returns {undefined}\n     * @private\n     * @memberof Reachability\n     */\n\n  }, {\n    key: \"handleIceGatheringStateChange\",\n    value: function handleIceGatheringStateChange(peerConnection) {\n      var _this2 = this;\n\n      peerConnection.onicegatheringstatechange = function () {\n        var COMPLETE = _constants.ICE_GATHERING_STATE.COMPLETE;\n\n        if (peerConnection.iceConnectionState === COMPLETE) {\n          var elapsed = _this2.getElapsedTime(peerConnection);\n\n          _loggerProxy.default.logger.log(\"Reachability:index#onIceGatheringStateChange --> Successfully pinged \".concat(peerConnection.key, \":\"), elapsed);\n\n          _this2.setLatencyAndClose(peerConnection, elapsed);\n        }\n      };\n    }\n    /**\n     * Attach an event handler for the icecandidate\n     * event and measure latency.\n     * @param {RTCPeerConnection} peerConnection\n     * @returns {undefined}\n     * @private\n     * @memberof Reachability\n     */\n\n  }, {\n    key: \"handleOnIceCandidate\",\n    value: function handleOnIceCandidate(peerConnection) {\n      var _this3 = this;\n\n      peerConnection.onicecandidate = function (e) {\n        var SERVER_REFLEXIVE = 'srflx';\n\n        if (e.candidate && String(e.candidate.type).toLowerCase() === SERVER_REFLEXIVE) {\n          var elapsed = _this3.getElapsedTime(peerConnection);\n\n          _loggerProxy.default.logger.log(\"Reachability:index#onIceCandidate --> Successfully pinged \".concat(peerConnection.key, \":\"), elapsed);\n\n          _this3.setLatencyAndClose(peerConnection, elapsed);\n        }\n      };\n    }\n    /**\n     * An event handler on an RTCPeerConnection when the state of the ICE\n     * candidate gathering process changes. Used to measure connection\n     * speed.\n     * @private\n     * @param {RTCPeerConnection} peerConnection\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"iceGatheringState\",\n    value: function iceGatheringState(peerConnection) {\n      var _this4 = this;\n\n      var ELAPSED = 'elapsed';\n      var waitTime = 5e3;\n      return new _promise.default(function (resolve) {\n        var peerConnectionProxy = new window.Proxy(peerConnection, {\n          get: function get(target, property) {\n            var targetMember = target[property];\n\n            if (typeof targetMember === 'function') {\n              return targetMember.bind(target);\n            }\n\n            return targetMember;\n          },\n          set: function set(target, property, value) {\n            // only intercept elapsed property\n            if (property === ELAPSED) {\n              resolve({\n                clusterId: peerConnection.key,\n                elapsed: value\n              });\n              return true;\n            } // pass thru\n\n\n            return window.Reflect.set(target, property, value);\n          }\n        }); // Using peerConnection proxy so handle functions below\n        // won't be coupled to our promise implementation\n\n        _this4.handleIceGatheringStateChange(peerConnectionProxy);\n\n        _this4.handleOnIceCandidate(peerConnectionProxy); // Set maximum timeout\n\n\n        window.setTimeout(function () {\n          var CLOSED = {\n            CONNECTION_STATE: _constants.CONNECTION_STATE\n          }; // Close any open peerConnections\n\n          if (peerConnectionProxy.connectionState !== CLOSED) {\n            _this4.setLatencyAndClose(peerConnectionProxy, null);\n          }\n        }, waitTime);\n      });\n    }\n    /**\n     * Make a log of unreachable clusters.\n     * @returns {undefined}\n     * @private\n     * @memberof Reachability\n     */\n\n  }, {\n    key: \"logUnreachableClusters\",\n    value: function logUnreachableClusters() {\n      var list = this.getUnreachablClusters();\n      list.forEach(function (cluster) {\n        _loggerProxy.default.logger.log(\"Reachability:index#getLocalSDPForClusters --> No ice candidate for \".concat(cluster, \".\"));\n      });\n    }\n    /**\n     * Calculates time to establish connection\n     * @param {array} iceResults iceResults\n     * @returns {object} reachabilityMap\n     * @private\n     * @memberof Reachability\n     */\n\n  }, {\n    key: \"parseIceResultsToReachabilityResults\",\n    value: function parseIceResultsToReachabilityResults(iceResults) {\n      var reachabilityMap = {};\n      iceResults.forEach(function (_ref2) {\n        var clusterId = _ref2.clusterId,\n            elapsed = _ref2.elapsed;\n        var latencyResult;\n\n        if (elapsed === null) {\n          latencyResult = {\n            reachable: 'false'\n          };\n        } else {\n          latencyResult = {\n            reachable: 'true',\n            latencyInMilliseconds: elapsed.toString()\n          };\n        }\n\n        reachabilityMap[clusterId] = {\n          udp: latencyResult,\n          tcp: latencyResult\n        };\n      });\n      return reachabilityMap;\n    }\n    /**\n     * fetches reachability data\n     * @param {object} clusterList\n     * @returns {Promise<localSDPData>} reachability check results\n     * @private\n     * @memberof Reachability\n     */\n\n  }, {\n    key: \"performReachabilityCheck\",\n    value: function performReachabilityCheck(clusterList) {\n      var _this5 = this;\n\n      if (!clusterList || !(0, _keys.default)(clusterList).length) {\n        return _promise.default.resolve({});\n      }\n\n      return new _promise.default(function (resolve) {\n        _this5.getLocalSDPForClusters(clusterList).then(function (localSDPData) {\n          if (!localSDPData || !(0, _keys.default)(localSDPData).length) {\n            // TODO: handle the error condition properly and try retry\n            _loggerProxy.default.logger.log('Reachability:index#performReachabilityCheck --> Local SDP is empty or has missing elements..returning');\n\n            resolve({});\n          } else {\n            resolve(localSDPData);\n          }\n        }).catch(function (error) {\n          _loggerProxy.default.logger.error(\"Reachability:index#performReachabilityCheck --> Error in getLocalSDPForClusters: \".concat(error));\n\n          resolve({});\n        });\n      });\n    }\n    /**\n     * Records latency and closes the peerConnection\n     * @param {RTCPeerConnection} peerConnection\n     * @param {number} elapsed Latency in milliseconds\n     * @returns {undefined}\n     * @private\n     * @memberof Reachability\n     */\n\n  }, {\n    key: \"setLatencyAndClose\",\n    value: function setLatencyAndClose(peerConnection, elapsed) {\n      var _intialState;\n\n      var REACHABLE = 'reachable';\n      var UNREACHABLE = 'unreachable';\n      var CLOSED = _constants.CONNECTION_STATE.CLOSED;\n      var key = peerConnection.key;\n      var resultKey = elapsed === null ? UNREACHABLE : REACHABLE;\n      var intialState = (_intialState = {}, (0, _defineProperty2.default)(_intialState, REACHABLE, 0), (0, _defineProperty2.default)(_intialState, UNREACHABLE, 0), _intialState);\n\n      if (peerConnection.connectionState === CLOSED) {\n        _loggerProxy.default.logger.log(\"Reachability:index#setLatencyAndClose --> Attempting to set latency of \".concat(elapsed, \" on closed peerConnection.\"));\n\n        return;\n      }\n\n      this.clusterLatencyResults[key] = this.clusterLatencyResults[key] || intialState;\n      this.clusterLatencyResults[key][resultKey] += 1; // Set to null in case this fired from\n      // an event other than onIceCandidate\n\n      peerConnection.onicecandidate = null;\n      peerConnection.close();\n      peerConnection.elapsed = elapsed;\n    }\n    /**\n     * utility function\n     * @returns {undefined}\n     * @private\n     * @memberof Reachability\n     */\n\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      this.clusterLatencyResults = {};\n    }\n  }]);\n  return Reachability;\n}();\n\nexports.default = Reachability;","map":{"version":3,"mappings":"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","names":["Reachability","webex","reachabilityRequest","ReachabilityRequest","clusterLatencyResults","setup","window","_window","localStorage","_window$localStorage","removeItem","_context","REACHABILITY","LoggerProxy","logger","error","getClusters","clusters","performReachabilityCheck","results","setItem","cluster","iceServers","udp","tcp","map","url","username","credential","urls","iceCandidatePoolSize","iceTransportPolicy","key","config","peerConnection","RTCPeerConnection","peerConnectionError","log","startTime","begin","clusterList","_this","buildPeerConnectionConfig","createPeerConnection","_context2","createOffer","offerToReceiveAudio","description","setLocalDescription","iceGatheringState","catch","iceGatheringStateError","_promise","all","then","parseIceResultsToReachabilityResults","reachabilityLatencyResults","logUnreachableClusters","unreachableList","forEach","unreachable","reachable","push","onicegatheringstatechange","COMPLETE","ICE_GATHERING_STATE","iceConnectionState","elapsed","_this2","getElapsedTime","setLatencyAndClose","onicecandidate","e","SERVER_REFLEXIVE","candidate","String","type","toLowerCase","_this3","ELAPSED","waitTime","resolve","peerConnectionProxy","Proxy","get","target","property","targetMember","bind","set","value","clusterId","Reflect","_this4","handleIceGatheringStateChange","handleOnIceCandidate","setTimeout","CLOSED","CONNECTION_STATE","connectionState","list","getUnreachablClusters","iceResults","reachabilityMap","latencyResult","latencyInMilliseconds","toString","length","_this5","getLocalSDPForClusters","localSDPData","REACHABLE","UNREACHABLE","resultKey","intialState","close"],"sources":["index.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\n/* eslint-disable class-methods-use-this */\n/* globals window */\nimport _ from 'lodash';\n\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport {\n  ICE_GATHERING_STATE,\n  CONNECTION_STATE,\n  REACHABILITY\n} from '../constants';\n\nimport ReachabilityRequest from './request';\n\n/**\n * @class Reachability\n * @export\n */\nexport default class Reachability {\n  /**\n   * Creates an instance of Reachability.\n   * @param {object} webex\n   * @memberof Reachability\n   */\n  constructor(webex) {\n    this.webex = webex;\n\n    /**\n     * internal request object for the server\n     * @instance\n     * @type {Array}\n     * @private\n     * @memberof Reachability\n     */\n    this.reachabilityRequest = new ReachabilityRequest(this.webex);\n\n    /**\n     * internal object of clusters latency results\n     * @instance\n     * @type {object}\n     * @private\n     * @memberof Reachability\n     */\n    this.clusterLatencyResults = {};\n  }\n\n\n  /**\n   * fetches reachability data\n   * @returns {Object} reachability data\n   * @public\n   * @async\n   * @memberof Reachability\n   */\n  async gatherReachability() {\n    this.setup();\n\n    // Remove stored reachability results to ensure no stale data\n    if (window?.localStorage?.removeItem) {\n      window.localStorage.removeItem(REACHABILITY.localStorage);\n    }\n    else {\n      LoggerProxy.logger.error('Reachability:index#gatherReachability --> Error in accessing LocalStorage.');\n\n      return {};\n    }\n\n    // Fetch clusters and measure latency\n    try {\n      const clusters = await this.reachabilityRequest.getClusters();\n\n      // Perform Reachability Check\n      const results = await this.performReachabilityCheck(clusters);\n\n      window.localStorage.setItem(REACHABILITY.localStorage, JSON.stringify(results));\n\n      return results;\n    }\n    catch (getClusterError) {\n      LoggerProxy.logger.error(`Reachability:index#gatherReachability --> Error in calling getClusters(): ${getClusterError}`);\n\n      return {};\n    }\n  }\n\n\n  /**\n   * Generate peerConnection config settings\n   * @param {object} cluster\n   * @returns {object} peerConnectionConfig\n   * @private\n   * @memberof Reachability\n   */\n  buildPeerConnectionConfig(cluster) {\n    const iceServers = _.uniq([\n      ...cluster.udp,\n      ...cluster.tcp\n    ]).map((url) => ({\n      username: '',\n      credential: '',\n      urls: [url]\n    }));\n\n    return {\n      iceServers: [\n        ...iceServers\n      ],\n      iceCandidatePoolSize: '0',\n      iceTransportPolicy: 'all'\n    };\n  }\n\n\n  /**\n   * Creates an RTCPeerConnection\n   * @param {object} cluster\n   * @returns {RTCPeerConnection} peerConnection\n   * @private\n   * @memberof Reachability\n   */\n  createPeerConnection(cluster) {\n    const {key, config} = cluster;\n\n    try {\n      const peerConnection = new window.RTCPeerConnection(config);\n\n      peerConnection.key = key;\n\n      return peerConnection;\n    }\n    catch (peerConnectionError) {\n      LoggerProxy.logger.log(`Reachability:index#getLocalSDPForClusters --> Error creating peerConnection: ${peerConnectionError}`);\n\n      return null;\n    }\n  }\n\n\n  /**\n   * Gets total elapsed time\n   * @param {RTCPeerConnection} peerConnection\n   * @returns {Number} Milliseconds\n   * @private\n   * @memberof Reachability\n   */\n  getElapsedTime(peerConnection) {\n    const startTime = peerConnection.begin;\n\n    delete peerConnection.begin;\n\n    return Date.now() - startTime;\n  }\n\n\n  /**\n   * creates offer and generates localSDP\n   * @param {object} clusterList cluster List\n   * @returns {Promise} Reachability latency results\n   * @private\n   * @memberof Reachability\n   */\n  getLocalSDPForClusters(clusterList) {\n    let clusters = [...Object.keys(clusterList)];\n\n    clusters = clusters.map(async (key) => {\n      const cluster = clusterList[key];\n      const config = this.buildPeerConnectionConfig(cluster);\n      const peerConnection = this.createPeerConnection({key, config});\n      const description = await peerConnection.createOffer({offerToReceiveAudio: true});\n\n      peerConnection.begin = Date.now();\n      peerConnection.setLocalDescription(description);\n\n      return this.iceGatheringState(peerConnection)\n        .catch((iceGatheringStateError) => {\n          LoggerProxy.logger.log(`Reachability:index#getLocalSDPForClusters --> Error in getLocalSDP : ${iceGatheringStateError}`);\n        });\n    });\n\n    return Promise.all(clusters)\n      .then(this.parseIceResultsToReachabilityResults)\n      .then((reachabilityLatencyResults) => {\n        this.logUnreachableClusters();\n\n        // return results\n        return reachabilityLatencyResults;\n      });\n  }\n\n\n  /**\n   * Get list of all unreachable clusters\n   * @returns {array} Unreachable clusters\n   * @private\n   * @memberof Reachability\n   */\n  getUnreachablClusters() {\n    const unreachableList = [];\n    const clusters = this.clusterLatencyResults;\n\n    Object.keys(clusters).forEach((key) => {\n      const cluster = clusters[key];\n\n      if (cluster.unreachable && !cluster.reachable) {\n        unreachableList.push(key);\n      }\n    });\n\n    return unreachableList;\n  }\n\n\n  /**\n   * Attach an event handler for the icegatheringstatechange\n   * event and measure latency.\n   * @param {RTCPeerConnection} peerConnection\n   * @returns {undefined}\n   * @private\n   * @memberof Reachability\n   */\n  handleIceGatheringStateChange(peerConnection) {\n    peerConnection.onicegatheringstatechange = () => {\n      const {COMPLETE} = ICE_GATHERING_STATE;\n\n      if (peerConnection.iceConnectionState === COMPLETE) {\n        const elapsed = this.getElapsedTime(peerConnection);\n\n        LoggerProxy.logger.log(`Reachability:index#onIceGatheringStateChange --> Successfully pinged ${peerConnection.key}:`, elapsed);\n        this.setLatencyAndClose(peerConnection, elapsed);\n      }\n    };\n  }\n\n\n  /**\n   * Attach an event handler for the icecandidate\n   * event and measure latency.\n   * @param {RTCPeerConnection} peerConnection\n   * @returns {undefined}\n   * @private\n   * @memberof Reachability\n   */\n  handleOnIceCandidate(peerConnection) {\n    peerConnection.onicecandidate = (e) => {\n      const SERVER_REFLEXIVE = 'srflx';\n\n      if (e.candidate && String(e.candidate.type).toLowerCase() === SERVER_REFLEXIVE) {\n        const elapsed = this.getElapsedTime(peerConnection);\n\n        LoggerProxy.logger.log(`Reachability:index#onIceCandidate --> Successfully pinged ${peerConnection.key}:`, elapsed);\n        this.setLatencyAndClose(peerConnection, elapsed);\n      }\n    };\n  }\n\n\n  /**\n   * An event handler on an RTCPeerConnection when the state of the ICE\n   * candidate gathering process changes. Used to measure connection\n   * speed.\n   * @private\n   * @param {RTCPeerConnection} peerConnection\n   * @returns {Promise}\n   */\n  iceGatheringState(peerConnection) {\n    const ELAPSED = 'elapsed';\n    const waitTime = 5e3;\n\n    return new Promise((resolve) => {\n      const peerConnectionProxy = new window.Proxy(peerConnection, {\n        get(target, property) {\n          const targetMember = target[property];\n\n          if (typeof (targetMember) === 'function') {\n            return targetMember.bind(target);\n          }\n\n          return targetMember;\n        },\n        set: (target, property, value) => {\n          // only intercept elapsed property\n          if (property === ELAPSED) {\n            resolve({clusterId: peerConnection.key, elapsed: value});\n\n            return true;\n          }\n\n          // pass thru\n          return window.Reflect.set(target, property, value);\n        }\n      });\n\n      // Using peerConnection proxy so handle functions below\n      // won't be coupled to our promise implementation\n      this.handleIceGatheringStateChange(peerConnectionProxy);\n      this.handleOnIceCandidate(peerConnectionProxy);\n\n      // Set maximum timeout\n      window.setTimeout(() => {\n        const CLOSED = {CONNECTION_STATE};\n\n        // Close any open peerConnections\n        if (peerConnectionProxy.connectionState !== CLOSED) {\n          this.setLatencyAndClose(peerConnectionProxy, null);\n        }\n      }, waitTime);\n    });\n  }\n\n\n  /**\n   * Make a log of unreachable clusters.\n   * @returns {undefined}\n   * @private\n   * @memberof Reachability\n   */\n  logUnreachableClusters() {\n    const list = this.getUnreachablClusters();\n\n    list.forEach((cluster) => {\n      LoggerProxy.logger.log(`Reachability:index#getLocalSDPForClusters --> No ice candidate for ${cluster}.`);\n    });\n  }\n\n\n  /**\n   * Calculates time to establish connection\n   * @param {array} iceResults iceResults\n   * @returns {object} reachabilityMap\n   * @private\n   * @memberof Reachability\n   */\n  parseIceResultsToReachabilityResults(iceResults) {\n    const reachabilityMap = {};\n\n    iceResults.forEach(({clusterId, elapsed}) => {\n      let latencyResult;\n\n      if (elapsed === null) {\n        latencyResult = {reachable: 'false'};\n      }\n      else {\n        latencyResult = {\n          reachable: 'true',\n          latencyInMilliseconds: (elapsed).toString()\n        };\n      }\n\n      reachabilityMap[clusterId] = {\n        udp: latencyResult,\n        tcp: latencyResult\n      };\n    });\n\n    return reachabilityMap;\n  }\n\n\n  /**\n   * fetches reachability data\n   * @param {object} clusterList\n   * @returns {Promise<localSDPData>} reachability check results\n   * @private\n   * @memberof Reachability\n   */\n  performReachabilityCheck(clusterList) {\n    if (!clusterList || !Object.keys(clusterList).length) {\n      return Promise.resolve({});\n    }\n\n    return new Promise((resolve) => {\n      this.getLocalSDPForClusters(clusterList)\n        .then((localSDPData) => {\n          if (!localSDPData || !Object.keys(localSDPData).length) {\n            // TODO: handle the error condition properly and try retry\n            LoggerProxy.logger.log('Reachability:index#performReachabilityCheck --> Local SDP is empty or has missing elements..returning');\n            resolve({});\n          }\n          else {\n            resolve(localSDPData);\n          }\n        })\n        .catch((error) => {\n          LoggerProxy.logger.error(`Reachability:index#performReachabilityCheck --> Error in getLocalSDPForClusters: ${error}`);\n          resolve({});\n        });\n    });\n  }\n\n\n  /**\n   * Records latency and closes the peerConnection\n   * @param {RTCPeerConnection} peerConnection\n   * @param {number} elapsed Latency in milliseconds\n   * @returns {undefined}\n   * @private\n   * @memberof Reachability\n   */\n  setLatencyAndClose(peerConnection, elapsed) {\n    const REACHABLE = 'reachable';\n    const UNREACHABLE = 'unreachable';\n    const {CLOSED} = CONNECTION_STATE;\n    const {key} = peerConnection;\n    const resultKey = elapsed === null ? UNREACHABLE : REACHABLE;\n    const intialState = {[REACHABLE]: 0, [UNREACHABLE]: 0};\n\n    if (peerConnection.connectionState === CLOSED) {\n      LoggerProxy.logger.log(`Reachability:index#setLatencyAndClose --> Attempting to set latency of ${elapsed} on closed peerConnection.`);\n\n      return;\n    }\n\n    this.clusterLatencyResults[key] = this.clusterLatencyResults[key] || intialState;\n    this.clusterLatencyResults[key][resultKey] += 1;\n\n    // Set to null in case this fired from\n    // an event other than onIceCandidate\n    peerConnection.onicecandidate = null;\n    peerConnection.close();\n    peerConnection.elapsed = elapsed;\n  }\n\n\n  /**\n   * utility function\n   * @returns {undefined}\n   * @private\n   * @memberof Reachability\n   */\n  setup() {\n    this.clusterLatencyResults = {};\n  }\n}\n"]},"metadata":{},"sourceType":"script"}