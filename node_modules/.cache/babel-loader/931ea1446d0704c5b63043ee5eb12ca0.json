{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _apply = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/reflect/apply\"));\n\nvar _partition2 = _interopRequireDefault(require(\"lodash/partition\"));\n\nrequire(\"@webex/internal-plugin-device\");\n\nvar _webexCore = require(\"@webex/webex-core\");\n/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar Feature = _webexCore.WebexPlugin.extend({\n  namespace: 'Feature',\n\n  /**\n   * Returns the value of the requested feature toggle.\n   * @param {string} keyType <developer|user|entitlement>\n   * @param {string} key\n   * @param {Object} options\n   * @param {boolean} options.full to get full feature record including metadata.\n   * @returns {string|boolean|number|FeatureModel|null}\n   */\n  getFeature: function getFeature(keyType, key, options) {\n    if (keyType !== 'developer' && keyType !== 'user' && keyType !== 'entitlement') {\n      return _promise.default.reject(new Error('Invalid feature keyType provided. Only `developer`, `user`, and `entitlement` feature toggles are permitted.'));\n    }\n\n    options = options || {};\n    var feature = this.webex.internal.device.features[keyType].get(key);\n\n    if (!feature) {\n      return _promise.default.resolve(null);\n    }\n\n    if (options.full) {\n      return _promise.default.resolve(feature.serialize());\n    }\n\n    return _promise.default.resolve(feature.value);\n  },\n\n  /**\n   * Handles a feature toggle update from the server.\n   * @param {Object} envelope\n   * @returns {undefined}\n   */\n  handleFeatureUpdate: function handleFeatureUpdate(envelope) {\n    if (envelope && envelope.data) {\n      var feature = envelope.data.featureToggle;\n      var keyType = feature.type.toLowerCase();\n\n      if (keyType === 'user' || keyType === 'developer') {\n        this.webex.internal.device.features[keyType].add([feature], {\n          merge: true\n        });\n      }\n    }\n  },\n\n  /**\n   * Register to listen for incoming feature events\n   * @instance\n   * @returns {undefined}\n   */\n  listen: function listen() {\n    this.listenTo(this.webex.internal.mercury, 'event:featureToggle_update', this.handleFeatureUpdate);\n  },\n\n  /**\n   * Issues request to server to set a value for a feature toggle.\n   * @param {string} keyType <developer|user>\n   * @param {string} key\n   * @param {string} value\n   * @returns {Promise} Refreshes the local device and resolves with the features endpoint's response.\n   */\n  setFeature: function setFeature(keyType, key, value) {\n    var _this = this; // Limit only to developer feature toggles for now.\n\n\n    if (keyType !== 'developer' && keyType !== 'user') {\n      return _promise.default.reject(new Error('Only `developer` and `user` feature toggles can be set.'));\n    }\n\n    return this.request({\n      method: 'POST',\n      api: 'feature',\n      resource: \"features/users/\".concat(this.webex.internal.device.userId, \"/\").concat(keyType),\n      body: {\n        key: key,\n        mutable: true,\n        val: value\n      }\n    }).then(function (res) {\n      return _this.webex.internal.device.features[keyType].add(res.body, {\n        merge: true\n      });\n    });\n  },\n\n  /**\n   * Issues request to server to set a value for a feature toggle.\n   * @param {array} featureList\n   * @returns {Promise} Refreshes the local device and resolves with the features endpoint`s response.\n   */\n  setBundledFeatures: function setBundledFeatures(featureList) {\n    var _this2 = this;\n\n    featureList.forEach(function (item) {\n      item.mutable = item.mutable || 'true';\n\n      if (item.type !== 'USER' && item.type !== 'DEV') {\n        item.type = 'USER';\n      }\n    });\n    return this.request({\n      method: 'POST',\n      api: 'feature',\n      resource: \"features/users/\".concat(this.webex.internal.device.userId, \"/toggles\"),\n      body: featureList\n    }).then(function (res) {\n      var partitionedToggles = (0, _partition2.default)(res.body.featureToggles, {\n        type: 'USER'\n      });\n\n      _this2.webex.internal.device.features.user.add(partitionedToggles[0], {\n        merge: true\n      });\n\n      _this2.webex.internal.device.features.developer.add(partitionedToggles[1], {\n        merge: true\n      });\n    });\n  },\n  initialize: function initialize() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    (0, _apply.default)(_webexCore.WebexPlugin.prototype.initialize, this, args);\n    this.listenToAndRun(this.webex, 'change:internal.device.features.developer', this.trigger.bind(this, 'change:developer'));\n    this.listenToAndRun(this.webex, 'change:internal.device.features.entitlement', this.trigger.bind(this, 'change:entitlement'));\n    this.listenToAndRun(this.webex, 'change:internal.device.features.user', this.trigger.bind(this, 'change:user'));\n  },\n  version: \"1.154.2\"\n});\n\nvar _default = Feature;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["require","Feature","WebexPlugin","extend","namespace","getFeature","keyType","key","options","_promise","reject","Error","feature","webex","internal","device","features","get","resolve","full","serialize","value","handleFeatureUpdate","envelope","data","featureToggle","type","toLowerCase","add","merge","listen","listenTo","mercury","setFeature","request","method","api","resource","userId","body","mutable","val","then","res","_this","setBundledFeatures","featureList","forEach","item","partitionedToggles","featureToggles","_this2","user","developer","initialize","args","arguments","prototype","listenToAndRun","trigger","bind","version"],"sources":["feature.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport '@webex/internal-plugin-device';\nimport {partition} from 'lodash';\nimport {WebexPlugin} from '@webex/webex-core';\n\nconst Feature = WebexPlugin.extend({\n  namespace: 'Feature',\n\n  /**\n   * Returns the value of the requested feature toggle.\n   * @param {string} keyType <developer|user|entitlement>\n   * @param {string} key\n   * @param {Object} options\n   * @param {boolean} options.full to get full feature record including metadata.\n   * @returns {string|boolean|number|FeatureModel|null}\n   */\n  getFeature(keyType, key, options) {\n    if (keyType !== 'developer' && keyType !== 'user' && keyType !== 'entitlement') {\n      return Promise.reject(new Error('Invalid feature keyType provided. Only `developer`, `user`, and `entitlement` feature toggles are permitted.'));\n    }\n\n    options = options || {};\n\n    const feature = this.webex.internal.device.features[keyType].get(key);\n\n    if (!feature) {\n      return Promise.resolve(null);\n    }\n\n    if (options.full) {\n      return Promise.resolve(feature.serialize());\n    }\n\n    return Promise.resolve(feature.value);\n  },\n\n  /**\n   * Handles a feature toggle update from the server.\n   * @param {Object} envelope\n   * @returns {undefined}\n   */\n  handleFeatureUpdate(envelope) {\n    if (envelope && envelope.data) {\n      const feature = envelope.data.featureToggle;\n      const keyType = feature.type.toLowerCase();\n\n      if (keyType === 'user' || keyType === 'developer') {\n        this.webex.internal.device.features[keyType].add([feature], {merge: true});\n      }\n    }\n  },\n\n  /**\n   * Register to listen for incoming feature events\n   * @instance\n   * @returns {undefined}\n   */\n  listen() {\n    this.listenTo(this.webex.internal.mercury, 'event:featureToggle_update', this.handleFeatureUpdate);\n  },\n\n  /**\n   * Issues request to server to set a value for a feature toggle.\n   * @param {string} keyType <developer|user>\n   * @param {string} key\n   * @param {string} value\n   * @returns {Promise} Refreshes the local device and resolves with the features endpoint's response.\n   */\n  setFeature(keyType, key, value) {\n    // Limit only to developer feature toggles for now.\n    if (keyType !== 'developer' && keyType !== 'user') {\n      return Promise.reject(new Error('Only `developer` and `user` feature toggles can be set.'));\n    }\n\n    return this.request({\n      method: 'POST',\n      api: 'feature',\n      resource: `features/users/${this.webex.internal.device.userId}/${keyType}`,\n      body: {\n        key,\n        mutable: true,\n        val: value\n      }\n    })\n      .then((res) => this.webex.internal.device.features[keyType].add(res.body, {merge: true}));\n  },\n\n  /**\n   * Issues request to server to set a value for a feature toggle.\n   * @param {array} featureList\n   * @returns {Promise} Refreshes the local device and resolves with the features endpoint`s response.\n   */\n  setBundledFeatures(featureList) {\n    featureList.forEach((item) => {\n      item.mutable = item.mutable || 'true';\n      if (item.type !== 'USER' && item.type !== 'DEV') {\n        item.type = 'USER';\n      }\n    });\n\n    return this.request({\n      method: 'POST',\n      api: 'feature',\n      resource: `features/users/${this.webex.internal.device.userId}/toggles`,\n      body: featureList\n    })\n      .then((res) => {\n        const partitionedToggles = partition(res.body.featureToggles, {type: 'USER'});\n\n        this.webex.internal.device.features.user.add(partitionedToggles[0], {merge: true});\n        this.webex.internal.device.features.developer.add(partitionedToggles[1], {merge: true});\n      });\n  },\n\n  initialize(...args) {\n    Reflect.apply(WebexPlugin.prototype.initialize, this, args);\n\n    this.listenToAndRun(this.webex, 'change:internal.device.features.developer', this.trigger.bind(this, 'change:developer'));\n    this.listenToAndRun(this.webex, 'change:internal.device.features.entitlement', this.trigger.bind(this, 'change:entitlement'));\n    this.listenToAndRun(this.webex, 'change:internal.device.features.user', this.trigger.bind(this, 'change:user'));\n  }\n});\n\nexport default Feature;\n"]},"metadata":{},"sourceType":"script"}