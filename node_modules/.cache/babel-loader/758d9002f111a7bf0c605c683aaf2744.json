{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = detectFileType;\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _httpCore = require(\"@webex/http-core\");\n\nvar _mime = require(\"mime\");\n/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\n/**\n * Determines the file type of the specified file\n * @param {FileLike} file\n * @param {Object} logger\n * @returns {Promise<string>}\n */\n\n\nfunction detectFileType(file, logger) {\n  if (file.type) {\n    logger.info(\"file already has type \".concat(file.type, \". using existing file.type.\"));\n    return _promise.default.resolve(file.type);\n  }\n\n  if (file.mimeType) {\n    logger.info(\"file already has mimeType \".concat(file.type, \". using existing file.mimeType.\"));\n    return _promise.default.resolve(file.mimeType);\n  } // This kinda belongs in http core, but since we have no guarantee that\n  // buffers are expected to have names there, it'll stay here for now.\n\n\n  return (0, _httpCore.detect)(file).then(function (type) {\n    if (type === 'application/x-msi' || type === 'application/octet-stream') {\n      logger.info(\"detected filetype to be \".concat(type, \". Falling back to mime.lookup\"));\n      return (0, _mime.getType)(file.name);\n    }\n\n    logger.info(\"detected filetype to be \".concat(type, \". returning it\"));\n    return type;\n  });\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;AAIA;;AACA;AALA;AACA;AACA;;AAKA;AACA;AACA;AACA;AACA;AACA;;;AACe,SAASA,cAAT,CAAwBC,IAAxB,EAA8BC,MAA9B,EAAsC;AACnD,MAAID,IAAI,CAACE,IAAT,EAAe;AACbD,UAAM,CAACE,IAAPF,iCAAqCD,IAAI,CAACE,IAA1C;AAEA,WAAOE,iBAAQC,OAAR,CAAgBL,IAAI,CAACE,IAArB,CAAP;AACD;;AAED,MAAIF,IAAI,CAACM,QAAT,EAAmB;AACjBL,UAAM,CAACE,IAAPF,qCAAyCD,IAAI,CAACE,IAA9C;AAEA,WAAOE,iBAAQC,OAAR,CAAgBL,IAAI,CAACM,QAArB,CAAP;AAViD,IAanD;AACA;;;AACA,SAAO,sBAAON,IAAP,EACJO,IADI,CACC,UAACL,IAAD,EAAU;AACd,QAAIA,IAAI,KAAK,mBAATA,IAAgCA,IAAI,KAAK,0BAA7C,EAAyE;AACvED,YAAM,CAACE,IAAPF,mCAAuCC,IAAvC;AAEA,aAAO,mBAAQF,IAAI,CAACQ,IAAb,CAAP;AACD;;AAEDP,UAAM,CAACE,IAAPF,mCAAuCC,IAAvC;AAEA,WAAOA,IAAP;AAVG,IAAP;AAYD","names":["detectFileType","file","logger","type","info","_promise","resolve","mimeType","then","name"],"sources":["detect-filetype.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {detect} from '@webex/http-core';\nimport {getType} from 'mime';\n\n/**\n * Determines the file type of the specified file\n * @param {FileLike} file\n * @param {Object} logger\n * @returns {Promise<string>}\n */\nexport default function detectFileType(file, logger) {\n  if (file.type) {\n    logger.info(`file already has type ${file.type}. using existing file.type.`);\n\n    return Promise.resolve(file.type);\n  }\n\n  if (file.mimeType) {\n    logger.info(`file already has mimeType ${file.type}. using existing file.mimeType.`);\n\n    return Promise.resolve(file.mimeType);\n  }\n\n  // This kinda belongs in http core, but since we have no guarantee that\n  // buffers are expected to have names there, it'll stay here for now.\n  return detect(file)\n    .then((type) => {\n      if (type === 'application/x-msi' || type === 'application/octet-stream') {\n        logger.info(`detected filetype to be ${type}. Falling back to mime.lookup`);\n\n        return getType(file.name);\n      }\n\n      logger.info(`detected filetype to be ${type}. returning it`);\n\n      return type;\n    });\n}\n"]},"metadata":{},"sourceType":"script"}