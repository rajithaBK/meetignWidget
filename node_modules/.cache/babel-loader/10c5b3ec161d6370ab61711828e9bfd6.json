{"ast":null,"code":"\"use strict\";\n\nvar _Object$keys2 = require(\"@babel/runtime-corejs2/core-js/object/keys\");\n\nvar _Object$getOwnPropertySymbols = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\");\n\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\");\n\nvar _Object$getOwnPropertyDescriptors = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\");\n\nvar _Object$defineProperties = require(\"@babel/runtime-corejs2/core-js/object/define-properties\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/array/is-array\"));\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/keys\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/toConsumableArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/defineProperty\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/createClass\"));\n\nvar _constants = require(\"./constants\");\n\nvar _serviceHost = _interopRequireDefault(require(\"./service-host\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = _Object$keys2(object);\n\n  if (_Object$getOwnPropertySymbols) {\n    var symbols = _Object$getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return _Object$getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (_Object$getOwnPropertyDescriptors) {\n      _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n/**\n * The parameter transfer object for {@link ServiceRegistry#mapRemoteCatalog}.\n * This object is shaped to match the object returned from the **U2C** service.\n *\n * @typedef {Record<string, string>} RSL\n * @typedef {Record<string, Array<Record<string, number | string>>>} RHC\n *\n * @typedef {Object} MapRemoteCatalogPTO\n * @property {string} MapRemoteCatalogPTO.catalog - Service catalog name.\n * @property {RSL} MapRemoteCatalogPTO.serviceLinks - Service links.\n * @property {RHC} MapRemoteCatalogPTO.hostCatalog - Service host catalog.\n */\n\n/**\n * Service manipulation filter object for retrieving services within the\n * {@link ServiceRegistry} class.\n *\n * @typedef {Object} HostFilter\n * @property {boolean} [HostFilter.active] - Active state to filter.\n * @property {Array<string> | string} [HostFilter.catalog] - Catalogs to filter.\n * @property {Array<string> | string} [HostFilter.cluster] - Clusters to filter.\n * @property {boolean} [HostFilter.local] - Filter to the user's home cluster.\n * @property {boolean} [HostFilter.priority] - Filter for the highest priority.\n * @property {Array<string> | string} [HostFilter.service] - Services to filter.\n * @property {Array<string> | string} [HostFilter.url] - URL to filter.\n */\n\n/**\n * @class\n * @classdesc - Manages a collection of {@link ServiceHost} class objects.\n */\n\n\nvar ServiceRegistry = /*#__PURE__*/function () {\n  /**\n   * Generate a new {@link ServiceHost}.\n   *\n   * @public\n   * @constructor\n   * @memberof ServiceHost\n   */\n  function ServiceRegistry() {\n    (0, _classCallCheck2.default)(this, ServiceRegistry);\n    /**\n     * The collection of managed {@link ServiceHost}s.\n     *\n     * @instance\n     * @type {Array<ServiceHost>}\n     * @private\n     * @memberof ServiceRegistry\n     */\n\n    this.hosts = [];\n  }\n  /**\n   * An active, local, and priority mapped record of the current\n   * {@link ServiceCatalog#hosts}.\n   *\n   * @public\n   * @memberof ServiceCatalog\n   * @type {Record<string, string>}\n   */\n\n\n  (0, _createClass2.default)(ServiceRegistry, [{\n    key: \"map\",\n    get: function get() {\n      // Get a list of active, local, and priority-mapped hosts.\n      return this.find({\n        active: true,\n        local: true,\n        priority: true\n      }).reduce(function (map, host) {\n        // Generate a new object to assign the existing map.\n        var hostReference = {}; // Assign the key:value pair for the service and url.\n\n        hostReference[host.service] = host.url; // Assign the reference to the map and return.\n\n        return _objectSpread(_objectSpread({}, map), hostReference);\n      }, {});\n    }\n    /**\n     * Removes a collection of {@link ServiceHost} class objects from the\n     * {@link ServiceRegistry#hosts} array based on the provided\n     * {@link HostFilter}.\n     *\n     * @public\n     * @memberof ServiceRegistry\n     * @param {HostFilter} filter - The inclusive filter for hosts to remove.\n     * @returns {Array<ServiceHost>} - The removed {@link ServiceHost}s.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear(filter) {\n      // Collect a list of hosts to remove based on the provided filter.\n      var removing = this.find(filter); // Remove the hosts from the array.\n\n      this.hosts = this.hosts.filter(function (host) {\n        return !removing.includes(host);\n      }); // Return the removed hosts.\n\n      return removing;\n    }\n    /**\n     * Mark a collection of {@link ServiceHost} class objects from the\n     * {@link ServiceRegistry#hosts} array as failed based on the provided\n     * {@link HostFilter}.\n     *\n     * @public\n     * @memberof ServiceRegistry\n     * @param {HostFilter} filter - The inclusive filter for hosts to mark failed.\n     * @returns {Array<ServiceHost>} - The {@link ServiceHost}s marked failed.\n     */\n\n  }, {\n    key: \"failed\",\n    value: function failed(filter) {\n      // Collect a list of hosts to mark as failed based on the provided filter.\n      var failing = this.find(filter); // Mark the hosts from the array as failed.\n\n      failing.forEach(function (host) {\n        host.setStatus({\n          failed: true\n        });\n      }); // Return the marked hosts.\n\n      return failing;\n    }\n    /**\n     * Filter the {@link ServiceRegistry#hosts} array against their active states.\n     *\n     * @private\n     * @memberof ServiceRegistry\n     * @param {boolean} [active] - Filter for the host state.\n     * @returns {Array<ServiceHost>} - The filtered host array.\n     */\n\n  }, {\n    key: \"filterActive\",\n    value: function filterActive(active) {\n      // Filter the host array if the active requirement is true.\n      return typeof active === 'boolean' ? this.hosts.filter(function (host) {\n        return host.active === active;\n      }) : (0, _toConsumableArray2.default)(this.hosts);\n    }\n    /**\n     * Filter the {@link ServiceRegistry#hosts} array against their assigned\n     * catalog values.\n     *\n     * @private\n     * @memberof ServiceRegistry\n     * @param {Array<string> | string} [catalog] - Catalogs to filter.\n     * @returns {Array<ServiceHost>} - The filtered host array.\n     */\n\n  }, {\n    key: \"filterCatalog\",\n    value: function filterCatalog() {\n      var catalog = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []; // Generate a catalog names array based on the provided catalog param.\n\n      var catalogs = ((0, _isArray.default)(catalog) ? catalog : [catalog]).map(function (catalogId) {\n        return ServiceRegistry.mapCatalogName({\n          id: catalogId,\n          type: _constants.SERVICE_CATALOGS_ENUM_TYPES.STRING\n        }) || catalogId;\n      }); // Filter the host array against the catalog names array.\n\n      return catalogs.length > 0 ? this.hosts.filter(function (host) {\n        return catalogs.includes(host.catalog);\n      }) : (0, _toConsumableArray2.default)(this.hosts);\n    }\n    /**\n     * Filter the {@link ServiceRegistry#hosts} array against their assigned\n     * cluster values.\n     *\n     * @private\n     * @memberof ServiceRegistry\n     * @param {Array<string> | string} [cluster] - Clusters to filter for.\n     * @returns {Array<ServiceHost>} - The filtered host array.\n     */\n\n  }, {\n    key: \"filterCluster\",\n    value: function filterCluster() {\n      var cluster = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []; // Generate an array of clusters regardless of parameter type.\n\n      var clusters = (0, _isArray.default)(cluster) ? cluster : [cluster]; // Filter the host array against the provided clusters.\n\n      return clusters.length > 0 ? this.hosts.filter(function (host) {\n        return clusters.includes(host.id);\n      }) : (0, _toConsumableArray2.default)(this.hosts);\n    }\n    /**\n     * Filter the {@link ServiceRegistry#hosts} array against their location in\n     * reference to the authenticated user.\n     *\n     * @private\n     * @memberof ServiceRegistry\n     * @param {boolean} [local] - Filter for the host location.\n     * @returns {Array<ServiceHost>} - The filtered host array.\n     */\n\n  }, {\n    key: \"filterLocal\",\n    value: function filterLocal(local) {\n      return typeof local === 'boolean' ? this.hosts.filter(function (host) {\n        return host.local === local;\n      }) : (0, _toConsumableArray2.default)(this.hosts);\n    }\n    /**\n     * Filter the {@link ServiceRegistry#hosts} array for the highest priority\n     * hosts for each specific service.\n     *\n     * @private\n     * @memberof ServiceRegistry\n     * @param {boolean} [priority] - Filter for the highest priority\n     * @returns {Array<ServiceHost>} - The filtered host array.\n     */\n\n  }, {\n    key: \"filterPriority\",\n    value: function filterPriority(priority) {\n      return priority ? this.hosts.reduce(function (filteredHosts, currentHost) {\n        // Validate that the current host is not active.\n        if (!currentHost.active) {\n          return filteredHosts;\n        } // Determine if the filtered hosts array contains a host from the same\n        // host group.\n\n\n        var foundHost = filteredHosts.find(function (host) {\n          return host.hostGroup === currentHost.hostGroup;\n        }); // Validate if a host was found.\n\n        if (!foundHost) {\n          filteredHosts.push(currentHost);\n          return filteredHosts;\n        } // Map the found host's catalog to its priority value.\n\n\n        var foundHostCatalogPriority = ServiceRegistry.mapCatalogName({\n          id: foundHost.catalog,\n          type: _constants.SERVICE_CATALOGS_ENUM_TYPES.NUMBER\n        }); // Map the current host's catalog to its priority value.\n\n        var currentHostCatalogPriority = ServiceRegistry.mapCatalogName({\n          id: currentHost.catalog,\n          type: _constants.SERVICE_CATALOGS_ENUM_TYPES.NUMBER\n        }); // Validate if the found host has a lower priority than the current\n        // host.\n\n        if (foundHostCatalogPriority < currentHostCatalogPriority || foundHost.priority < currentHost.priority) {\n          filteredHosts.splice(filteredHosts.indexOf(foundHost, 1));\n          filteredHosts.push(currentHost);\n        }\n\n        return filteredHosts;\n      }, []) : (0, _toConsumableArray2.default)(this.hosts);\n    }\n    /**\n     * Filter the {@link ServiceRegistry#hosts} array for hosts with a specified\n     * set of service names.\n     *\n     * @private\n     * @memberof ServiceRegistry\n     * @param {Array<string> | string} [service] - Services to filter.\n     * @returns {Array<ServiceHost>} - The filtered host array.\n     */\n\n  }, {\n    key: \"filterService\",\n    value: function filterService() {\n      var service = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []; // Generate an array of services regardless of parameter type.\n\n      var services = (0, _isArray.default)(service) ? service : [service]; // Filter the host array against the provided services.\n\n      return services.length > 0 ? this.hosts.filter(function (host) {\n        return services.includes(host.service);\n      }) : (0, _toConsumableArray2.default)(this.hosts);\n    }\n    /**\n     * Filter the {@link ServiceRegistry#hosts} array for hosts with a specified\n     * set of URLs.\n     *\n     * @private\n     * @memberof ServiceRegistry\n     * @param {Array<string> | string} [url] - URL to filter.\n     * @returns {Array<ServiceHost>} - The filter host array.\n     */\n\n  }, {\n    key: \"filterUrl\",\n    value: function filterUrl() {\n      var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []; // Generate an array of URLs regardless of the parameter type.\n\n      var urls = (0, _isArray.default)(url) ? url : [url]; // Filter the host array against the provided URLs.\n\n      return urls.length > 0 ? this.hosts.filter(function (host) {\n        return urls.includes(host.url);\n      }) : (0, _toConsumableArray2.default)(this.hosts);\n    }\n    /**\n     * Get an array of {@link ServiceHost}s based on a provided\n     * {@link HostFilter} from the {@link ServiceRegistry#hosts} array.\n     *\n     * @public\n     * @memberof ServiceRegistry\n     * @param {HostFilter} [filter] - The inclusive filter for hosts to find.\n     * @returns {Array<ServiceHost>} - The filtered hosts.\n     */\n\n  }, {\n    key: \"find\",\n    value: function find() {\n      var _this = this;\n\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          active = _ref.active,\n          catalog = _ref.catalog,\n          cluster = _ref.cluster,\n          local = _ref.local,\n          priority = _ref.priority,\n          service = _ref.service,\n          url = _ref.url;\n\n      return this.hosts.filter(function (host) {\n        return _this.filterActive(active).includes(host) && _this.filterCatalog(catalog).includes(host) && _this.filterCluster(cluster).includes(host) && _this.filterLocal(local).includes(host) && _this.filterPriority(priority).includes(host) && _this.filterService(service).includes(host) && _this.filterUrl(url).includes(host);\n      });\n    }\n    /**\n     * Load a formatted array of {@link ServiceHost} constructor parameter\n     * transfer objects as instances of {@link ServiceHost} class objects to the\n     * {@link ServiceRegistry#hosts} array.\n     *\n     * @public\n     * @memberof ServiceRegistry\n     * @param {Array<ServiceHost.ConstructorPTO>} hosts\n     * @returns {this}\n     */\n\n  }, {\n    key: \"load\",\n    value: function load() {\n      var _this$hosts;\n\n      var hosts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []; // Validate that the provided hosts are eligible to be loaded.\n\n      var validHosts = hosts.filter(function (host) {\n        return !!ServiceRegistry.mapCatalogName({\n          id: host.catalog,\n          type: _constants.SERVICE_CATALOGS_ENUM_TYPES.STRING\n        });\n      }); // Load the eligible hosts.\n\n      (_this$hosts = this.hosts).push.apply(_this$hosts, (0, _toConsumableArray2.default)(validHosts.map(function (loadableHost) {\n        return new _serviceHost.default(loadableHost);\n      })));\n\n      return this;\n    }\n    /**\n     * Mark a collection of {@link ServiceHost} class objects from the\n     * {@link ServiceRegistry#hosts} array as replaced based on the provided\n     * {@link HostFilter}.\n     *\n     * @public\n     * @memberof ServiceRegistry\n     * @param {HostFilter} filter - The inclusive filter to mark replaced.\n     * @returns {Array<ServiceHost>} - The {@link ServiceHost}s marked replaced.\n     */\n\n  }, {\n    key: \"replaced\",\n    value: function replaced(filter) {\n      // Collect a list of hosts to mark as replaced based on the provided filter.\n      var replacing = this.find(filter); // Mark the hosts from the array as replaced.\n\n      replacing.forEach(function (host) {\n        host.setStatus({\n          replaced: true\n        });\n      }); // Return the marked hosts.\n\n      return replacing;\n    }\n    /**\n     * Reset the failed status of a collection of {@link ServiceHost} class\n     * objects from the {@link ServiceRegistry#hosts} array based on the provided\n     * {@link HostFilter}.\n     *\n     * @public\n     * @memberof ServiceRegistry\n     * @param {HostFilter} filter - The inclusive filter of hosts to reset.\n     * @returns {Array<ServiceHost>} - The {@link ServiceHost}s that reset.\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset(filter) {\n      // Collect a list of hosts to mark as replaced based on the provided filter.\n      var resetting = this.find(filter); // Mark the hosts from the array as replaced.\n\n      resetting.forEach(function (host) {\n        host.setStatus({\n          failed: false\n        });\n      }); // Return the marked hosts.\n\n      return resetting;\n    }\n    /**\n     * Convert a {@link SERVICE_CATALOGS} identifier or value to its associated\n     * idenfier or value.\n     *\n     * @public\n     * @static\n     * @memberof ServiceRegistry\n     * @param {Object} pto - The parameter transfer object.\n     * @property {string | number} pto.id - The identifier to convert in the enum.\n     * @property {SERVICE_CATALOGS_ENUM_TYPES} pto.type - The desired output.\n     * @returns {string|number} - The matching enum value or index.\n     */\n\n  }], [{\n    key: \"mapCatalogName\",\n    value: function mapCatalogName(_ref2) {\n      var id = _ref2.id,\n          type = _ref2.type; // Validate that the id is a number.\n\n      if (typeof id === 'number') {\n        // Validate that the desired type is a number.\n        if (type === _constants.SERVICE_CATALOGS_ENUM_TYPES.NUMBER) {\n          return _constants.SERVICE_CATALOGS[id] !== undefined ? id : undefined;\n        } // Validate that the desired type is a string.\n\n\n        if (type === _constants.SERVICE_CATALOGS_ENUM_TYPES.STRING) {\n          return _constants.SERVICE_CATALOGS[id];\n        }\n      } // Validate that the id is a string.\n\n\n      if (typeof id === 'string') {\n        // Validate that the desired type is a string.\n        if (type === _constants.SERVICE_CATALOGS_ENUM_TYPES.STRING) {\n          return _constants.SERVICE_CATALOGS.includes(id) ? id : undefined;\n        } // Validate that the desired type is a number.\n\n\n        if (type === _constants.SERVICE_CATALOGS_ENUM_TYPES.NUMBER) {\n          return _constants.SERVICE_CATALOGS.includes(id) ? _constants.SERVICE_CATALOGS.indexOf(id) : undefined;\n        }\n      }\n\n      return undefined;\n    }\n    /**\n     * Generate a formatted array based on the object received from the **U2C**\n     * service for usage in the {@link ServiceRegistry#load} method.\n     *\n     * @public\n     * @static\n     * @memberof ServiceRegistry\n     * @param {MapRemoteCatalogPTO} pto - The parameter transfer object.\n     * @throws - If the target catalog does not exist.\n     * @returns {Array<ServiceHost#ServiceHostConstructorPTO>}\n     */\n\n  }, {\n    key: \"mapRemoteCatalog\",\n    value: function mapRemoteCatalog(_ref3) {\n      var catalog = _ref3.catalog,\n          hostCatalog = _ref3.hostCatalog,\n          serviceLinks = _ref3.serviceLinks; // Collect the service catalog name if needed.\n\n      var catalogIndex = ServiceRegistry.mapCatalogName({\n        id: catalog,\n        type: _constants.SERVICE_CATALOGS_ENUM_TYPES.STRING\n      }); // Validate that the target catalog exists.\n\n      if (!_constants.SERVICE_CATALOGS.includes(catalogIndex)) {\n        throw new Error(\"service-catalogs: '\".concat(catalog, \"' is not a valid catalog\"));\n      } // Map the remote catalog to a mountable host array.\n\n\n      return (0, _keys.default)(hostCatalog).reduce(function (output, key) {\n        output.push.apply(output, (0, _toConsumableArray2.default)(hostCatalog[key].map(function (host) {\n          return {\n            catalog: catalogIndex,\n            defaultUri: serviceLinks[host.id.split(':')[3]],\n            hostGroup: key,\n            id: host.id,\n            priority: host.priority,\n            uri: host.host\n          };\n        })));\n        return output;\n      }, []);\n    }\n  }]);\n  return ServiceRegistry;\n}();\n\nexports.default = ServiceRegistry;","map":{"version":3,"mappings":"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","names":["ServiceRegistry","hosts","find","active","local","priority","reduce","map","host","hostReference","service","url","filter","removing","includes","failing","forEach","setStatus","failed","catalog","catalogs","catalogId","mapCatalogName","id","type","SERVICE_CATALOGS_ENUM_TYPES","STRING","length","cluster","clusters","filteredHosts","currentHost","foundHost","hostGroup","push","foundHostCatalogPriority","NUMBER","currentHostCatalogPriority","splice","indexOf","services","urls","_this","filterActive","filterCatalog","filterCluster","filterLocal","filterPriority","filterService","filterUrl","validHosts","loadableHost","ServiceHost","replacing","replaced","resetting","SERVICE_CATALOGS","undefined","hostCatalog","serviceLinks","catalogIndex","Error","output","key","defaultUri","split","uri"],"sources":["service-registry.js"],"sourcesContent":["import {\n  SERVICE_CATALOGS,\n  SERVICE_CATALOGS_ENUM_TYPES\n} from './constants';\nimport ServiceHost from './service-host';\n\n/**\n * The parameter transfer object for {@link ServiceRegistry#mapRemoteCatalog}.\n * This object is shaped to match the object returned from the **U2C** service.\n *\n * @typedef {Record<string, string>} RSL\n * @typedef {Record<string, Array<Record<string, number | string>>>} RHC\n *\n * @typedef {Object} MapRemoteCatalogPTO\n * @property {string} MapRemoteCatalogPTO.catalog - Service catalog name.\n * @property {RSL} MapRemoteCatalogPTO.serviceLinks - Service links.\n * @property {RHC} MapRemoteCatalogPTO.hostCatalog - Service host catalog.\n */\n\n/**\n * Service manipulation filter object for retrieving services within the\n * {@link ServiceRegistry} class.\n *\n * @typedef {Object} HostFilter\n * @property {boolean} [HostFilter.active] - Active state to filter.\n * @property {Array<string> | string} [HostFilter.catalog] - Catalogs to filter.\n * @property {Array<string> | string} [HostFilter.cluster] - Clusters to filter.\n * @property {boolean} [HostFilter.local] - Filter to the user's home cluster.\n * @property {boolean} [HostFilter.priority] - Filter for the highest priority.\n * @property {Array<string> | string} [HostFilter.service] - Services to filter.\n * @property {Array<string> | string} [HostFilter.url] - URL to filter.\n */\n\n/**\n * @class\n * @classdesc - Manages a collection of {@link ServiceHost} class objects.\n */\nexport default class ServiceRegistry {\n  /**\n   * Generate a new {@link ServiceHost}.\n   *\n   * @public\n   * @constructor\n   * @memberof ServiceHost\n   */\n  constructor() {\n    /**\n     * The collection of managed {@link ServiceHost}s.\n     *\n     * @instance\n     * @type {Array<ServiceHost>}\n     * @private\n     * @memberof ServiceRegistry\n     */\n    this.hosts = [];\n  }\n\n  /**\n   * An active, local, and priority mapped record of the current\n   * {@link ServiceCatalog#hosts}.\n   *\n   * @public\n   * @memberof ServiceCatalog\n   * @type {Record<string, string>}\n   */\n  get map() {\n    // Get a list of active, local, and priority-mapped hosts.\n    return this.find({\n      active: true,\n      local: true,\n      priority: true\n    }).reduce(\n      (map, host) => {\n        // Generate a new object to assign the existing map.\n        const hostReference = {};\n\n        // Assign the key:value pair for the service and url.\n        hostReference[host.service] = host.url;\n\n        // Assign the reference to the map and return.\n        return {...map, ...hostReference};\n      }, {}\n    );\n  }\n\n  /**\n   * Removes a collection of {@link ServiceHost} class objects from the\n   * {@link ServiceRegistry#hosts} array based on the provided\n   * {@link HostFilter}.\n   *\n   * @public\n   * @memberof ServiceRegistry\n   * @param {HostFilter} filter - The inclusive filter for hosts to remove.\n   * @returns {Array<ServiceHost>} - The removed {@link ServiceHost}s.\n   */\n  clear(filter) {\n    // Collect a list of hosts to remove based on the provided filter.\n    const removing = this.find(filter);\n\n    // Remove the hosts from the array.\n    this.hosts = this.hosts.filter(\n      (host) => !removing.includes(host)\n    );\n\n    // Return the removed hosts.\n    return removing;\n  }\n\n  /**\n   * Mark a collection of {@link ServiceHost} class objects from the\n   * {@link ServiceRegistry#hosts} array as failed based on the provided\n   * {@link HostFilter}.\n   *\n   * @public\n   * @memberof ServiceRegistry\n   * @param {HostFilter} filter - The inclusive filter for hosts to mark failed.\n   * @returns {Array<ServiceHost>} - The {@link ServiceHost}s marked failed.\n   */\n  failed(filter) {\n    // Collect a list of hosts to mark as failed based on the provided filter.\n    const failing = this.find(filter);\n\n    // Mark the hosts from the array as failed.\n    failing.forEach(\n      (host) => {\n        host.setStatus({failed: true});\n      }\n    );\n\n    // Return the marked hosts.\n    return failing;\n  }\n\n  /**\n   * Filter the {@link ServiceRegistry#hosts} array against their active states.\n   *\n   * @private\n   * @memberof ServiceRegistry\n   * @param {boolean} [active] - Filter for the host state.\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterActive(active) {\n    // Filter the host array if the active requirement is true.\n    return (typeof active === 'boolean') ?\n      this.hosts.filter((host) => host.active === active) :\n      [...this.hosts];\n  }\n\n  /**\n   * Filter the {@link ServiceRegistry#hosts} array against their assigned\n   * catalog values.\n   *\n   * @private\n   * @memberof ServiceRegistry\n   * @param {Array<string> | string} [catalog] - Catalogs to filter.\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterCatalog(catalog = []) {\n    // Generate a catalog names array based on the provided catalog param.\n    const catalogs = (Array.isArray(catalog) ? catalog : [catalog])\n      .map((catalogId) => ServiceRegistry.mapCatalogName({\n        id: catalogId,\n        type: SERVICE_CATALOGS_ENUM_TYPES.STRING\n      }) || catalogId);\n\n    // Filter the host array against the catalog names array.\n    return (catalogs.length > 0) ?\n      this.hosts.filter((host) => catalogs.includes(host.catalog)) :\n      [...this.hosts];\n  }\n\n  /**\n   * Filter the {@link ServiceRegistry#hosts} array against their assigned\n   * cluster values.\n   *\n   * @private\n   * @memberof ServiceRegistry\n   * @param {Array<string> | string} [cluster] - Clusters to filter for.\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterCluster(cluster = []) {\n    // Generate an array of clusters regardless of parameter type.\n    const clusters = (Array.isArray(cluster) ? cluster : [cluster]);\n\n    // Filter the host array against the provided clusters.\n    return (clusters.length > 0) ?\n      this.hosts.filter((host) => clusters.includes(host.id)) :\n      [...this.hosts];\n  }\n\n  /**\n   * Filter the {@link ServiceRegistry#hosts} array against their location in\n   * reference to the authenticated user.\n   *\n   * @private\n   * @memberof ServiceRegistry\n   * @param {boolean} [local] - Filter for the host location.\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterLocal(local) {\n    return (typeof local === 'boolean') ?\n      this.hosts.filter((host) => host.local === local) :\n      [...this.hosts];\n  }\n\n  /**\n   * Filter the {@link ServiceRegistry#hosts} array for the highest priority\n   * hosts for each specific service.\n   *\n   * @private\n   * @memberof ServiceRegistry\n   * @param {boolean} [priority] - Filter for the highest priority\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterPriority(priority) {\n    return (priority) ?\n      this.hosts.reduce(\n        (filteredHosts, currentHost) => {\n          // Validate that the current host is not active.\n          if (!currentHost.active) {\n            return filteredHosts;\n          }\n\n          // Determine if the filtered hosts array contains a host from the same\n          // host group.\n          const foundHost = filteredHosts.find(\n            (host) => host.hostGroup === currentHost.hostGroup\n          );\n\n          // Validate if a host was found.\n          if (!foundHost) {\n            filteredHosts.push(currentHost);\n\n            return filteredHosts;\n          }\n\n          // Map the found host's catalog to its priority value.\n          const foundHostCatalogPriority = ServiceRegistry.mapCatalogName({\n            id: foundHost.catalog,\n            type: SERVICE_CATALOGS_ENUM_TYPES.NUMBER\n          });\n\n          // Map the current host's catalog to its priority value.\n          const currentHostCatalogPriority = ServiceRegistry.mapCatalogName({\n            id: currentHost.catalog,\n            type: SERVICE_CATALOGS_ENUM_TYPES.NUMBER\n          });\n\n          // Validate if the found host has a lower priority than the current\n          // host.\n          if (\n            foundHostCatalogPriority < currentHostCatalogPriority ||\n            foundHost.priority < currentHost.priority\n          ) {\n            filteredHosts.splice(filteredHosts.indexOf(foundHost, 1));\n            filteredHosts.push(currentHost);\n          }\n\n          return filteredHosts;\n        }, []\n      ) : [...this.hosts];\n  }\n\n  /**\n   * Filter the {@link ServiceRegistry#hosts} array for hosts with a specified\n   * set of service names.\n   *\n   * @private\n   * @memberof ServiceRegistry\n   * @param {Array<string> | string} [service] - Services to filter.\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterService(service = []) {\n    // Generate an array of services regardless of parameter type.\n    const services = (Array.isArray(service) ? service : [service]);\n\n    // Filter the host array against the provided services.\n    return (services.length > 0) ?\n      this.hosts.filter((host) => services.includes(host.service)) :\n      [...this.hosts];\n  }\n\n  /**\n   * Filter the {@link ServiceRegistry#hosts} array for hosts with a specified\n   * set of URLs.\n   *\n   * @private\n   * @memberof ServiceRegistry\n   * @param {Array<string> | string} [url] - URL to filter.\n   * @returns {Array<ServiceHost>} - The filter host array.\n   */\n  filterUrl(url = []) {\n    // Generate an array of URLs regardless of the parameter type.\n    const urls = (Array.isArray(url) ? url : [url]);\n\n    // Filter the host array against the provided URLs.\n    return (urls.length > 0) ?\n      this.hosts.filter((host) => urls.includes(host.url)) :\n      [...this.hosts];\n  }\n\n  /**\n   * Get an array of {@link ServiceHost}s based on a provided\n   * {@link HostFilter} from the {@link ServiceRegistry#hosts} array.\n   *\n   * @public\n   * @memberof ServiceRegistry\n   * @param {HostFilter} [filter] - The inclusive filter for hosts to find.\n   * @returns {Array<ServiceHost>} - The filtered hosts.\n   */\n  find({\n    active,\n    catalog,\n    cluster,\n    local,\n    priority,\n    service,\n    url\n  } = {}) {\n    return this.hosts.filter(\n      (host) => (\n        this.filterActive(active).includes(host) &&\n        this.filterCatalog(catalog).includes(host) &&\n        this.filterCluster(cluster).includes(host) &&\n        this.filterLocal(local).includes(host) &&\n        this.filterPriority(priority).includes(host) &&\n        this.filterService(service).includes(host) &&\n        this.filterUrl(url).includes(host)\n      )\n    );\n  }\n\n  /**\n   * Load a formatted array of {@link ServiceHost} constructor parameter\n   * transfer objects as instances of {@link ServiceHost} class objects to the\n   * {@link ServiceRegistry#hosts} array.\n   *\n   * @public\n   * @memberof ServiceRegistry\n   * @param {Array<ServiceHost.ConstructorPTO>} hosts\n   * @returns {this}\n   */\n  load(hosts = []) {\n    // Validate that the provided hosts are eligible to be loaded.\n    const validHosts = hosts.filter((host) => !!(\n      ServiceRegistry.mapCatalogName({\n        id: host.catalog,\n        type: SERVICE_CATALOGS_ENUM_TYPES.STRING\n      })));\n\n    // Load the eligible hosts.\n    this.hosts.push(\n      ...validHosts.map((loadableHost) => new ServiceHost(loadableHost))\n    );\n\n    return this;\n  }\n\n  /**\n   * Mark a collection of {@link ServiceHost} class objects from the\n   * {@link ServiceRegistry#hosts} array as replaced based on the provided\n   * {@link HostFilter}.\n   *\n   * @public\n   * @memberof ServiceRegistry\n   * @param {HostFilter} filter - The inclusive filter to mark replaced.\n   * @returns {Array<ServiceHost>} - The {@link ServiceHost}s marked replaced.\n   */\n  replaced(filter) {\n    // Collect a list of hosts to mark as replaced based on the provided filter.\n    const replacing = this.find(filter);\n\n    // Mark the hosts from the array as replaced.\n    replacing.forEach(\n      (host) => {\n        host.setStatus({replaced: true});\n      }\n    );\n\n    // Return the marked hosts.\n    return replacing;\n  }\n\n  /**\n   * Reset the failed status of a collection of {@link ServiceHost} class\n   * objects from the {@link ServiceRegistry#hosts} array based on the provided\n   * {@link HostFilter}.\n   *\n   * @public\n   * @memberof ServiceRegistry\n   * @param {HostFilter} filter - The inclusive filter of hosts to reset.\n   * @returns {Array<ServiceHost>} - The {@link ServiceHost}s that reset.\n   */\n  reset(filter) {\n    // Collect a list of hosts to mark as replaced based on the provided filter.\n    const resetting = this.find(filter);\n\n    // Mark the hosts from the array as replaced.\n    resetting.forEach(\n      (host) => {\n        host.setStatus({failed: false});\n      }\n    );\n\n    // Return the marked hosts.\n    return resetting;\n  }\n\n  /**\n   * Convert a {@link SERVICE_CATALOGS} identifier or value to its associated\n   * idenfier or value.\n   *\n   * @public\n   * @static\n   * @memberof ServiceRegistry\n   * @param {Object} pto - The parameter transfer object.\n   * @property {string | number} pto.id - The identifier to convert in the enum.\n   * @property {SERVICE_CATALOGS_ENUM_TYPES} pto.type - The desired output.\n   * @returns {string|number} - The matching enum value or index.\n   */\n  static mapCatalogName({id, type}) {\n    // Validate that the id is a number.\n    if (typeof id === 'number') {\n      // Validate that the desired type is a number.\n      if (type === SERVICE_CATALOGS_ENUM_TYPES.NUMBER) {\n        return (SERVICE_CATALOGS[id] !== undefined) ? id : undefined;\n      }\n\n      // Validate that the desired type is a string.\n      if (type === SERVICE_CATALOGS_ENUM_TYPES.STRING) {\n        return SERVICE_CATALOGS[id];\n      }\n    }\n\n    // Validate that the id is a string.\n    if (typeof id === 'string') {\n      // Validate that the desired type is a string.\n      if (type === SERVICE_CATALOGS_ENUM_TYPES.STRING) {\n        return SERVICE_CATALOGS.includes(id) ? id : undefined;\n      }\n\n      // Validate that the desired type is a number.\n      if (type === SERVICE_CATALOGS_ENUM_TYPES.NUMBER) {\n        return (SERVICE_CATALOGS.includes(id)) ?\n          SERVICE_CATALOGS.indexOf(id) :\n          undefined;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Generate a formatted array based on the object received from the **U2C**\n   * service for usage in the {@link ServiceRegistry#load} method.\n   *\n   * @public\n   * @static\n   * @memberof ServiceRegistry\n   * @param {MapRemoteCatalogPTO} pto - The parameter transfer object.\n   * @throws - If the target catalog does not exist.\n   * @returns {Array<ServiceHost#ServiceHostConstructorPTO>}\n   */\n  static mapRemoteCatalog({catalog, hostCatalog, serviceLinks}) {\n    // Collect the service catalog name if needed.\n    const catalogIndex = ServiceRegistry.mapCatalogName({\n      id: catalog,\n      type: SERVICE_CATALOGS_ENUM_TYPES.STRING\n    });\n\n    // Validate that the target catalog exists.\n    if (!SERVICE_CATALOGS.includes(catalogIndex)) {\n      throw new Error(`service-catalogs: '${catalog}' is not a valid catalog`);\n    }\n\n    // Map the remote catalog to a mountable host array.\n    return Object.keys(hostCatalog).reduce((output, key) => {\n      output.push(\n        ...hostCatalog[key].map((host) => ({\n          catalog: catalogIndex,\n          defaultUri: serviceLinks[host.id.split(':')[3]],\n          hostGroup: key,\n          id: host.id,\n          priority: host.priority,\n          uri: host.host\n        }))\n      );\n\n      return output;\n    }, []);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}