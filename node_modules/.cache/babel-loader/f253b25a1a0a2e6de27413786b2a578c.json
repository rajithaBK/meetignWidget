{"ast":null,"code":"import * as asn1js from \"asn1js\";\nimport { getParametersValue, utilConcatBuf, clearProps } from \"pvutils\";\nimport { getOIDByAlgorithm, getRandomValues, getCrypto, getAlgorithmByOID, kdf } from \"./common.js\";\nimport OriginatorInfo from \"./OriginatorInfo.js\";\nimport RecipientInfo from \"./RecipientInfo.js\";\nimport EncryptedContentInfo from \"./EncryptedContentInfo.js\";\nimport Attribute from \"./Attribute.js\";\nimport AlgorithmIdentifier from \"./AlgorithmIdentifier.js\";\nimport RSAESOAEPParams from \"./RSAESOAEPParams.js\";\nimport KeyTransRecipientInfo from \"./KeyTransRecipientInfo.js\";\nimport IssuerAndSerialNumber from \"./IssuerAndSerialNumber.js\";\nimport RecipientKeyIdentifier from \"./RecipientKeyIdentifier.js\";\nimport RecipientEncryptedKey from \"./RecipientEncryptedKey.js\";\nimport KeyAgreeRecipientIdentifier from \"./KeyAgreeRecipientIdentifier.js\";\nimport KeyAgreeRecipientInfo from \"./KeyAgreeRecipientInfo.js\";\nimport RecipientEncryptedKeys from \"./RecipientEncryptedKeys.js\";\nimport KEKRecipientInfo from \"./KEKRecipientInfo.js\";\nimport KEKIdentifier from \"./KEKIdentifier.js\";\nimport PBKDF2Params from \"./PBKDF2Params.js\";\nimport PasswordRecipientinfo from \"./PasswordRecipientinfo.js\";\nimport ECCCMSSharedInfo from \"./ECCCMSSharedInfo.js\";\nimport OriginatorIdentifierOrKey from \"./OriginatorIdentifierOrKey.js\";\nimport OriginatorPublicKey from \"./OriginatorPublicKey.js\"; //**************************************************************************************\n\nconst defaultEncryptionParams = {\n  kdfAlgorithm: \"SHA-512\",\n  kekEncryptionLength: 256\n};\nconst curveLengthByName = {\n  \"P-256\": 256,\n  \"P-384\": 384,\n  \"P-521\": 528\n}; //**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\n\nexport default class EnvelopedData {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for EnvelopedData class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    //region Internal properties of the object\n\n    /**\r\n     * @type {number}\r\n     * @desc version\r\n     */\n    this.version = getParametersValue(parameters, \"version\", EnvelopedData.defaultValues(\"version\"));\n    if (\"originatorInfo\" in parameters)\n      /**\r\n       * @type {OriginatorInfo}\r\n       * @desc originatorInfo\r\n       */\n      this.originatorInfo = getParametersValue(parameters, \"originatorInfo\", EnvelopedData.defaultValues(\"originatorInfo\"));\n    /**\r\n     * @type {Array.<RecipientInfo>}\r\n     * @desc recipientInfos\r\n     */\n\n    this.recipientInfos = getParametersValue(parameters, \"recipientInfos\", EnvelopedData.defaultValues(\"recipientInfos\"));\n    /**\r\n     * @type {EncryptedContentInfo}\r\n     * @desc encryptedContentInfo\r\n     */\n\n    this.encryptedContentInfo = getParametersValue(parameters, \"encryptedContentInfo\", EnvelopedData.defaultValues(\"encryptedContentInfo\"));\n    if (\"unprotectedAttrs\" in parameters)\n      /**\r\n       * @type {Array.<Attribute>}\r\n       * @desc unprotectedAttrs\r\n       */\n      this.unprotectedAttrs = getParametersValue(parameters, \"unprotectedAttrs\", EnvelopedData.defaultValues(\"unprotectedAttrs\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"version\":\n        return 0;\n\n      case \"originatorInfo\":\n        return new OriginatorInfo();\n\n      case \"recipientInfos\":\n        return [];\n\n      case \"encryptedContentInfo\":\n        return new EncryptedContentInfo();\n\n      case \"unprotectedAttrs\":\n        return [];\n\n      default:\n        throw new Error(`Invalid member name for EnvelopedData class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Compare values with default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   * @param {*} memberValue Value to compare with default value\r\n   */\n\n\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"version\":\n        return memberValue === EnvelopedData.defaultValues(memberName);\n\n      case \"originatorInfo\":\n        return memberValue.certs.certificates.length === 0 && memberValue.crls.crls.length === 0;\n\n      case \"recipientInfos\":\n      case \"unprotectedAttrs\":\n        return memberValue.length === 0;\n\n      case \"encryptedContentInfo\":\n        return EncryptedContentInfo.compareWithDefault(\"contentType\", memberValue.contentType) && EncryptedContentInfo.compareWithDefault(\"contentEncryptionAlgorithm\", memberValue.contentEncryptionAlgorithm) && EncryptedContentInfo.compareWithDefault(\"encryptedContent\", memberValue.encryptedContent);\n\n      default:\n        throw new Error(`Invalid member name for EnvelopedData class: ${memberName}`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Return value of pre-defined ASN.1 schema for current class\r\n   *\r\n   * ASN.1 schema:\r\n   * ```asn1\r\n   * EnvelopedData ::= SEQUENCE {\r\n   *    version CMSVersion,\r\n   *    originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,\r\n   *    recipientInfos RecipientInfos,\r\n   *    encryptedContentInfo EncryptedContentInfo,\r\n   *    unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL }\r\n   * ```\r\n   *\r\n   * @param {Object} parameters Input parameters for the schema\r\n   * @returns {Object} asn1js schema object\r\n   */\n\n\n  static schema() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    /**\r\n     * @type {Object}\r\n     * @property {string} [blockName]\r\n     * @property {string} [version]\r\n     * @property {string} [originatorInfo]\r\n     * @property {string} [recipientInfos]\r\n     * @property {string} [encryptedContentInfo]\r\n     * @property {string} [unprotectedAttrs]\r\n     */\n    const names = getParametersValue(parameters, \"names\", {});\n    return new asn1js.Sequence({\n      name: names.blockName || \"\",\n      value: [new asn1js.Integer({\n        name: names.version || \"\"\n      }), new asn1js.Constructed({\n        name: names.originatorInfo || \"\",\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: OriginatorInfo.schema().valueBlock.value\n      }), new asn1js.Set({\n        value: [new asn1js.Repeated({\n          name: names.recipientInfos || \"\",\n          value: RecipientInfo.schema()\n        })]\n      }), EncryptedContentInfo.schema(names.encryptedContentInfo || {}), new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: [new asn1js.Repeated({\n          name: names.unprotectedAttrs || \"\",\n          value: Attribute.schema()\n        })]\n      })]\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Convert parsed asn1js object into current class\r\n   * @param {!Object} schema\r\n   */\n\n\n  fromSchema(schema) {\n    //region Clear input data first\n    clearProps(schema, [\"version\", \"originatorInfo\", \"recipientInfos\", \"encryptedContentInfo\", \"unprotectedAttrs\"]); //endregion\n    //region Check the schema is valid\n\n    const asn1 = asn1js.compareSchema(schema, schema, EnvelopedData.schema({\n      names: {\n        version: \"version\",\n        originatorInfo: \"originatorInfo\",\n        recipientInfos: \"recipientInfos\",\n        encryptedContentInfo: {\n          names: {\n            blockName: \"encryptedContentInfo\"\n          }\n        },\n        unprotectedAttrs: \"unprotectedAttrs\"\n      }\n    }));\n    if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for EnvelopedData\"); //endregion\n    //region Get internal properties from parsed schema\n\n    this.version = asn1.result.version.valueBlock.valueDec;\n\n    if (\"originatorInfo\" in asn1.result) {\n      this.originatorInfo = new OriginatorInfo({\n        schema: new asn1js.Sequence({\n          value: asn1.result.originatorInfo.valueBlock.value\n        })\n      });\n    }\n\n    this.recipientInfos = Array.from(asn1.result.recipientInfos, element => new RecipientInfo({\n      schema: element\n    }));\n    this.encryptedContentInfo = new EncryptedContentInfo({\n      schema: asn1.result.encryptedContentInfo\n    });\n    if (\"unprotectedAttrs\" in asn1.result) this.unprotectedAttrs = Array.from(asn1.result.unprotectedAttrs, element => new Attribute({\n      schema: element\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current object to asn1js object and set correct values\r\n   * @returns {Object} asn1js object\r\n   */\n\n\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n    outputArray.push(new asn1js.Integer({\n      value: this.version\n    }));\n\n    if (\"originatorInfo\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 0 // [0]\n\n        },\n        value: this.originatorInfo.toSchema().valueBlock.value\n      }));\n    }\n\n    outputArray.push(new asn1js.Set({\n      value: Array.from(this.recipientInfos, element => element.toSchema())\n    }));\n    outputArray.push(this.encryptedContentInfo.toSchema());\n\n    if (\"unprotectedAttrs\" in this) {\n      outputArray.push(new asn1js.Constructed({\n        optional: true,\n        idBlock: {\n          tagClass: 3,\n          // CONTEXT-SPECIFIC\n          tagNumber: 1 // [1]\n\n        },\n        value: Array.from(this.unprotectedAttrs, element => element.toSchema())\n      }));\n    } //endregion\n    //region Construct and return new ASN.1 schema for this object\n\n\n    return new asn1js.Sequence({\n      value: outputArray\n    }); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the class to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    const _object = {\n      version: this.version\n    };\n    if (\"originatorInfo\" in this) _object.originatorInfo = this.originatorInfo.toJSON();\n    _object.recipientInfos = Array.from(this.recipientInfos, element => element.toJSON());\n    _object.encryptedContentInfo = this.encryptedContentInfo.toJSON();\n    if (\"unprotectedAttrs\" in this) _object.unprotectedAttrs = Array.from(this.unprotectedAttrs, element => element.toJSON());\n    return _object;\n  } //**********************************************************************************\n\n  /**\r\n   * Helpers function for filling \"RecipientInfo\" based on recipient's certificate.\r\n   * Problem with WebCrypto is that for RSA certificates we have only one option - \"key transport\" and\r\n   * for ECC certificates we also have one option - \"key agreement\". As soon as Google will implement\r\n   * DH algorithm it would be possible to use \"key agreement\" also for RSA certificates.\r\n   * @param {Certificate} [certificate] Recipient's certificate\r\n   * @param {Object} [parameters] Additional parameters neccessary for \"fine tunning\" of encryption process\r\n   * @param {number} [variant] Variant = 1 is for \"key transport\", variant = 2 is for \"key agreement\". In fact the \"variant\" is unneccessary now because Google has no DH algorithm implementation. Thus key encryption scheme would be choosen by certificate type only: \"key transport\" for RSA and \"key agreement\" for ECC certificates.\r\n   */\n\n\n  addRecipientByCertificate(certificate, parameters, variant) {\n    //region Initialize encryption parameters\n    const encryptionParameters = Object.assign({\n      useOAEP: true,\n      oaepHashAlgorithm: \"SHA-512\"\n    }, defaultEncryptionParams, parameters || {}); //endregion\n    //region Check type of certificate\n\n    if (certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf(\"1.2.840.113549\") !== -1) variant = 1; // For the moment it is the only variant for RSA-based certificates\n    else {\n      if (certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf(\"1.2.840.10045\") !== -1) variant = 2; // For the moment it is the only variant for ECC-based certificates\n      else throw new Error(`Unknown type of certificate's public key: ${certificate.subjectPublicKeyInfo.algorithm.algorithmId}`);\n    } //endregion\n    //region Add new \"recipient\" depends on \"variant\" and certificate type\n\n    switch (variant) {\n      case 1:\n        // Key transport scheme\n        {\n          let algorithmId;\n          let algorithmParams;\n\n          if (encryptionParameters.useOAEP === true) {\n            //region keyEncryptionAlgorithm\n            algorithmId = getOIDByAlgorithm({\n              name: \"RSA-OAEP\"\n            });\n            if (algorithmId === \"\") throw new Error(\"Can not find OID for RSA-OAEP\"); //endregion\n            //region RSAES-OAEP-params\n\n            const hashOID = getOIDByAlgorithm({\n              name: encryptionParameters.oaepHashAlgorithm\n            });\n            if (hashOID === \"\") throw new Error(`Unknown OAEP hash algorithm: ${encryptionParameters.oaepHashAlgorithm}`);\n            const hashAlgorithm = new AlgorithmIdentifier({\n              algorithmId: hashOID,\n              algorithmParams: new asn1js.Null()\n            });\n            const rsaOAEPParams = new RSAESOAEPParams({\n              hashAlgorithm,\n              maskGenAlgorithm: new AlgorithmIdentifier({\n                algorithmId: \"1.2.840.113549.1.1.8\",\n                // id-mgf1\n                algorithmParams: hashAlgorithm.toSchema()\n              })\n            });\n            algorithmParams = rsaOAEPParams.toSchema(); //endregion\n          } else // Use old RSAES-PKCS1-v1_5 schema instead\n            {\n              //region keyEncryptionAlgorithm\n              algorithmId = getOIDByAlgorithm({\n                name: \"RSAES-PKCS1-v1_5\"\n              });\n              if (algorithmId === \"\") throw new Error(\"Can not find OID for RSAES-PKCS1-v1_5\"); //endregion\n\n              algorithmParams = new asn1js.Null();\n            } //region KeyTransRecipientInfo\n\n\n          const keyInfo = new KeyTransRecipientInfo({\n            version: 0,\n            rid: new IssuerAndSerialNumber({\n              issuer: certificate.issuer,\n              serialNumber: certificate.serialNumber\n            }),\n            keyEncryptionAlgorithm: new AlgorithmIdentifier({\n              algorithmId,\n              algorithmParams\n            }),\n            recipientCertificate: certificate // \"encryptedKey\" will be calculated in \"encrypt\" function\n\n          }); //endregion\n          //region Final values for \"CMS_ENVELOPED_DATA\"\n\n          this.recipientInfos.push(new RecipientInfo({\n            variant: 1,\n            value: keyInfo\n          })); //endregion\n        }\n        break;\n\n      case 2:\n        // Key agreement scheme\n        {\n          const recipientIdentifier = new KeyAgreeRecipientIdentifier({\n            variant: 1,\n            value: new IssuerAndSerialNumber({\n              issuer: certificate.issuer,\n              serialNumber: certificate.serialNumber\n            })\n          });\n\n          this._addKeyAgreeRecipientInfo(recipientIdentifier, encryptionParameters, {\n            recipientCertificate: certificate\n          });\n        }\n        break;\n\n      default:\n        throw new Error(`Unknown \"variant\" value: ${variant}`);\n    } //endregion\n\n\n    return true;\n  } //**********************************************************************************\n\n  /**\r\n   * Add recipient based on pre-defined data like password or KEK\r\n   * @param {ArrayBuffer} preDefinedData ArrayBuffer with pre-defined data\r\n   * @param {Object} parameters Additional parameters neccessary for \"fine tunning\" of encryption process\r\n   * @param {number} variant Variant = 1 for pre-defined \"key encryption key\" (KEK). Variant = 2 for password-based encryption.\r\n   */\n\n\n  addRecipientByPreDefinedData(preDefinedData, parameters, variant) {\n    //region Initial variables\n    const encryptionParameters = parameters || {}; //endregion\n    //region Check initial parameters\n\n    if (preDefinedData instanceof ArrayBuffer === false) throw new Error(\"Please pass \\\"preDefinedData\\\" in ArrayBuffer type\");\n    if (preDefinedData.byteLength === 0) throw new Error(\"Pre-defined data could have zero length\"); //endregion\n    //region Initialize encryption parameters\n\n    if (\"keyIdentifier\" in encryptionParameters === false) {\n      const keyIdentifierBuffer = new ArrayBuffer(16);\n      const keyIdentifierView = new Uint8Array(keyIdentifierBuffer);\n      getRandomValues(keyIdentifierView);\n      encryptionParameters.keyIdentifier = keyIdentifierBuffer;\n    }\n\n    if (\"hmacHashAlgorithm\" in encryptionParameters === false) encryptionParameters.hmacHashAlgorithm = \"SHA-512\";\n    if (\"iterationCount\" in encryptionParameters === false) encryptionParameters.iterationCount = 2048;\n\n    if (\"keyEncryptionAlgorithm\" in encryptionParameters === false) {\n      encryptionParameters.keyEncryptionAlgorithm = {\n        name: \"AES-KW\",\n        length: 256\n      };\n    }\n\n    if (\"keyEncryptionAlgorithmParams\" in encryptionParameters === false) encryptionParameters.keyEncryptionAlgorithmParams = new asn1js.Null(); //endregion\n    //region Add new recipient based on passed variant\n\n    switch (variant) {\n      case 1:\n        // KEKRecipientInfo\n        {\n          //region keyEncryptionAlgorithm\n          const kekOID = getOIDByAlgorithm(encryptionParameters.keyEncryptionAlgorithm);\n          if (kekOID === \"\") throw new Error(\"Incorrect value for \\\"keyEncryptionAlgorithm\\\"\"); //endregion\n          //region KEKRecipientInfo\n\n          const keyInfo = new KEKRecipientInfo({\n            version: 4,\n            kekid: new KEKIdentifier({\n              keyIdentifier: new asn1js.OctetString({\n                valueHex: encryptionParameters.keyIdentifier\n              })\n            }),\n            keyEncryptionAlgorithm: new AlgorithmIdentifier({\n              algorithmId: kekOID,\n\n              /*\r\n               For AES-KW params are NULL, but for other algorithm could another situation.\r\n               */\n              algorithmParams: encryptionParameters.keyEncryptionAlgorithmParams\n            }),\n            preDefinedKEK: preDefinedData // \"encryptedKey\" would be set in \"ecrypt\" function\n\n          }); //endregion\n          //region Final values for \"CMS_ENVELOPED_DATA\"\n\n          this.recipientInfos.push(new RecipientInfo({\n            variant: 3,\n            value: keyInfo\n          })); //endregion\n        }\n        break;\n\n      case 2:\n        // PasswordRecipientinfo\n        {\n          //region keyDerivationAlgorithm\n          const pbkdf2OID = getOIDByAlgorithm({\n            name: \"PBKDF2\"\n          });\n          if (pbkdf2OID === \"\") throw new Error(\"Can not find OID for PBKDF2\"); //endregion\n          //region Salt\n\n          const saltBuffer = new ArrayBuffer(64);\n          const saltView = new Uint8Array(saltBuffer);\n          getRandomValues(saltView); //endregion\n          //region HMAC-based algorithm\n\n          const hmacOID = getOIDByAlgorithm({\n            name: \"HMAC\",\n            hash: {\n              name: encryptionParameters.hmacHashAlgorithm\n            }\n          });\n          if (hmacOID === \"\") throw new Error(`Incorrect value for \"hmacHashAlgorithm\": ${encryptionParameters.hmacHashAlgorithm}`); //endregion\n          //region PBKDF2-params\n\n          const pbkdf2Params = new PBKDF2Params({\n            salt: new asn1js.OctetString({\n              valueHex: saltBuffer\n            }),\n            iterationCount: encryptionParameters.iterationCount,\n            prf: new AlgorithmIdentifier({\n              algorithmId: hmacOID,\n              algorithmParams: new asn1js.Null()\n            })\n          }); //endregion\n          //region keyEncryptionAlgorithm\n\n          const kekOID = getOIDByAlgorithm(encryptionParameters.keyEncryptionAlgorithm);\n          if (kekOID === \"\") throw new Error(\"Incorrect value for \\\"keyEncryptionAlgorithm\\\"\"); //endregion\n          //region PasswordRecipientinfo\n\n          const keyInfo = new PasswordRecipientinfo({\n            version: 0,\n            keyDerivationAlgorithm: new AlgorithmIdentifier({\n              algorithmId: pbkdf2OID,\n              algorithmParams: pbkdf2Params.toSchema()\n            }),\n            keyEncryptionAlgorithm: new AlgorithmIdentifier({\n              algorithmId: kekOID,\n\n              /*\r\n               For AES-KW params are NULL, but for other algorithm could be another situation.\r\n               */\n              algorithmParams: encryptionParameters.keyEncryptionAlgorithmParams\n            }),\n            password: preDefinedData // \"encryptedKey\" would be set in \"ecrypt\" function\n\n          }); //endregion\n          //region Final values for \"CMS_ENVELOPED_DATA\"\n\n          this.recipientInfos.push(new RecipientInfo({\n            variant: 4,\n            value: keyInfo\n          })); //endregion\n        }\n        break;\n\n      default:\n        throw new Error(`Unknown value for \"variant\": ${variant}`);\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Add a \"RecipientInfo\" using a KeyAgreeRecipientInfo of type RecipientKeyIdentifier.\r\n   * @param {CryptoKey} [key] Recipient's public key\r\n   * @param {ArrayBuffer} [keyId] The id for the recipient's public key\r\n   * @param {Object} [parameters] Additional parameters for \"fine tuning\" the encryption process\r\n   */\n\n\n  addRecipientByKeyIdentifier(key, keyId, parameters) {\n    //region Initialize encryption parameters\n    const encryptionParameters = Object.assign({}, defaultEncryptionParams, parameters || {}); //endregion\n\n    const recipientIdentifier = new KeyAgreeRecipientIdentifier({\n      variant: 2,\n      value: new RecipientKeyIdentifier({\n        subjectKeyIdentifier: new asn1js.OctetString({\n          valueHex: keyId\n        })\n      })\n    });\n\n    this._addKeyAgreeRecipientInfo(recipientIdentifier, encryptionParameters, {\n      recipientPublicKey: key\n    });\n  } //**********************************************************************************\n\n  /**\r\n   * Add a \"RecipientInfo\" using a KeyAgreeRecipientInfo of type RecipientKeyIdentifier.\r\n   * @param {KeyAgreeRecipientIdentifier} [recipientIdentifier] Recipient identifier\r\n   * @param {Object} [encryptionParameters] Additional parameters for \"fine tuning\" the encryption process\r\n   * @param {Object} [extraRecipientInfoParams] Additional params for KeyAgreeRecipientInfo\r\n   */\n\n\n  _addKeyAgreeRecipientInfo(recipientIdentifier, encryptionParameters, extraRecipientInfoParams) {\n    //region RecipientEncryptedKey\n    const encryptedKey = new RecipientEncryptedKey({\n      rid: recipientIdentifier // \"encryptedKey\" will be calculated in \"encrypt\" function\n\n    }); //endregion\n    //region keyEncryptionAlgorithm\n\n    const aesKWoid = getOIDByAlgorithm({\n      name: \"AES-KW\",\n      length: encryptionParameters.kekEncryptionLength\n    });\n    if (aesKWoid === \"\") throw new Error(`Unknown length for key encryption algorithm: ${encryptionParameters.kekEncryptionLength}`);\n    const aesKW = new AlgorithmIdentifier({\n      algorithmId: aesKWoid\n    }); //endregion\n    //region KeyAgreeRecipientInfo\n\n    const ecdhOID = getOIDByAlgorithm({\n      name: \"ECDH\",\n      kdf: encryptionParameters.kdfAlgorithm\n    });\n    if (ecdhOID === \"\") throw new Error(`Unknown KDF algorithm: ${encryptionParameters.kdfAlgorithm}`); // In fact there is no need in so long UKM, but RFC2631\n    // has requirement that \"UserKeyMaterial\" must be 512 bits long\n\n    const ukmBuffer = new ArrayBuffer(64);\n    const ukmView = new Uint8Array(ukmBuffer);\n    getRandomValues(ukmView); // Generate random values in 64 bytes long buffer\n\n    const recipientInfoParams = {\n      version: 3,\n      // \"originator\" will be calculated in \"encrypt\" function because ephemeral key would be generated there\n      ukm: new asn1js.OctetString({\n        valueHex: ukmBuffer\n      }),\n      keyEncryptionAlgorithm: new AlgorithmIdentifier({\n        algorithmId: ecdhOID,\n        algorithmParams: aesKW.toSchema()\n      }),\n      recipientEncryptedKeys: new RecipientEncryptedKeys({\n        encryptedKeys: [encryptedKey]\n      })\n    };\n    const keyInfo = new KeyAgreeRecipientInfo(Object.assign(recipientInfoParams, extraRecipientInfoParams)); //endregion\n    //region Final values for \"CMS_ENVELOPED_DATA\"\n\n    this.recipientInfos.push(new RecipientInfo({\n      variant: 2,\n      value: keyInfo\n    })); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Create a new CMS Enveloped Data content with encrypted data\r\n   * @param {Object} contentEncryptionAlgorithm WebCrypto algorithm. For the moment here could be only \"AES-CBC\" or \"AES-GCM\" algorithms.\r\n   * @param {ArrayBuffer} contentToEncrypt Content to encrypt\r\n   * @returns {Promise}\r\n   */\n\n\n  encrypt(contentEncryptionAlgorithm, contentToEncrypt) {\n    //region Initial variables\n    let sequence = Promise.resolve();\n    const ivBuffer = new ArrayBuffer(16); // For AES we need IV 16 bytes long\n\n    const ivView = new Uint8Array(ivBuffer);\n    getRandomValues(ivView);\n    const contentView = new Uint8Array(contentToEncrypt);\n    let sessionKey;\n    let encryptedContent;\n    let exportedSessionKey;\n    const recipientsPromises = [];\n\n    const _this = this; //endregion\n    //region Check for input parameters\n\n\n    const contentEncryptionOID = getOIDByAlgorithm(contentEncryptionAlgorithm);\n    if (contentEncryptionOID === \"\") return Promise.reject(\"Wrong \\\"contentEncryptionAlgorithm\\\" value\"); //endregion\n    //region Get a \"crypto\" extension\n\n    const crypto = getCrypto();\n    if (typeof crypto === \"undefined\") return Promise.reject(\"Unable to create WebCrypto object\"); //endregion\n    //region Generate new content encryption key\n\n    sequence = sequence.then(() => crypto.generateKey(contentEncryptionAlgorithm, true, [\"encrypt\"])); //endregion\n    //region Encrypt content\n\n    sequence = sequence.then(result => {\n      sessionKey = result;\n      return crypto.encrypt({\n        name: contentEncryptionAlgorithm.name,\n        iv: ivView\n      }, sessionKey, contentView);\n    }, error => Promise.reject(error)); //endregion\n    //region Export raw content of content encryption key\n\n    sequence = sequence.then(result => {\n      //region Create output OCTETSTRING with encrypted content\n      encryptedContent = result; //endregion\n\n      return crypto.exportKey(\"raw\", sessionKey);\n    }, error => Promise.reject(error)).then(result => {\n      exportedSessionKey = result;\n      return true;\n    }, error => Promise.reject(error)); //endregion\n    //region Append common information to CMS_ENVELOPED_DATA\n\n    sequence = sequence.then(() => {\n      this.version = 2;\n      this.encryptedContentInfo = new EncryptedContentInfo({\n        contentType: \"1.2.840.113549.1.7.1\",\n        // \"data\"\n        contentEncryptionAlgorithm: new AlgorithmIdentifier({\n          algorithmId: contentEncryptionOID,\n          algorithmParams: new asn1js.OctetString({\n            valueHex: ivBuffer\n          })\n        }),\n        encryptedContent: new asn1js.OctetString({\n          valueHex: encryptedContent\n        })\n      });\n    }, error => Promise.reject(error)); //endregion\n    //region Special sub-functions to work with each recipient's type\n\n    function SubKeyAgreeRecipientInfo(index) {\n      //region Initial variables\n      let currentSequence = Promise.resolve();\n      const recipientInfo = _this.recipientInfos[index];\n      let ecdhPublicKey;\n      let ecdhPrivateKey;\n      let recipientPublicKey;\n      let recipientCurve;\n      let recipientCurveLength;\n      let exportedECDHPublicKey; //endregion\n      //region Get public key and named curve from recipient's certificate or public key\n\n      currentSequence = currentSequence.then(() => {\n        if (recipientInfo.value.recipientPublicKey) {\n          recipientCurve = recipientInfo.value.recipientPublicKey.algorithm.namedCurve;\n          return recipientInfo.value.recipientPublicKey;\n        } else {\n          const curveObject = recipientInfo.value.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;\n          if (curveObject.constructor.blockName() !== asn1js.ObjectIdentifier.blockName()) return Promise.reject(`Incorrect \"recipientCertificate\" for index ${index}`);\n          const curveOID = curveObject.valueBlock.toString();\n\n          switch (curveOID) {\n            case \"1.2.840.10045.3.1.7\":\n              recipientCurve = \"P-256\";\n              break;\n\n            case \"1.3.132.0.34\":\n              recipientCurve = \"P-384\";\n              break;\n\n            case \"1.3.132.0.35\":\n              recipientCurve = \"P-521\";\n              break;\n\n            default:\n              return Promise.reject(`Incorrect curve OID for index ${index}`);\n          }\n\n          return recipientInfo.value.recipientCertificate.getPublicKey({\n            algorithm: {\n              algorithm: {\n                name: \"ECDH\",\n                namedCurve: recipientCurve\n              },\n              usages: []\n            }\n          });\n        }\n      }, error => Promise.reject(error)); //endregion\n      //region Generate ephemeral ECDH key\n\n      currentSequence = currentSequence.then(result => {\n        recipientPublicKey = result;\n        recipientCurveLength = curveLengthByName[recipientCurve];\n        return crypto.generateKey({\n          name: \"ECDH\",\n          namedCurve: recipientCurve\n        }, true, [\"deriveBits\"]);\n      }, error => Promise.reject(error)); //endregion\n      //region Export public key of ephemeral ECDH key pair\n\n      currentSequence = currentSequence.then(result => {\n        ecdhPublicKey = result.publicKey;\n        ecdhPrivateKey = result.privateKey;\n        return crypto.exportKey(\"spki\", ecdhPublicKey);\n      }, error => Promise.reject(error)); //endregion\n      //region Save public key of ephemeral ECDH key pair\n\n      currentSequence = currentSequence.then(result => {\n        exportedECDHPublicKey = result;\n      }, error => Promise.reject(error)); //endregion\n      //region Create shared secret\n\n      currentSequence = currentSequence.then(() => crypto.deriveBits({\n        name: \"ECDH\",\n        public: recipientPublicKey\n      }, ecdhPrivateKey, recipientCurveLength), error => Promise.reject(error)); //endregion\n      //region Apply KDF function to shared secret\n\n      currentSequence = currentSequence.then(\n      /**\r\n       * @param {ArrayBuffer} result\r\n       */\n      result => {\n        //region Get length of used AES-KW algorithm\n        const aesKWAlgorithm = new AlgorithmIdentifier({\n          schema: recipientInfo.value.keyEncryptionAlgorithm.algorithmParams\n        });\n        const KWalgorithm = getAlgorithmByOID(aesKWAlgorithm.algorithmId);\n        if (\"name\" in KWalgorithm === false) return Promise.reject(`Incorrect OID for key encryption algorithm: ${aesKWAlgorithm.algorithmId}`); //endregion\n        //region Translate AES-KW length to ArrayBuffer\n\n        let kwLength = KWalgorithm.length;\n        const kwLengthBuffer = new ArrayBuffer(4);\n        const kwLengthView = new Uint8Array(kwLengthBuffer);\n\n        for (let j = 3; j >= 0; j--) {\n          kwLengthView[j] = kwLength;\n          kwLength >>= 8;\n        } //endregion\n        //region Create and encode \"ECC-CMS-SharedInfo\" structure\n\n\n        const eccInfo = new ECCCMSSharedInfo({\n          keyInfo: new AlgorithmIdentifier({\n            algorithmId: aesKWAlgorithm.algorithmId\n          }),\n          entityUInfo: recipientInfo.value.ukm,\n          suppPubInfo: new asn1js.OctetString({\n            valueHex: kwLengthBuffer\n          })\n        });\n        const encodedInfo = eccInfo.toSchema().toBER(false); //endregion\n        //region Get SHA algorithm used together with ECDH\n\n        const ecdhAlgorithm = getAlgorithmByOID(recipientInfo.value.keyEncryptionAlgorithm.algorithmId);\n        if (\"name\" in ecdhAlgorithm === false) return Promise.reject(`Incorrect OID for key encryption algorithm: ${recipientInfo.value.keyEncryptionAlgorithm.algorithmId}`); //endregion\n\n        return kdf(ecdhAlgorithm.kdf, result, KWalgorithm.length, encodedInfo);\n      }, error => Promise.reject(error)); //endregion\n      //region Import AES-KW key from result of KDF function\n\n      currentSequence = currentSequence.then(result => crypto.importKey(\"raw\", result, {\n        name: \"AES-KW\"\n      }, true, [\"wrapKey\"]), error => Promise.reject(error)); //endregion\n      //region Finally wrap session key by using AES-KW algorithm\n\n      currentSequence = currentSequence.then(result => crypto.wrapKey(\"raw\", sessionKey, result, {\n        name: \"AES-KW\"\n      }), error => Promise.reject(error)); //endregion\n      //region Append all neccessary data to current CMS_RECIPIENT_INFO object\n\n      currentSequence = currentSequence.then(result => {\n        //region OriginatorIdentifierOrKey\n        const asn1 = asn1js.fromBER(exportedECDHPublicKey);\n        const originator = new OriginatorIdentifierOrKey();\n        originator.variant = 3;\n        originator.value = new OriginatorPublicKey({\n          schema: asn1.result\n        });\n        recipientInfo.value.originator = originator; //endregion\n        //region RecipientEncryptedKey\n\n        /*\r\n         We will not support using of same ephemeral key for many recipients\r\n         */\n\n        recipientInfo.value.recipientEncryptedKeys.encryptedKeys[0].encryptedKey = new asn1js.OctetString({\n          valueHex: result\n        }); //endregion\n\n        return {\n          ecdhPrivateKey\n        };\n      }, error => Promise.reject(error)); //endregion\n\n      return currentSequence;\n    }\n\n    async function SubKeyTransRecipientInfo(index) {\n      const algorithmParameters = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\n      if (\"name\" in algorithmParameters === false) throw new Error(`Unknown keyEncryptionAlgorithm: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`); //region RSA-OAEP case\n\n      if (algorithmParameters.name === \"RSA-OAEP\") {\n        const schema = _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams;\n        const rsaOAEPParams = new RSAESOAEPParams({\n          schema\n        });\n        algorithmParameters.hash = getAlgorithmByOID(rsaOAEPParams.hashAlgorithm.algorithmId);\n        if (\"name\" in algorithmParameters.hash === false) throw new Error(`Incorrect OID for hash algorithm: ${rsaOAEPParams.hashAlgorithm.algorithmId}`);\n      } //endregion\n\n\n      try {\n        const publicKey = await _this.recipientInfos[index].value.recipientCertificate.getPublicKey({\n          algorithm: {\n            algorithm: algorithmParameters,\n            usages: [\"encrypt\", \"wrapKey\"]\n          }\n        });\n        const encryptedKey = await crypto.encrypt(publicKey.algorithm, publicKey, exportedSessionKey); //region RecipientEncryptedKey\n\n        _this.recipientInfos[index].value.encryptedKey = new asn1js.OctetString({\n          valueHex: encryptedKey\n        }); //endregion\n      } catch (ex) {\n        const jjj = 0;\n      }\n    }\n\n    function SubKEKRecipientInfo(index) {\n      //region Initial variables\n      let currentSequence = Promise.resolve();\n      let kekAlgorithm; //endregion\n      //region Import KEK from pre-defined data\n\n      currentSequence = currentSequence.then(() => {\n        //region Get WebCrypto form of \"keyEncryptionAlgorithm\"\n        kekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\n        if (\"name\" in kekAlgorithm === false) return Promise.reject(`Incorrect OID for \"keyEncryptionAlgorithm\": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`); //endregion\n\n        return crypto.importKey(\"raw\", new Uint8Array(_this.recipientInfos[index].value.preDefinedKEK), kekAlgorithm, true, [\"wrapKey\"]); // Too specific for AES-KW\n      }, error => Promise.reject(error)); //endregion\n      //region Wrap previously exported session key\n\n      currentSequence = currentSequence.then(result => crypto.wrapKey(\"raw\", sessionKey, result, kekAlgorithm), error => Promise.reject(error)); //endregion\n      //region Append all neccessary data to current CMS_RECIPIENT_INFO object\n\n      currentSequence = currentSequence.then(result => {\n        //region RecipientEncryptedKey\n        _this.recipientInfos[index].value.encryptedKey = new asn1js.OctetString({\n          valueHex: result\n        }); //endregion\n      }, error => Promise.reject(error)); //endregion\n\n      return currentSequence;\n    }\n\n    function SubPasswordRecipientinfo(index) {\n      //region Initial variables\n      let currentSequence = Promise.resolve();\n      let pbkdf2Params;\n      let kekAlgorithm; //endregion\n      //region Check that we have encoded \"keyDerivationAlgorithm\" plus \"PBKDF2_params\" in there\n\n      currentSequence = currentSequence.then(() => {\n        if (\"keyDerivationAlgorithm\" in _this.recipientInfos[index].value === false) return Promise.reject(\"Please append encoded \\\"keyDerivationAlgorithm\\\"\");\n        if (\"algorithmParams\" in _this.recipientInfos[index].value.keyDerivationAlgorithm === false) return Promise.reject(\"Incorrectly encoded \\\"keyDerivationAlgorithm\\\"\");\n\n        try {\n          pbkdf2Params = new PBKDF2Params({\n            schema: _this.recipientInfos[index].value.keyDerivationAlgorithm.algorithmParams\n          });\n        } catch (ex) {\n          return Promise.reject(\"Incorrectly encoded \\\"keyDerivationAlgorithm\\\"\");\n        }\n\n        return Promise.resolve();\n      }, error => Promise.reject(error)); //endregion\n      //region Derive PBKDF2 key from \"password\" buffer\n\n      currentSequence = currentSequence.then(() => {\n        const passwordView = new Uint8Array(_this.recipientInfos[index].value.password);\n        return crypto.importKey(\"raw\", passwordView, \"PBKDF2\", false, [\"deriveKey\"]);\n      }, error => Promise.reject(error)); //endregion\n      //region Derive key for \"keyEncryptionAlgorithm\"\n\n      currentSequence = currentSequence.then(result => {\n        //region Get WebCrypto form of \"keyEncryptionAlgorithm\"\n        kekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\n        if (\"name\" in kekAlgorithm === false) return Promise.reject(`Incorrect OID for \"keyEncryptionAlgorithm\": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`); //endregion\n        //region Get HMAC hash algorithm\n\n        let hmacHashAlgorithm = \"SHA-1\";\n\n        if (\"prf\" in pbkdf2Params) {\n          const algorithm = getAlgorithmByOID(pbkdf2Params.prf.algorithmId);\n          if (\"name\" in algorithm === false) return Promise.reject(\"Incorrect OID for HMAC hash algorithm\");\n          hmacHashAlgorithm = algorithm.hash.name;\n        } //endregion\n        //region Get PBKDF2 \"salt\" value\n\n\n        const saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex); //endregion\n        //region Get PBKDF2 iterations count\n\n        const iterations = pbkdf2Params.iterationCount; //endregion\n\n        return crypto.deriveKey({\n          name: \"PBKDF2\",\n          hash: {\n            name: hmacHashAlgorithm\n          },\n          salt: saltView,\n          iterations\n        }, result, kekAlgorithm, true, [\"wrapKey\"]); // Usages are too specific for KEK algorithm\n      }, error => Promise.reject(error)); //endregion\n      //region Wrap previously exported session key (Also too specific for KEK algorithm)\n\n      currentSequence = currentSequence.then(result => crypto.wrapKey(\"raw\", sessionKey, result, kekAlgorithm), error => Promise.reject(error)); //endregion\n      //region Append all neccessary data to current CMS_RECIPIENT_INFO object\n\n      currentSequence = currentSequence.then(result => {\n        //region RecipientEncryptedKey\n        _this.recipientInfos[index].value.encryptedKey = new asn1js.OctetString({\n          valueHex: result\n        }); //endregion\n      }, error => Promise.reject(error)); //endregion\n\n      return currentSequence;\n    } //endregion\n    //region Create special routines for each \"recipient\"\n\n\n    sequence = sequence.then(() => {\n      for (let i = 0; i < this.recipientInfos.length; i++) {\n        //region Initial variables\n        let currentSequence = Promise.resolve(); //endregion\n\n        switch (this.recipientInfos[i].variant) {\n          case 1:\n            // KeyTransRecipientInfo\n            currentSequence = SubKeyTransRecipientInfo(i);\n            break;\n\n          case 2:\n            // KeyAgreeRecipientInfo\n            currentSequence = SubKeyAgreeRecipientInfo(i);\n            break;\n\n          case 3:\n            // KEKRecipientInfo\n            currentSequence = SubKEKRecipientInfo(i);\n            break;\n\n          case 4:\n            // PasswordRecipientinfo\n            currentSequence = SubPasswordRecipientinfo(i);\n            break;\n\n          default:\n            return Promise.reject(`Uknown recipient type in array with index ${i}`);\n        }\n\n        recipientsPromises.push(currentSequence);\n      }\n\n      return Promise.all(recipientsPromises);\n    }, error => Promise.reject(error)); //endregion\n\n    return sequence;\n  } //**********************************************************************************\n\n  /**\r\n   * Decrypt existing CMS Enveloped Data content\r\n   * @param {number} recipientIndex Index of recipient\r\n   * @param {Object} parameters Additional parameters\r\n   * @returns {Promise}\r\n   */\n\n\n  decrypt(recipientIndex, parameters) {\n    //region Initial variables\n    let sequence = Promise.resolve();\n    const decryptionParameters = parameters || {};\n\n    const _this = this; //endregion\n    //region Check for input parameters\n\n\n    if (recipientIndex + 1 > this.recipientInfos.length) return Promise.reject(`Maximum value for \"index\" is: ${this.recipientInfos.length - 1}`); //endregion\n    //region Get a \"crypto\" extension\n\n    const crypto = getCrypto();\n    if (typeof crypto === \"undefined\") return Promise.reject(\"Unable to create WebCrypto object\"); //endregion\n    //region Special sub-functions to work with each recipient's type\n\n    function SubKeyAgreeRecipientInfo(index) {\n      //region Initial variables\n      let currentSequence = Promise.resolve();\n      let recipientCurve;\n      let recipientCurveLength;\n      let curveOID;\n      let ecdhPrivateKey; //endregion\n\n      const originator = _this.recipientInfos[index].value.originator; //region Get \"namedCurve\" parameter from recipient's certificate\n\n      currentSequence = currentSequence.then(() => {\n        if (\"recipientCertificate\" in decryptionParameters) {\n          const curveObject = decryptionParameters.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;\n\n          if (curveObject.constructor.blockName() !== asn1js.ObjectIdentifier.blockName()) {\n            return Promise.reject(`Incorrect \"recipientCertificate\" for index ${index}`);\n          }\n\n          curveOID = curveObject.valueBlock.toString();\n        } else if (\"algorithmParams\" in originator.value.algorithm) {\n          const curveObject = originator.value.algorithm.algorithmParams;\n\n          if (curveObject.constructor.blockName() !== asn1js.ObjectIdentifier.blockName()) {\n            return Promise.reject(`Incorrect originator for index ${index}`);\n          }\n\n          curveOID = curveObject.valueBlock.toString();\n        } else {\n          return Promise.reject(\"Parameter \\\"recipientCertificate\\\" is mandatory for \\\"KeyAgreeRecipientInfo\\\" if algorithm params are missing from originator\");\n        }\n\n        if (\"recipientPrivateKey\" in decryptionParameters === false) return Promise.reject(\"Parameter \\\"recipientPrivateKey\\\" is mandatory for \\\"KeyAgreeRecipientInfo\\\"\");\n\n        switch (curveOID) {\n          case \"1.2.840.10045.3.1.7\":\n            recipientCurve = \"P-256\";\n            recipientCurveLength = 256;\n            break;\n\n          case \"1.3.132.0.34\":\n            recipientCurve = \"P-384\";\n            recipientCurveLength = 384;\n            break;\n\n          case \"1.3.132.0.35\":\n            recipientCurve = \"P-521\";\n            recipientCurveLength = 528;\n            break;\n\n          default:\n            return Promise.reject(`Incorrect curve OID for index ${index}`);\n        }\n\n        return crypto.importKey(\"pkcs8\", decryptionParameters.recipientPrivateKey, {\n          name: \"ECDH\",\n          namedCurve: recipientCurve\n        }, true, [\"deriveBits\"]);\n      }, error => Promise.reject(error)); //endregion\n      //region Import sender's ephemeral public key\n\n      currentSequence = currentSequence.then(result => {\n        ecdhPrivateKey = result; //region Change \"OriginatorPublicKey\" if \"curve\" parameter absent\n\n        if (\"algorithmParams\" in originator.value.algorithm === false) originator.value.algorithm.algorithmParams = new asn1js.ObjectIdentifier({\n          value: curveOID\n        }); //endregion\n        //region Create ArrayBuffer with sender's public key\n\n        const buffer = originator.value.toSchema().toBER(false); //endregion\n\n        return crypto.importKey(\"spki\", buffer, {\n          name: \"ECDH\",\n          namedCurve: recipientCurve\n        }, true, []);\n      }, error => Promise.reject(error)); //endregion\n      //region Create shared secret\n\n      currentSequence = currentSequence.then(result => crypto.deriveBits({\n        name: \"ECDH\",\n        public: result\n      }, ecdhPrivateKey, recipientCurveLength), error => Promise.reject(error)); //endregion\n      //region Apply KDF function to shared secret\n\n      function applyKDF(includeAlgorithmParams) {\n        includeAlgorithmParams = includeAlgorithmParams || false; //region Get length of used AES-KW algorithm\n\n        const aesKWAlgorithm = new AlgorithmIdentifier({\n          schema: _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams\n        });\n        const KWalgorithm = getAlgorithmByOID(aesKWAlgorithm.algorithmId);\n        if (\"name\" in KWalgorithm === false) return Promise.reject(`Incorrect OID for key encryption algorithm: ${aesKWAlgorithm.algorithmId}`); //endregion\n        //region Translate AES-KW length to ArrayBuffer\n\n        let kwLength = KWalgorithm.length;\n        const kwLengthBuffer = new ArrayBuffer(4);\n        const kwLengthView = new Uint8Array(kwLengthBuffer);\n\n        for (let j = 3; j >= 0; j--) {\n          kwLengthView[j] = kwLength;\n          kwLength >>= 8;\n        } //endregion\n        //region Create and encode \"ECC-CMS-SharedInfo\" structure\n\n\n        const keyInfoAlgorithm = {\n          algorithmId: aesKWAlgorithm.algorithmId\n        };\n\n        if (includeAlgorithmParams) {\n          keyInfoAlgorithm.algorithmParams = new asn1js.Null();\n        }\n\n        const eccInfo = new ECCCMSSharedInfo({\n          keyInfo: new AlgorithmIdentifier(keyInfoAlgorithm),\n          entityUInfo: _this.recipientInfos[index].value.ukm,\n          suppPubInfo: new asn1js.OctetString({\n            valueHex: kwLengthBuffer\n          })\n        });\n        const encodedInfo = eccInfo.toSchema().toBER(false); //endregion\n        //region Get SHA algorithm used together with ECDH\n\n        const ecdhAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\n        if (\"name\" in ecdhAlgorithm === false) return Promise.reject(`Incorrect OID for key encryption algorithm: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`); //endregion\n\n        return kdf(ecdhAlgorithm.kdf, sharedSecret, KWalgorithm.length, encodedInfo);\n      }\n\n      let sharedSecret;\n      currentSequence = currentSequence.then(\n      /**\r\n       * @param {ArrayBuffer} result\r\n       */\n      result => {\n        sharedSecret = result;\n        return applyKDF();\n      }, error => Promise.reject(error)); //endregion\n      //region Import AES-KW key from result of KDF function\n\n      function importAesKwKey(kdfResult) {\n        return crypto.importKey(\"raw\", kdfResult, {\n          name: \"AES-KW\"\n        }, true, [\"unwrapKey\"]);\n      }\n\n      currentSequence = currentSequence.then(importAesKwKey, error => Promise.reject(error)); //endregion\n      //region Finally unwrap session key\n\n      function unwrapSessionKey(aesKwKey) {\n        //region Get WebCrypto form of content encryption algorithm\n        const contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\n        if (\"name\" in contentEncryptionAlgorithm === false) return Promise.reject(`Incorrect \"contentEncryptionAlgorithm\": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`); //endregion\n\n        return crypto.unwrapKey(\"raw\", _this.recipientInfos[index].value.recipientEncryptedKeys.encryptedKeys[0].encryptedKey.valueBlock.valueHex, aesKwKey, {\n          name: \"AES-KW\"\n        }, contentEncryptionAlgorithm, true, [\"decrypt\"]);\n      }\n\n      currentSequence = currentSequence.then(result => unwrapSessionKey(result).catch(() => applyKDF(true).then(importAesKwKey).then(unwrapSessionKey)), error => Promise.reject(error)); //endregion\n\n      return currentSequence;\n    }\n\n    async function SubKeyTransRecipientInfo(index) {\n      if (\"recipientPrivateKey\" in decryptionParameters === false) throw new Error(\"Parameter \\\"recipientPrivateKey\\\" is mandatory for \\\"KeyTransRecipientInfo\\\"\");\n      const algorithmParameters = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\n      if (\"name\" in algorithmParameters === false) throw new Error(`Unknown keyEncryptionAlgorithm: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`); //region RSA-OAEP case\n\n      if (algorithmParameters.name === \"RSA-OAEP\") {\n        const schema = _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams;\n        const rsaOAEPParams = new RSAESOAEPParams({\n          schema\n        });\n        algorithmParameters.hash = getAlgorithmByOID(rsaOAEPParams.hashAlgorithm.algorithmId);\n        if (\"name\" in algorithmParameters.hash === false) throw new Error(`Incorrect OID for hash algorithm: ${rsaOAEPParams.hashAlgorithm.algorithmId}`);\n      } //endregion\n\n\n      const privateKey = await crypto.importKey(\"pkcs8\", decryptionParameters.recipientPrivateKey, algorithmParameters, true, [\"decrypt\"]);\n      const sessionKey = await crypto.decrypt(privateKey.algorithm, privateKey, _this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex); //region Get WebCrypto form of content encryption algorithm\n\n      const contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\n      if (\"name\" in contentEncryptionAlgorithm === false) throw new Error(`Incorrect \"contentEncryptionAlgorithm\": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`); //endregion\n\n      return crypto.importKey(\"raw\", sessionKey, contentEncryptionAlgorithm, true, [\"decrypt\"]);\n    }\n\n    function SubKEKRecipientInfo(index) {\n      //region Initial variables\n      let currentSequence = Promise.resolve();\n      let kekAlgorithm; //endregion\n      //region Import KEK from pre-defined data\n\n      currentSequence = currentSequence.then(() => {\n        if (\"preDefinedData\" in decryptionParameters === false) return Promise.reject(\"Parameter \\\"preDefinedData\\\" is mandatory for \\\"KEKRecipientInfo\\\"\"); //region Get WebCrypto form of \"keyEncryptionAlgorithm\"\n\n        kekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\n        if (\"name\" in kekAlgorithm === false) return Promise.reject(`Incorrect OID for \"keyEncryptionAlgorithm\": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`); //endregion\n\n        return crypto.importKey(\"raw\", decryptionParameters.preDefinedData, kekAlgorithm, true, [\"unwrapKey\"]); // Too specific for AES-KW\n      }, error => Promise.reject(error)); //endregion\n      //region Unwrap previously exported session key\n\n      currentSequence = currentSequence.then(result => {\n        //region Get WebCrypto form of content encryption algorithm\n        const contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\n        if (\"name\" in contentEncryptionAlgorithm === false) return Promise.reject(`Incorrect \"contentEncryptionAlgorithm\": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`); //endregion\n\n        return crypto.unwrapKey(\"raw\", _this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex, result, kekAlgorithm, contentEncryptionAlgorithm, true, [\"decrypt\"]);\n      }, error => Promise.reject(error)); //endregion\n\n      return currentSequence;\n    }\n\n    function SubPasswordRecipientinfo(index) {\n      //region Initial variables\n      let currentSequence = Promise.resolve();\n      let pbkdf2Params;\n      let kekAlgorithm; //endregion\n      //region Derive PBKDF2 key from \"password\" buffer\n\n      currentSequence = currentSequence.then(() => {\n        if (\"preDefinedData\" in decryptionParameters === false) return Promise.reject(\"Parameter \\\"preDefinedData\\\" is mandatory for \\\"KEKRecipientInfo\\\"\");\n        if (\"keyDerivationAlgorithm\" in _this.recipientInfos[index].value === false) return Promise.reject(\"Please append encoded \\\"keyDerivationAlgorithm\\\"\");\n        if (\"algorithmParams\" in _this.recipientInfos[index].value.keyDerivationAlgorithm === false) return Promise.reject(\"Incorrectly encoded \\\"keyDerivationAlgorithm\\\"\");\n\n        try {\n          pbkdf2Params = new PBKDF2Params({\n            schema: _this.recipientInfos[index].value.keyDerivationAlgorithm.algorithmParams\n          });\n        } catch (ex) {\n          return Promise.reject(\"Incorrectly encoded \\\"keyDerivationAlgorithm\\\"\");\n        }\n\n        return crypto.importKey(\"raw\", decryptionParameters.preDefinedData, \"PBKDF2\", false, [\"deriveKey\"]);\n      }, error => Promise.reject(error)); //endregion\n      //region Derive key for \"keyEncryptionAlgorithm\"\n\n      currentSequence = currentSequence.then(result => {\n        //region Get WebCrypto form of \"keyEncryptionAlgorithm\"\n        kekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\n        if (\"name\" in kekAlgorithm === false) return Promise.reject(`Incorrect OID for \"keyEncryptionAlgorithm\": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`); //endregion\n        //region Get HMAC hash algorithm\n\n        let hmacHashAlgorithm = \"SHA-1\";\n\n        if (\"prf\" in pbkdf2Params) {\n          const algorithm = getAlgorithmByOID(pbkdf2Params.prf.algorithmId);\n          if (\"name\" in algorithm === false) return Promise.reject(\"Incorrect OID for HMAC hash algorithm\");\n          hmacHashAlgorithm = algorithm.hash.name;\n        } //endregion\n        //region Get PBKDF2 \"salt\" value\n\n\n        const saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex); //endregion\n        //region Get PBKDF2 iterations count\n\n        const iterations = pbkdf2Params.iterationCount; //endregion\n\n        return crypto.deriveKey({\n          name: \"PBKDF2\",\n          hash: {\n            name: hmacHashAlgorithm\n          },\n          salt: saltView,\n          iterations\n        }, result, kekAlgorithm, true, [\"unwrapKey\"]); // Usages are too specific for KEK algorithm\n      }, error => Promise.reject(error)); //endregion\n      //region Unwrap previously exported session key\n\n      currentSequence = currentSequence.then(result => {\n        //region Get WebCrypto form of content encryption algorithm\n        const contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\n        if (\"name\" in contentEncryptionAlgorithm === false) return Promise.reject(`Incorrect \"contentEncryptionAlgorithm\": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`); //endregion\n\n        return crypto.unwrapKey(\"raw\", _this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex, result, kekAlgorithm, contentEncryptionAlgorithm, true, [\"decrypt\"]);\n      }, error => Promise.reject(error)); //endregion\n\n      return currentSequence;\n    } //endregion\n    //region Perform steps, specific to each type of session key encryption\n\n\n    sequence = sequence.then(() => {\n      //region Initial variables\n      let currentSequence = Promise.resolve(); //endregion\n\n      switch (this.recipientInfos[recipientIndex].variant) {\n        case 1:\n          // KeyTransRecipientInfo\n          currentSequence = SubKeyTransRecipientInfo(recipientIndex);\n          break;\n\n        case 2:\n          // KeyAgreeRecipientInfo\n          currentSequence = SubKeyAgreeRecipientInfo(recipientIndex);\n          break;\n\n        case 3:\n          // KEKRecipientInfo\n          currentSequence = SubKEKRecipientInfo(recipientIndex);\n          break;\n\n        case 4:\n          // PasswordRecipientinfo\n          currentSequence = SubPasswordRecipientinfo(recipientIndex);\n          break;\n\n        default:\n          return Promise.reject(`Uknown recipient type in array with index ${recipientIndex}`);\n      }\n\n      return currentSequence;\n    }, error => Promise.reject(error)); //endregion\n    //region Finally decrypt data by session key\n\n    sequence = sequence.then(result => {\n      //region Get WebCrypto form of content encryption algorithm\n      const contentEncryptionAlgorithm = getAlgorithmByOID(this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\n      if (\"name\" in contentEncryptionAlgorithm === false) return Promise.reject(`Incorrect \"contentEncryptionAlgorithm\": ${this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`); //endregion\n      //region Get \"intialization vector\" for content encryption algorithm\n\n      const ivBuffer = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams.valueBlock.valueHex;\n      const ivView = new Uint8Array(ivBuffer); //endregion\n      //region Create correct data block for decryption\n\n      let dataBuffer = new ArrayBuffer(0);\n      if (this.encryptedContentInfo.encryptedContent.idBlock.isConstructed === false) dataBuffer = this.encryptedContentInfo.encryptedContent.valueBlock.valueHex;else {\n        for (const content of this.encryptedContentInfo.encryptedContent.valueBlock.value) dataBuffer = utilConcatBuf(dataBuffer, content.valueBlock.valueHex);\n      } //endregion\n\n      return crypto.decrypt({\n        name: contentEncryptionAlgorithm.name,\n        iv: ivView\n      }, result, dataBuffer);\n    }, error => Promise.reject(error)); //endregion\n\n    return sequence;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************","map":{"version":3,"sources":["C:/Users/rkanthet/Documents/test_window_object/node_modules/pkijs/src/EnvelopedData.js"],"names":["asn1js","getParametersValue","utilConcatBuf","clearProps","getOIDByAlgorithm","getRandomValues","getCrypto","getAlgorithmByOID","kdf","OriginatorInfo","RecipientInfo","EncryptedContentInfo","Attribute","AlgorithmIdentifier","RSAESOAEPParams","KeyTransRecipientInfo","IssuerAndSerialNumber","RecipientKeyIdentifier","RecipientEncryptedKey","KeyAgreeRecipientIdentifier","KeyAgreeRecipientInfo","RecipientEncryptedKeys","KEKRecipientInfo","KEKIdentifier","PBKDF2Params","PasswordRecipientinfo","ECCCMSSharedInfo","OriginatorIdentifierOrKey","OriginatorPublicKey","defaultEncryptionParams","kdfAlgorithm","kekEncryptionLength","curveLengthByName","EnvelopedData","constructor","parameters","version","defaultValues","originatorInfo","recipientInfos","encryptedContentInfo","unprotectedAttrs","fromSchema","schema","memberName","Error","compareWithDefault","memberValue","certs","certificates","length","crls","contentType","contentEncryptionAlgorithm","encryptedContent","names","Sequence","name","blockName","value","Integer","Constructed","optional","idBlock","tagClass","tagNumber","valueBlock","Set","Repeated","asn1","compareSchema","verified","result","valueDec","Array","from","element","toSchema","outputArray","push","toJSON","_object","addRecipientByCertificate","certificate","variant","encryptionParameters","Object","assign","useOAEP","oaepHashAlgorithm","subjectPublicKeyInfo","algorithm","algorithmId","indexOf","algorithmParams","hashOID","hashAlgorithm","Null","rsaOAEPParams","maskGenAlgorithm","keyInfo","rid","issuer","serialNumber","keyEncryptionAlgorithm","recipientCertificate","recipientIdentifier","_addKeyAgreeRecipientInfo","addRecipientByPreDefinedData","preDefinedData","ArrayBuffer","byteLength","keyIdentifierBuffer","keyIdentifierView","Uint8Array","keyIdentifier","hmacHashAlgorithm","iterationCount","keyEncryptionAlgorithmParams","kekOID","kekid","OctetString","valueHex","preDefinedKEK","pbkdf2OID","saltBuffer","saltView","hmacOID","hash","pbkdf2Params","salt","prf","keyDerivationAlgorithm","password","addRecipientByKeyIdentifier","key","keyId","subjectKeyIdentifier","recipientPublicKey","extraRecipientInfoParams","encryptedKey","aesKWoid","aesKW","ecdhOID","ukmBuffer","ukmView","recipientInfoParams","ukm","recipientEncryptedKeys","encryptedKeys","encrypt","contentToEncrypt","sequence","Promise","resolve","ivBuffer","ivView","contentView","sessionKey","exportedSessionKey","recipientsPromises","_this","contentEncryptionOID","reject","crypto","then","generateKey","iv","error","exportKey","SubKeyAgreeRecipientInfo","index","currentSequence","recipientInfo","ecdhPublicKey","ecdhPrivateKey","recipientCurve","recipientCurveLength","exportedECDHPublicKey","namedCurve","curveObject","ObjectIdentifier","curveOID","toString","getPublicKey","usages","publicKey","privateKey","deriveBits","public","aesKWAlgorithm","KWalgorithm","kwLength","kwLengthBuffer","kwLengthView","j","eccInfo","entityUInfo","suppPubInfo","encodedInfo","toBER","ecdhAlgorithm","importKey","wrapKey","fromBER","originator","SubKeyTransRecipientInfo","algorithmParameters","ex","jjj","SubKEKRecipientInfo","kekAlgorithm","SubPasswordRecipientinfo","passwordView","iterations","deriveKey","i","all","decrypt","recipientIndex","decryptionParameters","recipientPrivateKey","buffer","applyKDF","includeAlgorithmParams","keyInfoAlgorithm","sharedSecret","importAesKwKey","kdfResult","unwrapSessionKey","aesKwKey","unwrapKey","catch","dataBuffer","isConstructed","content"],"mappings":"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","sourcesContent":["import * as asn1js from \"asn1js\";\r\nimport { getParametersValue, utilConcatBuf, clearProps } from \"pvutils\";\r\nimport { getOIDByAlgorithm, getRandomValues, getCrypto, getAlgorithmByOID, kdf } from \"./common.js\";\r\nimport OriginatorInfo from \"./OriginatorInfo.js\";\r\nimport RecipientInfo from \"./RecipientInfo.js\";\r\nimport EncryptedContentInfo from \"./EncryptedContentInfo.js\";\r\nimport Attribute from \"./Attribute.js\";\r\nimport AlgorithmIdentifier from \"./AlgorithmIdentifier.js\";\r\nimport RSAESOAEPParams from \"./RSAESOAEPParams.js\";\r\nimport KeyTransRecipientInfo from \"./KeyTransRecipientInfo.js\";\r\nimport IssuerAndSerialNumber from \"./IssuerAndSerialNumber.js\";\r\nimport RecipientKeyIdentifier from \"./RecipientKeyIdentifier.js\";\r\nimport RecipientEncryptedKey from \"./RecipientEncryptedKey.js\";\r\nimport KeyAgreeRecipientIdentifier from \"./KeyAgreeRecipientIdentifier.js\";\r\nimport KeyAgreeRecipientInfo from \"./KeyAgreeRecipientInfo.js\";\r\nimport RecipientEncryptedKeys from \"./RecipientEncryptedKeys.js\";\r\nimport KEKRecipientInfo from \"./KEKRecipientInfo.js\";\r\nimport KEKIdentifier from \"./KEKIdentifier.js\";\r\nimport PBKDF2Params from \"./PBKDF2Params.js\";\r\nimport PasswordRecipientinfo from \"./PasswordRecipientinfo.js\";\r\nimport ECCCMSSharedInfo from \"./ECCCMSSharedInfo.js\";\r\nimport OriginatorIdentifierOrKey from \"./OriginatorIdentifierOrKey.js\";\r\nimport OriginatorPublicKey from \"./OriginatorPublicKey.js\";\r\n//**************************************************************************************\r\nconst defaultEncryptionParams = {\r\n\tkdfAlgorithm: \"SHA-512\",\r\n\tkekEncryptionLength: 256\r\n};\r\nconst curveLengthByName = {\r\n\t\"P-256\": 256,\r\n\t\"P-384\": 384,\r\n\t\"P-521\": 528\r\n};\r\n//**************************************************************************************\r\n/**\r\n * Class from RFC5652\r\n */\r\nexport default class EnvelopedData\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for EnvelopedData class\r\n\t * @param {Object} [parameters={}]\r\n\t * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\t//region Internal properties of the object\r\n\t\t/**\r\n\t\t * @type {number}\r\n\t\t * @desc version\r\n\t\t */\r\n\t\tthis.version = getParametersValue(parameters, \"version\", EnvelopedData.defaultValues(\"version\"));\r\n\r\n\t\tif(\"originatorInfo\" in parameters)\r\n\t\t\t/**\r\n\t\t\t * @type {OriginatorInfo}\r\n\t\t\t * @desc originatorInfo\r\n\t\t\t */\r\n\t\t\tthis.originatorInfo = getParametersValue(parameters, \"originatorInfo\", EnvelopedData.defaultValues(\"originatorInfo\"));\r\n\r\n\t\t/**\r\n\t\t * @type {Array.<RecipientInfo>}\r\n\t\t * @desc recipientInfos\r\n\t\t */\r\n\t\tthis.recipientInfos = getParametersValue(parameters, \"recipientInfos\", EnvelopedData.defaultValues(\"recipientInfos\"));\r\n\t\t/**\r\n\t\t * @type {EncryptedContentInfo}\r\n\t\t * @desc encryptedContentInfo\r\n\t\t */\r\n\t\tthis.encryptedContentInfo = getParametersValue(parameters, \"encryptedContentInfo\", EnvelopedData.defaultValues(\"encryptedContentInfo\"));\r\n\r\n\t\tif(\"unprotectedAttrs\" in parameters)\r\n\t\t\t/**\r\n\t\t\t * @type {Array.<Attribute>}\r\n\t\t\t * @desc unprotectedAttrs\r\n\t\t\t */\r\n\t\t\tthis.unprotectedAttrs = getParametersValue(parameters, \"unprotectedAttrs\", EnvelopedData.defaultValues(\"unprotectedAttrs\"));\r\n\t\t//endregion\r\n\r\n\t\t//region If input argument array contains \"schema\" for this object\r\n\t\tif(\"schema\" in parameters)\r\n\t\t\tthis.fromSchema(parameters.schema);\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Return default values for all class members\r\n\t * @param {string} memberName String name for a class member\r\n\t */\r\n\tstatic defaultValues(memberName)\r\n\t{\r\n\t\tswitch(memberName)\r\n\t\t{\r\n\t\t\tcase \"version\":\r\n\t\t\t\treturn 0;\r\n\t\t\tcase \"originatorInfo\":\r\n\t\t\t\treturn new OriginatorInfo();\r\n\t\t\tcase \"recipientInfos\":\r\n\t\t\t\treturn [];\r\n\t\t\tcase \"encryptedContentInfo\":\r\n\t\t\t\treturn new EncryptedContentInfo();\r\n\t\t\tcase \"unprotectedAttrs\":\r\n\t\t\t\treturn [];\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Invalid member name for EnvelopedData class: ${memberName}`);\r\n\t\t}\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Compare values with default values for all class members\r\n\t * @param {string} memberName String name for a class member\r\n\t * @param {*} memberValue Value to compare with default value\r\n\t */\r\n\tstatic compareWithDefault(memberName, memberValue)\r\n\t{\r\n\t\tswitch(memberName)\r\n\t\t{\r\n\t\t\tcase \"version\":\r\n\t\t\t\treturn (memberValue === EnvelopedData.defaultValues(memberName));\r\n\t\t\tcase \"originatorInfo\":\r\n\t\t\t\treturn ((memberValue.certs.certificates.length === 0) && (memberValue.crls.crls.length === 0));\r\n\t\t\tcase \"recipientInfos\":\r\n\t\t\tcase \"unprotectedAttrs\":\r\n\t\t\t\treturn (memberValue.length === 0);\r\n\t\t\tcase \"encryptedContentInfo\":\r\n\t\t\t\treturn ((EncryptedContentInfo.compareWithDefault(\"contentType\", memberValue.contentType)) &&\r\n\t\t\t\t(EncryptedContentInfo.compareWithDefault(\"contentEncryptionAlgorithm\", memberValue.contentEncryptionAlgorithm) &&\r\n\t\t\t\t(EncryptedContentInfo.compareWithDefault(\"encryptedContent\", memberValue.encryptedContent))));\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Invalid member name for EnvelopedData class: ${memberName}`);\r\n\t\t}\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Return value of pre-defined ASN.1 schema for current class\r\n\t *\r\n\t * ASN.1 schema:\r\n\t * ```asn1\r\n\t * EnvelopedData ::= SEQUENCE {\r\n\t *    version CMSVersion,\r\n\t *    originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,\r\n\t *    recipientInfos RecipientInfos,\r\n\t *    encryptedContentInfo EncryptedContentInfo,\r\n\t *    unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL }\r\n\t * ```\r\n\t *\r\n\t * @param {Object} parameters Input parameters for the schema\r\n\t * @returns {Object} asn1js schema object\r\n\t */\r\n\tstatic schema(parameters = {})\r\n\t{\r\n\t\t/**\r\n\t\t * @type {Object}\r\n\t\t * @property {string} [blockName]\r\n\t\t * @property {string} [version]\r\n\t\t * @property {string} [originatorInfo]\r\n\t\t * @property {string} [recipientInfos]\r\n\t\t * @property {string} [encryptedContentInfo]\r\n\t\t * @property {string} [unprotectedAttrs]\r\n\t\t */\r\n\t\tconst names = getParametersValue(parameters, \"names\", {});\r\n\r\n\t\treturn (new asn1js.Sequence({\r\n\t\t\tname: (names.blockName || \"\"),\r\n\t\t\tvalue: [\r\n\t\t\t\tnew asn1js.Integer({ name: (names.version || \"\") }),\r\n\t\t\t\tnew asn1js.Constructed({\r\n\t\t\t\t\tname: (names.originatorInfo || \"\"),\r\n\t\t\t\t\toptional: true,\r\n\t\t\t\t\tidBlock: {\r\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\r\n\t\t\t\t\t\ttagNumber: 0 // [0]\r\n\t\t\t\t\t},\r\n\t\t\t\t\tvalue: OriginatorInfo.schema().valueBlock.value\r\n\t\t\t\t}),\r\n\t\t\t\tnew asn1js.Set({\r\n\t\t\t\t\tvalue: [\r\n\t\t\t\t\t\tnew asn1js.Repeated({\r\n\t\t\t\t\t\t\tname: (names.recipientInfos || \"\"),\r\n\t\t\t\t\t\t\tvalue: RecipientInfo.schema()\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t]\r\n\t\t\t\t}),\r\n\t\t\t\tEncryptedContentInfo.schema(names.encryptedContentInfo || {}),\r\n\t\t\t\tnew asn1js.Constructed({\r\n\t\t\t\t\toptional: true,\r\n\t\t\t\t\tidBlock: {\r\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\r\n\t\t\t\t\t\ttagNumber: 1 // [1]\r\n\t\t\t\t\t},\r\n\t\t\t\t\tvalue: [\r\n\t\t\t\t\t\tnew asn1js.Repeated({\r\n\t\t\t\t\t\t\tname: (names.unprotectedAttrs || \"\"),\r\n\t\t\t\t\t\t\tvalue: Attribute.schema()\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t]\r\n\t\t\t\t})\r\n\t\t\t]\r\n\t\t}));\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convert parsed asn1js object into current class\r\n\t * @param {!Object} schema\r\n\t */\r\n\tfromSchema(schema)\r\n\t{\r\n\t\t//region Clear input data first\r\n\t\tclearProps(schema, [\r\n\t\t\t\"version\",\r\n\t\t\t\"originatorInfo\",\r\n\t\t\t\"recipientInfos\",\r\n\t\t\t\"encryptedContentInfo\",\r\n\t\t\t\"unprotectedAttrs\"\r\n\t\t]);\r\n\t\t//endregion\r\n\r\n\t\t//region Check the schema is valid\r\n\t\tconst asn1 = asn1js.compareSchema(schema,\r\n\t\t\tschema,\r\n\t\t\tEnvelopedData.schema({\r\n\t\t\t\tnames: {\r\n\t\t\t\t\tversion: \"version\",\r\n\t\t\t\t\toriginatorInfo: \"originatorInfo\",\r\n\t\t\t\t\trecipientInfos: \"recipientInfos\",\r\n\t\t\t\t\tencryptedContentInfo: {\r\n\t\t\t\t\t\tnames: {\r\n\t\t\t\t\t\t\tblockName: \"encryptedContentInfo\"\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tunprotectedAttrs: \"unprotectedAttrs\"\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t);\r\n\r\n\t\tif(asn1.verified === false)\r\n\t\t\tthrow new Error(\"Object's schema was not verified against input data for EnvelopedData\");\r\n\t\t//endregion\r\n\r\n\t\t//region Get internal properties from parsed schema\r\n\t\tthis.version = asn1.result.version.valueBlock.valueDec;\r\n\r\n\t\tif(\"originatorInfo\" in asn1.result)\r\n\t\t{\r\n\t\t\tthis.originatorInfo = new OriginatorInfo({\r\n\t\t\t\tschema: new asn1js.Sequence({\r\n\t\t\t\t\tvalue: asn1.result.originatorInfo.valueBlock.value\r\n\t\t\t\t})\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis.recipientInfos = Array.from(asn1.result.recipientInfos, element => new RecipientInfo({ schema: element }));\r\n\t\tthis.encryptedContentInfo = new EncryptedContentInfo({ schema: asn1.result.encryptedContentInfo });\r\n\r\n\t\tif(\"unprotectedAttrs\" in asn1.result)\r\n\t\t\tthis.unprotectedAttrs = Array.from(asn1.result.unprotectedAttrs, element => new Attribute({ schema: element }));\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convert current object to asn1js object and set correct values\r\n\t * @returns {Object} asn1js object\r\n\t */\r\n\ttoSchema()\r\n\t{\r\n\t\t//region Create array for output sequence\r\n\t\tconst outputArray = [];\r\n\r\n\t\toutputArray.push(new asn1js.Integer({ value: this.version }));\r\n\r\n\t\tif(\"originatorInfo\" in this)\r\n\t\t{\r\n\t\t\toutputArray.push(new asn1js.Constructed({\r\n\t\t\t\toptional: true,\r\n\t\t\t\tidBlock: {\r\n\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\r\n\t\t\t\t\ttagNumber: 0 // [0]\r\n\t\t\t\t},\r\n\t\t\t\tvalue: this.originatorInfo.toSchema().valueBlock.value\r\n\t\t\t}));\r\n\t\t}\r\n\r\n\t\toutputArray.push(new asn1js.Set({\r\n\t\t\tvalue: Array.from(this.recipientInfos, element => element.toSchema())\r\n\t\t}));\r\n\r\n\t\toutputArray.push(this.encryptedContentInfo.toSchema());\r\n\r\n\t\tif(\"unprotectedAttrs\" in this)\r\n\t\t{\r\n\t\t\toutputArray.push(new asn1js.Constructed({\r\n\t\t\t\toptional: true,\r\n\t\t\t\tidBlock: {\r\n\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\r\n\t\t\t\t\ttagNumber: 1 // [1]\r\n\t\t\t\t},\r\n\t\t\t\tvalue: Array.from(this.unprotectedAttrs, element => element.toSchema())\r\n\t\t\t}));\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\t//region Construct and return new ASN.1 schema for this object\r\n\t\treturn (new asn1js.Sequence({\r\n\t\t\tvalue: outputArray\r\n\t\t}));\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convertion for the class to JSON object\r\n\t * @returns {Object}\r\n\t */\r\n\ttoJSON()\r\n\t{\r\n\t\tconst _object = {\r\n\t\t\tversion: this.version\r\n\t\t};\r\n\r\n\t\tif(\"originatorInfo\" in this)\r\n\t\t\t_object.originatorInfo = this.originatorInfo.toJSON();\r\n\r\n\t\t_object.recipientInfos = Array.from(this.recipientInfos, element => element.toJSON());\r\n\t\t_object.encryptedContentInfo = this.encryptedContentInfo.toJSON();\r\n\r\n\t\tif(\"unprotectedAttrs\" in this)\r\n\t\t\t_object.unprotectedAttrs = Array.from(this.unprotectedAttrs, element => element.toJSON());\r\n\r\n\t\treturn _object;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Helpers function for filling \"RecipientInfo\" based on recipient's certificate.\r\n\t * Problem with WebCrypto is that for RSA certificates we have only one option - \"key transport\" and\r\n\t * for ECC certificates we also have one option - \"key agreement\". As soon as Google will implement\r\n\t * DH algorithm it would be possible to use \"key agreement\" also for RSA certificates.\r\n\t * @param {Certificate} [certificate] Recipient's certificate\r\n\t * @param {Object} [parameters] Additional parameters neccessary for \"fine tunning\" of encryption process\r\n\t * @param {number} [variant] Variant = 1 is for \"key transport\", variant = 2 is for \"key agreement\". In fact the \"variant\" is unneccessary now because Google has no DH algorithm implementation. Thus key encryption scheme would be choosen by certificate type only: \"key transport\" for RSA and \"key agreement\" for ECC certificates.\r\n\t */\r\n\taddRecipientByCertificate(certificate, parameters, variant)\r\n\t{\r\n\t\t//region Initialize encryption parameters\r\n\t\tconst encryptionParameters = Object.assign(\r\n\t\t\t{ useOAEP: true, oaepHashAlgorithm: \"SHA-512\" },\r\n\t\t\tdefaultEncryptionParams,\r\n\t\t\tparameters || {}\r\n\t\t);\r\n\t\t//endregion\r\n\r\n\t\t//region Check type of certificate\r\n\t\tif(certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf(\"1.2.840.113549\") !== (-1))\r\n\t\t\tvariant = 1; // For the moment it is the only variant for RSA-based certificates\r\n\t\telse\r\n\t\t{\r\n\t\t\tif(certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf(\"1.2.840.10045\") !== (-1))\r\n\t\t\t\tvariant = 2; // For the moment it is the only variant for ECC-based certificates\r\n\t\t\telse\r\n\t\t\t\tthrow new Error(`Unknown type of certificate's public key: ${certificate.subjectPublicKeyInfo.algorithm.algorithmId}`);\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\t//region Add new \"recipient\" depends on \"variant\" and certificate type\r\n\t\tswitch(variant)\r\n\t\t{\r\n\t\t\tcase 1: // Key transport scheme\r\n\t\t\t\t{\r\n\t\t\t\t\tlet algorithmId;\r\n\t\t\t\t\tlet algorithmParams;\r\n\r\n\t\t\t\t\tif(encryptionParameters.useOAEP === true)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t//region keyEncryptionAlgorithm\r\n\t\t\t\t\t\talgorithmId = getOIDByAlgorithm({\r\n\t\t\t\t\t\t\tname: \"RSA-OAEP\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tif(algorithmId === \"\")\r\n\t\t\t\t\t\t\tthrow new Error(\"Can not find OID for RSA-OAEP\");\r\n\t\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t\t//region RSAES-OAEP-params\r\n\t\t\t\t\t\tconst hashOID = getOIDByAlgorithm({\r\n\t\t\t\t\t\t\tname: encryptionParameters.oaepHashAlgorithm\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tif(hashOID === \"\")\r\n\t\t\t\t\t\t\tthrow new Error(`Unknown OAEP hash algorithm: ${encryptionParameters.oaepHashAlgorithm}`);\r\n\r\n\t\t\t\t\t\tconst hashAlgorithm = new AlgorithmIdentifier({\r\n\t\t\t\t\t\t\talgorithmId: hashOID,\r\n\t\t\t\t\t\t\talgorithmParams: new asn1js.Null()\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\tconst rsaOAEPParams = new RSAESOAEPParams({\r\n\t\t\t\t\t\t\thashAlgorithm,\r\n\t\t\t\t\t\t\tmaskGenAlgorithm: new AlgorithmIdentifier({\r\n\t\t\t\t\t\t\t\talgorithmId: \"1.2.840.113549.1.1.8\", // id-mgf1\r\n\t\t\t\t\t\t\t\talgorithmParams: hashAlgorithm.toSchema()\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\talgorithmParams = rsaOAEPParams.toSchema();\r\n\t\t\t\t\t\t//endregion\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse // Use old RSAES-PKCS1-v1_5 schema instead\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t//region keyEncryptionAlgorithm\r\n\t\t\t\t\t\talgorithmId = getOIDByAlgorithm({\r\n\t\t\t\t\t\t\tname: \"RSAES-PKCS1-v1_5\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tif(algorithmId === \"\")\r\n\t\t\t\t\t\t\tthrow new Error(\"Can not find OID for RSAES-PKCS1-v1_5\");\r\n\t\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t\talgorithmParams = new asn1js.Null();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//region KeyTransRecipientInfo\r\n\t\t\t\t\tconst keyInfo = new KeyTransRecipientInfo({\r\n\t\t\t\t\t\tversion: 0,\r\n\t\t\t\t\t\trid: new IssuerAndSerialNumber({\r\n\t\t\t\t\t\t\tissuer: certificate.issuer,\r\n\t\t\t\t\t\t\tserialNumber: certificate.serialNumber\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t\tkeyEncryptionAlgorithm: new AlgorithmIdentifier({\r\n\t\t\t\t\t\t\talgorithmId,\r\n\t\t\t\t\t\t\talgorithmParams\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t\trecipientCertificate: certificate\r\n\t\t\t\t\t\t// \"encryptedKey\" will be calculated in \"encrypt\" function\r\n\t\t\t\t\t});\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region Final values for \"CMS_ENVELOPED_DATA\"\r\n\t\t\t\t\tthis.recipientInfos.push(new RecipientInfo({\r\n\t\t\t\t\t\tvariant: 1,\r\n\t\t\t\t\t\tvalue: keyInfo\r\n\t\t\t\t\t}));\r\n\t\t\t\t\t//endregion\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2: // Key agreement scheme\r\n\t\t\t\t{\r\n\t\t\t\t\tconst recipientIdentifier = new KeyAgreeRecipientIdentifier({\r\n\t\t\t\t\t\tvariant: 1,\r\n\t\t\t\t\t\tvalue: new IssuerAndSerialNumber({\r\n\t\t\t\t\t\t\tissuer: certificate.issuer,\r\n\t\t\t\t\t\t\tserialNumber: certificate.serialNumber\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t});\r\n\t\t\t\t\tthis._addKeyAgreeRecipientInfo(\r\n\t\t\t\t\t\trecipientIdentifier,\r\n\t\t\t\t\t\tencryptionParameters,\r\n\t\t\t\t\t\t{recipientCertificate: certificate}\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Unknown \"variant\" value: ${variant}`);\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\treturn true;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Add recipient based on pre-defined data like password or KEK\r\n\t * @param {ArrayBuffer} preDefinedData ArrayBuffer with pre-defined data\r\n\t * @param {Object} parameters Additional parameters neccessary for \"fine tunning\" of encryption process\r\n\t * @param {number} variant Variant = 1 for pre-defined \"key encryption key\" (KEK). Variant = 2 for password-based encryption.\r\n\t */\r\n\taddRecipientByPreDefinedData(preDefinedData, parameters, variant)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tconst encryptionParameters = parameters || {};\r\n\t\t//endregion\r\n\r\n\t\t//region Check initial parameters\r\n\t\tif((preDefinedData instanceof ArrayBuffer) === false)\r\n\t\t\tthrow new Error(\"Please pass \\\"preDefinedData\\\" in ArrayBuffer type\");\r\n\r\n\t\tif(preDefinedData.byteLength === 0)\r\n\t\t\tthrow new Error(\"Pre-defined data could have zero length\");\r\n\t\t//endregion\r\n\r\n\t\t//region Initialize encryption parameters\r\n\t\tif((\"keyIdentifier\" in encryptionParameters) === false)\r\n\t\t{\r\n\t\t\tconst keyIdentifierBuffer = new ArrayBuffer(16);\r\n\t\t\tconst keyIdentifierView = new Uint8Array(keyIdentifierBuffer);\r\n\t\t\tgetRandomValues(keyIdentifierView);\r\n\r\n\t\t\tencryptionParameters.keyIdentifier = keyIdentifierBuffer;\r\n\t\t}\r\n\r\n\t\tif((\"hmacHashAlgorithm\" in encryptionParameters) === false)\r\n\t\t\tencryptionParameters.hmacHashAlgorithm = \"SHA-512\";\r\n\r\n\t\tif((\"iterationCount\" in encryptionParameters) === false)\r\n\t\t\tencryptionParameters.iterationCount = 2048;\r\n\r\n\t\tif((\"keyEncryptionAlgorithm\" in encryptionParameters) === false)\r\n\t\t{\r\n\t\t\tencryptionParameters.keyEncryptionAlgorithm = {\r\n\t\t\t\tname: \"AES-KW\",\r\n\t\t\t\tlength: 256\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tif((\"keyEncryptionAlgorithmParams\" in encryptionParameters) === false)\r\n\t\t\tencryptionParameters.keyEncryptionAlgorithmParams = new asn1js.Null();\r\n\t\t//endregion\r\n\r\n\t\t//region Add new recipient based on passed variant\r\n\t\tswitch(variant)\r\n\t\t{\r\n\t\t\tcase 1: // KEKRecipientInfo\r\n\t\t\t\t{\r\n\t\t\t\t\t//region keyEncryptionAlgorithm\r\n\t\t\t\t\tconst kekOID = getOIDByAlgorithm(encryptionParameters.keyEncryptionAlgorithm);\r\n\t\t\t\t\tif(kekOID === \"\")\r\n\t\t\t\t\t\tthrow new Error(\"Incorrect value for \\\"keyEncryptionAlgorithm\\\"\");\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region KEKRecipientInfo\r\n\t\t\t\t\tconst keyInfo = new KEKRecipientInfo({\r\n\t\t\t\t\t\tversion: 4,\r\n\t\t\t\t\t\tkekid: new KEKIdentifier({\r\n\t\t\t\t\t\t\tkeyIdentifier: new asn1js.OctetString({ valueHex: encryptionParameters.keyIdentifier })\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t\tkeyEncryptionAlgorithm: new AlgorithmIdentifier({\r\n\t\t\t\t\t\t\talgorithmId: kekOID,\r\n\t\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t\t For AES-KW params are NULL, but for other algorithm could another situation.\r\n\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\talgorithmParams: encryptionParameters.keyEncryptionAlgorithmParams\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t\tpreDefinedKEK: preDefinedData\r\n\t\t\t\t\t// \"encryptedKey\" would be set in \"ecrypt\" function\r\n\t\t\t\t\t});\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region Final values for \"CMS_ENVELOPED_DATA\"\r\n\t\t\t\t\tthis.recipientInfos.push(new RecipientInfo({\r\n\t\t\t\t\t\tvariant: 3,\r\n\t\t\t\t\t\tvalue: keyInfo\r\n\t\t\t\t\t}));\r\n\t\t\t\t\t//endregion\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2: // PasswordRecipientinfo\r\n\t\t\t\t{\r\n\t\t\t\t\t//region keyDerivationAlgorithm\r\n\t\t\t\t\tconst pbkdf2OID = getOIDByAlgorithm({\r\n\t\t\t\t\t\tname: \"PBKDF2\"\r\n\t\t\t\t\t});\r\n\t\t\t\t\tif(pbkdf2OID === \"\")\r\n\t\t\t\t\t\tthrow new Error(\"Can not find OID for PBKDF2\");\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region Salt\r\n\t\t\t\t\tconst saltBuffer = new ArrayBuffer(64);\r\n\t\t\t\t\tconst saltView = new Uint8Array(saltBuffer);\r\n\t\t\t\t\tgetRandomValues(saltView);\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region HMAC-based algorithm\r\n\t\t\t\t\tconst hmacOID = getOIDByAlgorithm({\r\n\t\t\t\t\t\tname: \"HMAC\",\r\n\t\t\t\t\t\thash: {\r\n\t\t\t\t\t\t\tname: encryptionParameters.hmacHashAlgorithm\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\tif(hmacOID === \"\")\r\n\t\t\t\t\t\tthrow new Error(`Incorrect value for \"hmacHashAlgorithm\": ${encryptionParameters.hmacHashAlgorithm}`);\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region PBKDF2-params\r\n\t\t\t\t\tconst pbkdf2Params = new PBKDF2Params({\r\n\t\t\t\t\t\tsalt: new asn1js.OctetString({ valueHex: saltBuffer }),\r\n\t\t\t\t\t\titerationCount: encryptionParameters.iterationCount,\r\n\t\t\t\t\t\tprf: new AlgorithmIdentifier({\r\n\t\t\t\t\t\t\talgorithmId: hmacOID,\r\n\t\t\t\t\t\t\talgorithmParams: new asn1js.Null()\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t});\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region keyEncryptionAlgorithm\r\n\t\t\t\t\tconst kekOID = getOIDByAlgorithm(encryptionParameters.keyEncryptionAlgorithm);\r\n\t\t\t\t\tif(kekOID === \"\")\r\n\t\t\t\t\t\tthrow new Error(\"Incorrect value for \\\"keyEncryptionAlgorithm\\\"\");\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region PasswordRecipientinfo\r\n\t\t\t\t\tconst keyInfo = new PasswordRecipientinfo({\r\n\t\t\t\t\t\tversion: 0,\r\n\t\t\t\t\t\tkeyDerivationAlgorithm: new AlgorithmIdentifier({\r\n\t\t\t\t\t\t\talgorithmId: pbkdf2OID,\r\n\t\t\t\t\t\t\talgorithmParams: pbkdf2Params.toSchema()\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t\tkeyEncryptionAlgorithm: new AlgorithmIdentifier({\r\n\t\t\t\t\t\t\talgorithmId: kekOID,\r\n\t\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t\t For AES-KW params are NULL, but for other algorithm could be another situation.\r\n\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\talgorithmParams: encryptionParameters.keyEncryptionAlgorithmParams\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t\tpassword: preDefinedData\r\n\t\t\t\t\t// \"encryptedKey\" would be set in \"ecrypt\" function\r\n\t\t\t\t\t});\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region Final values for \"CMS_ENVELOPED_DATA\"\r\n\t\t\t\t\tthis.recipientInfos.push(new RecipientInfo({\r\n\t\t\t\t\t\tvariant: 4,\r\n\t\t\t\t\t\tvalue: keyInfo\r\n\t\t\t\t\t}));\r\n\t\t\t\t\t//endregion\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Unknown value for \"variant\": ${variant}`);\r\n\t\t}\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Add a \"RecipientInfo\" using a KeyAgreeRecipientInfo of type RecipientKeyIdentifier.\r\n\t * @param {CryptoKey} [key] Recipient's public key\r\n\t * @param {ArrayBuffer} [keyId] The id for the recipient's public key\r\n\t * @param {Object} [parameters] Additional parameters for \"fine tuning\" the encryption process\r\n\t */\r\n\taddRecipientByKeyIdentifier(key, keyId, parameters)\r\n\t{\r\n\t\t//region Initialize encryption parameters\r\n\t\tconst encryptionParameters = Object.assign({}, defaultEncryptionParams, parameters || {});\r\n\t\t//endregion\r\n\r\n\t\tconst recipientIdentifier = new KeyAgreeRecipientIdentifier({\r\n\t\t\tvariant: 2,\r\n\t\t\tvalue: new RecipientKeyIdentifier({\r\n\t\t\t\tsubjectKeyIdentifier: new asn1js.OctetString({valueHex: keyId}),\r\n\t\t\t})\r\n\t\t});\r\n\t\tthis._addKeyAgreeRecipientInfo(\r\n\t\t\trecipientIdentifier,\r\n\t\t\tencryptionParameters,\r\n\t\t\t{recipientPublicKey: key}\r\n\t\t);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Add a \"RecipientInfo\" using a KeyAgreeRecipientInfo of type RecipientKeyIdentifier.\r\n\t * @param {KeyAgreeRecipientIdentifier} [recipientIdentifier] Recipient identifier\r\n\t * @param {Object} [encryptionParameters] Additional parameters for \"fine tuning\" the encryption process\r\n\t * @param {Object} [extraRecipientInfoParams] Additional params for KeyAgreeRecipientInfo\r\n\t */\r\n\t_addKeyAgreeRecipientInfo(recipientIdentifier, encryptionParameters, extraRecipientInfoParams)\r\n\t{\r\n\t\t//region RecipientEncryptedKey\r\n\t\tconst encryptedKey = new RecipientEncryptedKey({\r\n\t\t\trid: recipientIdentifier\r\n\t\t\t// \"encryptedKey\" will be calculated in \"encrypt\" function\r\n\t\t});\r\n\t\t//endregion\r\n\r\n\t\t//region keyEncryptionAlgorithm\r\n\t\tconst aesKWoid = getOIDByAlgorithm({\r\n\t\t\tname: \"AES-KW\",\r\n\t\t\tlength: encryptionParameters.kekEncryptionLength\r\n\t\t});\r\n\t\tif (aesKWoid === \"\")\r\n\t\t\tthrow new Error(`Unknown length for key encryption algorithm: ${encryptionParameters.kekEncryptionLength}`);\r\n\r\n\t\tconst aesKW = new AlgorithmIdentifier({\r\n\t\t\talgorithmId: aesKWoid,\r\n\t\t});\r\n\t\t//endregion\r\n\r\n\t\t//region KeyAgreeRecipientInfo\r\n\t\tconst ecdhOID = getOIDByAlgorithm({\r\n\t\t\tname: \"ECDH\",\r\n\t\t\tkdf: encryptionParameters.kdfAlgorithm\r\n\t\t});\r\n\t\tif (ecdhOID === \"\")\r\n\t\t\tthrow new Error(`Unknown KDF algorithm: ${encryptionParameters.kdfAlgorithm}`);\r\n\r\n\t\t// In fact there is no need in so long UKM, but RFC2631\r\n\t\t// has requirement that \"UserKeyMaterial\" must be 512 bits long\r\n\t\tconst ukmBuffer = new ArrayBuffer(64);\r\n\t\tconst ukmView = new Uint8Array(ukmBuffer);\r\n\t\tgetRandomValues(ukmView); // Generate random values in 64 bytes long buffer\r\n\r\n\t\tconst recipientInfoParams = {\r\n\t\t\tversion: 3,\r\n\t\t\t// \"originator\" will be calculated in \"encrypt\" function because ephemeral key would be generated there\r\n\t\t\tukm: new asn1js.OctetString({valueHex: ukmBuffer}),\r\n\t\t\tkeyEncryptionAlgorithm: new AlgorithmIdentifier({\r\n\t\t\t\talgorithmId: ecdhOID,\r\n\t\t\t\talgorithmParams: aesKW.toSchema()\r\n\t\t\t}),\r\n\t\t\trecipientEncryptedKeys: new RecipientEncryptedKeys({\r\n\t\t\t\tencryptedKeys: [encryptedKey]\r\n\t\t\t})\r\n\t\t};\r\n\t\tconst keyInfo = new KeyAgreeRecipientInfo(Object.assign(recipientInfoParams, extraRecipientInfoParams));\r\n\t\t//endregion\r\n\r\n\t\t//region Final values for \"CMS_ENVELOPED_DATA\"\r\n\t\tthis.recipientInfos.push(new RecipientInfo({\r\n\t\t\tvariant: 2,\r\n\t\t\tvalue: keyInfo\r\n\t\t}));\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Create a new CMS Enveloped Data content with encrypted data\r\n\t * @param {Object} contentEncryptionAlgorithm WebCrypto algorithm. For the moment here could be only \"AES-CBC\" or \"AES-GCM\" algorithms.\r\n\t * @param {ArrayBuffer} contentToEncrypt Content to encrypt\r\n\t * @returns {Promise}\r\n\t */\r\n\tencrypt(contentEncryptionAlgorithm, contentToEncrypt)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tlet sequence = Promise.resolve();\r\n\r\n\t\tconst ivBuffer = new ArrayBuffer(16); // For AES we need IV 16 bytes long\r\n\t\tconst ivView = new Uint8Array(ivBuffer);\r\n\t\tgetRandomValues(ivView);\r\n\r\n\t\tconst contentView = new Uint8Array(contentToEncrypt);\r\n\r\n\t\tlet sessionKey;\r\n\t\tlet encryptedContent;\r\n\t\tlet exportedSessionKey;\r\n\r\n\t\tconst recipientsPromises = [];\r\n\r\n\t\tconst _this = this;\r\n\t\t//endregion\r\n\r\n\t\t//region Check for input parameters\r\n\t\tconst contentEncryptionOID = getOIDByAlgorithm(contentEncryptionAlgorithm);\r\n\t\tif(contentEncryptionOID === \"\")\r\n\t\t\treturn Promise.reject(\"Wrong \\\"contentEncryptionAlgorithm\\\" value\");\r\n\t\t//endregion\r\n\r\n\t\t//region Get a \"crypto\" extension\r\n\t\tconst crypto = getCrypto();\r\n\t\tif(typeof crypto === \"undefined\")\r\n\t\t\treturn Promise.reject(\"Unable to create WebCrypto object\");\r\n\t\t//endregion\r\n\r\n\t\t//region Generate new content encryption key\r\n\t\tsequence = sequence.then(() =>\r\n\t\t\tcrypto.generateKey(contentEncryptionAlgorithm, true, [\"encrypt\"]));\r\n\t\t//endregion\r\n\t\t//region Encrypt content\r\n\t\tsequence = sequence.then(result =>\r\n\t\t{\r\n\t\t\tsessionKey = result;\r\n\r\n\t\t\treturn crypto.encrypt({\r\n\t\t\t\tname: contentEncryptionAlgorithm.name,\r\n\t\t\t\tiv: ivView\r\n\t\t\t},\r\n\t\t\tsessionKey,\r\n\t\t\tcontentView);\r\n\t\t}, error =>\r\n\t\t\tPromise.reject(error));\r\n\t\t//endregion\r\n\t\t//region Export raw content of content encryption key\r\n\t\tsequence = sequence.then(result =>\r\n\t\t{\r\n\t\t\t//region Create output OCTETSTRING with encrypted content\r\n\t\t\tencryptedContent = result;\r\n\t\t\t//endregion\r\n\r\n\t\t\treturn crypto.exportKey(\"raw\", sessionKey);\r\n\t\t}, error =>\r\n\t\t\tPromise.reject(error)\r\n\t\t).then(result =>\r\n\t\t{\r\n\t\t\texportedSessionKey = result;\r\n\r\n\t\t\treturn true;\r\n\t\t}, error =>\r\n\t\t\tPromise.reject(error));\r\n\t\t//endregion\r\n\t\t//region Append common information to CMS_ENVELOPED_DATA\r\n\t\tsequence = sequence.then(() =>\r\n\t\t{\r\n\t\t\tthis.version = 2;\r\n\t\t\tthis.encryptedContentInfo = new EncryptedContentInfo({\r\n\t\t\t\tcontentType: \"1.2.840.113549.1.7.1\", // \"data\"\r\n\t\t\t\tcontentEncryptionAlgorithm: new AlgorithmIdentifier({\r\n\t\t\t\t\talgorithmId: contentEncryptionOID,\r\n\t\t\t\t\talgorithmParams: new asn1js.OctetString({ valueHex: ivBuffer })\r\n\t\t\t\t}),\r\n\t\t\t\tencryptedContent: new asn1js.OctetString({ valueHex: encryptedContent })\r\n\t\t\t});\r\n\t\t}, error =>\r\n\t\t\tPromise.reject(error));\r\n\t\t//endregion\r\n\r\n\t\t//region Special sub-functions to work with each recipient's type\r\n\t\tfunction SubKeyAgreeRecipientInfo(index)\r\n\t\t{\r\n\t\t\t//region Initial variables\r\n\t\t\tlet currentSequence = Promise.resolve();\r\n\r\n\t\t\tconst recipientInfo = _this.recipientInfos[index];\r\n\r\n\t\t\tlet ecdhPublicKey;\r\n\t\t\tlet ecdhPrivateKey;\r\n\r\n\t\t\tlet recipientPublicKey;\r\n\t\t\tlet recipientCurve;\r\n\t\t\tlet recipientCurveLength;\r\n\r\n\t\t\tlet exportedECDHPublicKey;\r\n\t\t\t//endregion\r\n\r\n\t\t\t//region Get public key and named curve from recipient's certificate or public key\r\n\t\t\tcurrentSequence = currentSequence.then(() =>\r\n\t\t\t{\r\n\t\t\t\tif (recipientInfo.value.recipientPublicKey) {\r\n\t\t\t\t\trecipientCurve = recipientInfo.value.recipientPublicKey.algorithm.namedCurve;\r\n\t\t\t\t\treturn recipientInfo.value.recipientPublicKey;\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconst curveObject = recipientInfo.value.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;\r\n\r\n\t\t\t\t\tif (curveObject.constructor.blockName() !== asn1js.ObjectIdentifier.blockName())\r\n\t\t\t\t\t\treturn Promise.reject(`Incorrect \"recipientCertificate\" for index ${index}`);\r\n\r\n\t\t\t\t\tconst curveOID = curveObject.valueBlock.toString();\r\n\r\n\t\t\t\t\tswitch (curveOID) {\r\n\t\t\t\t\t\tcase \"1.2.840.10045.3.1.7\":\r\n\t\t\t\t\t\t\trecipientCurve = \"P-256\";\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"1.3.132.0.34\":\r\n\t\t\t\t\t\t\trecipientCurve = \"P-384\";\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"1.3.132.0.35\":\r\n\t\t\t\t\t\t\trecipientCurve = \"P-521\";\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\treturn Promise.reject(`Incorrect curve OID for index ${index}`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn recipientInfo.value.recipientCertificate.getPublicKey({\r\n\t\t\t\t\t\talgorithm: {\r\n\t\t\t\t\t\t\talgorithm: {\r\n\t\t\t\t\t\t\t\tname: \"ECDH\",\r\n\t\t\t\t\t\t\t\tnamedCurve: recipientCurve\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tusages: []\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error));\r\n\t\t\t//endregion\r\n\r\n\t\t\t//region Generate ephemeral ECDH key\r\n\t\t\tcurrentSequence = currentSequence.then(result => {\r\n\t\t\t\trecipientPublicKey = result;\r\n\t\t\t\trecipientCurveLength = curveLengthByName[recipientCurve];\r\n\r\n\t\t\t\treturn crypto.generateKey(\r\n\t\t\t\t\t{name: \"ECDH\", namedCurve: recipientCurve},\r\n\t\t\t\t\ttrue,\r\n\t\t\t\t\t[\"deriveBits\"]\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\terror =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Export public key of ephemeral ECDH key pair\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t{\r\n\t\t\t\tecdhPublicKey = result.publicKey;\r\n\t\t\t\tecdhPrivateKey = result.privateKey;\r\n\r\n\t\t\t\treturn crypto.exportKey(\"spki\", ecdhPublicKey);\r\n\t\t\t},\r\n\t\t\terror =>\r\n\t\t\t\tPromise.reject(error));\r\n\t\t\t//endregion\r\n\r\n\t\t\t//region Save public key of ephemeral ECDH key pair\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t{\r\n\t\t\t\texportedECDHPublicKey = result;\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error));\r\n\t\t\t//endregion\r\n\t\t\t//region Create shared secret\r\n\t\t\tcurrentSequence = currentSequence.then(() => crypto.deriveBits({\r\n\t\t\t\tname: \"ECDH\",\r\n\t\t\t\tpublic: recipientPublicKey\r\n\t\t\t},\r\n\t\t\tecdhPrivateKey,\r\n\t\t\trecipientCurveLength),\r\n\t\t\terror =>\r\n\t\t\t\tPromise.reject(error));\r\n\t\t\t//endregion\r\n\r\n\t\t\t//region Apply KDF function to shared secret\r\n\t\t\tcurrentSequence = currentSequence.then(\r\n\t\t\t\t/**\r\n\t\t\t\t * @param {ArrayBuffer} result\r\n\t\t\t\t */\r\n\t\t\t\tresult =>\r\n\t\t\t\t{\r\n\t\t\t\t\t//region Get length of used AES-KW algorithm\r\n\t\t\t\t\tconst aesKWAlgorithm = new AlgorithmIdentifier({ schema: recipientInfo.value.keyEncryptionAlgorithm.algorithmParams });\r\n\r\n\t\t\t\t\tconst KWalgorithm = getAlgorithmByOID(aesKWAlgorithm.algorithmId);\r\n\t\t\t\t\tif((\"name\" in KWalgorithm) === false)\r\n\t\t\t\t\t\treturn Promise.reject(`Incorrect OID for key encryption algorithm: ${aesKWAlgorithm.algorithmId}`);\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region Translate AES-KW length to ArrayBuffer\r\n\t\t\t\t\tlet kwLength = KWalgorithm.length;\r\n\r\n\t\t\t\t\tconst kwLengthBuffer = new ArrayBuffer(4);\r\n\t\t\t\t\tconst kwLengthView = new Uint8Array(kwLengthBuffer);\r\n\r\n\t\t\t\t\tfor(let j = 3; j >= 0; j--)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tkwLengthView[j] = kwLength;\r\n\t\t\t\t\t\tkwLength >>= 8;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region Create and encode \"ECC-CMS-SharedInfo\" structure\r\n\t\t\t\t\tconst eccInfo = new ECCCMSSharedInfo({\r\n\t\t\t\t\t\tkeyInfo: new AlgorithmIdentifier({\r\n\t\t\t\t\t\t\talgorithmId: aesKWAlgorithm.algorithmId\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t\tentityUInfo: recipientInfo.value.ukm,\r\n\t\t\t\t\t\tsuppPubInfo: new asn1js.OctetString({ valueHex: kwLengthBuffer })\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tconst encodedInfo = eccInfo.toSchema().toBER(false);\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region Get SHA algorithm used together with ECDH\r\n\t\t\t\t\tconst ecdhAlgorithm = getAlgorithmByOID(recipientInfo.value.keyEncryptionAlgorithm.algorithmId);\r\n\t\t\t\t\tif((\"name\" in ecdhAlgorithm) === false)\r\n\t\t\t\t\t\treturn Promise.reject(`Incorrect OID for key encryption algorithm: ${recipientInfo.value.keyEncryptionAlgorithm.algorithmId}`);\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\treturn kdf(ecdhAlgorithm.kdf, result, KWalgorithm.length, encodedInfo);\r\n\t\t\t\t},\r\n\t\t\t\terror =>\r\n\t\t\t\t\tPromise.reject(error));\r\n\t\t\t//endregion\r\n\t\t\t//region Import AES-KW key from result of KDF function\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t\tcrypto.importKey(\"raw\", result, { name: \"AES-KW\" }, true, [\"wrapKey\"]),\r\n\t\t\terror =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Finally wrap session key by using AES-KW algorithm\r\n\t\t\tcurrentSequence = currentSequence.then(result => crypto.wrapKey(\"raw\", sessionKey, result, { name: \"AES-KW\" }),\r\n\t\t\t\terror =>\r\n\t\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Append all neccessary data to current CMS_RECIPIENT_INFO object\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t{\r\n\t\t\t\t//region OriginatorIdentifierOrKey\r\n\t\t\t\tconst asn1 = asn1js.fromBER(exportedECDHPublicKey);\r\n\r\n\t\t\t\tconst originator = new OriginatorIdentifierOrKey();\r\n\t\t\t\toriginator.variant = 3;\r\n\t\t\t\toriginator.value = new OriginatorPublicKey({ schema: asn1.result });\r\n\r\n\t\t\t\trecipientInfo.value.originator = originator;\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\t//region RecipientEncryptedKey\r\n\t\t\t\t/*\r\n\t\t\t\t We will not support using of same ephemeral key for many recipients\r\n\t\t\t\t */\r\n\t\t\t\trecipientInfo.value.recipientEncryptedKeys.encryptedKeys[0].encryptedKey = new asn1js.OctetString({ valueHex: result });\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\treturn {ecdhPrivateKey};\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\r\n\t\t\treturn currentSequence;\r\n\t\t}\r\n\r\n\t\tasync function SubKeyTransRecipientInfo(index)\r\n\t\t{\r\n\t\t\tconst algorithmParameters = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\r\n\t\t\tif(\"name\" in algorithmParameters === false)\r\n\t\t\t\tthrow new Error(`Unknown keyEncryptionAlgorithm: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);\r\n\r\n\t\t\t//region RSA-OAEP case\r\n\t\t\tif(algorithmParameters.name === \"RSA-OAEP\")\r\n\t\t\t{\r\n\t\t\t\tconst schema = _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams;\r\n\t\t\t\tconst rsaOAEPParams = new RSAESOAEPParams({ schema });\r\n\r\n\t\t\t\talgorithmParameters.hash = getAlgorithmByOID(rsaOAEPParams.hashAlgorithm.algorithmId);\r\n\t\t\t\tif((\"name\" in algorithmParameters.hash) === false)\r\n\t\t\t\t\tthrow new Error(`Incorrect OID for hash algorithm: ${rsaOAEPParams.hashAlgorithm.algorithmId}`);\r\n\t\t\t}\r\n\t\t\t//endregion\r\n\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tconst publicKey = await _this.recipientInfos[index].value.recipientCertificate.getPublicKey({\r\n\t\t\t\t\talgorithm: {\r\n\t\t\t\t\t\talgorithm: algorithmParameters,\r\n\t\t\t\t\t\tusages: [\"encrypt\", \"wrapKey\"]\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tconst encryptedKey = await crypto.encrypt(publicKey.algorithm, publicKey, exportedSessionKey);\r\n\r\n\t\t\t\t//region RecipientEncryptedKey\r\n\t\t\t\t_this.recipientInfos[index].value.encryptedKey = new asn1js.OctetString({valueHex: encryptedKey});\r\n\t\t\t\t//endregion\r\n\t\t\t}\r\n\t\t\tcatch(ex)\r\n\t\t\t{\r\n\t\t\t\tconst jjj = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction SubKEKRecipientInfo(index)\r\n\t\t{\r\n\t\t\t//region Initial variables\r\n\t\t\tlet currentSequence = Promise.resolve();\r\n\t\t\tlet kekAlgorithm;\r\n\t\t\t//endregion\r\n\r\n\t\t\t//region Import KEK from pre-defined data\r\n\t\t\tcurrentSequence = currentSequence.then(() =>\r\n\t\t\t{\r\n\t\t\t\t//region Get WebCrypto form of \"keyEncryptionAlgorithm\"\r\n\t\t\t\tkekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\r\n\t\t\t\tif((\"name\" in kekAlgorithm) === false)\r\n\t\t\t\t\treturn Promise.reject(`Incorrect OID for \"keyEncryptionAlgorithm\": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\treturn crypto.importKey(\"raw\",\r\n\t\t\t\t\tnew Uint8Array(_this.recipientInfos[index].value.preDefinedKEK),\r\n\t\t\t\t\tkekAlgorithm,\r\n\t\t\t\t\ttrue,\r\n\t\t\t\t\t[\"wrapKey\"]); // Too specific for AES-KW\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\r\n\t\t\t//region Wrap previously exported session key\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t\tcrypto.wrapKey(\"raw\", sessionKey, result, kekAlgorithm),\r\n\t\t\terror =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Append all neccessary data to current CMS_RECIPIENT_INFO object\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t{\r\n\t\t\t\t//region RecipientEncryptedKey\r\n\t\t\t\t_this.recipientInfos[index].value.encryptedKey = new asn1js.OctetString({ valueHex: result });\r\n\t\t\t\t//endregion\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\r\n\t\t\treturn currentSequence;\r\n\t\t}\r\n\r\n\t\tfunction SubPasswordRecipientinfo(index)\r\n\t\t{\r\n\t\t\t//region Initial variables\r\n\t\t\tlet currentSequence = Promise.resolve();\r\n\t\t\tlet pbkdf2Params;\r\n\t\t\tlet kekAlgorithm;\r\n\t\t\t//endregion\r\n\r\n\t\t\t//region Check that we have encoded \"keyDerivationAlgorithm\" plus \"PBKDF2_params\" in there\r\n\t\t\tcurrentSequence = currentSequence.then(() =>\r\n\t\t\t{\r\n\t\t\t\tif((\"keyDerivationAlgorithm\" in _this.recipientInfos[index].value) === false)\r\n\t\t\t\t\treturn Promise.reject(\"Please append encoded \\\"keyDerivationAlgorithm\\\"\");\r\n\r\n\t\t\t\tif((\"algorithmParams\" in _this.recipientInfos[index].value.keyDerivationAlgorithm) === false)\r\n\t\t\t\t\treturn Promise.reject(\"Incorrectly encoded \\\"keyDerivationAlgorithm\\\"\");\r\n\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tpbkdf2Params = new PBKDF2Params({ schema: _this.recipientInfos[index].value.keyDerivationAlgorithm.algorithmParams });\r\n\t\t\t\t}\r\n\t\t\t\tcatch(ex)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn Promise.reject(\"Incorrectly encoded \\\"keyDerivationAlgorithm\\\"\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn Promise.resolve();\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Derive PBKDF2 key from \"password\" buffer\r\n\t\t\tcurrentSequence = currentSequence.then(() =>\r\n\t\t\t{\r\n\t\t\t\tconst passwordView = new Uint8Array(_this.recipientInfos[index].value.password);\r\n\r\n\t\t\t\treturn crypto.importKey(\"raw\",\r\n\t\t\t\t\tpasswordView,\r\n\t\t\t\t\t\"PBKDF2\",\r\n\t\t\t\t\tfalse,\r\n\t\t\t\t\t[\"deriveKey\"]);\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Derive key for \"keyEncryptionAlgorithm\"\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t{\r\n\t\t\t\t//region Get WebCrypto form of \"keyEncryptionAlgorithm\"\r\n\t\t\t\tkekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\r\n\t\t\t\tif((\"name\" in kekAlgorithm) === false)\r\n\t\t\t\t\treturn Promise.reject(`Incorrect OID for \"keyEncryptionAlgorithm\": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\t//region Get HMAC hash algorithm\r\n\t\t\t\tlet hmacHashAlgorithm = \"SHA-1\";\r\n\r\n\t\t\t\tif(\"prf\" in pbkdf2Params)\r\n\t\t\t\t{\r\n\t\t\t\t\tconst algorithm = getAlgorithmByOID(pbkdf2Params.prf.algorithmId);\r\n\t\t\t\t\tif((\"name\" in algorithm) === false)\r\n\t\t\t\t\t\treturn Promise.reject(\"Incorrect OID for HMAC hash algorithm\");\r\n\r\n\t\t\t\t\thmacHashAlgorithm = algorithm.hash.name;\r\n\t\t\t\t}\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\t//region Get PBKDF2 \"salt\" value\r\n\t\t\t\tconst saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex);\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\t//region Get PBKDF2 iterations count\r\n\t\t\t\tconst iterations = pbkdf2Params.iterationCount;\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\treturn crypto.deriveKey({\r\n\t\t\t\t\tname: \"PBKDF2\",\r\n\t\t\t\t\thash: {\r\n\t\t\t\t\t\tname: hmacHashAlgorithm\r\n\t\t\t\t\t},\r\n\t\t\t\t\tsalt: saltView,\r\n\t\t\t\t\titerations\r\n\t\t\t\t},\r\n\t\t\t\tresult,\r\n\t\t\t\tkekAlgorithm,\r\n\t\t\t\ttrue,\r\n\t\t\t\t[\"wrapKey\"]); // Usages are too specific for KEK algorithm\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Wrap previously exported session key (Also too specific for KEK algorithm)\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t\tcrypto.wrapKey(\"raw\", sessionKey, result, kekAlgorithm),\r\n\t\t\terror =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Append all neccessary data to current CMS_RECIPIENT_INFO object\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t{\r\n\t\t\t\t//region RecipientEncryptedKey\r\n\t\t\t\t_this.recipientInfos[index].value.encryptedKey = new asn1js.OctetString({ valueHex: result });\r\n\t\t\t\t//endregion\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\r\n\t\t\treturn currentSequence;\r\n\t\t}\r\n\r\n\t\t//endregion\r\n\r\n\t\t//region Create special routines for each \"recipient\"\r\n\t\tsequence = sequence.then(() =>\r\n\t\t{\r\n\t\t\tfor(let i = 0; i < this.recipientInfos.length; i++)\r\n\t\t\t{\r\n\t\t\t\t//region Initial variables\r\n\t\t\t\tlet currentSequence = Promise.resolve();\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\tswitch(this.recipientInfos[i].variant)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase 1: // KeyTransRecipientInfo\r\n\t\t\t\t\t\tcurrentSequence = SubKeyTransRecipientInfo(i);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 2: // KeyAgreeRecipientInfo\r\n\t\t\t\t\t\tcurrentSequence = SubKeyAgreeRecipientInfo(i);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 3: // KEKRecipientInfo\r\n\t\t\t\t\t\tcurrentSequence = SubKEKRecipientInfo(i);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 4: // PasswordRecipientinfo\r\n\t\t\t\t\t\tcurrentSequence = SubPasswordRecipientinfo(i);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\treturn Promise.reject(`Uknown recipient type in array with index ${i}`);\r\n\t\t\t\t}\r\n\r\n\t\t\t\trecipientsPromises.push(currentSequence);\r\n\t\t\t}\r\n\r\n\t\t\treturn Promise.all(recipientsPromises);\r\n\t\t}, error =>\r\n\t\t\tPromise.reject(error)\r\n\t\t);\r\n\t\t//endregion\r\n\r\n\t\treturn sequence;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Decrypt existing CMS Enveloped Data content\r\n\t * @param {number} recipientIndex Index of recipient\r\n\t * @param {Object} parameters Additional parameters\r\n\t * @returns {Promise}\r\n\t */\r\n\tdecrypt(recipientIndex, parameters)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tlet sequence = Promise.resolve();\r\n\r\n\t\tconst decryptionParameters = parameters || {};\r\n\r\n\t\tconst _this = this;\r\n\t\t//endregion\r\n\r\n\t\t//region Check for input parameters\r\n\t\tif((recipientIndex + 1) > this.recipientInfos.length)\r\n\t\t\treturn Promise.reject(`Maximum value for \"index\" is: ${this.recipientInfos.length - 1}`);\r\n\t\t//endregion\r\n\r\n\t\t//region Get a \"crypto\" extension\r\n\t\tconst crypto = getCrypto();\r\n\t\tif(typeof crypto === \"undefined\")\r\n\t\t\treturn Promise.reject(\"Unable to create WebCrypto object\");\r\n\t\t//endregion\r\n\r\n\t\t//region Special sub-functions to work with each recipient's type\r\n\t\tfunction SubKeyAgreeRecipientInfo(index)\r\n\t\t{\r\n\t\t\t//region Initial variables\r\n\t\t\tlet currentSequence = Promise.resolve();\r\n\r\n\t\t\tlet recipientCurve;\r\n\t\t\tlet recipientCurveLength;\r\n\r\n\t\t\tlet curveOID;\r\n\r\n\t\t\tlet ecdhPrivateKey;\r\n\t\t\t//endregion\r\n\r\n\t\t\tconst originator = _this.recipientInfos[index].value.originator;\r\n\r\n\t\t\t//region Get \"namedCurve\" parameter from recipient's certificate\r\n\t\t\tcurrentSequence = currentSequence.then(() =>\r\n\t\t\t{\r\n\t\t\t\tif (\"recipientCertificate\" in decryptionParameters) {\r\n\t\t\t\t\tconst curveObject = decryptionParameters.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;\r\n\t\t\t\t\tif(curveObject.constructor.blockName() !== asn1js.ObjectIdentifier.blockName()) {\r\n\t\t\t\t\t\treturn Promise.reject(`Incorrect \"recipientCertificate\" for index ${index}`);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcurveOID = curveObject.valueBlock.toString();\r\n\t\t\t\t} else if (\"algorithmParams\" in originator.value.algorithm) {\r\n\t\t\t\t\tconst curveObject = originator.value.algorithm.algorithmParams;\r\n\t\t\t\t\tif(curveObject.constructor.blockName() !== asn1js.ObjectIdentifier.blockName()) {\r\n\t\t\t\t\t\treturn Promise.reject(`Incorrect originator for index ${index}`);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcurveOID = curveObject.valueBlock.toString();\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn Promise.reject(\"Parameter \\\"recipientCertificate\\\" is mandatory for \\\"KeyAgreeRecipientInfo\\\" if algorithm params are missing from originator\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif((\"recipientPrivateKey\" in decryptionParameters) === false)\r\n\t\t\t\t\treturn Promise.reject(\"Parameter \\\"recipientPrivateKey\\\" is mandatory for \\\"KeyAgreeRecipientInfo\\\"\");\r\n\r\n\t\t\t\tswitch(curveOID)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase \"1.2.840.10045.3.1.7\":\r\n\t\t\t\t\t\trecipientCurve = \"P-256\";\r\n\t\t\t\t\t\trecipientCurveLength = 256;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"1.3.132.0.34\":\r\n\t\t\t\t\t\trecipientCurve = \"P-384\";\r\n\t\t\t\t\t\trecipientCurveLength = 384;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"1.3.132.0.35\":\r\n\t\t\t\t\t\trecipientCurve = \"P-521\";\r\n\t\t\t\t\t\trecipientCurveLength = 528;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\treturn Promise.reject(`Incorrect curve OID for index ${index}`);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn crypto.importKey(\"pkcs8\",\r\n\t\t\t\t\tdecryptionParameters.recipientPrivateKey,\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tname: \"ECDH\",\r\n\t\t\t\t\t\tnamedCurve: recipientCurve\r\n\t\t\t\t\t},\r\n\t\t\t\t\ttrue,\r\n\t\t\t\t\t[\"deriveBits\"]\r\n\t\t\t\t);\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Import sender's ephemeral public key\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t{\r\n\t\t\t\tecdhPrivateKey = result;\r\n\r\n\t\t\t\t//region Change \"OriginatorPublicKey\" if \"curve\" parameter absent\r\n\t\t\t\tif((\"algorithmParams\" in originator.value.algorithm) === false)\r\n\t\t\t\t\toriginator.value.algorithm.algorithmParams = new asn1js.ObjectIdentifier({ value: curveOID });\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\t//region Create ArrayBuffer with sender's public key\r\n\t\t\t\tconst buffer = originator.value.toSchema().toBER(false);\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\treturn crypto.importKey(\"spki\",\r\n\t\t\t\t\tbuffer,\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tname: \"ECDH\",\r\n\t\t\t\t\t\tnamedCurve: recipientCurve\r\n\t\t\t\t\t},\r\n\t\t\t\t\ttrue,\r\n\t\t\t\t\t[]);\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Create shared secret\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t\tcrypto.deriveBits({\r\n\t\t\t\t\tname: \"ECDH\",\r\n\t\t\t\t\tpublic: result\r\n\t\t\t\t},\r\n\t\t\t\tecdhPrivateKey,\r\n\t\t\t\trecipientCurveLength),\r\n\t\t\terror =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Apply KDF function to shared secret\r\n\t\t\tfunction applyKDF(includeAlgorithmParams) {\r\n\t\t\t\tincludeAlgorithmParams = includeAlgorithmParams || false;\r\n\r\n\t\t\t\t//region Get length of used AES-KW algorithm\r\n\t\t\t\tconst aesKWAlgorithm = new AlgorithmIdentifier({ schema: _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams });\r\n\r\n\t\t\t\tconst KWalgorithm = getAlgorithmByOID(aesKWAlgorithm.algorithmId);\r\n\t\t\t\tif((\"name\" in KWalgorithm) === false)\r\n\t\t\t\t\treturn Promise.reject(`Incorrect OID for key encryption algorithm: ${aesKWAlgorithm.algorithmId}`);\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\t//region Translate AES-KW length to ArrayBuffer\r\n\t\t\t\tlet kwLength = KWalgorithm.length;\r\n\r\n\t\t\t\tconst kwLengthBuffer = new ArrayBuffer(4);\r\n\t\t\t\tconst kwLengthView = new Uint8Array(kwLengthBuffer);\r\n\r\n\t\t\t\tfor(let j = 3; j >= 0; j--)\r\n\t\t\t\t{\r\n\t\t\t\t\tkwLengthView[j] = kwLength;\r\n\t\t\t\t\tkwLength >>= 8;\r\n\t\t\t\t}\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\t//region Create and encode \"ECC-CMS-SharedInfo\" structure\r\n\t\t\t\tconst keyInfoAlgorithm = {\r\n\t\t\t\t\talgorithmId: aesKWAlgorithm.algorithmId\r\n\t\t\t\t};\r\n\t\t\t\tif (includeAlgorithmParams) {\r\n\t\t\t\t\tkeyInfoAlgorithm.algorithmParams = new asn1js.Null();\r\n\t\t\t\t}\r\n\t\t\t\tconst eccInfo = new ECCCMSSharedInfo({\r\n\t\t\t\t\tkeyInfo: new AlgorithmIdentifier(keyInfoAlgorithm),\r\n\t\t\t\t\tentityUInfo: _this.recipientInfos[index].value.ukm,\r\n\t\t\t\t\tsuppPubInfo: new asn1js.OctetString({ valueHex: kwLengthBuffer })\r\n\t\t\t\t});\r\n\r\n\t\t\t\tconst encodedInfo = eccInfo.toSchema().toBER(false);\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\t//region Get SHA algorithm used together with ECDH\r\n\t\t\t\tconst ecdhAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\r\n\t\t\t\tif((\"name\" in ecdhAlgorithm) === false)\r\n\t\t\t\t\treturn Promise.reject(`Incorrect OID for key encryption algorithm: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\treturn kdf(ecdhAlgorithm.kdf, sharedSecret, KWalgorithm.length, encodedInfo);\r\n\t\t\t}\r\n\t\t\tlet sharedSecret;\r\n\t\t\tcurrentSequence = currentSequence.then(\r\n\t\t\t\t/**\r\n\t\t\t\t * @param {ArrayBuffer} result\r\n\t\t\t\t */\r\n\t\t\t\tresult =>\r\n\t\t\t\t{\r\n\t\t\t\t\tsharedSecret = result;\r\n\t\t\t\t\treturn applyKDF();\r\n\t\t\t\t},\r\n\t\t\t\terror =>\r\n\t\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Import AES-KW key from result of KDF function\r\n\t\t\tfunction importAesKwKey(kdfResult) {\r\n\t\t\t\treturn crypto.importKey(\"raw\",\r\n\t\t\t\t\tkdfResult,\r\n\t\t\t\t\t{ name: \"AES-KW\" },\r\n\t\t\t\t\ttrue,\r\n\t\t\t\t\t[\"unwrapKey\"]\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tcurrentSequence = currentSequence.then(\r\n\t\t\t\timportAesKwKey,\r\n\t\t\t\terror => Promise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Finally unwrap session key\r\n\t\t\tfunction unwrapSessionKey(aesKwKey) {\r\n\t\t\t\t//region Get WebCrypto form of content encryption algorithm\r\n\t\t\t\tconst contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\r\n\t\t\t\tif((\"name\" in contentEncryptionAlgorithm) === false)\r\n\t\t\t\t\treturn Promise.reject(`Incorrect \"contentEncryptionAlgorithm\": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\treturn crypto.unwrapKey(\"raw\",\r\n\t\t\t\t\t_this.recipientInfos[index].value.recipientEncryptedKeys.encryptedKeys[0].encryptedKey.valueBlock.valueHex,\r\n\t\t\t\t\taesKwKey,\r\n\t\t\t\t\t{ name: \"AES-KW\" },\r\n\t\t\t\t\tcontentEncryptionAlgorithm,\r\n\t\t\t\t\ttrue,\r\n\t\t\t\t\t[\"decrypt\"]);\r\n\t\t\t}\r\n\t\t\tcurrentSequence = currentSequence.then(\r\n\t\t\t\tresult => unwrapSessionKey(result).catch(() => applyKDF(true).then(importAesKwKey).then(unwrapSessionKey)),\r\n\t\t\t\terror => Promise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\r\n\t\t\treturn currentSequence;\r\n\t\t}\r\n\r\n\t\tasync function SubKeyTransRecipientInfo(index)\r\n\t\t{\r\n\t\t\tif((\"recipientPrivateKey\" in decryptionParameters) === false)\r\n\t\t\t\tthrow new Error(\"Parameter \\\"recipientPrivateKey\\\" is mandatory for \\\"KeyTransRecipientInfo\\\"\");\r\n\r\n\t\t\tconst algorithmParameters = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\r\n\t\t\tif(\"name\" in algorithmParameters === false)\r\n\t\t\t\tthrow new Error(`Unknown keyEncryptionAlgorithm: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);\r\n\r\n\t\t\t//region RSA-OAEP case\r\n\t\t\tif(algorithmParameters.name === \"RSA-OAEP\")\r\n\t\t\t{\r\n\t\t\t\tconst schema = _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams;\r\n\t\t\t\tconst rsaOAEPParams = new RSAESOAEPParams({ schema });\r\n\r\n\t\t\t\talgorithmParameters.hash = getAlgorithmByOID(rsaOAEPParams.hashAlgorithm.algorithmId);\r\n\t\t\t\tif((\"name\" in algorithmParameters.hash) === false)\r\n\t\t\t\t\tthrow new Error(`Incorrect OID for hash algorithm: ${rsaOAEPParams.hashAlgorithm.algorithmId}`);\r\n\t\t\t}\r\n\t\t\t//endregion\r\n\r\n\t\t\tconst privateKey = await crypto.importKey(\r\n\t\t\t\t\"pkcs8\",\r\n\t\t\t\tdecryptionParameters.recipientPrivateKey,\r\n\t\t\t\talgorithmParameters,\r\n\t\t\t\ttrue,\r\n\t\t\t\t[\"decrypt\"]\r\n\t\t\t);\r\n\r\n\t\t\tconst sessionKey = await crypto.decrypt(\r\n\t\t\t\tprivateKey.algorithm,\r\n\t\t\t\tprivateKey,\r\n\t\t\t\t_this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex\r\n\t\t\t);\r\n\r\n\t\t\t//region Get WebCrypto form of content encryption algorithm\r\n\t\t\tconst contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\r\n\t\t\tif((\"name\" in contentEncryptionAlgorithm) === false)\r\n\t\t\t\tthrow new Error(`Incorrect \"contentEncryptionAlgorithm\": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);\r\n\t\t\t//endregion\r\n\r\n\t\t\treturn crypto.importKey(\"raw\",\r\n\t\t\t\tsessionKey,\r\n\t\t\t\tcontentEncryptionAlgorithm,\r\n\t\t\t\ttrue,\r\n\t\t\t\t[\"decrypt\"]\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tfunction SubKEKRecipientInfo(index)\r\n\t\t{\r\n\t\t\t//region Initial variables\r\n\t\t\tlet currentSequence = Promise.resolve();\r\n\t\t\tlet kekAlgorithm;\r\n\t\t\t//endregion\r\n\r\n\t\t\t//region Import KEK from pre-defined data\r\n\t\t\tcurrentSequence = currentSequence.then(() =>\r\n\t\t\t{\r\n\t\t\t\tif((\"preDefinedData\" in decryptionParameters) === false)\r\n\t\t\t\t\treturn Promise.reject(\"Parameter \\\"preDefinedData\\\" is mandatory for \\\"KEKRecipientInfo\\\"\");\r\n\r\n\t\t\t\t//region Get WebCrypto form of \"keyEncryptionAlgorithm\"\r\n\t\t\t\tkekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\r\n\t\t\t\tif((\"name\" in kekAlgorithm) === false)\r\n\t\t\t\t\treturn Promise.reject(`Incorrect OID for \"keyEncryptionAlgorithm\": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\treturn crypto.importKey(\"raw\",\r\n\t\t\t\t\tdecryptionParameters.preDefinedData,\r\n\t\t\t\t\tkekAlgorithm,\r\n\t\t\t\t\ttrue,\r\n\t\t\t\t\t[\"unwrapKey\"]); // Too specific for AES-KW\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Unwrap previously exported session key\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t{\r\n\t\t\t\t//region Get WebCrypto form of content encryption algorithm\r\n\t\t\t\tconst contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\r\n\t\t\t\tif((\"name\" in contentEncryptionAlgorithm) === false)\r\n\t\t\t\t\treturn Promise.reject(`Incorrect \"contentEncryptionAlgorithm\": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\treturn crypto.unwrapKey(\"raw\",\r\n\t\t\t\t\t_this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex,\r\n\t\t\t\t\tresult,\r\n\t\t\t\t\tkekAlgorithm,\r\n\t\t\t\t\tcontentEncryptionAlgorithm,\r\n\t\t\t\t\ttrue,\r\n\t\t\t\t\t[\"decrypt\"]);\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\r\n\t\t\treturn currentSequence;\r\n\t\t}\r\n\r\n\t\tfunction SubPasswordRecipientinfo(index)\r\n\t\t{\r\n\t\t\t//region Initial variables\r\n\t\t\tlet currentSequence = Promise.resolve();\r\n\t\t\tlet pbkdf2Params;\r\n\t\t\tlet kekAlgorithm;\r\n\t\t\t//endregion\r\n\r\n\t\t\t//region Derive PBKDF2 key from \"password\" buffer\r\n\t\t\tcurrentSequence = currentSequence.then(() =>\r\n\t\t\t{\r\n\t\t\t\tif((\"preDefinedData\" in decryptionParameters) === false)\r\n\t\t\t\t\treturn Promise.reject(\"Parameter \\\"preDefinedData\\\" is mandatory for \\\"KEKRecipientInfo\\\"\");\r\n\r\n\t\t\t\tif((\"keyDerivationAlgorithm\" in _this.recipientInfos[index].value) === false)\r\n\t\t\t\t\treturn Promise.reject(\"Please append encoded \\\"keyDerivationAlgorithm\\\"\");\r\n\r\n\t\t\t\tif((\"algorithmParams\" in _this.recipientInfos[index].value.keyDerivationAlgorithm) === false)\r\n\t\t\t\t\treturn Promise.reject(\"Incorrectly encoded \\\"keyDerivationAlgorithm\\\"\");\r\n\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tpbkdf2Params = new PBKDF2Params({ schema: _this.recipientInfos[index].value.keyDerivationAlgorithm.algorithmParams });\r\n\t\t\t\t}\r\n\t\t\t\tcatch(ex)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn Promise.reject(\"Incorrectly encoded \\\"keyDerivationAlgorithm\\\"\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn crypto.importKey(\"raw\",\r\n\t\t\t\t\tdecryptionParameters.preDefinedData,\r\n\t\t\t\t\t\"PBKDF2\",\r\n\t\t\t\t\tfalse,\r\n\t\t\t\t\t[\"deriveKey\"]);\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Derive key for \"keyEncryptionAlgorithm\"\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t{\r\n\t\t\t\t//region Get WebCrypto form of \"keyEncryptionAlgorithm\"\r\n\t\t\t\tkekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\r\n\t\t\t\tif((\"name\" in kekAlgorithm) === false)\r\n\t\t\t\t\treturn Promise.reject(`Incorrect OID for \"keyEncryptionAlgorithm\": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\t//region Get HMAC hash algorithm\r\n\t\t\t\tlet hmacHashAlgorithm = \"SHA-1\";\r\n\r\n\t\t\t\tif(\"prf\" in pbkdf2Params)\r\n\t\t\t\t{\r\n\t\t\t\t\tconst algorithm = getAlgorithmByOID(pbkdf2Params.prf.algorithmId);\r\n\t\t\t\t\tif((\"name\" in algorithm) === false)\r\n\t\t\t\t\t\treturn Promise.reject(\"Incorrect OID for HMAC hash algorithm\");\r\n\r\n\t\t\t\t\thmacHashAlgorithm = algorithm.hash.name;\r\n\t\t\t\t}\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\t//region Get PBKDF2 \"salt\" value\r\n\t\t\t\tconst saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex);\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\t//region Get PBKDF2 iterations count\r\n\t\t\t\tconst iterations = pbkdf2Params.iterationCount;\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\treturn crypto.deriveKey({\r\n\t\t\t\t\tname: \"PBKDF2\",\r\n\t\t\t\t\thash: {\r\n\t\t\t\t\t\tname: hmacHashAlgorithm\r\n\t\t\t\t\t},\r\n\t\t\t\t\tsalt: saltView,\r\n\t\t\t\t\titerations\r\n\t\t\t\t},\r\n\t\t\t\tresult,\r\n\t\t\t\tkekAlgorithm,\r\n\t\t\t\ttrue,\r\n\t\t\t\t[\"unwrapKey\"]); // Usages are too specific for KEK algorithm\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Unwrap previously exported session key\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t{\r\n\t\t\t\t//region Get WebCrypto form of content encryption algorithm\r\n\t\t\t\tconst contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\r\n\t\t\t\tif((\"name\" in contentEncryptionAlgorithm) === false)\r\n\t\t\t\t\treturn Promise.reject(`Incorrect \"contentEncryptionAlgorithm\": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\treturn crypto.unwrapKey(\"raw\",\r\n\t\t\t\t\t_this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex,\r\n\t\t\t\t\tresult,\r\n\t\t\t\t\tkekAlgorithm,\r\n\t\t\t\t\tcontentEncryptionAlgorithm,\r\n\t\t\t\t\ttrue,\r\n\t\t\t\t\t[\"decrypt\"]);\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\r\n\t\t\treturn currentSequence;\r\n\t\t}\r\n\r\n\t\t//endregion\r\n\r\n\t\t//region Perform steps, specific to each type of session key encryption\r\n\t\tsequence = sequence.then(() =>\r\n\t\t{\r\n\t\t\t//region Initial variables\r\n\t\t\tlet currentSequence = Promise.resolve();\r\n\t\t\t//endregion\r\n\r\n\t\t\tswitch(this.recipientInfos[recipientIndex].variant)\r\n\t\t\t{\r\n\t\t\t\tcase 1: // KeyTransRecipientInfo\r\n\t\t\t\t\tcurrentSequence = SubKeyTransRecipientInfo(recipientIndex);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 2: // KeyAgreeRecipientInfo\r\n\t\t\t\t\tcurrentSequence = SubKeyAgreeRecipientInfo(recipientIndex);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 3: // KEKRecipientInfo\r\n\t\t\t\t\tcurrentSequence = SubKEKRecipientInfo(recipientIndex);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 4: // PasswordRecipientinfo\r\n\t\t\t\t\tcurrentSequence = SubPasswordRecipientinfo(recipientIndex);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn Promise.reject(`Uknown recipient type in array with index ${recipientIndex}`);\r\n\t\t\t}\r\n\r\n\t\t\treturn currentSequence;\r\n\t\t}, error =>\r\n\t\t\tPromise.reject(error)\r\n\t\t);\r\n\t\t//endregion\r\n\r\n\t\t//region Finally decrypt data by session key\r\n\t\tsequence = sequence.then(result =>\r\n\t\t{\r\n\t\t\t//region Get WebCrypto form of content encryption algorithm\r\n\t\t\tconst contentEncryptionAlgorithm = getAlgorithmByOID(this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\r\n\t\t\tif((\"name\" in contentEncryptionAlgorithm) === false)\r\n\t\t\t\treturn Promise.reject(`Incorrect \"contentEncryptionAlgorithm\": ${this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);\r\n\t\t\t//endregion\r\n\r\n\t\t\t//region Get \"intialization vector\" for content encryption algorithm\r\n\t\t\tconst ivBuffer = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams.valueBlock.valueHex;\r\n\t\t\tconst ivView = new Uint8Array(ivBuffer);\r\n\t\t\t//endregion\r\n\r\n\t\t\t//region Create correct data block for decryption\r\n\t\t\tlet dataBuffer = new ArrayBuffer(0);\r\n\r\n\t\t\tif(this.encryptedContentInfo.encryptedContent.idBlock.isConstructed === false)\r\n\t\t\t\tdataBuffer = this.encryptedContentInfo.encryptedContent.valueBlock.valueHex;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tfor(const content of this.encryptedContentInfo.encryptedContent.valueBlock.value)\r\n\t\t\t\t\tdataBuffer = utilConcatBuf(dataBuffer, content.valueBlock.valueHex);\r\n\t\t\t}\r\n\t\t\t//endregion\r\n\r\n\t\t\treturn crypto.decrypt({\r\n\t\t\t\tname: contentEncryptionAlgorithm.name,\r\n\t\t\t\tiv: ivView\r\n\t\t\t},\r\n\t\t\tresult,\r\n\t\t\tdataBuffer);\r\n\t\t}, error =>\r\n\t\t\tPromise.reject(error)\r\n\t\t);\r\n\t\t//endregion\r\n\r\n\t\treturn sequence;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n"]},"metadata":{},"sourceType":"module"}