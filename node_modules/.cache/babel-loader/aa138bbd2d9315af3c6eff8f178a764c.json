{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/defineProperty\"));\n\nvar _analyzer = _interopRequireDefault(require(\"../analyzer/analyzer\"));\n\nvar _constants = require(\"../constants\");\n/**\n * @param {Object} operate the filtered, parsed, converted, transformed, simplified data point to check against\n * @param {String} type - local or remote\n * @param {String} keys - the stat keys for types of stats defined by DEFAULT_TRANSFORM_REGEX\n * @param {String} stat - the accessor to get the actual stat\n * @param {String} kind - audio or video\n * @returns {Object} always whatever the first sentFirstVideoBytes were, in the past or if it happened now, or undefined if never\n * @private\n * @memberof StatsEvents\n */\n\n\nvar operateEvent = function operateEvent(operate, type, keys, stat, kind) {\n  var foundMatch = {};\n  foundMatch.found = keys.some(function (key) {\n    if (operate[key] && operate[key][stat] && operate[key][stat] > 0) {\n      foundMatch.match = {\n        type: type,\n        key: key,\n        data: operate[key],\n        stat: stat,\n        kind: kind\n      };\n      return true;\n    }\n\n    return false;\n  });\n  return foundMatch;\n};\n/**\n * @export\n * @class StatsEvents\n */\n\n\nvar StatsEvents = /*#__PURE__*/function () {\n  /**\n   * constructs an instance\n   * @constructor\n   * @param {StatsHistory} series\n   * @param {Function} callback\n   * @memberof StatsEvents\n   */\n  function StatsEvents() {\n    var series = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n    (0, _classCallCheck2.default)(this, StatsEvents);\n    (0, _defineProperty2.default)(this, \"namespace\", _constants.MEETINGS);\n    /**\n     * @instance\n     * @type {StatsHistory}\n     * @private\n     * @memberof StatsEvents\n     */\n\n    this.series = series;\n    /**\n     * @instance\n     * @type {Function}\n     * @private\n     * @memberof StatsEvents\n     */\n\n    this.callback = callback;\n    /**\n     * @instance\n     * @type {WebRTCData}\n     * @private\n     * @memberof StatsEvents\n     */\n\n    this.first = null;\n    /**\n     * @instance\n     * @type {Boolean}\n     * @private\n     * @memberof StatsEvents\n     */\n\n    this.sendRemainStopped = false;\n    /**\n     * @instance\n     * @type {Boolean}\n     * @private\n     * @memberof StatsEvents\n     */\n\n    this.recvRemainStopped = false;\n  }\n  /**\n   * looks for data starting to flow through\n   * @param {WebRTCData} data\n   * @returns {Object}\n   */\n\n\n  (0, _createClass2.default)(StatsEvents, [{\n    key: \"start\",\n    value: function start(data) {\n      if (data && data.data && data.data.getData()) {\n        var operate = data.data.getData();\n\n        if (operate && !this.first) {\n          var operator = [operateEvent(operate, _constants.EVENT_TYPES.LOCAL, _constants.DEFAULT_EVENT_AUDIO_SEND_KEYS, _constants.EVENT_STATS_MAP.BYTES_SENT, _constants.AUDIO), operateEvent(operate, _constants.EVENT_TYPES.LOCAL, _constants.DEFAULT_EVENT_VIDEO_SEND_KEYS, _constants.EVENT_STATS_MAP.BYTES_SENT, _constants.VIDEO), operateEvent(operate, _constants.EVENT_TYPES.REMOTE, _constants.DEFAULT_EVENT_VIDEO_RECEIVE_KEYS, _constants.EVENT_STATS_MAP.BYTES_RECEIVED, _constants.VIDEO), operateEvent(operate, _constants.EVENT_TYPES.REMOTE, _constants.DEFAULT_EVENT_AUDIO_RECEIVE_KEYS, _constants.EVENT_STATS_MAP.BYTES_RECEIVED, _constants.AUDIO)];\n          var somethingMatched = operator.find(function (element) {\n            return element && element.found && element.match;\n          });\n\n          if (somethingMatched) {\n            this.first = somethingMatched.match;\n            this.callback(this.first);\n            return somethingMatched;\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Looks for data to stop coming through\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (!this.series || this.series.get().length < 5) {\n        return null;\n      }\n\n      var fiveSecondsData = this.series.getSlice(5);\n      var prop = fiveSecondsData[0] && fiveSecondsData[0].rtpOutAudio || fiveSecondsData[0].rtpInAudio || fiveSecondsData[0].rtpInVideo || fiveSecondsData[0].rtpOutVideo;\n\n      var sendAnalysis = _analyzer.default.analyze(fiveSecondsData, {\n        analysisKeys: [{\n          key: _constants.EVENT_STATS_MAP.BYTES_SENT,\n          check: _constants.ANALYSIS_CHECKS.INCREASING,\n          prop: prop\n        }]\n      });\n\n      var receiveAnalysis = _analyzer.default.analyze(fiveSecondsData, {\n        analysisKeys: [{\n          key: _constants.EVENT_STATS_MAP.BYTES_RECEIVED,\n          check: _constants.ANALYSIS_CHECKS.INCREASING,\n          prop: prop\n        }]\n      });\n\n      if (!sendAnalysis.valid && sendAnalysis.data.bytesSent.reports.length > 0) {\n        if (!this.sendRemainStopped) {\n          var ret = {\n            stop: true,\n            stat: _constants.EVENT_STATS_MAP.BYTES_SENT\n          };\n          this.callback(ret);\n          this.sendRemainStopped = true;\n          this.first = null;\n          return ret;\n        }\n      } else if (sendAnalysis.valid && sendAnalysis.data.bytesSent.reports.length > 0) {\n        this.sendRemainStopped = false;\n      }\n\n      if (!receiveAnalysis.valid && receiveAnalysis.data.bytesReceived.reports.length > 0) {\n        if (!this.recvRemainStopped) {\n          var _ret = {\n            stop: true,\n            stat: _constants.EVENT_STATS_MAP.BYTES_RECEIVED\n          };\n          this.callback(_ret);\n          this.recvRemainStopped = true;\n          this.first = null;\n          return _ret;\n        }\n      } else if (receiveAnalysis.valid && receiveAnalysis.data.bytesReceived.reports.length > 0) {\n        this.recvRemainStopped = false;\n      }\n\n      return null;\n    }\n    /**\n     * handles all the types of events that need to be sent when they happen from getStats API\n     * @param {WebRTCData} data\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"event\",\n    value: function event(data) {\n      return {\n        start: this.start(data),\n        stop: this.stop()\n      };\n    }\n  }]);\n  return StatsEvents;\n}();\n\nexports.default = StatsEvents;","map":{"version":3,"mappings":"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","names":["operateEvent","operate","type","keys","stat","kind","foundMatch","found","some","key","match","data","StatsEvents","series","callback","MEETINGS","first","sendRemainStopped","recvRemainStopped","getData","operator","EVENT_TYPES","LOCAL","DEFAULT_EVENT_AUDIO_SEND_KEYS","EVENT_STATS_MAP","BYTES_SENT","AUDIO","DEFAULT_EVENT_VIDEO_SEND_KEYS","VIDEO","REMOTE","DEFAULT_EVENT_VIDEO_RECEIVE_KEYS","BYTES_RECEIVED","DEFAULT_EVENT_AUDIO_RECEIVE_KEYS","somethingMatched","find","element","get","length","fiveSecondsData","getSlice","prop","rtpOutAudio","rtpInAudio","rtpInVideo","rtpOutVideo","sendAnalysis","StatsAnalyzer","analyze","analysisKeys","check","ANALYSIS_CHECKS","INCREASING","receiveAnalysis","valid","bytesSent","reports","ret","stop","bytesReceived","start"],"sources":["events.js"],"sourcesContent":["import StatsAnalyzer from '../analyzer/analyzer';\nimport {\n  DEFAULT_EVENT_VIDEO_SEND_KEYS,\n  DEFAULT_EVENT_AUDIO_SEND_KEYS,\n  DEFAULT_EVENT_AUDIO_RECEIVE_KEYS,\n  DEFAULT_EVENT_VIDEO_RECEIVE_KEYS,\n  EVENT_TYPES,\n  EVENT_STATS_MAP,\n  MEETINGS,\n  AUDIO,\n  VIDEO,\n  ANALYSIS_CHECKS\n} from '../constants';\n\n/**\n * @param {Object} operate the filtered, parsed, converted, transformed, simplified data point to check against\n * @param {String} type - local or remote\n * @param {String} keys - the stat keys for types of stats defined by DEFAULT_TRANSFORM_REGEX\n * @param {String} stat - the accessor to get the actual stat\n * @param {String} kind - audio or video\n * @returns {Object} always whatever the first sentFirstVideoBytes were, in the past or if it happened now, or undefined if never\n * @private\n * @memberof StatsEvents\n */\nconst operateEvent = (operate, type, keys, stat, kind) => {\n  const foundMatch = {};\n\n  foundMatch.found = keys.some((key) => {\n    if (operate[key] && operate[key][stat] && operate[key][stat] > 0) {\n      foundMatch.match = {\n        type,\n        key,\n        data: operate[key],\n        stat,\n        kind\n      };\n\n      return true;\n    }\n\n    return false;\n  });\n\n  return foundMatch;\n};\n\n/**\n * @export\n * @class StatsEvents\n */\nexport default class StatsEvents {\n  namespace = MEETINGS;\n\n  /**\n   * constructs an instance\n   * @constructor\n   * @param {StatsHistory} series\n   * @param {Function} callback\n   * @memberof StatsEvents\n   */\n  constructor(series = null, callback = () => {}) {\n    /**\n     * @instance\n     * @type {StatsHistory}\n     * @private\n     * @memberof StatsEvents\n     */\n    this.series = series;\n    /**\n     * @instance\n     * @type {Function}\n     * @private\n     * @memberof StatsEvents\n     */\n    this.callback = callback;\n    /**\n     * @instance\n     * @type {WebRTCData}\n     * @private\n     * @memberof StatsEvents\n     */\n    this.first = null;\n    /**\n     * @instance\n     * @type {Boolean}\n     * @private\n     * @memberof StatsEvents\n     */\n    this.sendRemainStopped = false;\n    /**\n     * @instance\n     * @type {Boolean}\n     * @private\n     * @memberof StatsEvents\n     */\n    this.recvRemainStopped = false;\n  }\n\n  /**\n   * looks for data starting to flow through\n   * @param {WebRTCData} data\n   * @returns {Object}\n   */\n  start(data) {\n    if (data && data.data && data.data.getData()) {\n      const operate = data.data.getData();\n\n      if (operate && !this.first) {\n        const operator = [\n          operateEvent(operate, EVENT_TYPES.LOCAL, DEFAULT_EVENT_AUDIO_SEND_KEYS, EVENT_STATS_MAP.BYTES_SENT, AUDIO),\n          operateEvent(operate, EVENT_TYPES.LOCAL, DEFAULT_EVENT_VIDEO_SEND_KEYS, EVENT_STATS_MAP.BYTES_SENT, VIDEO),\n          operateEvent(operate, EVENT_TYPES.REMOTE, DEFAULT_EVENT_VIDEO_RECEIVE_KEYS, EVENT_STATS_MAP.BYTES_RECEIVED, VIDEO),\n          operateEvent(operate, EVENT_TYPES.REMOTE, DEFAULT_EVENT_AUDIO_RECEIVE_KEYS, EVENT_STATS_MAP.BYTES_RECEIVED, AUDIO)\n        ];\n        const somethingMatched = operator.find((element) => element && element.found && element.match);\n\n        if (somethingMatched) {\n          this.first = somethingMatched.match;\n          this.callback(this.first);\n\n          return somethingMatched;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Looks for data to stop coming through\n   * @returns {Object}\n   */\n  stop() {\n    if (!this.series || this.series.get().length < 5) {\n      return null;\n    }\n    const fiveSecondsData = this.series.getSlice(5);\n    const prop = fiveSecondsData[0] && fiveSecondsData[0].rtpOutAudio || fiveSecondsData[0].rtpInAudio || fiveSecondsData[0].rtpInVideo || fiveSecondsData[0].rtpOutVideo;\n    const sendAnalysis = StatsAnalyzer.analyze(fiveSecondsData, {analysisKeys: [{key: EVENT_STATS_MAP.BYTES_SENT, check: ANALYSIS_CHECKS.INCREASING, prop}]});\n    const receiveAnalysis = StatsAnalyzer.analyze(fiveSecondsData, {analysisKeys: [{key: EVENT_STATS_MAP.BYTES_RECEIVED, check: ANALYSIS_CHECKS.INCREASING, prop}]});\n\n    if (!sendAnalysis.valid && sendAnalysis.data.bytesSent.reports.length > 0) {\n      if (!this.sendRemainStopped) {\n        const ret = {stop: true, stat: EVENT_STATS_MAP.BYTES_SENT};\n\n        this.callback(ret);\n        this.sendRemainStopped = true;\n        this.first = null;\n\n        return ret;\n      }\n    }\n    else if (sendAnalysis.valid && sendAnalysis.data.bytesSent.reports.length > 0) {\n      this.sendRemainStopped = false;\n    }\n    if (!receiveAnalysis.valid && receiveAnalysis.data.bytesReceived.reports.length > 0) {\n      if (!this.recvRemainStopped) {\n        const ret = {stop: true, stat: EVENT_STATS_MAP.BYTES_RECEIVED};\n\n        this.callback(ret);\n        this.recvRemainStopped = true;\n        this.first = null;\n\n        return ret;\n      }\n    }\n    else if (receiveAnalysis.valid && receiveAnalysis.data.bytesReceived.reports.length > 0) {\n      this.recvRemainStopped = false;\n    }\n\n    return null;\n  }\n\n  /**\n   * handles all the types of events that need to be sent when they happen from getStats API\n   * @param {WebRTCData} data\n   * @returns {Object}\n   */\n  event(data) {\n    return {\n      start: this.start(data),\n      stop: this.stop()\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"script"}