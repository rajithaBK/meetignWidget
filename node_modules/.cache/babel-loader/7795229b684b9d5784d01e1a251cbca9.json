{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _javascriptStateMachine = _interopRequireDefault(require(\"javascript-state-machine\"));\n\nvar _loggerProxy = _interopRequireDefault(require(\"../common/logs/logger-proxy\"));\n\nvar _constants = require(\"../constants\");\n\nvar shouldStep = function shouldStep(roap, meeting) {\n  var messageType = roap.msg.messageType;\n\n  if (meeting) {\n    if (messageType === _constants._OFFER_ && roap.remote && meeting.shareStatus === _constants._REQUESTED_) {\n      // The peer-connection is waiting for answer but got an offer Reset. Try to\n      // send the offer later after you accept the answer\n      return false;\n    } // Assuming the mercury event has come first before the response for the event\n    // we have to wait for the response and trigger the ROAP request later on\n\n\n    if (!meeting.mediaProperties.peerConnection && messageType === _constants._ANSWER_) {\n      return false;\n    }\n  }\n\n  _loggerProxy.default.logger.log('Roap:state#shouldStep --> RoapStateMachine: PeerConnectionState, ', meeting.mediaProperties.peerConnection.signalingState);\n\n  _loggerProxy.default.logger.log('Roap:state#shouldStep --> RoapStateMachine: success save proceeding with transition, ', roap.msg);\n\n  return true;\n};\n\nvar handleTransition = function handleTransition(value, signal, meeting) {\n  _loggerProxy.default.logger.log(\"Roap:state#handleTransition --> current \".concat(value, \" to \").concat(signal));\n\n  switch (value) {\n    case _constants.ROAP.ROAP_STATE.INIT:\n      if (signal === _constants.ROAP.ROAP_SIGNAL.RX_OFFER) {\n        return _constants.ROAP.ROAP_STATE.WAIT_TX_ANSWER;\n      }\n\n      if (signal === _constants.ROAP.ROAP_SIGNAL.TX_OFFER) {\n        return _constants.ROAP.ROAP_STATE.WAIT_RX_ANSWER;\n      }\n\n      return value;\n\n    case _constants.ROAP.ROAP_STATE.WAIT_RX_OFFER:\n      return value;\n\n    case _constants.ROAP.ROAP_STATE.WAIT_RX_ANSWER:\n      if (signal === _constants.ROAP.ROAP_SIGNAL.RX_ANSWER) {\n        // There is a race condition where the /call response comes after mercury event from the server\n        // As mercury sends roap event if it didnt get back a response. We can send the roap ok after that\n        if (meeting.mediaId) {\n          return _constants.ROAP.ROAP_STATE.WAIT_TX_OK;\n        }\n\n        _loggerProxy.default.logger.error('Roap:state#handleTransition --> Race Condition no mediaId, continuing.');\n\n        return value;\n      }\n\n      if (signal === _constants.ROAP.ROAP_SIGNAL.RX_OFFER) {\n        return _constants.ROAP.ROAP_STATE.GLARE;\n      }\n\n      return value;\n\n    case _constants.ROAP.ROAP_STATE.WAIT_TX_OFFER:\n      return value;\n\n    case _constants.ROAP.ROAP_STATE.WAIT_TX_ANSWER:\n      if (signal === _constants.ROAP.ROAP_SIGNAL.TX_ANSWER) {\n        return _constants.ROAP.ROAP_STATE.WAIT_RX_OK;\n      }\n\n      return value;\n\n    case _constants.ROAP.ROAP_STATE.WAIT_TX_OK:\n      if (signal === _constants.ROAP.ROAP_SIGNAL.TX_OK) {\n        return _constants.ROAP.ROAP_STATE.INIT;\n      }\n\n      return value;\n\n    case _constants.ROAP.ROAP_STATE.WAIT_RX_OK:\n      if (signal === _constants.ROAP.ROAP_SIGNAL.RX_OK) {\n        return _constants.ROAP.ROAP_STATE.INIT;\n      }\n\n      return value;\n\n    case _constants.ROAP.ROAP_STATE.ERROR:\n      // eslint-disable-next-line no-warning-comments\n      // TODO: resolve error state. Add a signal constant and handle the cleanup\n      return _constants.ROAP.ROAP_STATE.INIT;\n\n    case _constants.ROAP.ROAP_STATE.GLARE:\n      return _constants.ROAP.ROAP_STATE.WAIT_RX_ANSWER;\n\n    default:\n      return value;\n  }\n};\n\nvar RoapStateMachine = {\n  /**\n   * @param {Roap} roapRef\n   * initializes the state machine\n   * @returns {StateMachine} an instance of a state machine\n   */\n  createState: function createState() {\n    var RoapState = _javascriptStateMachine.default.factory({\n      init: _constants.ROAP.ROAP_STATE.INIT,\n      transitions: [{\n        name: _constants.ROAP.ROAP_TRANSITIONS.STEP,\n        from: '*',\n\n        /**\n         * Method to handle the transitions between states\n         * @param {String} signal\n         * @param {Meeting} meeting instance of a Meeting\n         * @param {Object} roap\n         * @returns {String} new state value\n         */\n        to: function to(signal, meeting, roap) {\n          var value = this.state;\n\n          if (!shouldStep(roap, meeting)) {\n            return value;\n          }\n\n          return handleTransition(value, signal, meeting);\n        }\n      }],\n      methods: {\n        /**\n         * Event that fires after we've transitioned to a new state\n         * @param {Object} transition\n         * @returns {null}\n         */\n        onAfterStep: function onAfterStep(transition) {\n          _loggerProxy.default.logger.log(\"Roap:state#onAfterStep --> RoapStateMachine->onAfterStep#fired! State changed from '\".concat(transition.from, \"' to '\").concat(transition.to, \"' with transition '\").concat(transition.transition, \"''.\"));\n        }\n      }\n    });\n\n    return new RoapState();\n  }\n};\nvar _default = RoapStateMachine;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["shouldStep","roap","meeting","messageType","msg","_OFFER_","remote","shareStatus","_REQUESTED_","mediaProperties","peerConnection","_ANSWER_","LoggerProxy","logger","log","signalingState","handleTransition","value","signal","ROAP","ROAP_STATE","INIT","ROAP_SIGNAL","RX_OFFER","WAIT_TX_ANSWER","TX_OFFER","WAIT_RX_ANSWER","WAIT_RX_OFFER","RX_ANSWER","mediaId","WAIT_TX_OK","error","GLARE","WAIT_TX_OFFER","TX_ANSWER","WAIT_RX_OK","TX_OK","RX_OK","ERROR","RoapStateMachine","createState","RoapState","StateMachine","factory","init","transitions","name","ROAP_TRANSITIONS","STEP","from","to","state","methods","onAfterStep","transition"],"sources":["state.js"],"sourcesContent":["import StateMachine from 'javascript-state-machine';\n\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport {ROAP, _OFFER_, _ANSWER_, _REQUESTED_} from '../constants';\n\nconst shouldStep = (roap, meeting) => {\n  const {messageType} = roap.msg;\n\n  if (meeting) {\n    if (messageType === _OFFER_ && roap.remote && meeting.shareStatus === _REQUESTED_) {\n      // The peer-connection is waiting for answer but got an offer Reset. Try to\n      // send the offer later after you accept the answer\n      return false;\n    }\n    // Assuming the mercury event has come first before the response for the event\n    // we have to wait for the response and trigger the ROAP request later on\n    if (!meeting.mediaProperties.peerConnection && messageType === _ANSWER_) {\n      return false;\n    }\n  }\n  LoggerProxy.logger.log('Roap:state#shouldStep --> RoapStateMachine: PeerConnectionState, ', meeting.mediaProperties.peerConnection.signalingState);\n  LoggerProxy.logger.log('Roap:state#shouldStep --> RoapStateMachine: success save proceeding with transition, ', roap.msg);\n\n  return true;\n};\n\nconst handleTransition = (value, signal, meeting) => {\n  LoggerProxy.logger.log(`Roap:state#handleTransition --> current ${value} to ${signal}`);\n\n  switch (value) {\n    case ROAP.ROAP_STATE.INIT:\n      if (signal === ROAP.ROAP_SIGNAL.RX_OFFER) {\n        return ROAP.ROAP_STATE.WAIT_TX_ANSWER;\n      }\n      if (signal === ROAP.ROAP_SIGNAL.TX_OFFER) {\n        return ROAP.ROAP_STATE.WAIT_RX_ANSWER;\n      }\n\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_RX_OFFER:\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_RX_ANSWER:\n      if (signal === ROAP.ROAP_SIGNAL.RX_ANSWER) {\n        // There is a race condition where the /call response comes after mercury event from the server\n        // As mercury sends roap event if it didnt get back a response. We can send the roap ok after that\n        if (meeting.mediaId) {\n          return ROAP.ROAP_STATE.WAIT_TX_OK;\n        }\n        LoggerProxy.logger.error('Roap:state#handleTransition --> Race Condition no mediaId, continuing.');\n\n        return value;\n      }\n\n      if (signal === ROAP.ROAP_SIGNAL.RX_OFFER) {\n        return ROAP.ROAP_STATE.GLARE;\n      }\n\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_TX_OFFER:\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_TX_ANSWER:\n      if (signal === ROAP.ROAP_SIGNAL.TX_ANSWER) {\n        return ROAP.ROAP_STATE.WAIT_RX_OK;\n      }\n\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_TX_OK:\n      if (signal === ROAP.ROAP_SIGNAL.TX_OK) {\n        return ROAP.ROAP_STATE.INIT;\n      }\n\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_RX_OK:\n      if (signal === ROAP.ROAP_SIGNAL.RX_OK) {\n        return ROAP.ROAP_STATE.INIT;\n      }\n\n      return value;\n\n    case ROAP.ROAP_STATE.ERROR:\n      // eslint-disable-next-line no-warning-comments\n      // TODO: resolve error state. Add a signal constant and handle the cleanup\n      return ROAP.ROAP_STATE.INIT;\n\n    case ROAP.ROAP_STATE.GLARE:\n      return ROAP.ROAP_STATE.WAIT_RX_ANSWER;\n    default:\n      return value;\n  }\n};\n\nconst RoapStateMachine = {\n  /**\n   * @param {Roap} roapRef\n   * initializes the state machine\n   * @returns {StateMachine} an instance of a state machine\n   */\n  createState() {\n    const RoapState = StateMachine.factory({\n      init: ROAP.ROAP_STATE.INIT,\n      transitions: [\n        {\n          name: ROAP.ROAP_TRANSITIONS.STEP,\n          from: '*',\n          /**\n           * Method to handle the transitions between states\n           * @param {String} signal\n           * @param {Meeting} meeting instance of a Meeting\n           * @param {Object} roap\n           * @returns {String} new state value\n           */\n          to(signal, meeting, roap) {\n            const value = this.state;\n\n            if (!shouldStep(roap, meeting)) {\n              return value;\n            }\n\n            return handleTransition(value, signal, meeting);\n          }\n        }\n      ],\n      methods: {\n        /**\n         * Event that fires after we've transitioned to a new state\n         * @param {Object} transition\n         * @returns {null}\n         */\n        onAfterStep(transition) {\n          LoggerProxy.logger.log(\n            `Roap:state#onAfterStep --> RoapStateMachine->onAfterStep#fired! State changed from '${transition.from}' to '${\n              transition.to\n            }' with transition '${transition.transition}''.`\n          );\n        }\n      }\n    });\n\n    return new RoapState();\n  }\n};\n\nexport default RoapStateMachine;\n"]},"metadata":{},"sourceType":"script"}