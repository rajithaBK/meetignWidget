{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.persist = persist;\nexports.waitForValue = waitForValue;\n\nvar _apply = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/reflect/apply\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/map\"));\n\nvar _set = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/set\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/defineProperty\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/typeof\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/toConsumableArray\"));\n\nvar _wrap2 = _interopRequireDefault(require(\"lodash/wrap\"));\n\nvar _result2 = _interopRequireDefault(require(\"lodash/result\"));\n\nvar _identity2 = _interopRequireDefault(require(\"lodash/identity\"));\n\nvar _debounce2 = _interopRequireDefault(require(\"lodash/debounce\"));\n\nvar _curry2 = _interopRequireDefault(require(\"lodash/curry\"));\n\nvar _common = require(\"@webex/common\");\n\nvar _errors = require(\"./errors\");\n/**\n * Stores the result of fn before returning it\n * @param  {string} key\n * @private\n * @returns {Promise} resolves with the result of fn\n */\n\n\nfunction persist() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (args.length === 3) {\n    return persist('@').apply(void 0, args);\n  }\n\n  var key = args[0],\n      decider = args[1];\n  return function persistDecorator(target, prop, descriptor) {\n    if (prop !== 'initialize') {\n      // Once we have class-based alternative to AmpersandState, it should be\n      // detected here.\n      throw new TypeError('@persist can only currently be applied to AmpersandState objects or their derivatives and must be applied to the initialize method');\n    }\n\n    descriptor.value = (0, _wrap2.default)(descriptor.value, function persistExecutor(fn) {\n      var _this = this;\n\n      for (var _len2 = arguments.length, initializeArgs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        initializeArgs[_key2 - 1] = arguments[_key2];\n      }\n\n      var ret = (0, _apply.default)(fn, this, initializeArgs);\n      var changeEvent = key === '@' ? 'change' : \"change:\".concat(key); // Some scenarios will lead to lots of change events on a single tick; we\n      // really only care about writing once things have stopped changing. with\n      // a debounce of zero, we're effectively coalescing all the changes\n      // triggered by a single call to set() and commiting them on the next tick\n      // eslint-disable-next-line no-invalid-this\n\n      this.on(changeEvent, (0, _debounce2.default)(function () {\n        var shouldPersist = !decider || _apply.default.apply(Reflect, [decider, _this].concat(initializeArgs));\n\n        if (!shouldPersist) {\n          return _promise.default.resolve();\n        }\n\n        if (key === '@') {\n          // eslint-disable-next-line no-invalid-this\n          return _this.boundedStorage.put(key, _this);\n        } // eslint-disable-next-line no-invalid-this\n\n\n        return _this.boundedStorage.put(key, _this[key]);\n      }, 0));\n      return ret;\n    });\n    prepareInitialize(target, prop);\n  };\n}\n\nvar M = _map.default;\nvar S = _set.default;\nvar BlockingKeyMap = (0, _common.make)(M, M, S);\nvar blockingKeys = new BlockingKeyMap();\n/**\n * Prevents fn from executing until key has been (attempted to be) loaded\n * @param {string} key\n * @param {Function} fn\n * @private\n * @returns {Promise} result of fn\n */\n\nfunction waitForValue(key) {\n  if (!key) {\n    throw new Error('`key` is required');\n  }\n\n  return function waitForValueDecorator(target, prop, descriptor) {\n    blockingKeys.add(target, prop, key);\n    descriptor.value = (0, _wrap2.default)(descriptor.value, function waitForValueExecutor(fn) {\n      var _this2 = this;\n\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n\n      var keys = blockingKeys.get(target, prop);\n      return _promise.default.all((0, _toConsumableArray2.default)(keys).map(function (k) {\n        return _this2.boundedStorage.waitFor(k);\n      })).then(function () {\n        return (0, _apply.default)(fn, _this2, args);\n      });\n    }); // This *should* make decorators compatible with AmpersandState class\n    // definitions\n\n    if ((0, _typeof2.default)(target) === 'object' && !target.prototype) {\n      target[prop] = descriptor.value;\n    }\n\n    prepareInitialize(target, prop);\n    return descriptor;\n  };\n}\n\nvar inited = new _set.default();\n/**\n * finds a means of identitying the `target` param passed to\n * `prepareInitialize()`. When possible, avoids duplicate `init()` calls if\n * namespaces collide\n *\n * @param {Object|Constructor} target\n * @private\n * @returns {String|Constructor}\n */\n\nfunction identifyTarget(target) {\n  if (target.namespace) {\n    return target.namespace;\n  }\n\n  return target;\n}\n\nvar stack = new _set.default();\n/**\n * @param {Function} target\n * @param {string} prop\n * @private\n * @returns {undefined}\n */\n\nfunction prepareInitialize(target, prop) {\n  var id = identifyTarget(target);\n\n  if (!inited.has(id)) {\n    inited.add(id);\n\n    if (target.initialize) {\n      target.initialize = (0, _wrap2.default)(target.initialize, function applyInit(fn) {\n        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n          args[_key4 - 1] = arguments[_key4];\n        }\n\n        var ret = (0, _apply.default)(fn, this, args);\n        (0, _apply.default)(init, this, args);\n        return ret;\n      });\n      return;\n    }\n\n    target.initialize = init;\n  }\n  /**\n   * @private\n   * @returns {undefined}\n   */\n\n\n  function init() {\n    var self = this;\n    var namespace = this.getNamespace();\n    this.webex.initialize = (0, _wrap2.default)(this.webex.initialize || _identity2.default, function applyInit(fn) {\n      var _this3 = this; // Call webex's initalize method first\n      // Reminder: in order for MockWebex to accept initial storage data, the\n      // wrapped initialize() must be invoked before attempting to load data.\n      // Reminder: context here is `webex`, not `self`.\n\n\n      stack.add(namespace);\n\n      for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        args[_key5 - 1] = arguments[_key5];\n      }\n\n      (0, _apply.default)(fn, this, args); // Then prepare a function for setting values retrieved from storage\n\n      var set = (0, _curry2.default)(function (key, value) {\n        _this3.logger.debug(\"storage:(\".concat(namespace, \"): got `\").concat(key, \"` for first time\"));\n\n        if (key === '@') {\n          self.parent.set((0, _defineProperty2.default)({}, namespace.toLowerCase(), value));\n        } else if ((0, _result2.default)(self[key], 'isState')) {\n          self[key].set(value);\n        } else {\n          self.set(key, value);\n        }\n\n        _this3.logger.debug(\"storage:(\".concat(namespace, \"): set `\").concat(key, \"` for first time\"));\n      }); // And prepare an error handler for when those keys can't be found\n\n      var handle = (0, _curry2.default)(function (key, reason) {\n        if (reason instanceof _errors.NotFoundError || process.env.NODE_ENV !== 'production' && reason.toString().includes('MockNotFoundError')) {\n          _this3.logger.debug(\"storage(\".concat(namespace, \"): no data for `\").concat(key, \"`, continuing\"));\n\n          return _promise.default.resolve();\n        }\n\n        _this3.logger.error(\"storage(\".concat(namespace, \"): failed to init `\").concat(key, \"`\"), reason);\n\n        return _promise.default.reject(reason);\n      }); // Iterate over the list of keys marked as blocking via `@waitForValue`\n\n      var keys = blockingKeys.get(target, prop);\n      var promises = [];\n      keys.forEach(function (key) {\n        promises.push(_this3.boundedStorage.get(namespace, key).then(set(key)).catch(handle(key)));\n      });\n\n      _promise.default.all(promises).then(function () {\n        stack.delete(namespace);\n\n        if (stack.size === 0) {\n          _this3.loaded = true;\n        }\n      });\n    });\n  }\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAaA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASA,OAAT,GAA0B;AAAA,oCAANC,IAAM;AAANA,QAAM,MAANA,GAAMC,eAAND;AAAM;;AAC/B,MAAIA,IAAI,CAACE,MAALF,KAAgB,CAApB,EAAuB;AACrB,WAAOD,OAAO,CAAC,GAAD,CAAPA,eAAgBC,IAAhBD,CAAP;AACD;;AAED,MAAOI,GAAP,GAAuBH,IAAvB;AAAA,MAAYI,OAAZ,GAAuBJ,IAAvB;AAEA,SAAO,SAASK,gBAAT,CAA0BC,MAA1B,EAAkCC,IAAlC,EAAwCC,UAAxC,EAAoD;AACzD,QAAID,IAAI,KAAK,YAAb,EAA2B;AACzB;AACA;AACA,YAAM,IAAIE,SAAJ,CAAc,oIAAd,CAAN;AACD;;AAEDD,cAAU,CAACE,KAAXF,GAAmB,oBAAKA,UAAU,CAACE,KAAhB,EAAuB,SAASC,eAAT,CAAyBC,EAAzB,EAAgD;AAAA;;AAAA,yCAAhBC,cAAgB;AAAhBA,sBAAgB,WAAhBA,GAAgBZ,gBAAhBY;AAAgB;;AACxF,UAAMC,GAAG,GAAG,oBAAcF,EAAd,EAAkB,IAAlB,EAAwBC,cAAxB,CAAZ;AACA,UAAME,WAAW,GAAGZ,GAAG,KAAK,GAARA,GAAc,QAAdA,oBAAmCA,GAAnC,CAApB,CAFwF,CAIxF;AACA;AACA;AACA;AACA;;AACA,WAAKa,EAAL,CAAQD,WAAR,EAAqB,wBAAS,YAAM;AAClC,YAAME,aAAa,GAAG,CAACb,OAAD,IAAYc,8BAAO,CAAOd,OAAP,EAAgBe,KAAhB,SAAyBN,cAAzB,CAAP,CAAlC;;AAEA,YAAI,CAACI,aAAL,EAAoB;AAClB,iBAAOG,iBAAQC,OAAR,EAAP;AACD;;AACD,YAAIlB,GAAG,KAAK,GAAZ,EAAiB;AACf;AACA,iBAAOgB,KAAI,CAACG,cAAL,CAAoBC,GAApB,CAAwBpB,GAAxB,EAA6BgB,KAA7B,CAAP;AARgC,UAWlC;;;AACA,eAAOA,KAAI,CAACG,cAAL,CAAoBC,GAApB,CAAwBpB,GAAxB,EAA6BgB,KAAI,CAAChB,GAAD,CAAjC,CAAP;AAZmB,SAalB,CAbkB,CAArB;AAeA,aAAOW,GAAP;AAxBiB,MAAnBN;AA2BAgB,qBAAiB,CAAClB,MAAD,EAASC,IAAT,CAAjBiB;AAlCF;AAoCD;;AAED,IAAMC,CAAC,eAAP;AACA,IAAMC,CAAC,eAAP;AACA,IAAMC,cAAc,GAAG,kBAAKF,CAAL,EAAQA,CAAR,EAAWC,CAAX,CAAvB;AACA,IAAME,YAAY,GAAG,IAAID,cAAJ,EAArB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACO,SAASE,YAAT,CAAsB1B,GAAtB,EAA2B;AAChC,MAAI,CAACA,GAAL,EAAU;AACR,UAAM,IAAI2B,KAAJ,CAAU,mBAAV,CAAN;AACD;;AAED,SAAO,SAASC,qBAAT,CAA+BzB,MAA/B,EAAuCC,IAAvC,EAA6CC,UAA7C,EAAyD;AAC9DoB,gBAAY,CAACI,GAAbJ,CAAiBtB,MAAjBsB,EAAyBrB,IAAzBqB,EAA+BzB,GAA/ByB;AACApB,cAAU,CAACE,KAAXF,GAAmB,oBAAKA,UAAU,CAACE,KAAhB,EAAuB,SAASuB,oBAAT,CAA8BrB,EAA9B,EAA2C;AAAA;;AAAA,yCAANZ,IAAM;AAANA,YAAM,WAANA,GAAMC,gBAAND;AAAM;;AACnF,UAAMkC,IAAI,GAAGN,YAAY,CAACO,GAAbP,CAAiBtB,MAAjBsB,EAAyBrB,IAAzBqB,CAAb;AAEA,aAAOR,iBAAQgB,GAAR,CAAY,iCAAIF,IAAJ,EAAUG,GAAV,CAAc,UAACC,CAAD;AAAA,eAAOC,MAAI,CAACjB,cAAL,CAAoBkB,OAApB,CAA4BF,CAA5B,CAAP;AAAd,QAAZ,EACJG,IADI,CACC;AAAA,eAAM,oBAAc7B,EAAd,EAAkB2B,MAAlB,EAAwBvC,IAAxB,CAAN;AADD,QAAP;AAHiB,MAAnBQ,CAF8D,CAS9D;AACA;;AACA,QAAI,sBAAOF,MAAP,MAAkB,QAAlB,IAA8B,CAACA,MAAM,CAACoC,SAA1C,EAAqD;AACnDpC,YAAM,CAACC,IAAD,CAAND,GAAeE,UAAU,CAACE,KAA1BJ;AACD;;AAEDkB,qBAAiB,CAAClB,MAAD,EAASC,IAAT,CAAjBiB;AAEA,WAAOhB,UAAP;AAjBF;AAmBD;;AAED,IAAMmC,MAAM,GAAG,kBAAf;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,cAAT,CAAwBtC,MAAxB,EAAgC;AAC9B,MAAIA,MAAM,CAACuC,SAAX,EAAsB;AACpB,WAAOvC,MAAM,CAACuC,SAAd;AACD;;AAED,SAAOvC,MAAP;AACD;;AAED,IAAMwC,KAAK,GAAG,kBAAd;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAStB,iBAAT,CAA2BlB,MAA3B,EAAmCC,IAAnC,EAAyC;AACvC,MAAMwC,EAAE,GAAGH,cAAc,CAACtC,MAAD,CAAzB;;AAEA,MAAI,CAACqC,MAAM,CAACK,GAAPL,CAAWI,EAAXJ,CAAL,EAAqB;AACnBA,UAAM,CAACX,GAAPW,CAAWI,EAAXJ;;AACA,QAAIrC,MAAM,CAAC2C,UAAX,EAAuB;AACrB3C,YAAM,CAAC2C,UAAP3C,GAAoB,oBAAKA,MAAM,CAAC2C,UAAZ,EAAwB,SAASC,SAAT,CAAmBtC,EAAnB,EAAgC;AAAA,2CAANZ,IAAM;AAANA,cAAM,WAANA,GAAMC,gBAAND;AAAM;;AAC1E,YAAMc,GAAG,GAAG,oBAAcF,EAAd,EAAkB,IAAlB,EAAwBZ,IAAxB,CAAZ;AAEA,4BAAcmD,IAAd,EAAoB,IAApB,EAA0BnD,IAA1B;AAEA,eAAOc,GAAP;AALkB,QAApBR;AAQA;AACD;;AAEDA,UAAM,CAAC2C,UAAP3C,GAAoB6C,IAApB7C;AACD;AAED;AACF;AACA;AACA;;;AACE,WAAS6C,IAAT,GAAgB;AACd,QAAMC,IAAI,GAAG,IAAb;AACA,QAAMP,SAAS,GAAG,KAAKQ,YAAL,EAAlB;AAEA,SAAKC,KAAL,CAAWL,UAAX,GAAwB,oBAAK,KAAKK,KAAL,CAAWL,UAAX,sBAAL,EAAwC,SAASC,SAAT,CAAmBtC,EAAnB,EAAgC;AAAA,yBAC9F;AACA;AACA;AACA;;;AACAkC,WAAK,CAACd,GAANc,CAAUD,SAAVC;;AAL8F,yCAAN9C,IAAM;AAANA,YAAM,WAANA,GAAMC,gBAAND;AAAM;;AAM9F,0BAAcY,EAAd,EAAkB,IAAlB,EAAwBZ,IAAxB,EAN8F,CAQ9F;;AACA,UAAMuD,GAAG,GAAG,qBAAM,UAACpD,GAAD,EAAMO,KAAN,EAAgB;AAChC8C,cAAI,CAACC,MAAL,CAAYC,KAAZ,oBAA8Bb,SAA9B,qBAAmD1C,GAAnD;;AACA,YAAIA,GAAG,KAAK,GAAZ,EAAiB;AACfiD,cAAI,CAACO,MAALP,CAAYG,GAAZH,mCACGP,SAAS,CAACe,WAAVf,EADH,EAC6BnC,KAD7B;AADF,eAKK,IAAI,sBAAO0C,IAAI,CAACjD,GAAD,CAAX,EAAkB,SAAlB,CAAJ,EAAkC;AACrCiD,cAAI,CAACjD,GAAD,CAAJiD,CAAUG,GAAVH,CAAc1C,KAAd0C;AADG,eAGA;AACHA,cAAI,CAACG,GAALH,CAASjD,GAATiD,EAAc1C,KAAd0C;AACD;;AACDI,cAAI,CAACC,MAAL,CAAYC,KAAZ,oBAA8Bb,SAA9B,qBAAmD1C,GAAnD;AAbU,QAAZ,CAT8F,CAyB9F;;AACA,UAAM0D,MAAM,GAAG,qBAAM,UAAC1D,GAAD,EAAM2D,MAAN,EAAiB;AACpC,YAAIA,MAAM,YAAYC,qBAAlBD,IAAmCE,OAAO,CAACC,GAARD,CAAYE,QAAZF,KAAyB,YAAzBA,IAAyCF,MAAM,CAACK,QAAPL,GAAkBM,QAAlBN,CAA2B,mBAA3BA,CAAhF,EAAiI;AAC/HN,gBAAI,CAACC,MAAL,CAAYC,KAAZ,mBAA6Bb,SAA7B,6BAA0D1C,GAA1D;;AAEA,iBAAOiB,iBAAQC,OAAR,EAAP;AACD;;AACDmC,cAAI,CAACC,MAAL,CAAYY,KAAZ,mBAA6BxB,SAA7B,gCAA6D1C,GAA7D,QAAsE2D,MAAtE;;AAEA,eAAO1C,iBAAQkD,MAAR,CAAeR,MAAf,CAAP;AARa,QAAf,CA1B8F,CAqC9F;;AACA,UAAM5B,IAAI,GAAGN,YAAY,CAACO,GAAbP,CAAiBtB,MAAjBsB,EAAyBrB,IAAzBqB,CAAb;AACA,UAAM2C,QAAQ,GAAG,EAAjB;AAEArC,UAAI,CAACsC,OAALtC,CAAa,UAAC/B,GAAD,EAAS;AACpBoE,gBAAQ,CAACE,IAATF,CAAcf,MAAI,CAAClC,cAAL,CAAoBa,GAApB,CAAwBU,SAAxB,EAAmC1C,GAAnC,EACXsC,IADW,CACNc,GAAG,CAACpD,GAAD,CADG,EAEXuE,KAFW,CAELb,MAAM,CAAC1D,GAAD,CAFD,CAAdoE;AADF;;AAMAnD,uBAAQgB,GAAR,CAAYmC,QAAZ,EACG9B,IADH,CACQ,YAAM;AACVK,aAAK,CAAC6B,MAAN7B,CAAaD,SAAbC;;AACA,YAAIA,KAAK,CAAC8B,IAAN9B,KAAe,CAAnB,EAAsB;AACpBU,gBAAI,CAACqB,MAAL,GAAc,IAAd;AACD;AALL;AA/CsB,MAAxB;AAuDD;AACF","names":["persist","args","arguments","length","key","decider","persistDecorator","target","prop","descriptor","TypeError","value","persistExecutor","fn","initializeArgs","ret","changeEvent","on","shouldPersist","_apply","_this","_promise","resolve","boundedStorage","put","prepareInitialize","M","S","BlockingKeyMap","blockingKeys","waitForValue","Error","waitForValueDecorator","add","waitForValueExecutor","keys","get","all","map","k","_this2","waitFor","then","prototype","inited","identifyTarget","namespace","stack","id","has","initialize","applyInit","init","self","getNamespace","webex","set","_this3","logger","debug","parent","toLowerCase","handle","reason","NotFoundError","process","env","NODE_ENV","toString","includes","error","reject","promises","forEach","push","catch","delete","size","loaded"],"sources":["decorators.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\n/* eslint no-invalid-this: [0] */\n\nimport {\n  curry,\n  debounce,\n  identity,\n  result,\n  wrap\n} from 'lodash';\nimport {make} from '@webex/common';\n\nimport {NotFoundError} from './errors';\n\n/**\n * Stores the result of fn before returning it\n * @param  {string} key\n * @private\n * @returns {Promise} resolves with the result of fn\n */\nexport function persist(...args) {\n  if (args.length === 3) {\n    return persist('@')(...args);\n  }\n\n  const [key, decider] = args;\n\n  return function persistDecorator(target, prop, descriptor) {\n    if (prop !== 'initialize') {\n      // Once we have class-based alternative to AmpersandState, it should be\n      // detected here.\n      throw new TypeError('@persist can only currently be applied to AmpersandState objects or their derivatives and must be applied to the initialize method');\n    }\n\n    descriptor.value = wrap(descriptor.value, function persistExecutor(fn, ...initializeArgs) {\n      const ret = Reflect.apply(fn, this, initializeArgs);\n      const changeEvent = key === '@' ? 'change' : `change:${key}`;\n\n      // Some scenarios will lead to lots of change events on a single tick; we\n      // really only care about writing once things have stopped changing. with\n      // a debounce of zero, we're effectively coalescing all the changes\n      // triggered by a single call to set() and commiting them on the next tick\n      // eslint-disable-next-line no-invalid-this\n      this.on(changeEvent, debounce(() => {\n        const shouldPersist = !decider || Reflect.apply(decider, this, ...initializeArgs);\n\n        if (!shouldPersist) {\n          return Promise.resolve();\n        }\n        if (key === '@') {\n          // eslint-disable-next-line no-invalid-this\n          return this.boundedStorage.put(key, this);\n        }\n\n        // eslint-disable-next-line no-invalid-this\n        return this.boundedStorage.put(key, this[key]);\n      }, 0));\n\n      return ret;\n    });\n\n    prepareInitialize(target, prop);\n  };\n}\n\nconst M = Map;\nconst S = Set;\nconst BlockingKeyMap = make(M, M, S);\nconst blockingKeys = new BlockingKeyMap();\n\n/**\n * Prevents fn from executing until key has been (attempted to be) loaded\n * @param {string} key\n * @param {Function} fn\n * @private\n * @returns {Promise} result of fn\n */\nexport function waitForValue(key) {\n  if (!key) {\n    throw new Error('`key` is required');\n  }\n\n  return function waitForValueDecorator(target, prop, descriptor) {\n    blockingKeys.add(target, prop, key);\n    descriptor.value = wrap(descriptor.value, function waitForValueExecutor(fn, ...args) {\n      const keys = blockingKeys.get(target, prop);\n\n      return Promise.all([...keys].map((k) => this.boundedStorage.waitFor(k)))\n        .then(() => Reflect.apply(fn, this, args));\n    });\n\n    // This *should* make decorators compatible with AmpersandState class\n    // definitions\n    if (typeof target === 'object' && !target.prototype) {\n      target[prop] = descriptor.value;\n    }\n\n    prepareInitialize(target, prop);\n\n    return descriptor;\n  };\n}\n\nconst inited = new Set();\n\n/**\n * finds a means of identitying the `target` param passed to\n * `prepareInitialize()`. When possible, avoids duplicate `init()` calls if\n * namespaces collide\n *\n * @param {Object|Constructor} target\n * @private\n * @returns {String|Constructor}\n */\nfunction identifyTarget(target) {\n  if (target.namespace) {\n    return target.namespace;\n  }\n\n  return target;\n}\n\nconst stack = new Set();\n\n/**\n * @param {Function} target\n * @param {string} prop\n * @private\n * @returns {undefined}\n */\nfunction prepareInitialize(target, prop) {\n  const id = identifyTarget(target);\n\n  if (!inited.has(id)) {\n    inited.add(id);\n    if (target.initialize) {\n      target.initialize = wrap(target.initialize, function applyInit(fn, ...args) {\n        const ret = Reflect.apply(fn, this, args);\n\n        Reflect.apply(init, this, args);\n\n        return ret;\n      });\n\n      return;\n    }\n\n    target.initialize = init;\n  }\n\n  /**\n   * @private\n   * @returns {undefined}\n   */\n  function init() {\n    const self = this;\n    const namespace = this.getNamespace();\n\n    this.webex.initialize = wrap(this.webex.initialize || identity, function applyInit(fn, ...args) {\n      // Call webex's initalize method first\n      // Reminder: in order for MockWebex to accept initial storage data, the\n      // wrapped initialize() must be invoked before attempting to load data.\n      // Reminder: context here is `webex`, not `self`.\n      stack.add(namespace);\n      Reflect.apply(fn, this, args);\n\n      // Then prepare a function for setting values retrieved from storage\n      const set = curry((key, value) => {\n        this.logger.debug(`storage:(${namespace}): got \\`${key}\\` for first time`);\n        if (key === '@') {\n          self.parent.set({\n            [namespace.toLowerCase()]: value\n          });\n        }\n        else if (result(self[key], 'isState')) {\n          self[key].set(value);\n        }\n        else {\n          self.set(key, value);\n        }\n        this.logger.debug(`storage:(${namespace}): set \\`${key}\\` for first time`);\n      });\n\n      // And prepare an error handler for when those keys can't be found\n      const handle = curry((key, reason) => {\n        if (reason instanceof NotFoundError || process.env.NODE_ENV !== 'production' && reason.toString().includes('MockNotFoundError')) {\n          this.logger.debug(`storage(${namespace}): no data for \\`${key}\\`, continuing`);\n\n          return Promise.resolve();\n        }\n        this.logger.error(`storage(${namespace}): failed to init \\`${key}\\``, reason);\n\n        return Promise.reject(reason);\n      });\n\n      // Iterate over the list of keys marked as blocking via `@waitForValue`\n      const keys = blockingKeys.get(target, prop);\n      const promises = [];\n\n      keys.forEach((key) => {\n        promises.push(this.boundedStorage.get(namespace, key)\n          .then(set(key))\n          .catch(handle(key)));\n      });\n\n      Promise.all(promises)\n        .then(() => {\n          stack.delete(namespace);\n          if (stack.size === 0) {\n            this.loaded = true;\n          }\n        });\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}