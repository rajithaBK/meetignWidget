{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\rkanthet\\\\Documents\\\\test_window_object\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\");\n\nvar _asyncToGenerator = require(\"C:/Users/rkanthet/Documents/test_window_object/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/rkanthet/Documents/test_window_object/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/rkanthet/Documents/test_window_object/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StreamReader = exports.EndOfStreamError = void 0;\n\nvar EndOfFileStream_1 = require(\"./EndOfFileStream\");\n\nvar Deferred_1 = require(\"./Deferred\");\n\nvar EndOfFileStream_2 = require(\"./EndOfFileStream\");\n\nObject.defineProperty(exports, \"EndOfStreamError\", {\n  enumerable: true,\n  get: function get() {\n    return EndOfFileStream_2.EndOfStreamError;\n  }\n});\nvar maxStreamReadSize = 1 * 1024 * 1024; // Maximum request length on read-stream operation\n\nvar StreamReader = /*#__PURE__*/function () {\n  function StreamReader(s) {\n    var _this = this;\n\n    _classCallCheck(this, StreamReader);\n\n    this.s = s;\n    /**\r\n     * Deferred used for postponed read request (as not data is yet available to read)\r\n     */\n\n    this.deferred = null;\n    this.endOfStream = false;\n    /**\r\n     * Store peeked data\r\n     * @type {Array}\r\n     */\n\n    this.peekQueue = [];\n\n    if (!s.read || !s.once) {\n      throw new Error('Expected an instance of stream.Readable');\n    }\n\n    this.s.once('end', function () {\n      return _this.reject(new EndOfFileStream_1.EndOfStreamError());\n    });\n    this.s.once('error', function (err) {\n      return _this.reject(err);\n    });\n    this.s.once('close', function () {\n      return _this.reject(new Error('Stream closed'));\n    });\n  }\n  /**\r\n   * Read ahead (peek) from stream. Subsequent read or peeks will return the same data\r\n   * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in\r\n   * @param offset - Offset target\r\n   * @param length - Number of bytes to read\r\n   * @returns Number of bytes peeked\r\n   */\n\n\n  _createClass(StreamReader, [{\n    key: \"peek\",\n    value: function () {\n      var _peek = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(uint8Array, offset, length) {\n        var bytesRead;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.read(uint8Array, offset, length);\n\n              case 2:\n                bytesRead = _context.sent;\n                this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead)); // Put read data back to peek buffer\n\n                return _context.abrupt(\"return\", bytesRead);\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function peek(_x, _x2, _x3) {\n        return _peek.apply(this, arguments);\n      }\n\n      return peek;\n    }()\n    /**\r\n     * Read chunk from stream\r\n     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in\r\n     * @param offset - Offset target\r\n     * @param length - Number of bytes to read\r\n     * @returns Number of bytes read\r\n     */\n\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(buffer, offset, length) {\n        var remaining, bytesRead, peekData, lenCopy, reqLen, chunkLen;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(length === 0)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", 0);\n\n              case 2:\n                if (!(this.peekQueue.length === 0 && this.endOfStream)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                throw new EndOfFileStream_1.EndOfStreamError();\n\n              case 4:\n                remaining = length;\n                bytesRead = 0; // consume peeked data first\n\n              case 6:\n                if (!(this.peekQueue.length > 0 && remaining > 0)) {\n                  _context2.next = 17;\n                  break;\n                }\n\n                peekData = this.peekQueue.pop(); // Front of queue\n\n                if (peekData) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                throw new Error('peekData should be defined');\n\n              case 10:\n                lenCopy = Math.min(peekData.length, remaining);\n                buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);\n                bytesRead += lenCopy;\n                remaining -= lenCopy;\n\n                if (lenCopy < peekData.length) {\n                  // remainder back to queue\n                  this.peekQueue.push(peekData.subarray(lenCopy));\n                }\n\n                _context2.next = 6;\n                break;\n\n              case 17:\n                if (!(remaining > 0 && !this.endOfStream)) {\n                  _context2.next = 28;\n                  break;\n                }\n\n                reqLen = Math.min(remaining, maxStreamReadSize);\n                _context2.next = 21;\n                return this.readFromStream(buffer, offset + bytesRead, reqLen);\n\n              case 21:\n                chunkLen = _context2.sent;\n                bytesRead += chunkLen;\n\n                if (!(chunkLen < reqLen)) {\n                  _context2.next = 25;\n                  break;\n                }\n\n                return _context2.abrupt(\"break\", 28);\n\n              case 25:\n                remaining -= chunkLen;\n                _context2.next = 17;\n                break;\n\n              case 28:\n                return _context2.abrupt(\"return\", bytesRead);\n\n              case 29:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function read(_x4, _x5, _x6) {\n        return _read.apply(this, arguments);\n      }\n\n      return read;\n    }()\n    /**\r\n     * Read chunk from stream\r\n     * @param buffer Target Uint8Array (or Buffer) to store data read from stream in\r\n     * @param offset Offset target\r\n     * @param length Number of bytes to read\r\n     * @returns Number of bytes read\r\n     */\n\n  }, {\n    key: \"readFromStream\",\n    value: function () {\n      var _readFromStream = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(buffer, offset, length) {\n        var _this2 = this;\n\n        var readBuffer, request;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                readBuffer = this.s.read(length);\n\n                if (!readBuffer) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                buffer.set(readBuffer, offset);\n                return _context3.abrupt(\"return\", readBuffer.length);\n\n              case 6:\n                request = {\n                  buffer: buffer,\n                  offset: offset,\n                  length: length,\n                  deferred: new Deferred_1.Deferred()\n                };\n                this.deferred = request.deferred;\n                this.s.once('readable', function () {\n                  _this2.readDeferred(request);\n                });\n                return _context3.abrupt(\"return\", request.deferred.promise);\n\n              case 10:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function readFromStream(_x7, _x8, _x9) {\n        return _readFromStream.apply(this, arguments);\n      }\n\n      return readFromStream;\n    }()\n    /**\r\n     * Process deferred read request\r\n     * @param request Deferred read request\r\n     */\n\n  }, {\n    key: \"readDeferred\",\n    value: function readDeferred(request) {\n      var _this3 = this;\n\n      var readBuffer = this.s.read(request.length);\n\n      if (readBuffer) {\n        request.buffer.set(readBuffer, request.offset);\n        request.deferred.resolve(readBuffer.length);\n        this.deferred = null;\n      } else {\n        this.s.once('readable', function () {\n          _this3.readDeferred(request);\n        });\n      }\n    }\n  }, {\n    key: \"reject\",\n    value: function reject(err) {\n      this.endOfStream = true;\n\n      if (this.deferred) {\n        this.deferred.reject(err);\n        this.deferred = null;\n      }\n    }\n  }]);\n\n  return StreamReader;\n}();\n\nexports.StreamReader = StreamReader;","map":{"version":3,"sources":["C:/Users/rkanthet/Documents/test_window_object/node_modules/peek-readable/lib/StreamReader.js"],"names":["Object","defineProperty","exports","value","StreamReader","EndOfStreamError","EndOfFileStream_1","require","Deferred_1","EndOfFileStream_2","enumerable","get","maxStreamReadSize","s","deferred","endOfStream","peekQueue","read","once","Error","reject","err","uint8Array","offset","length","bytesRead","push","subarray","buffer","remaining","peekData","pop","lenCopy","Math","min","set","reqLen","readFromStream","chunkLen","readBuffer","request","Deferred","readDeferred","promise","resolve"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.StreamReader = exports.EndOfStreamError = void 0;\r\nconst EndOfFileStream_1 = require(\"./EndOfFileStream\");\r\nconst Deferred_1 = require(\"./Deferred\");\r\nvar EndOfFileStream_2 = require(\"./EndOfFileStream\");\r\nObject.defineProperty(exports, \"EndOfStreamError\", { enumerable: true, get: function () { return EndOfFileStream_2.EndOfStreamError; } });\r\nconst maxStreamReadSize = 1 * 1024 * 1024; // Maximum request length on read-stream operation\r\nclass StreamReader {\r\n    constructor(s) {\r\n        this.s = s;\r\n        /**\r\n         * Deferred used for postponed read request (as not data is yet available to read)\r\n         */\r\n        this.deferred = null;\r\n        this.endOfStream = false;\r\n        /**\r\n         * Store peeked data\r\n         * @type {Array}\r\n         */\r\n        this.peekQueue = [];\r\n        if (!s.read || !s.once) {\r\n            throw new Error('Expected an instance of stream.Readable');\r\n        }\r\n        this.s.once('end', () => this.reject(new EndOfFileStream_1.EndOfStreamError()));\r\n        this.s.once('error', err => this.reject(err));\r\n        this.s.once('close', () => this.reject(new Error('Stream closed')));\r\n    }\r\n    /**\r\n     * Read ahead (peek) from stream. Subsequent read or peeks will return the same data\r\n     * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in\r\n     * @param offset - Offset target\r\n     * @param length - Number of bytes to read\r\n     * @returns Number of bytes peeked\r\n     */\r\n    async peek(uint8Array, offset, length) {\r\n        const bytesRead = await this.read(uint8Array, offset, length);\r\n        this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead)); // Put read data back to peek buffer\r\n        return bytesRead;\r\n    }\r\n    /**\r\n     * Read chunk from stream\r\n     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in\r\n     * @param offset - Offset target\r\n     * @param length - Number of bytes to read\r\n     * @returns Number of bytes read\r\n     */\r\n    async read(buffer, offset, length) {\r\n        if (length === 0) {\r\n            return 0;\r\n        }\r\n        if (this.peekQueue.length === 0 && this.endOfStream) {\r\n            throw new EndOfFileStream_1.EndOfStreamError();\r\n        }\r\n        let remaining = length;\r\n        let bytesRead = 0;\r\n        // consume peeked data first\r\n        while (this.peekQueue.length > 0 && remaining > 0) {\r\n            const peekData = this.peekQueue.pop(); // Front of queue\r\n            if (!peekData)\r\n                throw new Error('peekData should be defined');\r\n            const lenCopy = Math.min(peekData.length, remaining);\r\n            buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);\r\n            bytesRead += lenCopy;\r\n            remaining -= lenCopy;\r\n            if (lenCopy < peekData.length) {\r\n                // remainder back to queue\r\n                this.peekQueue.push(peekData.subarray(lenCopy));\r\n            }\r\n        }\r\n        // continue reading from stream if required\r\n        while (remaining > 0 && !this.endOfStream) {\r\n            const reqLen = Math.min(remaining, maxStreamReadSize);\r\n            const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);\r\n            bytesRead += chunkLen;\r\n            if (chunkLen < reqLen)\r\n                break;\r\n            remaining -= chunkLen;\r\n        }\r\n        return bytesRead;\r\n    }\r\n    /**\r\n     * Read chunk from stream\r\n     * @param buffer Target Uint8Array (or Buffer) to store data read from stream in\r\n     * @param offset Offset target\r\n     * @param length Number of bytes to read\r\n     * @returns Number of bytes read\r\n     */\r\n    async readFromStream(buffer, offset, length) {\r\n        const readBuffer = this.s.read(length);\r\n        if (readBuffer) {\r\n            buffer.set(readBuffer, offset);\r\n            return readBuffer.length;\r\n        }\r\n        else {\r\n            const request = {\r\n                buffer,\r\n                offset,\r\n                length,\r\n                deferred: new Deferred_1.Deferred()\r\n            };\r\n            this.deferred = request.deferred;\r\n            this.s.once('readable', () => {\r\n                this.readDeferred(request);\r\n            });\r\n            return request.deferred.promise;\r\n        }\r\n    }\r\n    /**\r\n     * Process deferred read request\r\n     * @param request Deferred read request\r\n     */\r\n    readDeferred(request) {\r\n        const readBuffer = this.s.read(request.length);\r\n        if (readBuffer) {\r\n            request.buffer.set(readBuffer, request.offset);\r\n            request.deferred.resolve(readBuffer.length);\r\n            this.deferred = null;\r\n        }\r\n        else {\r\n            this.s.once('readable', () => {\r\n                this.readDeferred(request);\r\n            });\r\n        }\r\n    }\r\n    reject(err) {\r\n        this.endOfStream = true;\r\n        if (this.deferred) {\r\n            this.deferred.reject(err);\r\n            this.deferred = null;\r\n        }\r\n    }\r\n}\r\nexports.StreamReader = StreamReader;\r\n"]},"metadata":{},"sourceType":"script"}