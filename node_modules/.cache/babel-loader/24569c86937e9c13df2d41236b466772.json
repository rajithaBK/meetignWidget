{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.proxyEvents = proxyEvents;\nexports.transferEvents = transferEvents;\n\nvar _apply = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/reflect/apply\"));\n\nvar _isArray2 = _interopRequireDefault(require(\"lodash/isArray\"));\n/**\n * Proxies the event binding methods of emitter onto proxy\n * @param {EventEmitter|EventEmitterProxy} emitter\n * @param {mixed} proxy (probably a promise)\n * @returns {EventEmitter} Returns the source emitter to ease use in promise chains\n */\n\n\nfunction proxyEvents(emitter, proxy) {\n  ['on', 'once'].forEach(function (key) {\n    proxy[key] = function () {\n      emitter[key].apply(emitter, arguments);\n      return proxy;\n    };\n  });\n  return emitter;\n}\n/**\n * Given a list of events, fires them on drain when they're emitted from source\n * @param {Array|string} events\n * @param {EventEmitter} source\n * @param {EventEmitter} drain\n * @returns {undefined}\n */\n\n\nfunction transferEvents(events, source, drain) {\n  events = (0, _isArray2.default)(events) ? events : [events];\n  events.forEach(function (event) {\n    if (source.on) {\n      source.on(event, function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        return emit.apply(void 0, [drain, event].concat(args));\n      });\n    }\n  });\n}\n/**\n * Emits an event\n * @param {EventEmitter} target The EventEmitter from which to emit an event\n * @returns {mixed}\n */\n\n\nfunction emit(target) {\n  var method = target.trigger || target.emit;\n  /* istanbul ignore if */\n\n  if (!method) {\n    throw new Error('count not determine emit method');\n  }\n\n  for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    rest[_key2 - 1] = arguments[_key2];\n  }\n\n  return (0, _apply.default)(method, target, rest);\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASA,WAAT,CAAqBC,OAArB,EAA8BC,KAA9B,EAAqC;AAC1C,GACE,IADF,EAEE,MAFF,EAGEC,OAHF,CAGU,UAACC,GAAD,EAAS;AACjBF,SAAK,CAACE,GAAD,CAALF,GAAa,YAAa;AACxBD,aAAO,CAACG,GAAD,CAAPH,gBAAOI,SAAPJ;AAEA,aAAOC,KAAP;AAHF;AAJF;AAWA,SAAOD,OAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASK,cAAT,CAAwBC,MAAxB,EAAgCC,MAAhC,EAAwCC,KAAxC,EAA+C;AACpDF,QAAM,GAAG,uBAAQA,MAAR,IAAkBA,MAAlB,GAA2B,CAACA,MAAD,CAApCA;AACAA,QAAM,CAACJ,OAAPI,CAAe,UAACG,KAAD,EAAW;AACxB,QAAIF,MAAM,CAACG,EAAX,EAAe;AACbH,YAAM,CAACG,EAAPH,CAAUE,KAAVF,EAAiB;AAAA,0CAAII,IAAJ;AAAIA,cAAJ,MAAIA,GAAJP,eAAIO;AAAJ;;AAAA,eAAaC,IAAI,MAAJA,UAAKJ,KAAL,EAAYC,KAAZ,SAAsBE,IAAtB,EAAb;AAAjB;AACD;AAHH;AAKD;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASC,IAAT,CAAcC,MAAd,EAA+B;AAC7B,MAAMC,MAAM,GAAGD,MAAM,CAACE,OAAPF,IAAkBA,MAAM,CAACD,IAAxC;AAEA;;AACA,MAAI,CAACE,MAAL,EAAa;AACX,UAAM,IAAIE,KAAJ,CAAU,iCAAV,CAAN;AACD;;AAN4B,qCAANC,IAAM;AAANA,QAAM,WAANA,GAAMb,gBAANa;AAAM;;AAQ7B,SAAO,oBAAcH,MAAd,EAAsBD,MAAtB,EAA8BI,IAA9B,CAAP;AACD","names":["proxyEvents","emitter","proxy","forEach","key","arguments","transferEvents","events","source","drain","event","on","args","emit","target","method","trigger","Error","rest"],"sources":["events.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {isArray} from 'lodash';\n\n/**\n * Proxies the event binding methods of emitter onto proxy\n * @param {EventEmitter|EventEmitterProxy} emitter\n * @param {mixed} proxy (probably a promise)\n * @returns {EventEmitter} Returns the source emitter to ease use in promise chains\n */\nexport function proxyEvents(emitter, proxy) {\n  [\n    'on',\n    'once'\n  ].forEach((key) => {\n    proxy[key] = (...args) => {\n      emitter[key](...args);\n\n      return proxy;\n    };\n  });\n\n  return emitter;\n}\n\n/**\n * Given a list of events, fires them on drain when they're emitted from source\n * @param {Array|string} events\n * @param {EventEmitter} source\n * @param {EventEmitter} drain\n * @returns {undefined}\n */\nexport function transferEvents(events, source, drain) {\n  events = isArray(events) ? events : [events];\n  events.forEach((event) => {\n    if (source.on) {\n      source.on(event, (...args) => emit(drain, event, ...args));\n    }\n  });\n}\n\n/**\n * Emits an event\n * @param {EventEmitter} target The EventEmitter from which to emit an event\n * @returns {mixed}\n */\nfunction emit(target, ...rest) {\n  const method = target.trigger || target.emit;\n\n  /* istanbul ignore if */\n  if (!method) {\n    throw new Error('count not determine emit method');\n  }\n\n  return Reflect.apply(method, target, rest);\n}\n"]},"metadata":{},"sourceType":"script"}