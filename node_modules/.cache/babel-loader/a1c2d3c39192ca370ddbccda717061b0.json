{"ast":null,"code":"\"use strict\";\n\nvar _Object$keys = require(\"@babel/runtime-corejs2/core-js/object/keys\");\n\nvar _Object$getOwnPropertySymbols = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\");\n\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\");\n\nvar _Object$getOwnPropertyDescriptors = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\");\n\nvar _Object$defineProperties = require(\"@babel/runtime-corejs2/core-js/object/define-properties\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/defineProperty\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/json/stringify\"));\n\nvar _events = require(\"events\");\n\nvar _url = _interopRequireDefault(require(\"url\"));\n\nvar _webexCore = require(\"@webex/webex-core\");\n\nvar _common = require(\"@webex/common\");\n\nvar _nodeJose = _interopRequireDefault(require(\"node-jose\"));\n\nvar _nodeScr = _interopRequireDefault(require(\"node-scr\"));\n\nvar _ensureBuffer = _interopRequireDefault(require(\"./ensure-buffer\"));\n\nvar _kms = _interopRequireDefault(require(\"./kms\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = _Object$keys(object);\n\n  if (_Object$getOwnPropertySymbols) {\n    var symbols = _Object$getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return _Object$getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (_Object$getOwnPropertyDescriptors) {\n      _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Encryption = _webexCore.WebexPlugin.extend({\n  children: {\n    kms: _kms.default\n  },\n  namespace: 'Encryption',\n  processKmsMessageEvent: function processKmsMessageEvent(event) {\n    return this.kms.processKmsMessageEvent(event);\n  },\n  decryptBinary: function decryptBinary(scr, buffer) {\n    return (0, _ensureBuffer.default)(buffer).then(function (b) {\n      /* istanbul ignore if */\n      if (buffer.length === 0 || buffer.byteLength === 0) {\n        return _promise.default.reject(new Error('Attempted to decrypt zero-length buffer'));\n      }\n\n      return scr.decrypt(b);\n    });\n  },\n\n  /**\n   * Decrypt a SCR (Secure Content Resource) using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {Object} cipherScr - An encrypted SCR\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {Object} Decrypted SCR\n   */\n  decryptScr: function decryptScr(key, cipherScr, options) {\n    return this.getKey(key, options).then(function (k) {\n      return _nodeScr.default.fromJWE(k.jwk, cipherScr);\n    });\n  },\n\n  /**\n   * Decrypt text using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {string} ciphertext - Encrypted text\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Decrypted plaintext\n   */\n  decryptText: function decryptText(key, ciphertext, options) {\n    return this.getKey(key, options).then(function (k) {\n      return _nodeJose.default.JWE.createDecrypt(k.jwk).decrypt(ciphertext).then(function (result) {\n        return result.plaintext.toString();\n      });\n    });\n  },\n\n  /**\n   * Validate and initiate a Download request for requested file\n   *\n   * @param {Object} scr - Plaintext\n   * @param {Object} options - optional paramaters to download a file\n   * @returns {promise}\n   */\n  download: function download(scr, options) {\n    var _this = this;\n    /* istanbul ignore if */\n\n\n    if (!scr.loc) {\n      return _promise.default.reject(new Error('`scr.loc` is required'));\n    }\n\n    var shunt = new _events.EventEmitter();\n\n    var promise = this._fetchDownloadUrl(scr, options).then(function (uri) {\n      var options = {\n        method: 'GET',\n        uri: uri,\n        responseType: 'buffer'\n      };\n\n      var ret = _this.request(options);\n\n      (0, _common.transferEvents)('progress', options.download, shunt);\n      return ret;\n    }).then(function (res) {\n      return _this.decryptBinary(scr, res.body);\n    });\n\n    (0, _common.proxyEvents)(shunt, promise);\n    return promise;\n  },\n\n  /**\n   * Fetch Download URL for the requested file\n   *\n   * @param {Object} scr - Plaintext\n   * @param {Object} options - optional paramaters to download a file\n   * @returns {promise} url of the downloadable file\n   */\n  _fetchDownloadUrl: function _fetchDownloadUrl(scr, options) {\n    var _this2 = this;\n\n    this.logger.info('encryption: retrieving download url for encrypted file');\n\n    if (process.env.NODE_ENV !== 'production' && scr.loc.includes('localhost')) {\n      this.logger.info('encryption: bypassing webex files because this looks to be a test file on localhost');\n      return _promise.default.resolve(scr.loc);\n    }\n\n    var inputBody = {\n      endpoints: [scr.loc]\n    };\n\n    var endpointUrl = _url.default.parse(scr.loc); // hardcode the url to use 'https' and the file service '/v1/download/endpoints' api\n\n\n    endpointUrl.protocol = 'https';\n    endpointUrl.pathname = '/v1/download/endpoints';\n    return this.request({\n      method: 'POST',\n      uri: _url.default.format(endpointUrl),\n      body: options ? _objectSpread(_objectSpread({}, inputBody), {}, {\n        allow: options.params.allow\n      }) : inputBody\n    }).then(function (res) {\n      var url = res.body.endpoints[scr.loc];\n\n      if (!url) {\n        _this2.logger.warn('encryption: could not determine download url for `scr.loc`; attempting to download `scr.loc` directly');\n\n        return scr.loc;\n      }\n\n      _this2.logger.info('encryption: retrieved download url for encrypted file');\n\n      return url;\n    });\n  },\n  encryptBinary: function encryptBinary(file) {\n    return (0, _ensureBuffer.default)(file).then(function (buffer) {\n      return _nodeScr.default.create().then(function (scr) {\n        return scr.encrypt(buffer).then(_ensureBuffer.default) // eslint-disable-next-line max-nested-callbacks\n        .then(function (cdata) {\n          return {\n            scr: scr,\n            cdata: cdata\n          };\n        });\n      });\n    });\n  },\n\n  /**\n   * Encrypt a SCR (Secure Content Resource) using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {Object} scr - Plaintext\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Encrypted SCR\n   */\n  encryptScr: function encryptScr(key, scr, options) {\n    /* istanbul ignore if */\n    if (!scr.loc) {\n      return _promise.default.reject(new Error('Cannot encrypt `scr` without first setting `loc`'));\n    }\n\n    return this.getKey(key, options).then(function (k) {\n      return scr.toJWE(k.jwk);\n    });\n  },\n\n  /**\n   * Encrypt plaintext using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {string} plaintext\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Encrypted text\n   */\n  encryptText: function encryptText(key, plaintext, options) {\n    var _this3 = this;\n\n    return this.getKey(key, options).then(function (k) {\n      return _nodeJose.default.JWE.createEncrypt(_this3.config.joseOptions, {\n        key: k.jwk,\n        header: {\n          alg: 'dir'\n        },\n        reference: null\n      }).final(plaintext, 'utf8');\n    });\n  },\n\n  /**\n   * Fetch the key associated with the supplied KMS uri.\n   *\n   * @param {string} uri - The uri of a key stored in KMS\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Key\n   */\n  getKey: function getKey(uri) {\n    var _this4 = this;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        onBehalfOf = _ref.onBehalfOf;\n\n    if (uri.jwk) {\n      return this.kms.asKey(uri);\n    }\n\n    var storageKey = uri;\n\n    if (onBehalfOf) {\n      storageKey += \"/onBehalfOf/\".concat(onBehalfOf);\n    }\n\n    return this.unboundedStorage.get(storageKey).then(function (keyString) {\n      return JSON.parse(keyString);\n    }).then(function (keyObject) {\n      return _this4.kms.asKey(keyObject);\n    }).catch(function () {\n      return _this4.kms.fetchKey({\n        uri: uri,\n        onBehalfOf: onBehalfOf\n      }).then((0, _common.tap)(function (key) {\n        return _this4.unboundedStorage.put(storageKey, (0, _stringify.default)(key, replacer));\n      }));\n    });\n  },\n  version: \"1.154.2\"\n});\n/**\n * JSON.stringify replacer that ensures private key data is serialized.\n * @param {string} k\n * @param {mixed} v\n * @returns {mixed}\n */\n\n\nfunction replacer(k, v) {\n  if (k === 'jwk') {\n    // note: this[k] and v may be different representations of the same value\n    // eslint-disable-next-line no-invalid-this\n    var json = this[k].toJSON(true);\n    return json;\n  }\n\n  return v;\n}\n\nvar _default = Encryption;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["Encryption","WebexPlugin","extend","children","kms","KMS","namespace","processKmsMessageEvent","event","decryptBinary","scr","buffer","then","b","length","byteLength","_promise","reject","Error","decrypt","decryptScr","key","cipherScr","options","getKey","k","SCR","fromJWE","jwk","decryptText","ciphertext","jose","JWE","createDecrypt","result","plaintext","toString","download","loc","shunt","EventEmitter","promise","_fetchDownloadUrl","uri","method","responseType","ret","_this","request","res","body","logger","info","process","env","NODE_ENV","includes","resolve","inputBody","endpoints","endpointUrl","url","parse","protocol","pathname","format","allow","params","_this2","warn","encryptBinary","file","create","encrypt","ensureBuffer","cdata","encryptScr","toJWE","encryptText","createEncrypt","_this3","config","joseOptions","header","alg","reference","final","onBehalfOf","asKey","storageKey","unboundedStorage","get","keyString","JSON","keyObject","_this4","catch","fetchKey","put","replacer","version","v","json","toJSON"],"sources":["encryption.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {EventEmitter} from 'events';\nimport url from 'url';\n\nimport {WebexPlugin} from '@webex/webex-core';\nimport {proxyEvents, tap, transferEvents} from '@webex/common';\nimport jose from 'node-jose';\nimport SCR from 'node-scr';\n\nimport ensureBuffer from './ensure-buffer';\nimport KMS from './kms';\n\nconst Encryption = WebexPlugin.extend({\n  children: {\n    kms: KMS\n  },\n\n  namespace: 'Encryption',\n\n  processKmsMessageEvent(event) {\n    return this.kms.processKmsMessageEvent(event);\n  },\n\n  decryptBinary(scr, buffer) {\n    return ensureBuffer(buffer)\n      .then((b) => {\n        /* istanbul ignore if */\n        if (buffer.length === 0 || buffer.byteLength === 0) {\n          return Promise.reject(new Error('Attempted to decrypt zero-length buffer'));\n        }\n\n        return scr.decrypt(b);\n      });\n  },\n\n  /**\n   * Decrypt a SCR (Secure Content Resource) using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {Object} cipherScr - An encrypted SCR\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {Object} Decrypted SCR\n   */\n  decryptScr(key, cipherScr, options) {\n    return this.getKey(key, options)\n      .then((k) => SCR.fromJWE(k.jwk, cipherScr));\n  },\n\n  /**\n   * Decrypt text using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {string} ciphertext - Encrypted text\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Decrypted plaintext\n   */\n  decryptText(key, ciphertext, options) {\n    return this.getKey(key, options)\n      .then((k) => jose.JWE\n        .createDecrypt(k.jwk)\n        .decrypt(ciphertext)\n        .then((result) => result.plaintext.toString()));\n  },\n\n  /**\n   * Validate and initiate a Download request for requested file\n   *\n   * @param {Object} scr - Plaintext\n   * @param {Object} options - optional paramaters to download a file\n   * @returns {promise}\n   */\n  download(scr, options) {\n    /* istanbul ignore if */\n    if (!scr.loc) {\n      return Promise.reject(new Error('`scr.loc` is required'));\n    }\n\n    const shunt = new EventEmitter();\n    const promise = this._fetchDownloadUrl(scr, options)\n      .then((uri) => {\n        const options = {\n          method: 'GET',\n          uri,\n          responseType: 'buffer'\n        };\n\n        const ret = this.request(options);\n\n        transferEvents('progress', options.download, shunt);\n\n        return ret;\n      })\n      .then((res) => this.decryptBinary(scr, res.body));\n\n    proxyEvents(shunt, promise);\n\n    return promise;\n  },\n\n  /**\n   * Fetch Download URL for the requested file\n   *\n   * @param {Object} scr - Plaintext\n   * @param {Object} options - optional paramaters to download a file\n   * @returns {promise} url of the downloadable file\n   */\n  _fetchDownloadUrl(scr, options) {\n    this.logger.info('encryption: retrieving download url for encrypted file');\n\n    if (process.env.NODE_ENV !== 'production' && scr.loc.includes('localhost')) {\n      this.logger.info('encryption: bypassing webex files because this looks to be a test file on localhost');\n\n      return Promise.resolve(scr.loc);\n    }\n\n    const inputBody = {\n      endpoints: [scr.loc]\n    };\n    const endpointUrl = url.parse(scr.loc);\n\n    // hardcode the url to use 'https' and the file service '/v1/download/endpoints' api\n    endpointUrl.protocol = 'https';\n    endpointUrl.pathname = '/v1/download/endpoints';\n\n    return this.request({\n      method: 'POST',\n      uri: url.format(endpointUrl),\n      body: options ? {\n        ...inputBody,\n        allow: options.params.allow\n      } : inputBody\n    })\n      .then((res) => {\n        const url = res.body.endpoints[scr.loc];\n\n        if (!url) {\n          this.logger.warn('encryption: could not determine download url for `scr.loc`; attempting to download `scr.loc` directly');\n\n          return scr.loc;\n        }\n        this.logger.info('encryption: retrieved download url for encrypted file');\n\n        return url;\n      });\n  },\n\n  encryptBinary(file) {\n    return ensureBuffer(file)\n      .then((buffer) => SCR.create()\n        .then((scr) => scr.encrypt(buffer)\n          .then(ensureBuffer)\n          // eslint-disable-next-line max-nested-callbacks\n          .then((cdata) => ({scr, cdata}))));\n  },\n\n  /**\n   * Encrypt a SCR (Secure Content Resource) using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {Object} scr - Plaintext\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Encrypted SCR\n   */\n  encryptScr(key, scr, options) {\n    /* istanbul ignore if */\n    if (!scr.loc) {\n      return Promise.reject(new Error('Cannot encrypt `scr` without first setting `loc`'));\n    }\n\n    return this.getKey(key, options)\n      .then((k) => scr.toJWE(k.jwk));\n  },\n\n  /**\n   * Encrypt plaintext using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {string} plaintext\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Encrypted text\n   */\n  encryptText(key, plaintext, options) {\n    return this.getKey(key, options)\n      .then((k) => jose.JWE\n        .createEncrypt(this.config.joseOptions, {\n          key: k.jwk,\n          header: {\n            alg: 'dir'\n          },\n          reference: null\n        })\n        .final(plaintext, 'utf8'));\n  },\n\n  /**\n   * Fetch the key associated with the supplied KMS uri.\n   *\n   * @param {string} uri - The uri of a key stored in KMS\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Key\n   */\n  getKey(uri, {onBehalfOf} = {}) {\n    if (uri.jwk) {\n      return this.kms.asKey(uri);\n    }\n\n    let storageKey = uri;\n\n    if (onBehalfOf) {\n      storageKey += `/onBehalfOf/${onBehalfOf}`;\n    }\n\n    return this.unboundedStorage.get(storageKey)\n      .then((keyString) => JSON.parse(keyString))\n      .then((keyObject) => this.kms.asKey(keyObject))\n      .catch(() => this.kms.fetchKey({uri, onBehalfOf})\n        .then(tap((key) => this.unboundedStorage.put(storageKey, JSON.stringify(key, replacer)))));\n  }\n});\n\n/**\n * JSON.stringify replacer that ensures private key data is serialized.\n * @param {string} k\n * @param {mixed} v\n * @returns {mixed}\n */\nfunction replacer(k, v) {\n  if (k === 'jwk') {\n    // note: this[k] and v may be different representations of the same value\n    // eslint-disable-next-line no-invalid-this\n    const json = this[k].toJSON(true);\n\n    return json;\n  }\n\n  return v;\n}\n\nexport default Encryption;\n"]},"metadata":{},"sourceType":"script"}