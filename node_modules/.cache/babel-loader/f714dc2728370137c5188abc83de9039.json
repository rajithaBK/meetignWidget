{"ast":null,"code":"\"use strict\";\n\nvar _Reflect$construct = require(\"@babel/runtime-corejs2/core-js/reflect/construct\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/createClass\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/getPrototypeOf\"));\n\nvar _set2 = _interopRequireDefault(require(\"lodash/set\"));\n\nvar _httpCore = require(\"@webex/http-core\");\n\nvar _constants = require(\"../constants\");\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2.default)(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;\n      result = _Reflect$construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0, _possibleConstructorReturn2.default)(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false;\n  if (_Reflect$construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n  * Adds 'cisco-device-url' header, as appropriate, to requests\n  */\n\n\nvar DeviceUrlInterceptor = /*#__PURE__*/function (_Interceptor) {\n  (0, _inherits2.default)(DeviceUrlInterceptor, _Interceptor);\n\n  var _super = _createSuper(DeviceUrlInterceptor);\n\n  function DeviceUrlInterceptor() {\n    (0, _classCallCheck2.default)(this, DeviceUrlInterceptor);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(DeviceUrlInterceptor, [{\n    key: \"onRequest\",\n    value:\n    /**\n     * @see Interceptor#onRequest\n     * @param {Object} options\n     * @returns {Object}\n     */\n    function onRequest(options) {\n      var headers = options.headers,\n          service = options.service,\n          uri = options.uri;\n      var _this$webex$internal = this.webex.internal,\n          device = _this$webex$internal.device,\n          services = _this$webex$internal.services; // Check if header is already set before moving forward\n\n      if (!device.url || headers && _constants.CISCO_DEVICE_URL in headers && !headers[_constants.CISCO_DEVICE_URL]) {\n        return _promise.default.resolve(options);\n      } // Wait for catalog and service to be defined.\n\n\n      return services.waitForService({\n        service: service,\n        url: uri\n      }).then(function (url) {\n        // Grab the service name with the url returned from waitForService\n        var _ref = services.getServiceFromUrl(url) || {},\n            serviceName = _ref.name;\n\n        var invalidServices = ['idbroker', 'oauth', 'saml']; // Check if service is not one of the invalid services\n        // Assign the url to the device header\n\n        if (serviceName && !invalidServices.includes(serviceName)) {\n          (0, _set2.default)(options, \"headers['\".concat(_constants.CISCO_DEVICE_URL, \"']\"), device.url);\n        }\n\n        return options;\n      }).catch(function (error) {\n        // Validate that the error came from getServiceFromUrl\n        if (error.message.match(/was not found after waiting/)) {\n          return options;\n        }\n\n        return _promise.default.reject(error);\n      });\n    }\n  }], [{\n    key: \"create\",\n    value:\n    /**\n     * @returns {DeviceUrlInterceptor}\n     */\n    function create() {\n      /* eslint no-invalid-this: [0] */\n      return new DeviceUrlInterceptor({\n        webex: this\n      });\n    }\n  }]);\n  return DeviceUrlInterceptor;\n}(_httpCore.Interceptor);\n\nexports.default = DeviceUrlInterceptor;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;;;IACqBA,oB;;;;;;;;;;;;;AASnB;AACF;AACA;AACA;AACA;AACE,uBAAUC,OAAV,EAAmB;AACjB,UAAOC,OAAP,GAAgCD,OAAhC,CAAOC,OAAP;AAAA,UAAgBC,OAAhB,GAAgCF,OAAhC,CAAgBE,OAAhB;AAAA,UAAyBC,GAAzB,GAAgCH,OAAhC,CAAyBG,GAAzB;AACA,iCAA2B,KAAKC,KAAL,CAAWC,QAAtC;AAAA,UAAOC,MAAP,wBAAOA,MAAP;AAAA,UAAeC,QAAf,wBAAeA,QAAf,CAFiB,CAIjB;;AACA,UACE,CAACD,MAAM,CAACE,GAAR,IACCP,OAAO,IAAIQ,+BAAoBR,OAA/BA,IAA0C,CAACA,OAAO,CAACQ,2BAAD,CAFrD,EAGE;AACA,eAAOC,iBAAQC,OAAR,CAAgBX,OAAhB,CAAP;AATe,QAYjB;;;AACA,aAAOO,QAAQ,CAACK,cAATL,CAAwB;AAACL,eAAO,EAAPA,OAAD;AAAUM,WAAG,EAAEL;AAAf,OAAxBI,EACJM,IADIN,CACC,UAACC,GAAD,EAAS;AACb;AACA,mBAA4BD,QAAQ,CAACO,iBAATP,CAA2BC,GAA3BD,KAAmC,EAA/D;AAAA,YAAaQ,WAAb,QAAOC,IAAP;;AACA,YAAMC,eAAe,GAAG,CAAC,UAAD,EAAa,OAAb,EAAsB,MAAtB,CAAxB,CAHa,CAKb;AACA;;AACA,YAAIF,WAAW,IAAI,CAACE,eAAe,CAACC,QAAhBD,CAAyBF,WAAzBE,CAApB,EAA2D;AACzD,6BAAIjB,OAAJ,qBAAyBS,2BAAzB,SAA+CH,MAAM,CAACE,GAAtD;AACD;;AAED,eAAOR,OAAP;AAZG,SAcJmB,KAdIZ,CAcE,UAACa,KAAD,EAAW;AAChB;AACA,YAAIA,KAAK,CAACC,OAAND,CAAcE,KAAdF,CAAoB,6BAApBA,CAAJ,EAAwD;AACtD,iBAAOpB,OAAP;AACD;;AAED,eAAOU,iBAAQa,MAAR,CAAeH,KAAf,CAAP;AApBG,QAAP;AAsBD;;;;AAhDD;AACF;AACA;AACE,sBAAgB;AACd;AACA,aAAO,IAAIrB,oBAAJ,CAAyB;AAACK,aAAK,EAAE;AAAR,OAAzB,CAAP;AACD;;;EAP+CoB,qB","names":["DeviceUrlInterceptor","options","headers","service","uri","webex","internal","device","services","url","CISCO_DEVICE_URL","_promise","resolve","waitForService","then","getServiceFromUrl","serviceName","name","invalidServices","includes","catch","error","message","match","reject","Interceptor"],"sources":["device-url.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {Interceptor} from '@webex/http-core';\nimport {set} from 'lodash';\n\nimport {CISCO_DEVICE_URL} from '../constants';\n\n/**\n  * Adds 'cisco-device-url' header, as appropriate, to requests\n  */\nexport default class DeviceUrlInterceptor extends Interceptor {\n  /**\n   * @returns {DeviceUrlInterceptor}\n   */\n  static create() {\n    /* eslint no-invalid-this: [0] */\n    return new DeviceUrlInterceptor({webex: this});\n  }\n\n  /**\n   * @see Interceptor#onRequest\n   * @param {Object} options\n   * @returns {Object}\n   */\n  onRequest(options) {\n    const {headers, service, uri} = options;\n    const {device, services} = this.webex.internal;\n\n    // Check if header is already set before moving forward\n    if (\n      !device.url ||\n      (headers && CISCO_DEVICE_URL in headers && !headers[CISCO_DEVICE_URL])\n    ) {\n      return Promise.resolve(options);\n    }\n\n    // Wait for catalog and service to be defined.\n    return services.waitForService({service, url: uri})\n      .then((url) => {\n        // Grab the service name with the url returned from waitForService\n        const {name: serviceName} = services.getServiceFromUrl(url) || {};\n        const invalidServices = ['idbroker', 'oauth', 'saml'];\n\n        // Check if service is not one of the invalid services\n        // Assign the url to the device header\n        if (serviceName && !invalidServices.includes(serviceName)) {\n          set(options, `headers['${CISCO_DEVICE_URL}']`, device.url);\n        }\n\n        return options;\n      })\n      .catch((error) => {\n        // Validate that the error came from getServiceFromUrl\n        if (error.message.match(/was not found after waiting/)) {\n          return options;\n        }\n\n        return Promise.reject(error);\n      });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}