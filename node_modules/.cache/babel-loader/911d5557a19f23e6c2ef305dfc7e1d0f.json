{"ast":null,"code":"\"use strict\";\n\nvar _Reflect$construct = require(\"@babel/runtime-corejs2/core-js/reflect/construct\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _defineProperties = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/define-properties\"));\n\nvar _values = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/values\"));\n\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/json/stringify\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/typeof\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/createClass\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/getPrototypeOf\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/defineProperty\"));\n\nvar _pick2 = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _common = require(\"@webex/common\");\n\nvar _httpErrorSubtypes = _interopRequireDefault(require(\"./http-error-subtypes\"));\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2.default)(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;\n      result = _Reflect$construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0, _possibleConstructorReturn2.default)(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false;\n  if (_Reflect$construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * Base HttpError class. Unlikely to be thrown directly, but handy for general\n * type comparison.\n */\n\n\nvar HttpError = /*#__PURE__*/function (_Exception) {\n  (0, _inherits2.default)(HttpError, _Exception);\n\n  var _super = _createSuper(HttpError);\n\n  function HttpError() {\n    (0, _classCallCheck2.default)(this, HttpError);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(HttpError, [{\n    key: \"parse\",\n    value:\n    /**\n     * @example Extend via\n     * MyError extends HttpError {\n     *  static errorKeys = HttpError.errorKeys.concat([\n     *    `key1`,\n     *    `key2`\n     *  ])\n     * }\n     *\n     * @type {Array}\n     */\n\n    /**\n     * Default error string if no error can be extracted from the http response\n     * @type {string}\n     */\n\n    /**\n     * Parses HttpResponse objects for useful information (status, headers, etc)\n     * as well as attempting to extract a useful error message.\n     * @param {HttpResponse} res\n     * @returns {string}\n     */\n    function parse(res) {\n      // complexity is high here because of all the default values below.\n\n      /* eslint complexity: [0] */\n      var body = res.body;\n      var message;\n\n      switch ((0, _typeof2.default)(body)) {\n        case 'string':\n          try {\n            body = JSON.parse(body);\n            message = this.parseObject(body);\n          } catch (err) {\n            message = body;\n          }\n\n          break;\n\n        case 'object':\n          message = this.parseObject(body);\n          break;\n\n        default:\n      }\n\n      if (!message) {\n        message = this.defaultMessage;\n      }\n\n      (0, _defineProperties.default)(this, {\n        body: {\n          enumerable: false,\n          value: body\n        },\n        httpVersion: {\n          enumerable: false,\n          value: res.httpVersion\n        },\n        headers: {\n          enumerable: false,\n          value: res.headers || {}\n        },\n        rawHeaders: {\n          enumerable: false,\n          value: res.rawHeaders || []\n        },\n        trailers: {\n          enumerable: false,\n          value: res.trailers || {}\n        },\n        rawTrailers: {\n          enumerable: false,\n          value: res.rawTrailers || []\n        },\n        method: {\n          enumerable: false,\n          value: res.method\n        },\n        url: {\n          enumerable: false,\n          value: res.url\n        },\n        statusCode: {\n          enumerable: false,\n          value: res.statusCode\n        },\n        statusMessage: {\n          enumerable: false,\n          value: res.statusMessage\n        },\n        socket: {\n          enumerable: false,\n          value: res.socket\n        },\n        _res: {\n          enumerable: false,\n          value: res\n        }\n      });\n      return message;\n    }\n    /**\n     * Recursively parses an error body looking for a likely error candidate\n     * @param {object} body\n     * @returns {string}\n     */\n\n  }, {\n    key: \"parseObject\",\n    value: function parseObject(body) {\n      // Search body for common names of error strings\n      var messages = (0, _values.default)((0, _pick2.default)(body, HttpError.errorKeys)); // If no error candidate was found, stringify the entire body\n\n      if (messages.length === 0) {\n        return (0, _stringify.default)(body, null, 2);\n      } // Assume the first key found was the error explanation\n\n\n      var message = messages[0]; // If the explanation is an object, recurse and try again\n\n      if ((0, _typeof2.default)(message) === 'object') {\n        return this.parseObject(message);\n      } // Return the first key\n\n\n      return message;\n    }\n  }]);\n  return HttpError;\n}(_common.Exception);\n\nexports.default = HttpError;\n(0, _defineProperty2.default)(HttpError, \"errorKeys\", ['error', 'errorString', 'response', 'errorResponse', 'message', 'msg']);\n(0, _defineProperty2.default)(HttpError, \"defaultMessage\", 'An error was received while trying to fulfill the request');\n(0, _httpErrorSubtypes.default)(HttpError);\nHttpError.makeSubTypes = _httpErrorSubtypes.default;","map":{"version":3,"mappings":"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","names":["HttpError","res","body","message","JSON","parse","parseObject","err","defaultMessage","enumerable","value","httpVersion","headers","rawHeaders","trailers","rawTrailers","method","url","statusCode","statusMessage","socket","_res","messages","errorKeys","length","Exception","makeSubTypes"],"sources":["http-error.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {pick} from 'lodash';\nimport {Exception} from '@webex/common';\n\nimport makeSubTypes from './http-error-subtypes';\n\n/**\n * Base HttpError class. Unlikely to be thrown directly, but handy for general\n * type comparison.\n */\nexport default class HttpError extends Exception {\n  /**\n   * @example Extend via\n   * MyError extends HttpError {\n   *  static errorKeys = HttpError.errorKeys.concat([\n   *    `key1`,\n   *    `key2`\n   *  ])\n   * }\n   *\n   * @type {Array}\n   */\n  static errorKeys = [\n    'error',\n    'errorString',\n    'response',\n    'errorResponse',\n    'message',\n    'msg'\n  ];\n\n  /**\n   * Default error string if no error can be extracted from the http response\n   * @type {string}\n   */\n  static defaultMessage = 'An error was received while trying to fulfill the request';\n\n  /**\n   * Parses HttpResponse objects for useful information (status, headers, etc)\n   * as well as attempting to extract a useful error message.\n   * @param {HttpResponse} res\n   * @returns {string}\n   */\n  parse(res) {\n    // complexity is high here because of all the default values below.\n    /* eslint complexity: [0] */\n    let {body} = res;\n    let message;\n\n    switch (typeof body) {\n      case 'string':\n        try {\n          body = JSON.parse(body);\n          message = this.parseObject(body);\n        }\n        catch (err) {\n          message = body;\n        }\n        break;\n      case 'object':\n        message = this.parseObject(body);\n        break;\n      default:\n    }\n\n    if (!message) {\n      message = this.defaultMessage;\n    }\n\n    Object.defineProperties(this, {\n      body: {\n        enumerable: false,\n        value: body\n      },\n      httpVersion: {\n        enumerable: false,\n        value: res.httpVersion\n      },\n      headers: {\n        enumerable: false,\n        value: res.headers || {}\n      },\n      rawHeaders: {\n        enumerable: false,\n        value: res.rawHeaders || []\n      },\n      trailers: {\n        enumerable: false,\n        value: res.trailers || {}\n      },\n      rawTrailers: {\n        enumerable: false,\n        value: res.rawTrailers || []\n      },\n      method: {\n        enumerable: false,\n        value: res.method\n      },\n      url: {\n        enumerable: false,\n        value: res.url\n      },\n      statusCode: {\n        enumerable: false,\n        value: res.statusCode\n      },\n      statusMessage: {\n        enumerable: false,\n        value: res.statusMessage\n      },\n      socket: {\n        enumerable: false,\n        value: res.socket\n      },\n      _res: {\n        enumerable: false,\n        value: res\n      }\n    });\n\n    return message;\n  }\n\n  /**\n   * Recursively parses an error body looking for a likely error candidate\n   * @param {object} body\n   * @returns {string}\n   */\n  parseObject(body) {\n    // Search body for common names of error strings\n    const messages = Object.values(pick(body, HttpError.errorKeys));\n\n    // If no error candidate was found, stringify the entire body\n    if (messages.length === 0) {\n      return JSON.stringify(body, null, 2);\n    }\n\n    // Assume the first key found was the error explanation\n    const message = messages[0];\n\n    // If the explanation is an object, recurse and try again\n    if (typeof message === 'object') {\n      return this.parseObject(message);\n    }\n\n    // Return the first key\n    return message;\n  }\n}\n\nmakeSubTypes(HttpError);\nHttpError.makeSubTypes = makeSubTypes;\n"]},"metadata":{},"sourceType":"script"}