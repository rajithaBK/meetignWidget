{"ast":null,"code":"\"use strict\";\n\nvar _Object$keys = require(\"@babel/runtime-corejs2/core-js/object/keys\");\n\nvar _Object$getOwnPropertySymbols = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\");\n\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\");\n\nvar _Object$getOwnPropertyDescriptors = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\");\n\nvar _Object$defineProperties = require(\"@babel/runtime-corejs2/core-js/object/define-properties\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/defineProperty\"));\n\nvar _isEqual2 = _interopRequireDefault(require(\"lodash/isEqual\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = _Object$keys(object);\n\n  if (_Object$getOwnPropertySymbols) {\n    var symbols = _Object$getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return _Object$getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (_Object$getOwnPropertyDescriptors) {\n      _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar ControlsUtils = {};\n/**\n * Controls\n * @typedef {Object} LocusControls\n * @property {Object} record\n * @property {Boolean} record.recording\n * @property {Object} record.meta\n * @property {String} record.meta.modifiedBy\n */\n\n/**\n * parse the relevant host values that we care about: id\n * @param {LocusControls} controls\n * @returns {Object} parsedObject - parsed host or null if host was undefined\n * @returns {String} parsedObject.recordingId\n */\n\nControlsUtils.parse = function (controls) {\n  var parsedControls = _objectSpread({}, controls);\n\n  if (controls && controls.record) {\n    parsedControls.record = {\n      modifiedBy: ControlsUtils.getId(controls),\n      paused: controls.record.paused ? controls.record.paused : false,\n      recording: controls.record.recording,\n      lastModified: controls.record.meta.lastModified\n    };\n  }\n\n  return parsedControls;\n};\n/**\n * parses and returns previous state vs current state and triggers the changes.\n * @param {LocusControl} oldControls previous state\n * @param {LocusControl} newControls current state\n * @returns {Object} combination of state plus the changes\n */\n\n\nControlsUtils.getControls = function (oldControls, newControls) {\n  var _previous$record, _previous$record2, _current$record, _previous$record3, _current$record2, _previous$record4, _current$record3;\n\n  var previous = ControlsUtils.parse(oldControls);\n  var current = ControlsUtils.parse(newControls);\n  return {\n    previous: previous,\n    current: current,\n    updates: {\n      hasRecordingPausedChanged: (current === null || current === void 0 ? void 0 : current.record) && !(0, _isEqual2.default)(previous === null || previous === void 0 ? void 0 : (_previous$record = previous.record) === null || _previous$record === void 0 ? void 0 : _previous$record.paused, current.record.paused) && ((previous === null || previous === void 0 ? void 0 : (_previous$record2 = previous.record) === null || _previous$record2 === void 0 ? void 0 : _previous$record2.recording) || (current === null || current === void 0 ? void 0 : (_current$record = current.record) === null || _current$record === void 0 ? void 0 : _current$record.recording)),\n      // see comments directly below\n      hasRecordingChanged: (current === null || current === void 0 ? void 0 : current.record) && !(0, _isEqual2.default)(previous === null || previous === void 0 ? void 0 : (_previous$record3 = previous.record) === null || _previous$record3 === void 0 ? void 0 : _previous$record3.recording, current === null || current === void 0 ? void 0 : (_current$record2 = current.record) === null || _current$record2 === void 0 ? void 0 : _current$record2.recording) && ((previous === null || previous === void 0 ? void 0 : (_previous$record4 = previous.record) === null || _previous$record4 === void 0 ? void 0 : _previous$record4.recording) || (current === null || current === void 0 ? void 0 : (_current$record3 = current.record) === null || _current$record3 === void 0 ? void 0 : _current$record3.recording)) // therefore, condition added to prevent false firings of #meeting:recording:stopped upon first joining a meeting\n\n    }\n  };\n};\n/**\n * Extract the id from the record controls object\n * @param {LocusControls} controls\n * @returns {String|null}\n */\n\n\nControlsUtils.getId = function (controls) {\n  if (controls.record.meta) {\n    return controls.record.meta.modifiedBy;\n  }\n\n  return null;\n};\n\nvar _default = ControlsUtils;\nexports.default = _default;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAMA,aAAa,GAAG,EAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACAA,aAAa,CAACC,KAAdD,GAAsB,UAACE,QAAD,EAAc;AAClC,MAAMC,cAAc,qBAAOD,QAAP,CAApB;;AAEA,MAAIA,QAAQ,IAAIA,QAAQ,CAACE,MAAzB,EAAiC;AAC/BD,kBAAc,CAACC,MAAfD,GAAwB;AACtBE,gBAAU,EAAEL,aAAa,CAACM,KAAdN,CAAoBE,QAApBF,CADU;AAEtBO,YAAM,EAAEL,QAAQ,CAACE,MAATF,CAAgBK,MAAhBL,GAAyBA,QAAQ,CAACE,MAATF,CAAgBK,MAAzCL,GAAkD,KAFpC;AAGtBM,eAAS,EAAEN,QAAQ,CAACE,MAATF,CAAgBM,SAHL;AAItBC,kBAAY,EAAEP,QAAQ,CAACE,MAATF,CAAgBQ,IAAhBR,CAAqBO;AAJb,KAAxBN;AAMD;;AAED,SAAOA,cAAP;AAZF;AAeA;AACA;AACA;AACA;AACA;AACA;;;AACAH,aAAa,CAACW,WAAdX,GAA4B,UAACY,WAAD,EAAcC,WAAd,EAA8B;AAAA;;AACxD,MAAMC,QAAQ,GAAGd,aAAa,CAACC,KAAdD,CAAoBY,WAApBZ,CAAjB;AACA,MAAMe,OAAO,GAAGf,aAAa,CAACC,KAAdD,CAAoBa,WAApBb,CAAhB;AAEA,SAAO;AACLc,YAAQ,EAARA,QADK;AAELC,WAAO,EAAPA,OAFK;AAGLC,WAAO,EAAE;AACPC,+BAAyB,EAAE,QAAO,SAAPF,WAAO,WAAPA,mBAAO,CAAEX,MAAT,KAC3B,CAAC,uBAAQU,QAAR,SAAQA,YAAR,WAAQA,GAAR,MAAQA,GAAR,oBAAQA,QAAQ,CAAEV,MAAlB,qDAAQc,iBAAkBX,MAA1B,EAAkCQ,OAAO,CAACX,MAARW,CAAeR,MAAjD,CAD0B,KAE1B,SAAQ,SAARO,YAAQ,WAARA,yCAAQ,CAAEV,MAAV,wEAAkBI,SAAlB,MAA+BO,OAA/B,SAA+BA,WAA/B,WAA+BA,GAA/B,MAA+BA,GAA/B,mBAA+BA,OAAO,CAAEX,MAAxC,oDAA+Be,gBAAiBX,SAAhD,CAF0B,CADpB;AAGsD;AAE7DY,yBAAmB,EAAE,QAAO,SAAPL,WAAO,WAAPA,mBAAO,CAAEX,MAAT,KACrB,CAAC,uBAAQU,QAAR,SAAQA,YAAR,WAAQA,GAAR,MAAQA,GAAR,qBAAQA,QAAQ,CAAEV,MAAlB,sDAAQiB,kBAAkBb,SAA1B,EAAqCO,OAArC,SAAqCA,WAArC,WAAqCA,GAArC,MAAqCA,GAArC,oBAAqCA,OAAO,CAAEX,MAA9C,qDAAqCkB,iBAAiBd,SAAtD,CADoB,KAEpB,SAAQ,SAARM,YAAQ,WAARA,yCAAQ,CAAEV,MAAV,wEAAkBI,SAAlB,MAA+BO,OAA/B,SAA+BA,WAA/B,WAA+BA,GAA/B,MAA+BA,GAA/B,oBAA+BA,OAAO,CAAEX,MAAxC,qDAA+BmB,iBAAiBf,SAAhD,CAFoB,CALd,CAOqD;;AAPrD;AAHJ,GAAP;AAJF;AAmBA;AACA;AACA;AACA;AACA;;;AACAR,aAAa,CAACM,KAAdN,GAAsB,UAACE,QAAD,EAAc;AAClC,MAAIA,QAAQ,CAACE,MAATF,CAAgBQ,IAApB,EAA0B;AACxB,WAAOR,QAAQ,CAACE,MAATF,CAAgBQ,IAAhBR,CAAqBG,UAA5B;AACD;;AAED,SAAO,IAAP;AALF;;eAQeL","names":["ControlsUtils","parse","controls","parsedControls","record","modifiedBy","getId","paused","recording","lastModified","meta","getControls","oldControls","newControls","previous","current","updates","hasRecordingPausedChanged","_previous$record","_current$record","hasRecordingChanged","_previous$record3","_current$record2","_current$record3"],"sources":["controlsUtils.js"],"sourcesContent":["import {isEqual} from 'lodash';\n\nconst ControlsUtils = {};\n\n/**\n * Controls\n * @typedef {Object} LocusControls\n * @property {Object} record\n * @property {Boolean} record.recording\n * @property {Object} record.meta\n * @property {String} record.meta.modifiedBy\n */\n\n/**\n * parse the relevant host values that we care about: id\n * @param {LocusControls} controls\n * @returns {Object} parsedObject - parsed host or null if host was undefined\n * @returns {String} parsedObject.recordingId\n */\nControlsUtils.parse = (controls) => {\n  const parsedControls = {...controls};\n\n  if (controls && controls.record) {\n    parsedControls.record = {\n      modifiedBy: ControlsUtils.getId(controls),\n      paused: controls.record.paused ? controls.record.paused : false,\n      recording: controls.record.recording,\n      lastModified: controls.record.meta.lastModified\n    };\n  }\n\n  return parsedControls;\n};\n\n/**\n * parses and returns previous state vs current state and triggers the changes.\n * @param {LocusControl} oldControls previous state\n * @param {LocusControl} newControls current state\n * @returns {Object} combination of state plus the changes\n */\nControlsUtils.getControls = (oldControls, newControls) => {\n  const previous = ControlsUtils.parse(oldControls);\n  const current = ControlsUtils.parse(newControls);\n\n  return {\n    previous,\n    current,\n    updates: {\n      hasRecordingPausedChanged: current?.record &&\n      !isEqual(previous?.record?.paused, current.record.paused) &&\n      (previous?.record?.recording || current?.record?.recording), // see comments directly below\n\n      hasRecordingChanged: current?.record &&\n      !isEqual(previous?.record?.recording, current?.record?.recording) && // upon first join, previous?.record?.recording = undefined; thus, never going to be equal and will always return true\n      (previous?.record?.recording || current?.record?.recording) // therefore, condition added to prevent false firings of #meeting:recording:stopped upon first joining a meeting\n    }\n  };\n};\n\n/**\n * Extract the id from the record controls object\n * @param {LocusControls} controls\n * @returns {String|null}\n */\nControlsUtils.getId = (controls) => {\n  if (controls.record.meta) {\n    return controls.record.meta.modifiedBy;\n  }\n\n  return null;\n};\n\nexport default ControlsUtils;\n"]},"metadata":{},"sourceType":"script"}