{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _taggedTemplateLiteral2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/taggedTemplateLiteral\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/defineProperty\"));\n\nvar _difference2 = _interopRequireDefault(require(\"lodash/difference\"));\n\nvar _queue = _interopRequireDefault(require(\"../common/queue\"));\n\nvar _loggerProxy = _interopRequireDefault(require(\"../common/logs/logger-proxy\"));\n\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10;\n/**\n * Locus Delta Parser\n * @private\n * https://sqbu-github.cisco.com/WebExSquared/cloud-apps/wiki/Locus-Delta-Events\n */\n\n\nvar Parser = /*#__PURE__*/function () {\n  // processing status\n  // loci comparison states\n\n  /**\n   * @constructs Parser\n   */\n  function Parser() {\n    (0, _classCallCheck2.default)(this, Parser);\n    this.queue = new _queue.default();\n    this.status = Parser.status.IDLE;\n    this.onDeltaAction = null;\n    this.workingCopy = null;\n  }\n  /**\n   * Checks if two sequences overlap in time,\n   * the sequence with the higher minimum value is greater.\n   * Chooses sequence with most recent data.\n   * @param {Types~Locus} current\n   * @param {Types~Locus} incoming\n   * @returns {string} loci comparison state\n   */\n\n\n  (0, _createClass2.default)(Parser, [{\n    key: \"isValidLocus\",\n    value:\n    /**\n     * Checks if newLoci or workingCopy is invalid.\n     * @param {Types~Locus} newLoci\n     * @returns {boolean}\n     */\n    function isValidLocus(newLoci) {\n      var _this = this;\n\n      var isValid = false;\n      var IDLE = Parser.status.IDLE;\n      var isLoci = Parser.isLoci;\n\n      var setStatus = function setStatus(status) {\n        _this.status = status;\n      }; // one or both objects are not locus delta events\n\n\n      if (!isLoci(this.workingCopy) || !isLoci(newLoci)) {\n        setStatus(IDLE);\n\n        _loggerProxy.default.logger.info('Locus-info:parser#processDeltaEvent --> Ignoring non-locus object. workingCopy:', this.workingCopy, 'newLoci:', newLoci);\n      } else {\n        isValid = true;\n      }\n\n      return isValid;\n    }\n    /**\n     * Determines if a paricular locus's sequence is empty\n     * @param {Types~Locus} locus\n     * @returns {bool}\n     */\n\n  }, {\n    key: \"nextEvent\",\n    value:\n    /**\n     * Processes next event in queue,\n     * if queue is empty sets status to idle.\n     * @returns {undefined}\n     */\n    function nextEvent() {\n      if (this.status === Parser.status.PAUSED) {\n        _loggerProxy.default.logger.info('Locus-info:parser#nextEvent --> Locus parser paused.');\n\n        return;\n      } // continue processing until queue is empty\n\n\n      if (this.queue.size() > 0) {\n        this.processDeltaEvent();\n      } else {\n        this.status = Parser.status.IDLE;\n      }\n    }\n    /**\n     * Function handler for delta actions,\n     * is set by instance callee.\n     * @param {string} action Locus delta action\n     * @param {Types~Locus} locus Locus delta\n     * @returns {undefined}\n     */\n    // eslint-disable-next-line no-unused-vars\n\n  }, {\n    key: \"onDeltaAction\",\n    value: function onDeltaAction(action, locus) {}\n    /**\n     * Event handler for locus delta events\n     * @param {Types~Locus} loci Locus Delta\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"onDeltaEvent\",\n    value: function onDeltaEvent(loci) {\n      // enqueue the new loci\n      this.queue.enqueue(loci); // start processing events in the queue if idle\n      // and a function handler is defined\n\n      if (this.status === Parser.status.IDLE && this.onDeltaAction) {\n        // Update status, ensure we only process one event at a time.\n        this.status = Parser.status.WORKING;\n        this.processDeltaEvent();\n      }\n    }\n    /**\n     * Appends new data onto a string of existing data.\n     * @param {string} newData\n     * @param {string} oldData\n     * @returns {string}\n     */\n\n  }, {\n    key: \"pause\",\n    value:\n    /**\n     * Pause locus processing\n     * @returns {undefined}\n     */\n    function pause() {\n      this.status = Parser.status.PAUSED;\n\n      _loggerProxy.default.logger.info('Locus-info:parser#pause --> Locus parser paused.');\n    }\n    /**\n     * Processes next locus delta in the queue,\n     * continues until the queue is empty\n     * or cleared.\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"processDeltaEvent\",\n    value: function processDeltaEvent() {\n      var _Parser$loci = Parser.loci,\n          DESYNC = _Parser$loci.DESYNC,\n          USE_INCOMING = _Parser$loci.USE_INCOMING;\n      var extract = Parser.extractComparisonState;\n      var newLoci = this.queue.dequeue();\n\n      if (!this.isValidLocus(newLoci)) {\n        return;\n      }\n\n      var result = Parser.compare(this.workingCopy, newLoci);\n      var lociComparison = extract(result); // limited debugging, use chrome extension\n      // for full debugging.\n\n      _loggerProxy.default.logger.debug(\"Locus-info:parser#processDeltaEvent --> Locus Debug: \".concat(result));\n\n      if (lociComparison === DESYNC) {\n        // wait for desync response\n        this.pause();\n      } else if (lociComparison === USE_INCOMING) {\n        // update working copy for future comparisons.\n        // Note: The working copy of parser gets updated in .onFullLocus()\n        // and here when USE_INCOMING locus.\n        this.workingCopy = newLoci;\n      }\n\n      if (this.onDeltaAction) {\n        _loggerProxy.default.logger.info(\"Locus-info:parser#processDeltaEvent --> Locus Delta Action: \".concat(lociComparison));\n\n        this.onDeltaAction.call(this, lociComparison, newLoci);\n      }\n\n      this.nextEvent();\n    }\n    /**\n     * Resume from a paused state\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      _loggerProxy.default.logger.info('Locus-info:parser#resume --> Locus parser resumed.');\n\n      this.status = Parser.status.WORKING;\n      this.nextEvent();\n    }\n    /**\n     * Gets related debug info for given error code\n     * @param {string} debugCode Debug code\n     * @param {string} comparison Locus comparison string\n     * @returns {object} Debug message\n     */\n\n  }], [{\n    key: \"checkSequenceOverlap\",\n    value: function checkSequenceOverlap(current, incoming) {\n      var comparison = null; // if earliest working copy sequence is more recent than last incoming sequence\n\n      if (current.min > incoming.max) {\n        // choose left side (current)\n        comparison = \"\".concat(Parser.loci.GT, \":SO001\");\n      } // if last working copy sequence is before the earliest incoming sequence\n      else if (current.max < incoming.min) {\n        // choose right side (incoming)\n        comparison = \"\".concat(Parser.loci.LT, \":SO002\");\n      } // if no match above, defaults to null\n\n\n      return comparison;\n    }\n    /**\n     * Checks if two sequences have unequal ranges.\n     * Chooses sequence with most larger range.\n     * @param {Types~Locus} current\n     * @param {Types~Locus} incoming\n     * @returns {object} loci comparison\n     */\n\n  }, {\n    key: \"checkUnequalRanges\",\n    value: function checkUnequalRanges(current, incoming) {\n      var comparison = null;\n      var currentIsNotUnique = current.unique.length === 0;\n      var incomingIsNotUnique = incoming.unique.length === 0;\n      var currentTotalRange = current.end - current.min;\n      var incomingTotalRange = incoming.end - incoming.min; // no unique values for both loci\n\n      if (currentIsNotUnique && incomingIsNotUnique) {\n        // current working copy loci has a larger range\n        if (currentTotalRange > incomingTotalRange) {\n          // choose left side (current)\n          comparison = \"\".concat(Parser.loci.GT, \":UR001\");\n        } // incoming delta loci has a larger range\n        else if (currentTotalRange < incomingTotalRange) {\n          // choose right side (incoming)\n          comparison = \"\".concat(Parser.loci.LT, \":UR002\");\n        } else {\n          // with no unique entries and with ranges either absent or\n          // of the same size, the sequences are considered equal.\n          comparison = \"\".concat(Parser.loci.EQ, \":UR003\");\n        }\n      }\n\n      return comparison;\n    }\n    /**\n     * Checks if either sequences has unique entries.\n     * Entries are considered unique if they do not overlap\n     * with other Loci sequences or range values.\n     * Chooses sequence with the unique entries.\n     * @param {Types~Locus} current\n     * @param {Types~Locus} incoming\n     * @returns {string} loci comparison state\n     */\n\n  }, {\n    key: \"checkForUniqueEntries\",\n    value: function checkForUniqueEntries(current, incoming) {\n      var comparison = null;\n      var currentIsUnique = current.unique.length > 0;\n      var incomingIsUnique = incoming.unique.length > 0; // current has unique entries and incoming does not\n\n      if (currentIsUnique && !incomingIsUnique) {\n        // choose left side (current)\n        comparison = \"\".concat(Parser.loci.GT, \":UE001\");\n      } // current has no unique entries but incoming does\n      else if (!currentIsUnique && incomingIsUnique) {\n        // choose right side (incoming)\n        comparison = \"\".concat(Parser.loci.LT, \":UE002\");\n      }\n\n      return comparison;\n    }\n    /**\n     * Checks both Locus Delta objects to see if they are\n     * out of sync with one another. If so sends a DESYNC\n     * request to the server.\n     * @param {Types~Locus} current\n     * @param {Types~Locus} incoming\n     * @returns {string} loci comparison state\n     */\n\n  }, {\n    key: \"checkIfOutOfSync\",\n    value: function checkIfOutOfSync(current, incoming) {\n      var comparison = null;\n      var currentUniqueMin = current.unique[0];\n      var incomingUniqueMin = incoming.unique[0];\n      var currentHasNoRange = !current.start && !current.end;\n      var incomingHasNoRange = !incoming.start && !incoming.end;\n      var neitherSeqHasRange = currentHasNoRange && incomingHasNoRange;\n\n      var hasUniqOverlap = function hasUniqOverlap(list, min, max) {\n        return list.some(function (seq) {\n          return min < seq && seq < max;\n        });\n      }; // current unique entries overlap the total range of incoming\n\n\n      var currentUniqOverlap = hasUniqOverlap(current.unique, incoming.min, incoming.max); // vice-versa, incoming unique entries overlap the total range of current\n\n      var incomingUniqOverlap = hasUniqOverlap(incoming.unique, current.min, current.max);\n\n      if (neitherSeqHasRange || currentUniqOverlap || incomingUniqOverlap) {\n        // outputs string indicating which condition occurred. ex: 0,1,0\n        var debugInfo = \"\".concat(+neitherSeqHasRange, \",\").concat(+currentUniqOverlap, \",\").concat(+incomingUniqOverlap); // send DESYNC to server\n\n        comparison = \"\".concat(Parser.loci.DESYNC, \":OOS001:\").concat(debugInfo);\n      } else if (currentUniqueMin > incomingUniqueMin) {\n        // choose left side (current)\n        comparison = \"\".concat(Parser.loci.GT, \":OOS002\");\n      } else {\n        // choose right side (incoming)\n        comparison = \"\".concat(Parser.loci.LT, \":OOS003\");\n      }\n\n      return comparison;\n    }\n    /**\n     * Compares two loci to determine which one contains the most recent state\n     * @instance\n     * @memberof Locus\n     * @param {Types~Locus} current\n     * @param {Types~Locus} incoming\n     * @returns {string} loci comparison state\n     */\n\n  }, {\n    key: \"compare\",\n    value: function compare(current, incoming) {\n      var isSequenceEmpty = Parser.isSequenceEmpty;\n      var extract = Parser.extractComparisonState;\n      var pack = Parser.packComparisonResult;\n\n      if (isSequenceEmpty(current) || isSequenceEmpty(incoming)) {\n        return pack(Parser.loci.USE_INCOMING, 'C001');\n      }\n\n      if (incoming.baseSequence) {\n        return pack(Parser.compareDelta(current, incoming), 'C002');\n      }\n\n      var result = Parser.compareSequence(current.sequence, incoming.sequence);\n      var action = Parser.compareToAction(extract(result));\n      return pack(action, result);\n    }\n    /**\n     * Compares two loci sequences (with delta params) and indicates what action\n     * to take.\n     * @instance\n     * @memberof Locus\n     * @param {Types~Locus} current\n     * @param {Types~Locus} incoming\n     * @private\n     * @returns {string} loci comparison state\n     */\n\n  }, {\n    key: \"compareDelta\",\n    value: function compareDelta(current, incoming) {\n      var _Parser$loci2 = Parser.loci,\n          LT = _Parser$loci2.LT,\n          GT = _Parser$loci2.GT,\n          EQ = _Parser$loci2.EQ,\n          DESYNC = _Parser$loci2.DESYNC,\n          USE_INCOMING = _Parser$loci2.USE_INCOMING;\n      var extract = Parser.extractComparisonState;\n      var pack = Parser.packComparisonResult;\n      var result = Parser.compareSequence(current.sequence, incoming.sequence);\n      var comparison = extract(result);\n\n      if (comparison !== LT) {\n        return pack(Parser.compareToAction(comparison), result);\n      }\n\n      comparison = Parser.compareSequence(current.sequence, incoming.baseSequence);\n\n      switch (extract(comparison)) {\n        case GT:\n        case EQ:\n          comparison = USE_INCOMING;\n          break;\n\n        default:\n          comparison = DESYNC;\n      }\n\n      return pack(comparison, result);\n    }\n    /**\n     * Compares Locus sequences\n     * @param {Types~Locus} current Current working copy\n     * @param {Types~Locus} incoming New Locus delta\n     * @returns {string}\n     */\n\n  }, {\n    key: \"compareSequence\",\n    value: function compareSequence(current, incoming) {\n      // Locus sequence comparison rules in order of priority.\n      // https://sqbu-github.cisco.com/WebExSquared/cloud-apps/wiki/Locus-Sequence-Comparison-Algorithm\n      var local = Parser.getMetaData(current);\n      var delta = Parser.getMetaData(incoming); // update loci metadata\n\n      local.unique = Parser.getUniqueSequences(local, delta);\n      delta.unique = Parser.getUniqueSequences(delta, local); // Locus sequence comparison rules\n      // order matters\n\n      var rules = [Parser.checkSequenceOverlap, Parser.checkUnequalRanges, Parser.checkForUniqueEntries, Parser.checkIfOutOfSync];\n\n      for (var _i = 0, _rules = rules; _i < _rules.length; _i++) {\n        var rule = _rules[_i]; // Rule only returns a value if the rule applies,\n        // otherwise returns null.\n\n        var result = rule(local, delta);\n\n        if (result) {\n          return result;\n        }\n      } // error, none of rules above applied\n      // should never get here as last rule\n      // should be catch all.\n\n\n      return Parser.loci.ERROR;\n    }\n    /**\n     * Transates the result of a sequence comparison into an intended behavior\n     * @param {string} result\n     * @returns {string} Locus comparison action\n     */\n\n  }, {\n    key: \"compareToAction\",\n    value: function compareToAction(result) {\n      var _Parser$loci3 = Parser.loci,\n          DESYNC = _Parser$loci3.DESYNC,\n          EQ = _Parser$loci3.EQ,\n          ERROR = _Parser$loci3.ERROR,\n          GT = _Parser$loci3.GT,\n          LT = _Parser$loci3.LT,\n          USE_CURRENT = _Parser$loci3.USE_CURRENT,\n          USE_INCOMING = _Parser$loci3.USE_INCOMING;\n      var action = ERROR;\n\n      switch (result) {\n        case EQ:\n        case GT:\n          action = USE_CURRENT;\n          break;\n\n        case LT:\n          action = USE_INCOMING;\n          break;\n\n        case DESYNC:\n          action = DESYNC;\n          break;\n\n        default:\n          _loggerProxy.default.logger.info(\"Locus-info:parser#compareToAction --> Error: \".concat(result, \" is not a recognized sequence comparison result.\"));\n\n      }\n\n      return action;\n    }\n    /**\n     * Extracts a loci comparison from a string of data.\n     * @param {string} lociComparisonResult Comparison result with extra data\n     * @returns {string} Comparison of EQ, LT, GT, or DESYNC.\n     */\n\n  }, {\n    key: \"extractComparisonState\",\n    value: function extractComparisonState(lociComparisonResult) {\n      return lociComparisonResult.split(':')[0];\n    }\n    /**\n     * @typedef {object} LociMetadata\n     * @property {number} start - Starting sequence number\n     * @property {number} end - Ending sequence number\n     * @property {number} first - First sequence number\n     * @property {number} last - Last sequence number\n     * @property {number} min - Minimum sequence number\n     * @property {number} max - Maximum sequence number\n     * @property {number} entries - Loci sequence entries\n     */\n\n    /**\n     * Metadata for Locus delta\n     * @param {Array.<number>} sequence Locus delta sequence\n     * @returns {LociMetadata} Locus Delta Metadata\n     */\n\n  }, {\n    key: \"getMetaData\",\n    value: function getMetaData(sequence) {\n      var entries = sequence.entries;\n      var first = entries[0];\n      var last = entries.slice(-1)[0]; // rangeStart or rangeEnd is 0 if a range doesn't exist\n\n      var start = sequence.rangeStart;\n      var end = sequence.rangeEnd; // sequence data\n\n      return {\n        start: start,\n        end: end,\n        first: first,\n        last: last,\n        // Rule is: rangeStart <= rangeEnd <= min(entries)\n        min: start || first,\n        // Grab last entry if exist else default to rangeEnd\n        max: last || end,\n        // keep reference to actual sequence entries\n        entries: entries\n      };\n    }\n    /**\n     * Compares two Locus delta objects and notes unique\n     * values contained within baseLoci.\n     * @param {LociMetadata} baseLoci\n     * @param {LociMetadata} otherLoci\n     * @returns {Array.<number>} List of unique sequences\n     */\n\n  }, {\n    key: \"getUniqueSequences\",\n    value: function getUniqueSequences(baseLoci, otherLoci) {\n      var diff = (0, _difference2.default)(baseLoci.entries, otherLoci.entries);\n      var start = otherLoci.start,\n          end = otherLoci.end;\n      return Parser.getNumbersOutOfRange(diff, start, end);\n    }\n    /**\n     * Returns an array of numbers outside of a given range.\n     * @param {Array.<number>} list Array to filter\n     * @param {number} rangeStart Start of range\n     * @param {number} rangeEnd End of range\n     * @returns {Array.<number>} Array of numbers sorted ASC\n     */\n\n  }, {\n    key: \"getNumbersOutOfRange\",\n    value: function getNumbersOutOfRange(list, rangeStart, rangeEnd) {\n      // Collect all numbers if number is outside of specified range\n      var output = list.filter(function (num) {\n        return num < rangeStart || num > rangeEnd;\n      }); // sort ascending\n\n      return output.sort(function (a, b) {\n        return a - b;\n      });\n    }\n  }, {\n    key: \"isSequenceEmpty\",\n    value: function isSequenceEmpty(locus) {\n      var _sequence$entries;\n\n      var sequence = locus.sequence;\n      var hasEmptyEntries = !((_sequence$entries = sequence.entries) !== null && _sequence$entries !== void 0 && _sequence$entries.length);\n      var hasEmptyRange = sequence.rangeStart === 0 && sequence.rangeEnd === 0;\n      return hasEmptyEntries && hasEmptyRange;\n    }\n    /**\n     * Determines if an object has basic\n     * structure of a locus object.\n     * @param {Types~Locus} loci\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isLoci\",\n    value: function isLoci(loci) {\n      if (!loci || !loci.sequence) {\n        return false;\n      }\n\n      var hasProp = function hasProp(prop) {\n        return Object.prototype.hasOwnProperty.call(loci.sequence, prop);\n      };\n\n      if (hasProp('rangeStart') && hasProp('rangeEnd')) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"packComparisonResult\",\n    value: function packComparisonResult(newData, oldData) {\n      return \"\".concat(newData, \":\").concat(oldData);\n    }\n  }, {\n    key: \"getDebugMessage\",\n    value: function getDebugMessage(debugCode, comparison) {\n      // removes extra spaces from multiline string\n      var mStr = function mStr(strings) {\n        return strings.join('').replace(/\\s{2,}/g, ' ');\n      };\n\n      var resolutionMap = {\n        EQ: \"\".concat(Parser.loci.LT, \": is equal (current == incoming).\"),\n        LT: \"\".concat(Parser.loci.LT, \": choose right side (incoming).\"),\n        GT: \"\".concat(Parser.loci.GT, \": choose left side (current).\")\n      };\n      var debugMap = {\n        SO001: {\n          title: 'checkSequenceOverlap-001',\n          description: mStr(_templateObject || (_templateObject = (0, _taggedTemplateLiteral2.default)([\"Occurs if earliest working copy sequence is more             recent than last incoming sequence.\"], [\"Occurs if earliest working copy sequence is more \\\\\\n            recent than last incoming sequence.\"]))),\n          logic: 'current.min > incoming.max'\n        },\n        SO002: {\n          title: 'checkSequenceOverlap-002',\n          description: mStr(_templateObject2 || (_templateObject2 = (0, _taggedTemplateLiteral2.default)([\"Occurs if last working copy sequence is before the           earliest incoming sequence.\"], [\"Occurs if last working copy sequence is before the \\\\\\n          earliest incoming sequence.\"]))),\n          logic: 'current.max < incoming.min'\n        },\n        UR001: {\n          title: 'checkUnequalRanges-001',\n          description: mStr(_templateObject3 || (_templateObject3 = (0, _taggedTemplateLiteral2.default)([\"Occurs if there are no unique values for both loci,           and the current working copy loci has a larger range.\"], [\"Occurs if there are no unique values for both loci, \\\\\\n          and the current working copy loci has a larger range.\"]))),\n          logic: 'currentTotalRange > incomingTotalRange'\n        },\n        UR002: {\n          title: 'checkUnequalRanges-002',\n          description: mStr(_templateObject4 || (_templateObject4 = (0, _taggedTemplateLiteral2.default)([\"Occurs if there are no unique values for both loci,           and the incoming delta loci has a larger range.\"], [\"Occurs if there are no unique values for both loci, \\\\\\n          and the incoming delta loci has a larger range.\"]))),\n          logic: 'currentTotalRange < incomingTotalRange'\n        },\n        UR003: {\n          title: 'checkUnequalRanges-003',\n          description: mStr(_templateObject5 || (_templateObject5 = (0, _taggedTemplateLiteral2.default)([\"Occurs if there are no unique values for both loci,           and with ranges either absent or of the same size, the sequences           are considered equal.\"], [\"Occurs if there are no unique values for both loci, \\\\\\n          and with ranges either absent or of the same size, the sequences \\\\\\n          are considered equal.\"]))),\n          logic: 'currentTotalRange == incomingTotalRange'\n        },\n        UE001: {\n          title: 'checkForUniqueEntries-001',\n          description: mStr(_templateObject6 || (_templateObject6 = (0, _taggedTemplateLiteral2.default)([\"Occurs if current loci has unique entries and           incoming does not. Entries are considered unique if they           do not overlap with other Loci sequences or range values.\"], [\"Occurs if current loci has unique entries and \\\\\\n          incoming does not. Entries are considered unique if they \\\\\\n          do not overlap with other Loci sequences or range values.\"]))),\n          logic: 'currentIsUnique && !incomingIsUnique'\n        },\n        UE002: {\n          title: 'checkForUniqueEntries-002',\n          description: mStr(_templateObject7 || (_templateObject7 = (0, _taggedTemplateLiteral2.default)([\"Occurs if current has no unique entries but           incoming does. Entries are considered unique if they           do not overlap with other Loci sequences or range values.\"], [\"Occurs if current has no unique entries but \\\\\\n          incoming does. Entries are considered unique if they \\\\\\n          do not overlap with other Loci sequences or range values.\"]))),\n          logic: '!currentIsUnique && incomingIsUnique'\n        },\n        OOS001: {\n          title: 'checkIfOutOfSync-001',\n          description: mStr(_templateObject8 || (_templateObject8 = (0, _taggedTemplateLiteral2.default)([\"Occurs if neither sequence has a range, or           if the current loci unique entries overlap the total range of the           incoming sequence, or if the incoming unique entries overlap           the total range of current sequence.\"], [\"Occurs if neither sequence has a range, or \\\\\\n          if the current loci unique entries overlap the total range of the \\\\\\n          incoming sequence, or if the incoming unique entries overlap \\\\\\n          the total range of current sequence.\"]))),\n          logic: 'neitherSeqHasRange || currentUniqOverlap || incomingUniqOverlap'\n        },\n        OOS002: {\n          title: 'checkIfOutOfSync-002',\n          description: mStr(_templateObject9 || (_templateObject9 = (0, _taggedTemplateLiteral2.default)([\"Occurs if the minimum value from sequences that are           unique to the current loci is greater than the minimum value from           sequences that are unique to the incoming loci.\"], [\"Occurs if the minimum value from sequences that are \\\\\\n          unique to the current loci is greater than the minimum value from \\\\\\n          sequences that are unique to the incoming loci.\"]))),\n          logic: 'currentUniqueMin > incomingUniqueMin'\n        },\n        OOS003: {\n          title: 'checkIfOutOfSync-003',\n          description: mStr(_templateObject10 || (_templateObject10 = (0, _taggedTemplateLiteral2.default)([\"Occurs if none of the comparison rules applied.           It is a catch all.\"], [\"Occurs if none of the comparison rules applied. \\\\\\n          It is a catch all.\"]))),\n          logic: 'else (catch all)'\n        }\n      };\n      var debugObj = debugMap[debugCode];\n      debugObj.title = \"Debug: \".concat(debugObj.title);\n      debugObj.resolution = resolutionMap[comparison];\n      return debugObj;\n    }\n  }]);\n  return Parser;\n}();\n\nexports.default = Parser;\n(0, _defineProperty2.default)(Parser, \"status\", {\n  IDLE: 'IDLE',\n  PAUSED: 'PAUSED',\n  WORKING: 'WORKING'\n});\n(0, _defineProperty2.default)(Parser, \"loci\", {\n  EQ: 'EQUAL',\n  GT: 'GREATER_THAN',\n  LT: 'LESS_THAN',\n  DESYNC: 'DESYNC',\n  USE_INCOMING: 'USE_INCOMING',\n  USE_CURRENT: 'USE_CURRENT',\n  ERROR: 'ERROR'\n});","map":{"version":3,"mappings":"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","names":["Parser","queue","SimpleQueue","status","IDLE","onDeltaAction","workingCopy","newLoci","isValid","isLoci","setStatus","_this","LoggerProxy","logger","info","PAUSED","size","processDeltaEvent","action","locus","loci","enqueue","WORKING","DESYNC","USE_INCOMING","extract","extractComparisonState","dequeue","isValidLocus","result","compare","lociComparison","debug","pause","call","nextEvent","current","incoming","comparison","min","max","GT","LT","currentIsNotUnique","unique","length","incomingIsNotUnique","currentTotalRange","end","incomingTotalRange","EQ","currentIsUnique","incomingIsUnique","currentUniqueMin","incomingUniqueMin","currentHasNoRange","start","incomingHasNoRange","neitherSeqHasRange","hasUniqOverlap","list","some","seq","currentUniqOverlap","incomingUniqOverlap","debugInfo","isSequenceEmpty","pack","packComparisonResult","baseSequence","compareDelta","compareSequence","sequence","compareToAction","local","getMetaData","delta","getUniqueSequences","rules","checkSequenceOverlap","checkUnequalRanges","checkForUniqueEntries","checkIfOutOfSync","rule","ERROR","USE_CURRENT","lociComparisonResult","split","entries","first","last","slice","rangeStart","rangeEnd","baseLoci","otherLoci","diff","getNumbersOutOfRange","output","filter","num","sort","a","b","hasEmptyEntries","_sequence$entries","hasEmptyRange","hasProp","prop","Object","prototype","hasOwnProperty","newData","oldData","debugCode","mStr","strings","join","replace","resolutionMap","debugMap","SO001","title","description","logic","SO002","UR001","UR002","UR003","UE001","UE002","OOS001","OOS002","OOS003","debugObj","resolution"],"sources":["parser.js"],"sourcesContent":["import {difference} from 'lodash';\n\nimport SimpleQueue from '../common/queue';\nimport LoggerProxy from '../common/logs/logger-proxy';\n\n/**\n * Locus Delta Parser\n * @private\n * https://sqbu-github.cisco.com/WebExSquared/cloud-apps/wiki/Locus-Delta-Events\n */\nexport default class Parser {\n  // processing status\n  static status = {\n    IDLE: 'IDLE',\n    PAUSED: 'PAUSED',\n    WORKING: 'WORKING'\n  }\n\n  // loci comparison states\n  static loci = {\n    EQ: 'EQUAL',\n    GT: 'GREATER_THAN',\n    LT: 'LESS_THAN',\n    DESYNC: 'DESYNC',\n    USE_INCOMING: 'USE_INCOMING',\n    USE_CURRENT: 'USE_CURRENT',\n    ERROR: 'ERROR'\n  }\n\n\n  /**\n   * @constructs Parser\n   */\n  constructor() {\n    this.queue = new SimpleQueue();\n    this.status = Parser.status.IDLE;\n    this.onDeltaAction = null;\n    this.workingCopy = null;\n  }\n\n\n  /**\n   * Checks if two sequences overlap in time,\n   * the sequence with the higher minimum value is greater.\n   * Chooses sequence with most recent data.\n   * @param {Types~Locus} current\n   * @param {Types~Locus} incoming\n   * @returns {string} loci comparison state\n   */\n  static checkSequenceOverlap(current, incoming) {\n    let comparison = null;\n\n    // if earliest working copy sequence is more recent than last incoming sequence\n    if (current.min > incoming.max) {\n      // choose left side (current)\n      comparison = `${Parser.loci.GT}:SO001`;\n    }\n    // if last working copy sequence is before the earliest incoming sequence\n    else if (current.max < incoming.min) {\n      // choose right side (incoming)\n      comparison = `${Parser.loci.LT}:SO002`;\n    }\n\n    // if no match above, defaults to null\n    return comparison;\n  }\n\n\n  /**\n   * Checks if two sequences have unequal ranges.\n   * Chooses sequence with most larger range.\n   * @param {Types~Locus} current\n   * @param {Types~Locus} incoming\n   * @returns {object} loci comparison\n   */\n  static checkUnequalRanges(current, incoming) {\n    let comparison = null;\n    const currentIsNotUnique = current.unique.length === 0;\n    const incomingIsNotUnique = incoming.unique.length === 0;\n    const currentTotalRange = current.end - current.min;\n    const incomingTotalRange = incoming.end - incoming.min;\n\n    // no unique values for both loci\n    if (currentIsNotUnique && incomingIsNotUnique) {\n      // current working copy loci has a larger range\n      if (currentTotalRange > incomingTotalRange) {\n        // choose left side (current)\n        comparison = `${Parser.loci.GT}:UR001`;\n      }\n      // incoming delta loci has a larger range\n      else if (currentTotalRange < incomingTotalRange) {\n        // choose right side (incoming)\n        comparison = `${Parser.loci.LT}:UR002`;\n      }\n      else {\n        // with no unique entries and with ranges either absent or\n        // of the same size, the sequences are considered equal.\n        comparison = `${Parser.loci.EQ}:UR003`;\n      }\n    }\n\n    return comparison;\n  }\n\n\n  /**\n   * Checks if either sequences has unique entries.\n   * Entries are considered unique if they do not overlap\n   * with other Loci sequences or range values.\n   * Chooses sequence with the unique entries.\n   * @param {Types~Locus} current\n   * @param {Types~Locus} incoming\n   * @returns {string} loci comparison state\n   */\n  static checkForUniqueEntries(current, incoming) {\n    let comparison = null;\n    const currentIsUnique = current.unique.length > 0;\n    const incomingIsUnique = incoming.unique.length > 0;\n\n    // current has unique entries and incoming does not\n    if (currentIsUnique && !incomingIsUnique) {\n      // choose left side (current)\n      comparison = `${Parser.loci.GT}:UE001`;\n    }\n    // current has no unique entries but incoming does\n    else if (!currentIsUnique && incomingIsUnique) {\n      // choose right side (incoming)\n      comparison = `${Parser.loci.LT}:UE002`;\n    }\n\n    return comparison;\n  }\n\n\n  /**\n   * Checks both Locus Delta objects to see if they are\n   * out of sync with one another. If so sends a DESYNC\n   * request to the server.\n   * @param {Types~Locus} current\n   * @param {Types~Locus} incoming\n   * @returns {string} loci comparison state\n   */\n  static checkIfOutOfSync(current, incoming) {\n    let comparison = null;\n    const currentUniqueMin = current.unique[0];\n    const incomingUniqueMin = incoming.unique[0];\n\n    const currentHasNoRange = !current.start && !current.end;\n    const incomingHasNoRange = !incoming.start && !incoming.end;\n    const neitherSeqHasRange = currentHasNoRange && incomingHasNoRange;\n\n    const hasUniqOverlap = (list, min, max) => list.some((seq) => min < seq && seq < max);\n    // current unique entries overlap the total range of incoming\n    const currentUniqOverlap = hasUniqOverlap(current.unique, incoming.min, incoming.max);\n    // vice-versa, incoming unique entries overlap the total range of current\n    const incomingUniqOverlap = hasUniqOverlap(incoming.unique, current.min, current.max);\n\n    if (neitherSeqHasRange || currentUniqOverlap || incomingUniqOverlap) {\n      // outputs string indicating which condition occurred. ex: 0,1,0\n      const debugInfo = `${+neitherSeqHasRange},${+currentUniqOverlap},${+incomingUniqOverlap}`;\n\n      // send DESYNC to server\n      comparison = `${Parser.loci.DESYNC}:OOS001:${debugInfo}`;\n    }\n    else if (currentUniqueMin > incomingUniqueMin) {\n      // choose left side (current)\n      comparison = `${Parser.loci.GT}:OOS002`;\n    }\n    else {\n      // choose right side (incoming)\n      comparison = `${Parser.loci.LT}:OOS003`;\n    }\n\n    return comparison;\n  }\n\n\n  /**\n   * Compares two loci to determine which one contains the most recent state\n   * @instance\n   * @memberof Locus\n   * @param {Types~Locus} current\n   * @param {Types~Locus} incoming\n   * @returns {string} loci comparison state\n   */\n  static compare(current, incoming) {\n    const {isSequenceEmpty} = Parser;\n    const {extractComparisonState: extract} = Parser;\n    const {packComparisonResult: pack} = Parser;\n\n\n    if (isSequenceEmpty(current) || isSequenceEmpty(incoming)) {\n      return pack(Parser.loci.USE_INCOMING, 'C001');\n    }\n\n    if (incoming.baseSequence) {\n      return pack(Parser.compareDelta(current, incoming), 'C002');\n    }\n\n    const result = Parser.compareSequence(current.sequence, incoming.sequence);\n    const action = Parser.compareToAction(extract(result));\n\n    return pack(action, result);\n  }\n\n\n  /**\n   * Compares two loci sequences (with delta params) and indicates what action\n   * to take.\n   * @instance\n   * @memberof Locus\n   * @param {Types~Locus} current\n   * @param {Types~Locus} incoming\n   * @private\n   * @returns {string} loci comparison state\n   */\n  static compareDelta(current, incoming) {\n    const {\n      LT, GT, EQ, DESYNC, USE_INCOMING\n    } = Parser.loci;\n    const {extractComparisonState: extract} = Parser;\n    const {packComparisonResult: pack} = Parser;\n\n    const result = Parser.compareSequence(current.sequence, incoming.sequence);\n    let comparison = extract(result);\n\n\n    if (comparison !== LT) {\n      return pack(Parser.compareToAction(comparison), result);\n    }\n\n    comparison = Parser.compareSequence(current.sequence, incoming.baseSequence);\n\n    switch (extract(comparison)) {\n      case GT:\n      case EQ:\n        comparison = USE_INCOMING;\n        break;\n\n      default:\n        comparison = DESYNC;\n    }\n\n    return pack(comparison, result);\n  }\n\n\n  /**\n   * Compares Locus sequences\n   * @param {Types~Locus} current Current working copy\n   * @param {Types~Locus} incoming New Locus delta\n   * @returns {string}\n   */\n  static compareSequence(current, incoming) {\n    // Locus sequence comparison rules in order of priority.\n    // https://sqbu-github.cisco.com/WebExSquared/cloud-apps/wiki/Locus-Sequence-Comparison-Algorithm\n\n    const local = Parser.getMetaData(current);\n    const delta = Parser.getMetaData(incoming);\n\n    // update loci metadata\n    local.unique = Parser.getUniqueSequences(local, delta);\n    delta.unique = Parser.getUniqueSequences(delta, local);\n\n    // Locus sequence comparison rules\n    // order matters\n    const rules = [\n      Parser.checkSequenceOverlap,\n      Parser.checkUnequalRanges,\n      Parser.checkForUniqueEntries,\n      Parser.checkIfOutOfSync\n    ];\n\n    for (const rule of rules) {\n      // Rule only returns a value if the rule applies,\n      // otherwise returns null.\n      const result = rule(local, delta);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    // error, none of rules above applied\n    // should never get here as last rule\n    // should be catch all.\n    return Parser.loci.ERROR;\n  }\n\n\n  /**\n   * Transates the result of a sequence comparison into an intended behavior\n   * @param {string} result\n   * @returns {string} Locus comparison action\n   */\n  static compareToAction(result) {\n    const {\n      DESYNC, EQ, ERROR, GT, LT, USE_CURRENT, USE_INCOMING\n    } = Parser.loci;\n\n    let action = ERROR;\n\n    switch (result) {\n      case EQ:\n      case GT:\n        action = USE_CURRENT;\n        break;\n      case LT:\n        action = USE_INCOMING;\n        break;\n      case DESYNC:\n        action = DESYNC;\n        break;\n      default:\n        LoggerProxy.logger.info(`Locus-info:parser#compareToAction --> Error: ${result} is not a recognized sequence comparison result.`);\n    }\n\n    return action;\n  }\n\n\n  /**\n   * Extracts a loci comparison from a string of data.\n   * @param {string} lociComparisonResult Comparison result with extra data\n   * @returns {string} Comparison of EQ, LT, GT, or DESYNC.\n   */\n  static extractComparisonState(lociComparisonResult) {\n    return lociComparisonResult.split(':')[0];\n  }\n\n\n  /**\n   * @typedef {object} LociMetadata\n   * @property {number} start - Starting sequence number\n   * @property {number} end - Ending sequence number\n   * @property {number} first - First sequence number\n   * @property {number} last - Last sequence number\n   * @property {number} min - Minimum sequence number\n   * @property {number} max - Maximum sequence number\n   * @property {number} entries - Loci sequence entries\n   */\n\n  /**\n   * Metadata for Locus delta\n   * @param {Array.<number>} sequence Locus delta sequence\n   * @returns {LociMetadata} Locus Delta Metadata\n   */\n  static getMetaData(sequence) {\n    const {entries} = sequence;\n    const first = entries[0];\n    const last = entries.slice(-1)[0];\n\n    // rangeStart or rangeEnd is 0 if a range doesn't exist\n    const start = sequence.rangeStart;\n    const end = sequence.rangeEnd;\n\n    // sequence data\n    return {\n      start,\n      end,\n      first,\n      last,\n      // Rule is: rangeStart <= rangeEnd <= min(entries)\n      min: start || first,\n      // Grab last entry if exist else default to rangeEnd\n      max: last || end,\n      // keep reference to actual sequence entries\n      entries\n    };\n  }\n\n\n  /**\n   * Compares two Locus delta objects and notes unique\n   * values contained within baseLoci.\n   * @param {LociMetadata} baseLoci\n   * @param {LociMetadata} otherLoci\n   * @returns {Array.<number>} List of unique sequences\n   */\n  static getUniqueSequences(baseLoci, otherLoci) {\n    const diff = difference(\n      baseLoci.entries,\n      otherLoci.entries\n    );\n    const {start, end} = otherLoci;\n\n    return Parser.getNumbersOutOfRange(diff, start, end);\n  }\n\n\n  /**\n   * Returns an array of numbers outside of a given range.\n   * @param {Array.<number>} list Array to filter\n   * @param {number} rangeStart Start of range\n   * @param {number} rangeEnd End of range\n   * @returns {Array.<number>} Array of numbers sorted ASC\n   */\n  static getNumbersOutOfRange(list, rangeStart, rangeEnd) {\n    // Collect all numbers if number is outside of specified range\n    const output = list.filter((num) => num < rangeStart || num > rangeEnd);\n\n    // sort ascending\n    return output.sort((a, b) => a - b);\n  }\n\n\n  /**\n   * Checks if newLoci or workingCopy is invalid.\n   * @param {Types~Locus} newLoci\n   * @returns {boolean}\n   */\n  isValidLocus(newLoci) {\n    let isValid = false;\n    const {IDLE} = Parser.status;\n    const {isLoci} = Parser;\n    const setStatus = (status) => { this.status = status; };\n\n    // one or both objects are not locus delta events\n    if (!isLoci(this.workingCopy) || !isLoci(newLoci)) {\n      setStatus(IDLE);\n      LoggerProxy.logger.info('Locus-info:parser#processDeltaEvent --> Ignoring non-locus object. workingCopy:', this.workingCopy, 'newLoci:', newLoci);\n    }\n    else {\n      isValid = true;\n    }\n\n    return isValid;\n  }\n\n\n  /**\n   * Determines if a paricular locus's sequence is empty\n   * @param {Types~Locus} locus\n   * @returns {bool}\n   */\n  static isSequenceEmpty(locus) {\n    const {sequence} = locus;\n    const hasEmptyEntries = !sequence.entries?.length;\n    const hasEmptyRange = sequence.rangeStart === 0 && sequence.rangeEnd === 0;\n\n    return hasEmptyEntries && hasEmptyRange;\n  }\n\n\n  /**\n   * Determines if an object has basic\n   * structure of a locus object.\n   * @param {Types~Locus} loci\n   * @returns {boolean}\n   */\n  static isLoci(loci) {\n    if (!loci || !loci.sequence) {\n      return false;\n    }\n    const hasProp = (prop) =>\n      Object.prototype.hasOwnProperty.call(loci.sequence, prop);\n\n    if (hasProp('rangeStart') && hasProp('rangeEnd')) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Processes next event in queue,\n   * if queue is empty sets status to idle.\n   * @returns {undefined}\n   */\n  nextEvent() {\n    if (this.status === Parser.status.PAUSED) {\n      LoggerProxy.logger.info('Locus-info:parser#nextEvent --> Locus parser paused.');\n\n      return;\n    }\n\n    // continue processing until queue is empty\n    if (this.queue.size() > 0) {\n      this.processDeltaEvent();\n    }\n    else {\n      this.status = Parser.status.IDLE;\n    }\n  }\n\n\n  /**\n   * Function handler for delta actions,\n   * is set by instance callee.\n   * @param {string} action Locus delta action\n   * @param {Types~Locus} locus Locus delta\n   * @returns {undefined}\n   */\n  // eslint-disable-next-line no-unused-vars\n  onDeltaAction(action, locus) {}\n\n\n  /**\n   * Event handler for locus delta events\n   * @param {Types~Locus} loci Locus Delta\n   * @returns {undefined}\n   */\n  onDeltaEvent(loci) {\n    // enqueue the new loci\n    this.queue.enqueue(loci);\n    // start processing events in the queue if idle\n    // and a function handler is defined\n    if (this.status === Parser.status.IDLE && this.onDeltaAction) {\n      // Update status, ensure we only process one event at a time.\n      this.status = Parser.status.WORKING;\n\n      this.processDeltaEvent();\n    }\n  }\n\n\n  /**\n   * Appends new data onto a string of existing data.\n   * @param {string} newData\n   * @param {string} oldData\n   * @returns {string}\n   */\n  static packComparisonResult(newData, oldData) {\n    return `${newData}:${oldData}`;\n  }\n\n\n  /**\n   * Pause locus processing\n   * @returns {undefined}\n   */\n  pause() {\n    this.status = Parser.status.PAUSED;\n    LoggerProxy.logger.info('Locus-info:parser#pause --> Locus parser paused.');\n  }\n\n\n  /**\n   * Processes next locus delta in the queue,\n   * continues until the queue is empty\n   * or cleared.\n   * @returns {undefined}\n   */\n  processDeltaEvent() {\n    const {DESYNC, USE_INCOMING} = Parser.loci;\n    const {extractComparisonState: extract} = Parser;\n    const newLoci = this.queue.dequeue();\n\n    if (!this.isValidLocus(newLoci)) {\n      return;\n    }\n\n    const result = Parser.compare(this.workingCopy, newLoci);\n    const lociComparison = extract(result);\n\n    // limited debugging, use chrome extension\n    // for full debugging.\n    LoggerProxy.logger.debug(`Locus-info:parser#processDeltaEvent --> Locus Debug: ${result}`);\n\n    if (lociComparison === DESYNC) {\n      // wait for desync response\n      this.pause();\n    }\n    else if (lociComparison === USE_INCOMING) {\n      // update working copy for future comparisons.\n      // Note: The working copy of parser gets updated in .onFullLocus()\n      // and here when USE_INCOMING locus.\n      this.workingCopy = newLoci;\n    }\n\n    if (this.onDeltaAction) {\n      LoggerProxy.logger.info(`Locus-info:parser#processDeltaEvent --> Locus Delta Action: ${lociComparison}`);\n      this.onDeltaAction.call(this, lociComparison, newLoci);\n    }\n\n    this.nextEvent();\n  }\n\n\n  /**\n   * Resume from a paused state\n   * @returns {undefined}\n   */\n  resume() {\n    LoggerProxy.logger.info('Locus-info:parser#resume --> Locus parser resumed.');\n    this.status = Parser.status.WORKING;\n    this.nextEvent();\n  }\n\n\n  /**\n   * Gets related debug info for given error code\n   * @param {string} debugCode Debug code\n   * @param {string} comparison Locus comparison string\n   * @returns {object} Debug message\n   */\n  static getDebugMessage(debugCode, comparison) {\n    // removes extra spaces from multiline string\n    const mStr = (strings) => strings.join('').replace(/\\s{2,}/g, ' ');\n\n    const resolutionMap = {\n      EQ: `${Parser.loci.LT}: is equal (current == incoming).`,\n      LT: `${Parser.loci.LT}: choose right side (incoming).`,\n      GT: `${Parser.loci.GT}: choose left side (current).`\n    };\n\n    const debugMap = {\n      SO001: {\n        title: 'checkSequenceOverlap-001',\n        description: mStr`Occurs if earliest working copy sequence is more \\\n            recent than last incoming sequence.`,\n        logic: 'current.min > incoming.max'\n      },\n\n      SO002: {\n        title: 'checkSequenceOverlap-002',\n        description: mStr`Occurs if last working copy sequence is before the \\\n          earliest incoming sequence.`,\n        logic: 'current.max < incoming.min'\n      },\n\n      UR001: {\n        title: 'checkUnequalRanges-001',\n        description: mStr`Occurs if there are no unique values for both loci, \\\n          and the current working copy loci has a larger range.`,\n        logic: 'currentTotalRange > incomingTotalRange'\n      },\n\n      UR002: {\n        title: 'checkUnequalRanges-002',\n        description: mStr`Occurs if there are no unique values for both loci, \\\n          and the incoming delta loci has a larger range.`,\n        logic: 'currentTotalRange < incomingTotalRange'\n      },\n\n      UR003: {\n        title: 'checkUnequalRanges-003',\n        description: mStr`Occurs if there are no unique values for both loci, \\\n          and with ranges either absent or of the same size, the sequences \\\n          are considered equal.`,\n        logic: 'currentTotalRange == incomingTotalRange'\n      },\n\n      UE001: {\n        title: 'checkForUniqueEntries-001',\n        description: mStr`Occurs if current loci has unique entries and \\\n          incoming does not. Entries are considered unique if they \\\n          do not overlap with other Loci sequences or range values.`,\n        logic: 'currentIsUnique && !incomingIsUnique'\n      },\n\n      UE002: {\n        title: 'checkForUniqueEntries-002',\n        description: mStr`Occurs if current has no unique entries but \\\n          incoming does. Entries are considered unique if they \\\n          do not overlap with other Loci sequences or range values.`,\n        logic: '!currentIsUnique && incomingIsUnique'\n      },\n\n      OOS001: {\n        title: 'checkIfOutOfSync-001',\n        description: mStr`Occurs if neither sequence has a range, or \\\n          if the current loci unique entries overlap the total range of the \\\n          incoming sequence, or if the incoming unique entries overlap \\\n          the total range of current sequence.`,\n        logic: 'neitherSeqHasRange || currentUniqOverlap || incomingUniqOverlap'\n      },\n\n      OOS002: {\n        title: 'checkIfOutOfSync-002',\n        description: mStr`Occurs if the minimum value from sequences that are \\\n          unique to the current loci is greater than the minimum value from \\\n          sequences that are unique to the incoming loci.`,\n        logic: 'currentUniqueMin > incomingUniqueMin'\n      },\n\n      OOS003: {\n        title: 'checkIfOutOfSync-003',\n        description: mStr`Occurs if none of the comparison rules applied. \\\n          It is a catch all.`,\n        logic: 'else (catch all)'\n      }\n    };\n\n    const debugObj = debugMap[debugCode];\n\n    debugObj.title = `Debug: ${debugObj.title}`;\n    debugObj.resolution = resolutionMap[comparison];\n\n    return debugObj;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}