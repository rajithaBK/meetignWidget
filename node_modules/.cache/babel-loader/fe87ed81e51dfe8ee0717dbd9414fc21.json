{"ast":null,"code":"\"use strict\";\n\nvar _typeof = require(\"@babel/runtime-corejs2/helpers/typeof\");\n\nvar _WeakMap = require(\"@babel/runtime-corejs2/core-js/weak-map\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _Object$getOwnPropertyDescriptor2 = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/slicedToArray\"));\n\nvar _applyDecoratedDescriptor2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/applyDecoratedDescriptor\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _assign = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/assign\"));\n\nvar _apply = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/reflect/apply\"));\n\nvar _now = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/date/now\"));\n\nvar _getOwnPropertyDescriptor = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\"));\n\nvar _pick2 = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _common = require(\"@webex/common\");\n\nvar _commonTimers = require(\"@webex/common-timers\");\n\nvar _webexHttpError = _interopRequireDefault(require(\"../webex-http-error\"));\n\nvar _webexPlugin = _interopRequireDefault(require(\"../webex-plugin\"));\n\nvar _scope = require(\"./scope\");\n\nvar _grantErrors = _interopRequireWildcard(require(\"./grant-errors\"));\n\nvar _dec, _obj;\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof _WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new _WeakMap();\n  var cacheNodeInterop = new _WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = _Object$defineProperty && _Object$getOwnPropertyDescriptor2;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? _Object$getOwnPropertyDescriptor2(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        _Object$defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n/* eslint-disable camelcase */\n\n/**\n * Parse response from CI and converts to structured error when appropriate\n * @param {WebexHttpError} res\n * @private\n * @returns {GrantError}\n */\n\n\nfunction processGrantError(res) {\n  if (res.statusCode !== 400) {\n    return _promise.default.reject(res);\n  }\n\n  var ErrorConstructor = _grantErrors.default.select(res.body.error);\n\n  if (ErrorConstructor === _grantErrors.OAuthError && res instanceof _webexHttpError.default) {\n    return _promise.default.reject(res);\n  }\n\n  if (!ErrorConstructor) {\n    return _promise.default.reject(res);\n  }\n\n  return _promise.default.reject(new ErrorConstructor(res._res || res));\n}\n/**\n * @class\n */\n\n\nvar Token = _webexPlugin.default.extend((_dec = (0, _common.oneFlight)({\n  keyFactory: function keyFactory(scope) {\n    return scope;\n  }\n}), (_obj = {\n  derived: {\n    /**\n     * Indicates if this token can be used in an auth header. `true` iff\n     * {@link Token#access_token} is defined and {@link Token#isExpired} is\n     * false.\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    canAuthorize: {\n      deps: ['access_token', 'isExpired'],\n      fn: function fn() {\n        return !!this.access_token && !this.isExpired;\n      }\n    },\n\n    /**\n     * Indicates that this token can be downscoped. `true` iff\n     * {@link config.credentials.client_id} is defined and if\n     * {@link Token#canAuthorize} is true\n     *\n     * Note: since {@link config} is not evented, we can't listen for changes to\n     * {@link config.credentials.client_id}. As such,\n     * {@link config.credentials.client_id} must always be set before\n     * instantiating a {@link Token}\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    canDownscope: {\n      deps: ['canAuthorize'],\n      fn: function fn() {\n        return this.canAuthorize && !!this.config.client_id;\n      }\n    },\n\n    /**\n     * Indicates if this token can be refreshed. `true` iff\n     * {@link Token@refresh_token} is defined and\n     * {@link config.credentials.refreshCallback()} is defined\n     *\n     * Note: since {@link config} is not evented, we can't listen for changes to\n     * {@link config.credentials.refreshCallback()}. As such,\n     * {@link config.credentials.refreshCallback()} must always be set before\n     * instantiating a {@link Token}\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    canRefresh: {\n      deps: ['refresh_token'],\n      fn: function fn() {\n        if (_common.inBrowser) {\n          return !!this.refresh_token && !!this.config.refreshCallback;\n        }\n\n        return !!this.refresh_token && !!this.config.client_secret;\n      }\n    },\n\n    /**\n     * Indicates if this `Token` is expired. `true` iff {@link Token#expires} is\n     * defined and is less than {@link Date.now()}.\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    isExpired: {\n      deps: ['expires', '_isExpired'],\n      fn: function fn() {\n        // in order to avoid setting `cache:false`, we'll use a private property\n        // and a timer rather than comparing to `Date.now()`;\n        return !!this.expires && this._isExpired;\n      }\n    },\n\n    /**\n     * Cache for toString()\n     * @instance\n     * @memberof Token\n     * @private\n     * @readonly\n     * @type {string}\n     */\n    _string: {\n      deps: ['access_token', 'token_type'],\n      fn: function fn() {\n        if (!this.access_token || !this.token_type) {\n          return '';\n        }\n\n        return \"\".concat(this.token_type, \" \").concat(this.access_token);\n      }\n    }\n  },\n  namespace: 'Credentials',\n  props: {\n    /**\n     * Used for indexing in the credentials userTokens collection\n     * @instance\n     * @memberof Token\n     * @private\n     * @type {string}\n     */\n    scope: 'string',\n\n    /**\n     * @instance\n     * @memberof Token\n     * @type {string}\n     */\n    access_token: 'string',\n\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    expires: 'number',\n\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    expires_in: 'number',\n\n    /**\n     * @instance\n     * @memberof Token\n     * @type {string}\n     */\n    refresh_token: 'string',\n\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    refresh_token_expires: 'number',\n\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    refresh_token_expires_in: 'number',\n\n    /**\n     * @default \"Bearer\"\n     * @instance\n     * @memberof Token\n     * @type {string}\n     */\n    token_type: {\n      default: 'Bearer',\n      type: 'string'\n    }\n  },\n  session: {\n    /**\n     * Used by {@link Token#isExpired} to avoid doing a Date comparison.\n     * @instance\n     * @memberof Token\n     * @private\n     * @type {boolean}\n     */\n    _isExpired: {\n      default: false,\n      type: 'boolean'\n    },\n\n    /**\n     * Handle to the previous token that we'll revoke when we refresh this\n     * token. The idea is to keep allow two valid tokens when a refresh occurs;\n     * we don't want revoke a token that's in the middle of being used, so when\n     * we do a token refresh, we won't revoke the token being refreshed, but\n     * we'll revoke the previous one.\n     * @instance\n     * @memberof Token\n     * @private\n     * @type {Object}\n     */\n    previousToken: {\n      type: 'state'\n    }\n  },\n\n  /**\n   * Uses this token to request a new Token with a subset of this Token's scopes\n   * @instance\n   * @memberof Token\n   * @param {string} scope\n   * @returns {Promise<Token>}\n   */\n  downscope: function downscope(scope) {\n    var _this = this;\n\n    this.logger.info(\"token: downscoping token to \".concat(scope));\n\n    if (this.isExpired) {\n      this.logger.info('token: request received to downscope expired access_token');\n      return _promise.default.reject(new Error('cannot downscope expired access token'));\n    }\n\n    if (!this.canDownscope) {\n      if (this.config.client_id) {\n        this.logger.info('token: request received to downscope invalid access_token');\n      } else {\n        this.logger.trace('token: cannot downscope without client_id');\n      }\n\n      return _promise.default.reject(new Error('cannot downscope access token'));\n    } // Since we're going to use scope as the index in our token collection, it's\n    // important scopes are always deterministically specified.\n\n\n    if (scope) {\n      scope = (0, _scope.sortScope)(scope);\n    } // Ideally, we could depend on the service to communicate this error, but\n    // all we get is \"invalid scope\", which, to the lay person, implies\n    // something wrong with *one* of the scopes, not the whole thing.\n\n\n    if (scope === (0, _scope.sortScope)(this.config.scope)) {\n      return _promise.default.reject(new Error('token: scope reduction requires a reduced scope'));\n    }\n\n    return this.webex.request({\n      method: 'POST',\n      uri: this.config.tokenUrl,\n      addAuthHeader: false,\n      form: {\n        grant_type: 'urn:cisco:oauth:grant-type:scope-reduction',\n        token: this.access_token,\n        scope: scope,\n        client_id: this.config.client_id,\n        self_contained_token: true\n      }\n    }).then(function (res) {\n      _this.logger.info(\"token: downscoped token to \".concat(scope));\n\n      return new Token((0, _assign.default)(res.body, {\n        scope: scope\n      }), {\n        parent: _this.parent\n      });\n    });\n  },\n\n  /**\n   * Initializer\n   * @instance\n   * @memberof Token\n   * @param {Object} [attrs={}]\n   * @param {Object} [options={}]\n   * @see {@link WebexPlugin#initialize()}\n   * @returns {Token}\n   */\n  initialize: function initialize() {\n    var _this2 = this;\n\n    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _apply.default)(_webexPlugin.default.prototype.initialize, this, [attrs, options]);\n\n    if (typeof attrs === 'string') {\n      this.access_token = attrs;\n    }\n\n    if (!this.access_token) {\n      throw new Error('`access_token` is required');\n    } // We don't want the derived property `isExpired` to need {cache:false}, so\n    // we'll set up a timer the runs when this token should expire.\n\n\n    if (this.expires) {\n      if (this.expires < (0, _now.default)()) {\n        this._isExpired = true;\n      } else {\n        (0, _commonTimers.safeSetTimeout)(function () {\n          _this2._isExpired = true;\n        }, this.expires - (0, _now.default)());\n      }\n    }\n  },\n\n  /**\n   * Refreshes this Token. Relies on\n   * {@link config.credentials.refreshCallback()}\n   * @instance\n   * @memberof Token\n   * @returns {Promise<Token>}\n   */\n  refresh: function refresh() {\n    var _this3 = this;\n\n    if (!this.canRefresh) {\n      throw new Error('Not enough information available to refresh this access token');\n    }\n\n    var promise;\n\n    if (_common.inBrowser) {\n      if (!this.config.refreshCallback) {\n        throw new Error('Cannot refresh access token without refreshCallback');\n      }\n\n      promise = _promise.default.resolve(this.config.refreshCallback(this.webex, this));\n    }\n\n    return (promise || this.webex.request({\n      method: 'POST',\n      uri: this.config.tokenUrl,\n      form: {\n        grant_type: 'refresh_token',\n        redirect_uri: this.config.redirect_uri,\n        refresh_token: this.refresh_token\n      },\n      auth: {\n        user: this.config.client_id,\n        pass: this.config.client_secret,\n        sendImmediately: true\n      },\n      shouldRefreshAccessToken: false\n    }).then(function (res) {\n      return res.body;\n    })).then(function (obj) {\n      if (!obj) {\n        throw new Error('token: refreshCallback() did not produce an object');\n      } // If the authentication server did not send back a refresh token, copy\n      // the current refresh token and related values to the response (note:\n      // at time of implementation, CI never sends a new refresh token)\n\n\n      if (!obj.refresh_token) {\n        (0, _assign.default)(obj, (0, _pick2.default)(_this3, 'refresh_token', 'refresh_token_expires', 'refresh_token_expires_in'));\n      } // If the new token is the same as the previous token, then we may have\n      // found a bug in CI; log the details and reject the Promise\n\n\n      if (_this3.access_token === obj.access_token) {\n        _this3.logger.error('token: new token matches current token'); // log the tokens if it is not production\n\n\n        if (process.env.NODE_ENV !== 'production') {\n          _this3.logger.error('token: current token:', _this3.access_token);\n\n          _this3.logger.error('token: new token:', obj.access_token);\n        }\n\n        return _promise.default.reject(new Error('new token matches current token'));\n      }\n\n      if (_this3.previousToken) {\n        _this3.previousToken.revoke();\n\n        _this3.unset('previousToken');\n      }\n\n      obj.previousToken = _this3;\n      obj.scope = _this3.scope;\n      return new Token(obj, {\n        parent: _this3.parent\n      });\n    }).catch(processGrantError);\n  },\n\n  /**\n   * Revokes this token and unsets its local properties\n   * @instance\n   * @memberof Token\n   * @returns {Promise}\n   */\n  revoke: function revoke() {\n    var _this4 = this;\n\n    if (this.isExpired) {\n      this.logger.info('token: already expired, not making making revocation request');\n      return _promise.default.resolve();\n    }\n\n    if (!this.canAuthorize) {\n      this.logger.info('token: no longer valid, not making revocation request');\n      return _promise.default.resolve();\n    } // FIXME we need to use the user token revocation endpoint to revoke a token\n    // without a client_secret, but it doesn't current support using a token to\n    // revoke itself\n    // Note: I'm not making a canRevoke property because there should be changes\n    // coming to the user token revocation endpoint that allow us to do this\n    // correctly.\n\n\n    if (!this.config.client_secret) {\n      this.logger.info('token: no client secret available, not making revocation request');\n      return _promise.default.resolve();\n    }\n\n    this.logger.info('token: revoking access token');\n    return this.webex.request({\n      method: 'POST',\n      uri: this.config.revokeUrl,\n      form: {\n        token: this.access_token,\n        token_type_hint: 'access_token'\n      },\n      auth: {\n        user: this.config.client_id,\n        pass: this.config.client_secret,\n        sendImmediately: true\n      },\n      shouldRefreshAccessToken: false\n    }).then(function () {\n      _this4.unset(['access_token', 'expires', 'expires_in', 'token_type']);\n\n      _this4.logger.info('token: access token revoked');\n    }).catch(processGrantError);\n  },\n  set: function set() {\n    // eslint-disable-next-line prefer-const\n    var _this$_filterSetParam = this._filterSetParameters.apply(this, arguments),\n        _this$_filterSetParam2 = (0, _slicedToArray2.default)(_this$_filterSetParam, 2),\n        attrs = _this$_filterSetParam2[0],\n        options = _this$_filterSetParam2[1];\n\n    if (!attrs.token_type && attrs.access_token && attrs.access_token.includes(' ')) {\n      var _attrs$access_token$s = attrs.access_token.split(' '),\n          _attrs$access_token$s2 = (0, _slicedToArray2.default)(_attrs$access_token$s, 2),\n          token_type = _attrs$access_token$s2[0],\n          access_token = _attrs$access_token$s2[1];\n\n      attrs = (0, _assign.default)({}, attrs, {\n        access_token: access_token,\n        token_type: token_type\n      });\n    }\n\n    var now = (0, _now.default)();\n\n    if (!attrs.expires && attrs.expires_in) {\n      attrs.expires = now + attrs.expires_in * 1000;\n    }\n\n    if (!attrs.refresh_token_expires && attrs.refresh_token_expires_in) {\n      attrs.refresh_token_expires = now + attrs.refresh_token_expires_in * 1000;\n    }\n\n    if (attrs.scope) {\n      attrs.scope = (0, _scope.sortScope)(attrs.scope);\n    }\n\n    return (0, _apply.default)(_webexPlugin.default.prototype.set, this, [attrs, options]);\n  },\n\n  /**\n   * Renders the token object as an HTTP Header Value\n   * @instance\n   * @memberof Token\n   * @returns {string}\n   * @see {@link Object#toString()}\n   */\n  toString: function toString() {\n    if (!this._string) {\n      throw new Error('cannot stringify Token');\n    }\n\n    return this._string;\n  },\n\n  /**\n   * Uses a non-producation api to return information about this token. This\n   * method is primarily for tests and will throw if NODE_ENV === production\n   * @instance\n   * @memberof Token\n   * @private\n   * @returns {Promise}\n   */\n  validate: function validate() {\n    var _this5 = this;\n\n    if (process.env.NODE_ENV === 'production') {\n      throw new Error('Token#validate() must not be used in production');\n    }\n\n    return this.webex.request({\n      method: 'POST',\n      service: 'conversation',\n      resource: 'users/validateAuthToken',\n      body: {\n        token: this.access_token\n      }\n    }).catch(function (reason) {\n      if ('statusCode' in reason) {\n        return _promise.default.reject(reason);\n      }\n\n      _this5.logger.info('REMINDER: If you\\'re investigating a network error here, it\\'s normal'); // If we got an error that isn't a WebexHttpError, assume the problem is\n      // that we don't have the wdm plugin loaded and service/resource isn't\n      // a valid means of identifying a request.\n\n\n      var convApi = process.env.CONVERSATION_SERVICE || process.env.CONVERSATION_SERVICE_URL || 'https://conv-a.wbx2.com/conversation/api/v1';\n      return _this5.webex.request({\n        method: 'POST',\n        uri: \"\".concat(convApi, \"/users/validateAuthToken\"),\n        body: {\n          token: _this5.access_token\n        },\n        headers: {\n          authorization: \"Bearer \".concat(_this5.access_token)\n        }\n      });\n    }).then(function (res) {\n      return res.body;\n    });\n  },\n  version: \"1.154.2\"\n}, ((0, _applyDecoratedDescriptor2.default)(_obj, \"downscope\", [_dec], (0, _getOwnPropertyDescriptor.default)(_obj, \"downscope\"), _obj), (0, _applyDecoratedDescriptor2.default)(_obj, \"refresh\", [_common.oneFlight], (0, _getOwnPropertyDescriptor.default)(_obj, \"refresh\"), _obj), (0, _applyDecoratedDescriptor2.default)(_obj, \"revoke\", [_common.oneFlight], (0, _getOwnPropertyDescriptor.default)(_obj, \"revoke\"), _obj)), _obj)));\n\nvar _default = Token;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["processGrantError","res","statusCode","_promise","reject","ErrorConstructor","grantErrors","select","body","error","OAuthError","WebexHttpError","_res","Token","WebexPlugin","extend","keyFactory","scope","derived","canAuthorize","deps","fn","access_token","isExpired","canDownscope","config","client_id","canRefresh","inBrowser","refresh_token","refreshCallback","client_secret","expires","_isExpired","_string","token_type","namespace","props","expires_in","refresh_token_expires","refresh_token_expires_in","default","type","session","previousToken","downscope","logger","info","Error","trace","webex","request","method","uri","tokenUrl","addAuthHeader","form","grant_type","token","self_contained_token","then","_this","parent","initialize","attrs","options","prototype","_this2","refresh","promise","resolve","redirect_uri","auth","user","pass","sendImmediately","shouldRefreshAccessToken","obj","_this3","process","env","NODE_ENV","revoke","unset","catch","revokeUrl","token_type_hint","_this4","set","_filterSetParameters","includes","split","now","toString","validate","service","resource","reason","_this5","convApi","CONVERSATION_SERVICE","CONVERSATION_SERVICE_URL","headers","authorization","version","oneFlight"],"sources":["token.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {pick} from 'lodash';\nimport {inBrowser, oneFlight} from '@webex/common';\nimport {safeSetTimeout} from '@webex/common-timers';\n\nimport WebexHttpError from '../webex-http-error';\nimport WebexPlugin from '../webex-plugin';\n\nimport {sortScope} from './scope';\nimport grantErrors, {OAuthError} from './grant-errors';\n\n/* eslint-disable camelcase */\n\n/**\n * Parse response from CI and converts to structured error when appropriate\n * @param {WebexHttpError} res\n * @private\n * @returns {GrantError}\n */\nfunction processGrantError(res) {\n  if (res.statusCode !== 400) {\n    return Promise.reject(res);\n  }\n\n  const ErrorConstructor = grantErrors.select(res.body.error);\n\n  if (ErrorConstructor === OAuthError && res instanceof WebexHttpError) {\n    return Promise.reject(res);\n  }\n  if (!ErrorConstructor) {\n    return Promise.reject(res);\n  }\n\n  return Promise.reject(new ErrorConstructor(res._res || res));\n}\n\n/**\n * @class\n */\nconst Token = WebexPlugin.extend({\n  derived: {\n    /**\n     * Indicates if this token can be used in an auth header. `true` iff\n     * {@link Token#access_token} is defined and {@link Token#isExpired} is\n     * false.\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    canAuthorize: {\n      deps: ['access_token', 'isExpired'],\n      fn() {\n        return !!this.access_token && !this.isExpired;\n      }\n    },\n\n    /**\n     * Indicates that this token can be downscoped. `true` iff\n     * {@link config.credentials.client_id} is defined and if\n     * {@link Token#canAuthorize} is true\n     *\n     * Note: since {@link config} is not evented, we can't listen for changes to\n     * {@link config.credentials.client_id}. As such,\n     * {@link config.credentials.client_id} must always be set before\n     * instantiating a {@link Token}\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    canDownscope: {\n      deps: ['canAuthorize'],\n      fn() {\n        return this.canAuthorize && !!this.config.client_id;\n      }\n    },\n\n    /**\n     * Indicates if this token can be refreshed. `true` iff\n     * {@link Token@refresh_token} is defined and\n     * {@link config.credentials.refreshCallback()} is defined\n     *\n     * Note: since {@link config} is not evented, we can't listen for changes to\n     * {@link config.credentials.refreshCallback()}. As such,\n     * {@link config.credentials.refreshCallback()} must always be set before\n     * instantiating a {@link Token}\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    canRefresh: {\n      deps: ['refresh_token'],\n      fn() {\n        if (inBrowser) {\n          return !!this.refresh_token && !!this.config.refreshCallback;\n        }\n\n        return !!this.refresh_token && !!this.config.client_secret;\n      }\n    },\n\n    /**\n     * Indicates if this `Token` is expired. `true` iff {@link Token#expires} is\n     * defined and is less than {@link Date.now()}.\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    isExpired: {\n      deps: ['expires', '_isExpired'],\n      fn() {\n        // in order to avoid setting `cache:false`, we'll use a private property\n        // and a timer rather than comparing to `Date.now()`;\n        return !!this.expires && this._isExpired;\n      }\n    },\n\n    /**\n     * Cache for toString()\n     * @instance\n     * @memberof Token\n     * @private\n     * @readonly\n     * @type {string}\n     */\n    _string: {\n      deps: ['access_token', 'token_type'],\n      fn() {\n        if (!this.access_token || !this.token_type) {\n          return '';\n        }\n\n        return `${this.token_type} ${this.access_token}`;\n      }\n    }\n  },\n\n  namespace: 'Credentials',\n\n  props: {\n    /**\n     * Used for indexing in the credentials userTokens collection\n     * @instance\n     * @memberof Token\n     * @private\n     * @type {string}\n     */\n    scope: 'string',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {string}\n     */\n    access_token: 'string',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    expires: 'number',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    expires_in: 'number',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {string}\n     */\n    refresh_token: 'string',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    refresh_token_expires: 'number',\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    refresh_token_expires_in: 'number',\n    /**\n     * @default \"Bearer\"\n     * @instance\n     * @memberof Token\n     * @type {string}\n     */\n    token_type: {\n      default: 'Bearer',\n      type: 'string'\n    }\n  },\n\n  session: {\n    /**\n     * Used by {@link Token#isExpired} to avoid doing a Date comparison.\n     * @instance\n     * @memberof Token\n     * @private\n     * @type {boolean}\n     */\n    _isExpired: {\n      default: false,\n      type: 'boolean'\n    },\n    /**\n     * Handle to the previous token that we'll revoke when we refresh this\n     * token. The idea is to keep allow two valid tokens when a refresh occurs;\n     * we don't want revoke a token that's in the middle of being used, so when\n     * we do a token refresh, we won't revoke the token being refreshed, but\n     * we'll revoke the previous one.\n     * @instance\n     * @memberof Token\n     * @private\n     * @type {Object}\n     */\n    previousToken: {\n      type: 'state'\n    }\n  },\n\n  @oneFlight({\n    keyFactory(scope) {\n      return scope;\n    }\n  })\n  /**\n   * Uses this token to request a new Token with a subset of this Token's scopes\n   * @instance\n   * @memberof Token\n   * @param {string} scope\n   * @returns {Promise<Token>}\n   */\n  downscope(scope) {\n    this.logger.info(`token: downscoping token to ${scope}`);\n\n    if (this.isExpired) {\n      this.logger.info('token: request received to downscope expired access_token');\n\n      return Promise.reject(new Error('cannot downscope expired access token'));\n    }\n\n    if (!this.canDownscope) {\n      if (this.config.client_id) {\n        this.logger.info('token: request received to downscope invalid access_token');\n      }\n      else {\n        this.logger.trace('token: cannot downscope without client_id');\n      }\n\n      return Promise.reject(new Error('cannot downscope access token'));\n    }\n\n    // Since we're going to use scope as the index in our token collection, it's\n    // important scopes are always deterministically specified.\n    if (scope) {\n      scope = sortScope(scope);\n    }\n\n    // Ideally, we could depend on the service to communicate this error, but\n    // all we get is \"invalid scope\", which, to the lay person, implies\n    // something wrong with *one* of the scopes, not the whole thing.\n    if (scope === sortScope(this.config.scope)) {\n      return Promise.reject(new Error('token: scope reduction requires a reduced scope'));\n    }\n\n    return this.webex.request({\n      method: 'POST',\n      uri: this.config.tokenUrl,\n      addAuthHeader: false,\n      form: {\n        grant_type: 'urn:cisco:oauth:grant-type:scope-reduction',\n        token: this.access_token,\n        scope,\n        client_id: this.config.client_id,\n        self_contained_token: true\n      }\n    })\n      .then((res) => {\n        this.logger.info(`token: downscoped token to ${scope}`);\n\n        return new Token(Object.assign(res.body, {scope}), {parent: this.parent});\n      });\n  },\n\n  /**\n   * Initializer\n   * @instance\n   * @memberof Token\n   * @param {Object} [attrs={}]\n   * @param {Object} [options={}]\n   * @see {@link WebexPlugin#initialize()}\n   * @returns {Token}\n   */\n  initialize(attrs = {}, options = {}) {\n    Reflect.apply(WebexPlugin.prototype.initialize, this, [attrs, options]);\n\n    if (typeof attrs === 'string') {\n      this.access_token = attrs;\n    }\n\n    if (!this.access_token) {\n      throw new Error('`access_token` is required');\n    }\n\n    // We don't want the derived property `isExpired` to need {cache:false}, so\n    // we'll set up a timer the runs when this token should expire.\n    if (this.expires) {\n      if (this.expires < Date.now()) {\n        this._isExpired = true;\n      }\n      else {\n        safeSetTimeout(() => {\n          this._isExpired = true;\n        }, this.expires - Date.now());\n      }\n    }\n  },\n\n  @oneFlight\n  /**\n   * Refreshes this Token. Relies on\n   * {@link config.credentials.refreshCallback()}\n   * @instance\n   * @memberof Token\n   * @returns {Promise<Token>}\n   */\n  refresh() {\n    if (!this.canRefresh) {\n      throw new Error('Not enough information available to refresh this access token');\n    }\n\n    let promise;\n\n    if (inBrowser) {\n      if (!this.config.refreshCallback) {\n        throw new Error('Cannot refresh access token without refreshCallback');\n      }\n\n      promise = Promise.resolve(this.config.refreshCallback(this.webex, this));\n    }\n\n    return (promise || this.webex.request({\n      method: 'POST',\n      uri: this.config.tokenUrl,\n      form: {\n        grant_type: 'refresh_token',\n        redirect_uri: this.config.redirect_uri,\n        refresh_token: this.refresh_token\n      },\n      auth: {\n        user: this.config.client_id,\n        pass: this.config.client_secret,\n        sendImmediately: true\n      },\n      shouldRefreshAccessToken: false\n    })\n      .then((res) => res.body))\n      .then((obj) => {\n        if (!obj) {\n          throw new Error('token: refreshCallback() did not produce an object');\n        }\n        // If the authentication server did not send back a refresh token, copy\n        // the current refresh token and related values to the response (note:\n        // at time of implementation, CI never sends a new refresh token)\n        if (!obj.refresh_token) {\n          Object.assign(obj, pick(this, 'refresh_token', 'refresh_token_expires', 'refresh_token_expires_in'));\n        }\n\n        // If the new token is the same as the previous token, then we may have\n        // found a bug in CI; log the details and reject the Promise\n        if (this.access_token === obj.access_token) {\n          this.logger.error('token: new token matches current token');\n          // log the tokens if it is not production\n          if (process.env.NODE_ENV !== 'production') {\n            this.logger.error('token: current token:', this.access_token);\n            this.logger.error('token: new token:', obj.access_token);\n          }\n\n          return Promise.reject(new Error('new token matches current token'));\n        }\n\n        if (this.previousToken) {\n          this.previousToken.revoke();\n          this.unset('previousToken');\n        }\n\n        obj.previousToken = this;\n        obj.scope = this.scope;\n\n        return new Token(obj, {parent: this.parent});\n      })\n      .catch(processGrantError);\n  },\n\n  @oneFlight\n  /**\n   * Revokes this token and unsets its local properties\n   * @instance\n   * @memberof Token\n   * @returns {Promise}\n   */\n  revoke() {\n    if (this.isExpired) {\n      this.logger.info('token: already expired, not making making revocation request');\n\n      return Promise.resolve();\n    }\n\n    if (!this.canAuthorize) {\n      this.logger.info('token: no longer valid, not making revocation request');\n\n      return Promise.resolve();\n    }\n\n    // FIXME we need to use the user token revocation endpoint to revoke a token\n    // without a client_secret, but it doesn't current support using a token to\n    // revoke itself\n    // Note: I'm not making a canRevoke property because there should be changes\n    // coming to the user token revocation endpoint that allow us to do this\n    // correctly.\n    if (!this.config.client_secret) {\n      this.logger.info('token: no client secret available, not making revocation request');\n\n      return Promise.resolve();\n    }\n\n    this.logger.info('token: revoking access token');\n\n    return this.webex.request({\n      method: 'POST',\n      uri: this.config.revokeUrl,\n      form: {\n        token: this.access_token,\n        token_type_hint: 'access_token'\n      },\n      auth: {\n        user: this.config.client_id,\n        pass: this.config.client_secret,\n        sendImmediately: true\n      },\n      shouldRefreshAccessToken: false\n    })\n      .then(() => {\n        this.unset([\n          'access_token',\n          'expires',\n          'expires_in',\n          'token_type'\n        ]);\n        this.logger.info('token: access token revoked');\n      })\n      .catch(processGrantError);\n  },\n\n  set(...args) {\n    // eslint-disable-next-line prefer-const\n    let [attrs, options] = this._filterSetParameters(...args);\n\n    if (!attrs.token_type && attrs.access_token && attrs.access_token.includes(' ')) {\n      const [token_type, access_token] = attrs.access_token.split(' ');\n\n      attrs = Object.assign({}, attrs, {access_token, token_type});\n    }\n    const now = Date.now();\n\n    if (!attrs.expires && attrs.expires_in) {\n      attrs.expires = now + attrs.expires_in * 1000;\n    }\n\n    if (!attrs.refresh_token_expires && attrs.refresh_token_expires_in) {\n      attrs.refresh_token_expires = now + attrs.refresh_token_expires_in * 1000;\n    }\n\n    if (attrs.scope) {\n      attrs.scope = sortScope(attrs.scope);\n    }\n\n    return Reflect.apply(WebexPlugin.prototype.set, this, [attrs, options]);\n  },\n\n  /**\n   * Renders the token object as an HTTP Header Value\n   * @instance\n   * @memberof Token\n   * @returns {string}\n   * @see {@link Object#toString()}\n   */\n  toString() {\n    if (!this._string) {\n      throw new Error('cannot stringify Token');\n    }\n\n    return this._string;\n  },\n\n  /**\n   * Uses a non-producation api to return information about this token. This\n   * method is primarily for tests and will throw if NODE_ENV === production\n   * @instance\n   * @memberof Token\n   * @private\n   * @returns {Promise}\n   */\n  validate() {\n    if (process.env.NODE_ENV === 'production') {\n      throw new Error('Token#validate() must not be used in production');\n    }\n\n    return this.webex.request({\n      method: 'POST',\n      service: 'conversation',\n      resource: 'users/validateAuthToken',\n      body: {\n        token: this.access_token\n      }\n    })\n      .catch((reason) => {\n        if ('statusCode' in reason) {\n          return Promise.reject(reason);\n        }\n        this.logger.info('REMINDER: If you\\'re investigating a network error here, it\\'s normal');\n\n        // If we got an error that isn't a WebexHttpError, assume the problem is\n        // that we don't have the wdm plugin loaded and service/resource isn't\n        // a valid means of identifying a request.\n        const convApi = process.env.CONVERSATION_SERVICE || process.env.CONVERSATION_SERVICE_URL || 'https://conv-a.wbx2.com/conversation/api/v1';\n\n        return this.webex.request({\n          method: 'POST',\n          uri: `${convApi}/users/validateAuthToken`,\n          body: {\n            token: this.access_token\n          },\n          headers: {\n            authorization: `Bearer ${this.access_token}`\n          }\n        });\n      })\n      .then((res) => res.body);\n  }\n});\n\nexport default Token;\n"]},"metadata":{},"sourceType":"script"}