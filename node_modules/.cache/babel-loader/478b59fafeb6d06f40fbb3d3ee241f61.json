{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = makeWebexPluginStorage;\n\nvar _weakMap = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/weak-map\"));\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/keys\"));\n\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/map\"));\n\nvar _getOwnPropertyDescriptor = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/createClass\"));\n\nvar _applyDecoratedDescriptor2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/applyDecoratedDescriptor\"));\n\nvar _result2 = _interopRequireDefault(require(\"lodash/result\"));\n\nvar _isObject2 = _interopRequireDefault(require(\"lodash/isObject\"));\n\nvar _isArray2 = _interopRequireDefault(require(\"lodash/isArray\"));\n\nvar _common = require(\"@webex/common\");\n\nvar _errors = require(\"./errors\");\n/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar defers = new _weakMap.default();\n/**\n * Walks an object before writing it to the store and omits empty arrays\n * @private\n * @param {Object} value\n * @returns {Object}\n */\n\nfunction serialize(value) {\n  if (!(0, _isObject2.default)(value)) {\n    return value;\n  }\n\n  var serialized = value.serialize ? value.serialize() : value;\n  (0, _keys.default)(serialized).forEach(function (key) {\n    var val = serialized[key];\n\n    if ((0, _isArray2.default)(val)) {\n      if (val.length === 0) {\n        serialized[key] = undefined;\n      } else {\n        serialized[key] = val.map(serialize);\n      }\n    } else if ((0, _isObject2.default)(val)) {\n      (0, _keys.default)(val).forEach(function (k) {\n        val[k] = serialize(val[k]);\n      });\n    }\n  });\n  var empty = (0, _keys.default)(serialized).reduce(function (acc, key) {\n    return acc && !serialized[key];\n  }, true);\n\n  if (empty) {\n    return undefined;\n  }\n\n  return serialized;\n}\n/**\n * [makeWebexPluginStorage description]\n * @param {[type]} type\n * @param {[type]} context\n * @private\n * @returns {[type]}\n */\n\n\nfunction makeWebexPluginStorage(type, context) {\n  var _dec, _class;\n  /**\n   * Interface between WebexPlugin and Webex#boundeStorage or\n   * Webex#unboundedStorage\n   */\n\n\n  var WebexPluginStorage = (_dec = (0, _common.oneFlight)({\n    keyFactory: function keyFactory(key) {\n      return \"initValue-\".concat(key);\n    }\n  }), (_class = /*#__PURE__*/function () {\n    /**\n     * @param {Object} attrs\n     * @param {Object} options\n     * @returns {WebexPluginStorage}\n     */\n    function WebexPluginStorage() {\n      (0, _classCallCheck2.default)(this, WebexPluginStorage);\n      defers.set(this, new _map.default());\n    }\n    /**\n     * Clears an entire namespace\n     * @returns {Promise}\n     */\n\n\n    (0, _createClass2.default)(WebexPluginStorage, [{\n      key: \"clear\",\n      value: function clear() {\n        return context.webex[\"\".concat(type, \"Storage\")].del(context.getNamespace());\n      }\n      /**\n       * Deletes the specified key from the store\n       * @param {string} key\n       * @returns {[type]}\n       */\n\n    }, {\n      key: \"del\",\n      value: function del() {\n        var _context$webex$;\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        return (_context$webex$ = context.webex[\"\".concat(type, \"Storage\")]).del.apply(_context$webex$, [context.getNamespace()].concat(args));\n      }\n      /**\n       * Retrieves the value specified by key from the store. Rejects with\n       * NotFoundError if no value can be found\n       * @param {string} key\n       * @returns {Promise}\n       */\n\n    }, {\n      key: \"get\",\n      value: function get(key) {\n        var defer = defers.get(this).get(key);\n\n        if (!defer) {\n          defer = new _common.Defer();\n          defers.get(this).set(key, defer);\n        }\n\n        return context.webex[\"\".concat(type, \"Storage\")].get(context.getNamespace(), key).then(function (res) {\n          defer.resolve();\n          return res;\n        });\n      }\n      /**\n       * Writes a value to the store\n       * @param {string} key\n       * @param {any} value\n       * @returns {Promise}\n       */\n\n    }, {\n      key: \"put\",\n      value: function put(key, value) {\n        return context.webex[\"\".concat(type, \"Storage\")].put(context.getNamespace(), key, serialize(value));\n      }\n      /**\n       * Returns a Promise that won't resolve until the value specified by key has\n       * been attempted to be loaded from the store. This allows us to lazily\n       * prevent certain method from executing until the specified keys have been\n       * retrieved from the store.\n       * @param {string} key\n       * @returns {Promise}\n       */\n\n    }, {\n      key: \"waitFor\",\n      value: function waitFor(key) {\n        context.logger.debug(\"plugin-storage(\".concat(context.getNamespace(), \"): waiting to init key `\").concat(key, \"`\"));\n        var defer = defers.get(this).get(key);\n\n        if (defer) {\n          context.logger.debug(\"plugin-storage(\".concat(context.getNamespace(), \"): already inited `\").concat(key, \"`\"));\n          return defer.promise;\n        }\n\n        context.logger.debug(\"plugin-storage(\".concat(context.getNamespace(), \"): initing `\").concat(key, \"`\"));\n        return this.initValue(key);\n      }\n    }, {\n      key: \"initValue\",\n      value: function initValue(key) {\n        var defer = new _common.Defer();\n        defers.get(this).set(key, defer); // Intentionally bypasses this.get so we don't resolve the promise until\n        // after the parent value is set.\n\n        context.webex[\"\".concat(type, \"Storage\")].get(context.getNamespace(), key).then(function (value) {\n          context.logger.debug(\"plugin-storage(\".concat(context.getNamespace(), \"): got `\").concat(key, \"` for first time\"));\n\n          if (key === '@') {\n            context.parent.set(value);\n          } else if ((0, _result2.default)(context[key], 'isState')) {\n            context[key].set(value);\n          } else {\n            context.set(key, value);\n          }\n\n          context.logger.debug(\"plugin-storage(\".concat(context.getNamespace(), \"): set `\").concat(key, \"` for first time\"));\n          defer.resolve();\n          context.logger.debug(\"plugin-storage(\".concat(context.getNamespace(), \"): inited `\").concat(key, \"`\"));\n        }).catch(function (reason) {\n          // The  next conditional is a bit of an unfortunate solution to deal\n          // with circular dependencies in unit tests. It should not effect\n          // integration tests or production code.\n          if (reason instanceof _errors.NotFoundError || process.env.NODE_ENV !== 'production' && reason.toString().includes('MockNotFoundError')) {\n            context.logger.debug(\"plugin-storage(\".concat(context.getNamespace(), \"): no data for `\").concat(key, \"`, continuing\"));\n            return defer.resolve();\n          }\n\n          context.logger.warn(\"plugin-storage(\".concat(context.getNamespace(), \"): failed to init `\").concat(key, \"`\"), reason);\n          return defer.reject(reason);\n        });\n        return defer.promise;\n      }\n    }]);\n    return WebexPluginStorage;\n  }(), (0, _applyDecoratedDescriptor2.default)(_class.prototype, \"initValue\", [_dec], (0, _getOwnPropertyDescriptor.default)(_class.prototype, \"initValue\"), _class.prototype), _class));\n  return new WebexPluginStorage();\n}","map":{"version":3,"mappings":"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","names":["defers","serialize","value","serialized","forEach","key","val","length","undefined","map","k","empty","reduce","acc","makeWebexPluginStorage","type","context","WebexPluginStorage","keyFactory","set","webex","del","getNamespace","args","arguments","defer","get","Defer","then","res","resolve","put","logger","debug","promise","initValue","parent","catch","reason","NotFoundError","process","env","NODE_ENV","toString","includes","warn","reject"],"sources":["make-webex-plugin-store.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {Defer, oneFlight} from '@webex/common';\nimport {isArray, isObject, result} from 'lodash';\n\nimport {NotFoundError} from './errors';\n\nconst defers = new WeakMap();\n\n/**\n * Walks an object before writing it to the store and omits empty arrays\n * @private\n * @param {Object} value\n * @returns {Object}\n */\nfunction serialize(value) {\n  if (!isObject(value)) {\n    return value;\n  }\n\n  const serialized = value.serialize ? value.serialize() : value;\n\n  Object.keys(serialized).forEach((key) => {\n    const val = serialized[key];\n\n    if (isArray(val)) {\n      if (val.length === 0) {\n        serialized[key] = undefined;\n      }\n      else {\n        serialized[key] = val.map(serialize);\n      }\n    }\n    else if (isObject(val)) {\n      Object.keys(val).forEach((k) => {\n        val[k] = serialize(val[k]);\n      });\n    }\n  });\n\n  const empty = Object.keys(serialized).reduce((acc, key) => acc && !serialized[key], true);\n\n  if (empty) {\n    return undefined;\n  }\n\n  return serialized;\n}\n\n/**\n * [makeWebexPluginStorage description]\n * @param {[type]} type\n * @param {[type]} context\n * @private\n * @returns {[type]}\n */\nexport default function makeWebexPluginStorage(type, context) {\n  /**\n   * Interface between WebexPlugin and Webex#boundeStorage or\n   * Webex#unboundedStorage\n   */\n  class WebexPluginStorage {\n    /**\n     * @param {Object} attrs\n     * @param {Object} options\n     * @returns {WebexPluginStorage}\n     */\n    constructor() {\n      defers.set(this, new Map());\n    }\n\n    /**\n     * Clears an entire namespace\n     * @returns {Promise}\n     */\n    clear() {\n      return context.webex[`${type}Storage`].del(context.getNamespace());\n    }\n\n    /**\n     * Deletes the specified key from the store\n     * @param {string} key\n     * @returns {[type]}\n     */\n    del(...args) {\n      return context.webex[`${type}Storage`].del(context.getNamespace(), ...args);\n    }\n\n    /**\n     * Retrieves the value specified by key from the store. Rejects with\n     * NotFoundError if no value can be found\n     * @param {string} key\n     * @returns {Promise}\n     */\n    get(key) {\n      let defer = defers.get(this).get(key);\n\n      if (!defer) {\n        defer = new Defer();\n        defers.get(this).set(key, defer);\n      }\n\n      return context.webex[`${type}Storage`].get(context.getNamespace(), key)\n        .then((res) => {\n          defer.resolve();\n\n          return res;\n        });\n    }\n\n    /**\n     * Writes a value to the store\n     * @param {string} key\n     * @param {any} value\n     * @returns {Promise}\n     */\n    put(key, value) {\n      return context.webex[`${type}Storage`].put(context.getNamespace(), key, serialize(value));\n    }\n\n    /**\n     * Returns a Promise that won't resolve until the value specified by key has\n     * been attempted to be loaded from the store. This allows us to lazily\n     * prevent certain method from executing until the specified keys have been\n     * retrieved from the store.\n     * @param {string} key\n     * @returns {Promise}\n     */\n    waitFor(key) {\n      context.logger.debug(`plugin-storage(${context.getNamespace()}): waiting to init key \\`${key}\\``);\n      const defer = defers.get(this).get(key);\n\n      if (defer) {\n        context.logger.debug(`plugin-storage(${context.getNamespace()}): already inited \\`${key}\\``);\n\n        return defer.promise;\n      }\n\n      context.logger.debug(`plugin-storage(${context.getNamespace()}): initing \\`${key}\\``);\n\n      return this.initValue(key);\n    }\n\n    @oneFlight({keyFactory: (key) => `initValue-${key}`})\n    /**\n     * Attempts to load the specified key from the store and set it on the parent\n     * object.\n     * @param {string} key\n     * @returns {Promise} Resolves (but not with the retrieved value) when\n     * the value retrieval complete\n     */\n    // suppress doc warning because decorators confuse eslint\n    // eslint-disable-next-line require-jsdoc\n    initValue(key) {\n      const defer = new Defer();\n\n      defers.get(this).set(key, defer);\n\n      // Intentionally bypasses this.get so we don't resolve the promise until\n      // after the parent value is set.\n      context.webex[`${type}Storage`].get(context.getNamespace(), key)\n        .then((value) => {\n          context.logger.debug(`plugin-storage(${context.getNamespace()}): got \\`${key}\\` for first time`);\n          if (key === '@') {\n            context.parent.set(value);\n          }\n          else if (result(context[key], 'isState')) {\n            context[key].set(value);\n          }\n          else {\n            context.set(key, value);\n          }\n          context.logger.debug(`plugin-storage(${context.getNamespace()}): set \\`${key}\\` for first time`);\n          defer.resolve();\n          context.logger.debug(`plugin-storage(${context.getNamespace()}): inited \\`${key}\\``);\n        })\n        .catch((reason) => {\n          // The  next conditional is a bit of an unfortunate solution to deal\n          // with circular dependencies in unit tests. It should not effect\n          // integration tests or production code.\n          if (reason instanceof NotFoundError || process.env.NODE_ENV !== 'production' && reason.toString().includes('MockNotFoundError')) {\n            context.logger.debug(`plugin-storage(${context.getNamespace()}): no data for \\`${key}\\`, continuing`);\n\n            return defer.resolve();\n          }\n          context.logger.warn(`plugin-storage(${context.getNamespace()}): failed to init \\`${key}\\``, reason);\n\n          return defer.reject(reason);\n        });\n\n      return defer.promise;\n    }\n  }\n\n  return new WebexPluginStorage();\n}\n"]},"metadata":{},"sourceType":"script"}