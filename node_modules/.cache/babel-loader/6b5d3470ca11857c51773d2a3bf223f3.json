{"ast":null,"code":"\"use strict\";\n\nvar _Reflect$construct = require(\"@babel/runtime-corejs2/core-js/reflect/construct\");\n\nvar _Array$from = require(\"@babel/runtime-corejs2/core-js/array/from\");\n\nvar _Symbol = require(\"@babel/runtime-corejs2/core-js/symbol\");\n\nvar _Symbol$iterator = require(\"@babel/runtime-corejs2/core-js/symbol/iterator\");\n\nvar _Array$isArray = require(\"@babel/runtime-corejs2/core-js/array/is-array\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = exports.KMSError = void 0;\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/slicedToArray\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/getPrototypeOf\"));\n\nvar _wrapNativeSuper2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/wrapNativeSuper\"));\n\nvar _isArray2 = _interopRequireDefault(require(\"lodash/isArray\"));\n\nvar _url = require(\"url\");\n\nvar _validUrl = require(\"valid-url\");\n\nvar _asn1js = require(\"asn1js\");\n\nvar _pkijs = require(\"pkijs\");\n\nvar _nodeJose = _interopRequireDefault(require(\"node-jose\"));\n\nvar _isomorphicWebcrypto = _interopRequireDefault(require(\"isomorphic-webcrypto\"));\n\nvar _safeBuffer = require(\"safe-buffer\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof _Symbol !== \"undefined\" && o[_Symbol$iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (_Array$isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return _Array$from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2.default)(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;\n      result = _Reflect$construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0, _possibleConstructorReturn2.default)(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false;\n  if (_Reflect$construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n(0, _pkijs.setEngine)('newEngine', _isomorphicWebcrypto.default, new _pkijs.CryptoEngine({\n  name: '',\n  crypto: _isomorphicWebcrypto.default,\n  subtle: _isomorphicWebcrypto.default.subtle\n}));\nvar VALID_KTY = 'RSA';\nvar VALID_KID_PROTOCOL = 'kms:';\nvar X509_COMMON_NAME_KEY = '2.5.4.3';\nvar X509_SUBJECT_ALT_NAME_KEY = '2.5.29.17';\n/**\n * Customize Error so the SDK knows to quit retrying and notify\n * the user\n */\n\nvar KMSError = /*#__PURE__*/function (_Error) {\n  (0, _inherits2.default)(KMSError, _Error);\n\n  var _super = _createSuper(KMSError);\n  /**\n   * add kmsError field to notify\n   * @param {string} message\n   */\n\n\n  function KMSError(message) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, KMSError);\n    _this = _super.call(this, message);\n    _this.kmsError = true;\n    return _this;\n  }\n\n  return KMSError;\n}( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Error));\n\nexports.KMSError = KMSError;\n\nvar throwError = function throwError(err) {\n  throw new KMSError(\"INVALID KMS: \".concat(err));\n};\n/**\n * Converts the PEM string to a pkijs certificate object\n * @param {string} pem PEM representation of a certificate\n * @returns {Certificate} pkijs object of the certificate\n */\n\n\nvar decodeCert = function decodeCert(pem) {\n  if (typeof pem !== 'string') {\n    throwError('certificate needs to be a string');\n  }\n\n  var der = _safeBuffer.Buffer.from(pem, 'base64');\n\n  var ber = new Uint8Array(der).buffer;\n  var asn1 = (0, _asn1js.fromBER)(ber);\n  return new _pkijs.Certificate({\n    schema: asn1.result\n  });\n};\n/**\n * Validate the 'kty' property of the KMS credentials\n * @param {Object} JWT KMS credentials\n * @param {string} JWT.kty type of certificate\n * @throws {KMSError} if kty is not a valid type\n * @returns {void}\n */\n\n\nvar validateKtyHeader = function validateKtyHeader(_ref) {\n  var kty = _ref.kty;\n\n  if (kty !== VALID_KTY) {\n    throwError(\"'kty' header must be '\".concat(VALID_KTY, \"'\"));\n  }\n};\n\nvar validateKidHeader = function validateKidHeader(_ref2) {\n  var kid = _ref2.kid;\n\n  if (!(0, _validUrl.isUri)(kid)) {\n    throwError('\\'kid\\' is not a valid URI');\n  }\n\n  if ((0, _url.parse)(kid).protocol !== VALID_KID_PROTOCOL) {\n    throwError(\"'kid' protocol must be '\".concat(VALID_KID_PROTOCOL, \"'\"));\n  }\n};\n/**\n * Checks the first certificate matches the 'kid' in the JWT.\n * It first checks the Subject Alternative Name then it checks\n * the Common Name\n * @param {Certificate} certificate represents the KMS\n * @param {Object} JWT KMS credentials\n * @param {string} JWT.kid the uri of the KMS\n * @throws {KMSError} if unable to validate certificate against KMS credentials\n * @returns {void}\n */\n\n\nvar validateCommonName = function validateCommonName(_ref3, _ref4) {\n  var _ref5 = (0, _slicedToArray2.default)(_ref3, 1),\n      certificate = _ref5[0];\n\n  var kid = _ref4.kid;\n  var kidHostname = (0, _url.parse)(kid).hostname;\n  var validationSuccessful = false;\n\n  if (certificate.extensions) {\n    // Subject Alt Names are in here\n    var _iterator = _createForOfIteratorHelper(certificate.extensions),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var extension = _step.value;\n\n        if (extension.extnID === X509_SUBJECT_ALT_NAME_KEY) {\n          var altNames = extension.parsedValue.altNames;\n\n          var _iterator2 = _createForOfIteratorHelper(altNames),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var entry = _step2.value;\n              var san = entry.value;\n              validationSuccessful = san === kidHostname;\n\n              if (validationSuccessful) {\n                break;\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          if (validationSuccessful) {\n            break;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  if (!validationSuccessful) {\n    // Didn't match kid in the Subject Alt Names, checking the Common Name\n    var subjectAttributes = certificate.subject.typesAndValues;\n\n    var _iterator3 = _createForOfIteratorHelper(subjectAttributes),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var attribute = _step3.value;\n\n        if (attribute.type === X509_COMMON_NAME_KEY) {\n          var commonName = attribute.value.valueBlock.value;\n          validationSuccessful = commonName === kidHostname;\n\n          if (validationSuccessful) {\n            break;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n\n  if (!validationSuccessful) {\n    throwError('hostname of the 1st certificate does not match \\'kid\\'');\n  }\n};\n/**\n * Validate the first KMS certificate against the information\n * provided in the JWT\n * @param {Certificate} certificate first certificate the identifies the KMS\n * @param {Object} JWT credentials of the KMS\n * @param {string} JWT.e Public exponent of the first certificate\n * @param {string} KWT.n Modulus of the first certificate\n * @throws {KMSError} if e or n doesn't match the first certificate\n * @returns {void}\n */\n\n\nvar validatePublicCertificate = function validatePublicCertificate(_ref6, _ref7) {\n  var _ref8 = (0, _slicedToArray2.default)(_ref6, 1),\n      certificate = _ref8[0];\n\n  var publicExponent = _ref7.e,\n      modulus = _ref7.n;\n  var encode = _nodeJose.default.util.base64url.encode;\n  var publicKey = certificate.subjectPublicKeyInfo.subjectPublicKey;\n  var asn1PublicCert = (0, _asn1js.fromBER)(publicKey.valueBlock.valueHex);\n  var publicCert = new _pkijs.RSAPublicKey({\n    schema: asn1PublicCert.result\n  });\n  var publicExponentHex = publicCert.publicExponent.valueBlock.valueHex;\n  var modulusHex = publicCert.modulus.valueBlock.valueHex;\n\n  if (publicExponent !== encode(publicExponentHex)) {\n    throwError('Public exponent is invalid');\n  }\n\n  if (modulus !== encode(modulusHex)) {\n    throwError('Modulus is invalid');\n  }\n};\n/**\n * Validates the list of certificates against the CAs provided\n * @param {certificate[]} certificates list of certificates provided\n *   by the KMS to certify itself\n * @param {string[]} [caroots=[]] list of Certificate Authorities used to\n *   validate the KMS's certificates\n * @returns {Promise} rejects if unable to validate the certificates\n */\n\n\nvar validateCertificatesSignature = function validateCertificatesSignature(certificates) {\n  var caroots = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var certificateEngine = new _pkijs.CertificateChainValidationEngine({\n    trustedCerts: caroots.map(decodeCert),\n    certs: certificates\n  });\n  return certificateEngine.verify().then(function (_ref9) {\n    var result = _ref9.result,\n        resultCode = _ref9.resultCode,\n        resultMessage = _ref9.resultMessage;\n\n    if (!result) {\n      throwError(\"Certificate Validation failed [\".concat(resultCode, \"]: \").concat(resultMessage));\n    }\n  });\n};\n/**\n * Validates the information provided by the KMS. This is a curried function.\n * The first function takes the caroots param and returns a second function.\n * The second function takes the credentials of the KMS and validates it\n * @param {string[]} caroots PEM encoded certificates that will be used\n *   as Certificate Authorities\n * @param {Object} jwt Object containing the fields necessary to\n *   validate the KMS\n * @returns {Promise} when resolved will return the jwt\n */\n\n\nvar validateKMS = function validateKMS(caroots) {\n  return function () {\n    var jwt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return _promise.default.resolve().then(function () {\n      validateKtyHeader(jwt);\n      validateKidHeader(jwt);\n\n      if (!((0, _isArray2.default)(jwt.x5c) && jwt.x5c.length > 0)) {\n        throwError('JWK does not contain a list of certificates');\n      }\n\n      var certificates = jwt.x5c.map(decodeCert);\n      validateCommonName(certificates, jwt);\n      validatePublicCertificate(certificates, jwt); // Skip validating signatures if no CA roots were provided\n\n      var promise = caroots ? validateCertificatesSignature(certificates, caroots) : _promise.default.resolve();\n      return promise.then(function () {\n        return jwt;\n      });\n    });\n  };\n};\n\nvar _default = validateKMS;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["crypto","CryptoEngine","name","subtle","VALID_KTY","VALID_KID_PROTOCOL","X509_COMMON_NAME_KEY","X509_SUBJECT_ALT_NAME_KEY","KMSError","message","_this","kmsError","Error","throwError","err","decodeCert","pem","der","Buffer","from","ber","Uint8Array","buffer","asn1","Certificate","schema","result","validateKtyHeader","kty","validateKidHeader","kid","protocol","validateCommonName","certificate","kidHostname","hostname","validationSuccessful","extensions","extension","extnID","altNames","parsedValue","entry","san","value","_iterator2","_iterator","subjectAttributes","subject","typesAndValues","attribute","type","commonName","valueBlock","_iterator3","validatePublicCertificate","publicExponent","e","modulus","n","encode","jose","util","base64url","publicKey","subjectPublicKeyInfo","subjectPublicKey","asn1PublicCert","valueHex","publicCert","RSAPublicKey","publicExponentHex","modulusHex","validateCertificatesSignature","certificates","caroots","certificateEngine","CertificateChainValidationEngine","trustedCerts","map","certs","verify","then","resultCode","resultMessage","validateKMS","jwt","_promise","resolve","x5c","length","promise"],"sources":["kms-certificate-validation.js"],"sourcesContent":["import {parse as parseUrl} from 'url';\n\nimport {isUri} from 'valid-url';\nimport {fromBER} from 'asn1js';\nimport {\n  Certificate,\n  RSAPublicKey,\n  CertificateChainValidationEngine,\n  CryptoEngine,\n  setEngine\n} from 'pkijs';\nimport {isArray} from 'lodash';\nimport jose from 'node-jose';\nimport crypto from 'isomorphic-webcrypto';\nimport {Buffer} from 'safe-buffer';\n\nsetEngine(\n  'newEngine',\n  crypto,\n  new CryptoEngine({\n    name: '',\n    crypto,\n    subtle: crypto.subtle\n  })\n);\n\nconst VALID_KTY = 'RSA';\nconst VALID_KID_PROTOCOL = 'kms:';\n\nconst X509_COMMON_NAME_KEY = '2.5.4.3';\n\nconst X509_SUBJECT_ALT_NAME_KEY = '2.5.29.17';\n\n/**\n * Customize Error so the SDK knows to quit retrying and notify\n * the user\n */\nexport class KMSError extends Error {\n  /**\n   * add kmsError field to notify\n   * @param {string} message\n   */\n  constructor(message) {\n    super(message);\n    this.kmsError = true;\n  }\n}\n\nconst throwError = (err) => {\n  throw new KMSError(`INVALID KMS: ${err}`);\n};\n\n/**\n * Converts the PEM string to a pkijs certificate object\n * @param {string} pem PEM representation of a certificate\n * @returns {Certificate} pkijs object of the certificate\n */\nconst decodeCert = (pem) => {\n  if (typeof pem !== 'string') {\n    throwError('certificate needs to be a string');\n  }\n\n  const der = Buffer.from(pem, 'base64');\n  const ber = new Uint8Array(der).buffer;\n\n  const asn1 = fromBER(ber);\n\n  return new Certificate({schema: asn1.result});\n};\n\n/**\n * Validate the 'kty' property of the KMS credentials\n * @param {Object} JWT KMS credentials\n * @param {string} JWT.kty type of certificate\n * @throws {KMSError} if kty is not a valid type\n * @returns {void}\n */\nconst validateKtyHeader = ({kty}) => {\n  if (kty !== VALID_KTY) {\n    throwError(`'kty' header must be '${VALID_KTY}'`);\n  }\n};\n\nconst validateKidHeader = ({kid}) => {\n  if (!isUri(kid)) {\n    throwError('\\'kid\\' is not a valid URI');\n  }\n\n  if (parseUrl(kid).protocol !== VALID_KID_PROTOCOL) {\n    throwError(`'kid' protocol must be '${VALID_KID_PROTOCOL}'`);\n  }\n};\n\n/**\n * Checks the first certificate matches the 'kid' in the JWT.\n * It first checks the Subject Alternative Name then it checks\n * the Common Name\n * @param {Certificate} certificate represents the KMS\n * @param {Object} JWT KMS credentials\n * @param {string} JWT.kid the uri of the KMS\n * @throws {KMSError} if unable to validate certificate against KMS credentials\n * @returns {void}\n */\nconst validateCommonName = ([certificate], {kid}) => {\n  const kidHostname = parseUrl(kid).hostname;\n  let validationSuccessful = false;\n\n  if (certificate.extensions) {\n    // Subject Alt Names are in here\n    for (const extension of certificate.extensions) {\n      if (extension.extnID === X509_SUBJECT_ALT_NAME_KEY) {\n        const {altNames} = extension.parsedValue;\n\n        for (const entry of altNames) {\n          const san = entry.value;\n\n          validationSuccessful = san === kidHostname;\n          if (validationSuccessful) {\n            break;\n          }\n        }\n\n        if (validationSuccessful) {\n          break;\n        }\n      }\n    }\n  }\n\n  if (!validationSuccessful) {\n    // Didn't match kid in the Subject Alt Names, checking the Common Name\n    const subjectAttributes = certificate.subject.typesAndValues;\n\n    for (const attribute of subjectAttributes) {\n      if (attribute.type === X509_COMMON_NAME_KEY) {\n        const commonName = attribute.value.valueBlock.value;\n\n        validationSuccessful = commonName === kidHostname;\n        if (validationSuccessful) {\n          break;\n        }\n      }\n    }\n  }\n\n  if (!validationSuccessful) {\n    throwError('hostname of the 1st certificate does not match \\'kid\\'');\n  }\n};\n\n/**\n * Validate the first KMS certificate against the information\n * provided in the JWT\n * @param {Certificate} certificate first certificate the identifies the KMS\n * @param {Object} JWT credentials of the KMS\n * @param {string} JWT.e Public exponent of the first certificate\n * @param {string} KWT.n Modulus of the first certificate\n * @throws {KMSError} if e or n doesn't match the first certificate\n * @returns {void}\n */\nconst validatePublicCertificate =\n  ([certificate], {e: publicExponent, n: modulus}) => {\n    const {encode} = jose.util.base64url;\n\n    const publicKey = certificate.subjectPublicKeyInfo.subjectPublicKey;\n    const asn1PublicCert = fromBER(publicKey.valueBlock.valueHex);\n    const publicCert = new RSAPublicKey({schema: asn1PublicCert.result});\n    const publicExponentHex = publicCert.publicExponent.valueBlock.valueHex;\n    const modulusHex = publicCert.modulus.valueBlock.valueHex;\n\n    if (publicExponent !== encode(publicExponentHex)) {\n      throwError('Public exponent is invalid');\n    }\n    if (modulus !== encode(modulusHex)) {\n      throwError('Modulus is invalid');\n    }\n  };\n\n/**\n * Validates the list of certificates against the CAs provided\n * @param {certificate[]} certificates list of certificates provided\n *   by the KMS to certify itself\n * @param {string[]} [caroots=[]] list of Certificate Authorities used to\n *   validate the KMS's certificates\n * @returns {Promise} rejects if unable to validate the certificates\n */\nconst validateCertificatesSignature = (certificates, caroots = []) => {\n  const certificateEngine = new CertificateChainValidationEngine({\n    trustedCerts: caroots.map(decodeCert),\n    certs: certificates\n  });\n\n  return certificateEngine.verify()\n    .then(({result, resultCode, resultMessage}) => {\n      if (!result) {\n        throwError(\n          `Certificate Validation failed [${resultCode}]: ${resultMessage}`\n        );\n      }\n    });\n};\n\n/**\n * Validates the information provided by the KMS. This is a curried function.\n * The first function takes the caroots param and returns a second function.\n * The second function takes the credentials of the KMS and validates it\n * @param {string[]} caroots PEM encoded certificates that will be used\n *   as Certificate Authorities\n * @param {Object} jwt Object containing the fields necessary to\n *   validate the KMS\n * @returns {Promise} when resolved will return the jwt\n */\nconst validateKMS = (caroots) => (jwt = {}) => Promise.resolve()\n  .then(() => {\n    validateKtyHeader(jwt);\n    validateKidHeader(jwt);\n\n    if (!(isArray(jwt.x5c) && jwt.x5c.length > 0)) {\n      throwError('JWK does not contain a list of certificates');\n    }\n    const certificates = jwt.x5c.map(decodeCert);\n\n    validateCommonName(certificates, jwt);\n    validatePublicCertificate(certificates, jwt);\n\n    // Skip validating signatures if no CA roots were provided\n    const promise = caroots ?\n      validateCertificatesSignature(certificates, caroots) : Promise.resolve();\n\n    return promise\n      .then(() => jwt);\n  });\n\nexport default validateKMS;\n"]},"metadata":{},"sourceType":"script"}