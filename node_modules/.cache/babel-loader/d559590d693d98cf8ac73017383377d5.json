{"ast":null,"code":"\"use strict\";\n\nvar _typeof = require(\"@babel/runtime-corejs2/helpers/typeof\");\n\nvar _WeakMap2 = require(\"@babel/runtime-corejs2/core-js/weak-map\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _Object$getOwnPropertyDescriptor2 = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/slicedToArray\"));\n\nvar _applyDecoratedDescriptor2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/applyDecoratedDescriptor\"));\n\nvar _weakMap = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/weak-map\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/json/stringify\"));\n\nvar _now = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/date/now\"));\n\nvar _getOwnPropertyDescriptor = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\"));\n\nvar _omit2 = _interopRequireDefault(require(\"lodash/omit\"));\n\nvar _querystring = _interopRequireDefault(require(\"querystring\"));\n\nvar _util = _interopRequireDefault(require(\"util\"));\n\nvar _commonTimers = require(\"@webex/common-timers\");\n\nvar _common = require(\"@webex/common\");\n\nvar _webexCore = require(\"@webex/webex-core\");\n\nvar _nodeKms = require(\"node-kms\");\n\nvar _nodeJose = _interopRequireDefault(require(\"node-jose\"));\n\nvar _kmsBatcher = _interopRequireWildcard(require(\"./kms-batcher\"));\n\nvar _kmsCertificateValidation = _interopRequireWildcard(require(\"./kms-certificate-validation\"));\n\nvar _dec, _obj;\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof _WeakMap2 !== \"function\") return null;\n  var cacheBabelInterop = new _WeakMap2();\n  var cacheNodeInterop = new _WeakMap2();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = _Object$defineProperty && _Object$getOwnPropertyDescriptor2;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? _Object$getOwnPropertyDescriptor2(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        _Object$defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar contexts = new _weakMap.default();\nvar kmsDetails = new _weakMap.default();\nvar partialContexts = new _weakMap.default();\n\nvar consoleDebug = require('debug')('kms');\n/**\n * @class\n */\n\n\nvar KMS = _webexCore.WebexPlugin.extend((_dec = (0, _common.oneFlight)({\n  keyFactory: function keyFactory(_ref) {\n    var uri = _ref.uri,\n        onBehalfOf = _ref.onBehalfOf;\n    return \"\".concat(uri, \"/\").concat(onBehalfOf);\n  }\n}), (_obj = {\n  namespace: 'Encryption',\n  children: {\n    batcher: _kmsBatcher.default\n  },\n\n  /**\n   * Binds a key to a resource\n   * @param {Object} options\n   * @param {KMSResourceObject} options.kro\n   * @param {string} options.kroUri\n   * @param {Key} options.key\n   * @param {string} options.keyUri\n   * @returns {Promise<Key>}\n   */\n  bindKey: function bindKey(_ref2) {\n    var _this = this;\n\n    var kro = _ref2.kro,\n        kroUri = _ref2.kroUri,\n        key = _ref2.key,\n        keyUri = _ref2.keyUri;\n    kroUri = kroUri || kro.uri;\n    keyUri = keyUri || key.uri;\n    this.logger.info('kms: binding key to resource');\n    /* istanbul ignore if */\n\n    if (!kroUri) {\n      return _promise.default.reject(new Error('`kro` or `kroUri` is required'));\n    }\n    /* istanbul ignore if */\n\n\n    if (!keyUri) {\n      return _promise.default.reject(new Error('`key` or `keyUri` is required'));\n    }\n\n    return this.request({\n      method: 'update',\n      resourceUri: kroUri,\n      uri: keyUri\n    }).then(function (res) {\n      _this.logger.info('kms: bound key to resource');\n\n      return res.key;\n    });\n  },\n\n  /**\n   * Creates a new KMS Resource\n   * @param {Object} options\n   * @param {Array<string>} options.userIds\n   * @param {Array<string>} options.keyUris\n   * @param {Key} options.key\n   * @param {Array<Keys>} options.keys\n   * @returns {Promise<KMSResourceObject>}\n   */\n  createResource: function createResource(_ref3) {\n    var _this2 = this;\n\n    var userIds = _ref3.userIds,\n        keyUris = _ref3.keyUris,\n        key = _ref3.key,\n        keys = _ref3.keys;\n    keyUris = keyUris || [];\n    /* istanbul ignore if */\n\n    if (keys) {\n      keyUris = keys.reduce(function (uris, k) {\n        uris.push(k.uri);\n        return uris;\n      }, keyUris);\n    }\n    /* istanbul ignore else */\n\n\n    if (key) {\n      keyUris.push(key.uri);\n    }\n    /* istanbul ignore if */\n\n\n    if (keyUris.length === 0) {\n      return _promise.default.reject(new Error('Cannot create KMS Resource without at least one keyUri'));\n    }\n\n    this.logger.info('kms: creating resource');\n    return this.request({\n      method: 'create',\n      uri: '/resources',\n      userIds: userIds,\n      keyUris: keyUris\n    }).then(function (res) {\n      _this2.logger.info('kms: created resource');\n\n      return res.resource;\n    });\n  },\n\n  /**\n   * Authorizes a user or KRO to a KRO\n   * @param {Object} options\n   * @param {Array<string>} options.userIds\n   * @param {Array<string>} options.authIds interchangable with userIds\n   * @param {KMSResourceObject} options.kro the target kro\n   * @param {string} options.kroUri\n   * @returns {Promise<KMSAuthorizationObject>}\n   */\n  addAuthorization: function addAuthorization(_ref4) {\n    var _this3 = this;\n\n    var userIds = _ref4.userIds,\n        authIds = _ref4.authIds,\n        kro = _ref4.kro,\n        kroUri = _ref4.kroUri;\n    userIds = userIds || [];\n    kroUri = kroUri || kro.uri;\n\n    if (authIds) {\n      userIds = userIds.concat(authIds);\n    }\n    /* istanbul ignore if */\n\n\n    if (userIds.length === 0) {\n      return _promise.default.reject(new Error('Cannot add authorization without userIds or authIds'));\n    }\n    /* istanbul ignore if */\n\n\n    if (!kroUri) {\n      return _promise.default.reject(new Error('`kro` or `kroUri` is required'));\n    }\n\n    this.logger.info('kms: adding authorization to kms resource');\n    return this.request({\n      method: 'create',\n      uri: '/authorizations',\n      resourceUri: kroUri,\n      userIds: userIds\n    }).then(function (res) {\n      _this3.logger.info('kms: added authorization');\n\n      return res.authorizations;\n    });\n  },\n\n  /**\n   * Retrieve a list of users that have been authorized to the KRO\n   * @param {Object} options\n   * @param {KMSResourceObject} options.kro the target kro\n   * @param {string} options.kroUri\n   * @returns {Array<authId>}\n   */\n  listAuthorizations: function listAuthorizations(_ref5) {\n    var _this4 = this;\n\n    var kro = _ref5.kro,\n        kroUri = _ref5.kroUri;\n    kroUri = kroUri || kro.uri;\n    /* istanbul ignore if */\n\n    if (!kroUri) {\n      return _promise.default.reject(new Error('`kro` or `kroUri` is required'));\n    }\n\n    return this.request({\n      method: 'retrieve',\n      uri: \"\".concat(kroUri, \"/authorizations\")\n    }).then(function (res) {\n      _this4.logger.info('kms: retrieved authorization list');\n\n      return res.authorizations;\n    });\n  },\n\n  /**\n   * Deauthorizes a user or KRO from a KRO\n   * @param {Object} options\n   * @param {string} options.userId\n   * @param {string} options.authId interchangable with userIds\n   * @param {KMSResourceObject} options.kro the target kro\n   * @param {string} options.kroUri\n   * @returns {Promise<KMSAuthorizationObject>}\n   */\n  removeAuthorization: function removeAuthorization(_ref6) {\n    var _this5 = this;\n\n    var authId = _ref6.authId,\n        userId = _ref6.userId,\n        kro = _ref6.kro,\n        kroUri = _ref6.kroUri;\n    authId = authId || userId;\n    kroUri = kroUri || kro.uri;\n    /* istanbul ignore if */\n\n    if (!authId) {\n      return _promise.default.reject(new Error('Cannot remove authorization without authId'));\n    }\n    /* istanbul ignore if */\n\n\n    if (!kroUri) {\n      return _promise.default.reject(new Error('`kro` or `kroUri` is required'));\n    }\n\n    this.logger.info('kms: removing authorization from kms resource');\n    return this.request({\n      method: 'delete',\n      uri: \"\".concat(kroUri, \"/authorizations?\").concat(_querystring.default.stringify({\n        authId: authId\n      }))\n    }).then(function (res) {\n      _this5.logger.info('kms: removed authorization');\n\n      return res.authorizations;\n    });\n  },\n\n  /**\n   * Requests `count` unbound keys from the kms\n   * @param {Object} options\n   * @param {Number} options.count\n   * @returns {Array<Key>}\n   */\n  createUnboundKeys: function createUnboundKeys(_ref7) {\n    var _this6 = this;\n\n    var count = _ref7.count;\n    this.logger.info(\"kms: request \".concat(count, \" unbound keys\"));\n    /* istanbul ignore if */\n\n    if (!count) {\n      return _promise.default.reject(new Error('`options.count` is required'));\n    }\n\n    return this.request({\n      method: 'create',\n      uri: '/keys',\n      count: count\n    }).then(function (res) {\n      _this6.logger.info('kms: received unbound keys');\n\n      return _promise.default.all(res.keys.map(_this6.asKey));\n    });\n  },\n  fetchKey: function fetchKey(_ref8) {\n    var _this7 = this;\n\n    var uri = _ref8.uri,\n        onBehalfOf = _ref8.onBehalfOf;\n    /* istanbul ignore if */\n\n    if (!uri) {\n      return _promise.default.reject(new Error('`options.uri` is required'));\n    }\n\n    this.logger.info('kms: fetching key');\n    return this.request({\n      method: 'retrieve',\n      uri: uri\n    }, {\n      onBehalfOf: onBehalfOf\n    }).then(function (res) {\n      _this7.logger.info('kms: fetched key');\n\n      return _this7.asKey(res.key);\n    });\n  },\n\n  /**\n   * Pings the kms. Mostly for testing\n   * @returns {Promise}\n   */\n  ping: function ping() {\n    return this.request({\n      method: 'update',\n      uri: '/ping'\n    });\n  },\n\n  /**\n   * Ensures a key obect is Key instance\n   * @param {Object} key\n   * @returns {Promise<Key>}\n   */\n  asKey: function asKey(key) {\n    return _nodeJose.default.JWK.asKey(key.jwk).then(function (jwk) {\n      key.jwk = jwk;\n      return key;\n    });\n  },\n\n  /**\n   * Adds appropriate metadata to the KMS request\n   * @param {Object} payload\n   * @param {Object} onBehalfOf Optional parameter to prepare the request on behalf of another user\n   * @returns {Promise<KMS.Request>}\n   */\n  prepareRequest: function prepareRequest(payload, onBehalfOf) {\n    var _this8 = this;\n\n    var isECDHRequest = payload.method === 'create' && payload.uri.includes('/ecdhe');\n    return _promise.default.resolve(isECDHRequest ? partialContexts.get(this) : this._getContext()).then(function (context) {\n      _this8.logger.info(\"kms: wrapping \".concat(isECDHRequest ? 'ephemeral key' : 'kms', \" request\"));\n\n      var req = new _nodeKms.Request(payload);\n      var requestContext = context;\n\n      if (onBehalfOf) {\n        requestContext = _this8._contextOnBehalfOf(context, onBehalfOf);\n      }\n\n      return req.wrap(requestContext, {\n        serverKey: isECDHRequest\n      }).then(function () {\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production') {\n          _this8.logger.info('kms: request payload', _util.default.inspect((0, _omit2.default)(JSON.parse((0, _stringify.default)(req)), 'wrapped'), {\n            depth: null\n          }));\n        }\n\n        return req;\n      });\n    });\n  },\n\n  /**\n   * Accepts a kms message event, decrypts it, and passes it to the batcher\n   * @param {Object} event\n   * @returns {Promise<Object>}\n   */\n  processKmsMessageEvent: function processKmsMessageEvent(event) {\n    var _this9 = this;\n\n    this.logger.info('kms: received kms message');\n    return _promise.default.all(event.encryption.kmsMessages.map(function (kmsMessage, index) {\n      return _this9._isECDHEMessage(kmsMessage).then(function (isECDHMessage) {\n        _this9.logger.info(\"kms: received \".concat(isECDHMessage ? 'ecdhe' : 'normal', \" message\"));\n\n        var res = new _nodeKms.Response(kmsMessage);\n        return _promise.default.resolve(isECDHMessage ? partialContexts.get(_this9) : contexts.get(_this9)) // eslint-disable-next-line max-nested-callbacks\n        .then(function (context) {\n          return res.unwrap(context);\n        }) // eslint-disable-next-line max-nested-callbacks\n        .then(function () {\n          if (process.env.NODE_ENV !== 'production') {\n            _this9.logger.info('kms: response payload', _util.default.inspect((0, _omit2.default)(JSON.parse((0, _stringify.default)(res)), 'wrapped'), {\n              depth: null\n            }));\n          }\n        }) // eslint-disable-next-line max-nested-callbacks\n        .then(function () {\n          event.encryption.kmsMessages[index] = res;\n        }) // eslint-disable-next-line max-nested-callbacks\n        .then(function () {\n          return res;\n        });\n      });\n    })).then(function () {\n      return _this9.batcher.processKmsMessageEvent(event);\n    }).catch(function (reason) {\n      _this9.logger.error('kms: decrypt failed', reason.stack);\n\n      return _promise.default.reject(reason);\n    }).then(function () {\n      return event;\n    });\n  },\n\n  /**\n   * Decrypts a kms message\n   * @param {Object} kmsMessage\n   * @returns {Promise<Object>}\n   */\n  decryptKmsMessage: function decryptKmsMessage(kmsMessage) {\n    var res = new _nodeKms.Response(kmsMessage);\n    return contexts.get(this).then(function (context) {\n      return res.unwrap(context);\n    }).then(function () {\n      return res.body;\n    });\n  },\n\n  /**\n   * Determines if the kms message is an ecdhe message or a normal message\n   * @param {Object} kmsMessage\n   * @returns {Promise<boolean>}\n   */\n  _isECDHEMessage: function _isECDHEMessage(kmsMessage) {\n    return this._getKMSStaticPubKey().then(function (kmsStaticPubKey) {\n      var fields = kmsMessage.split('.');\n\n      if (fields.length !== 3) {\n        return false;\n      }\n\n      var header = JSON.parse(_nodeJose.default.util.base64url.decode(fields[0]));\n      return header.kid === kmsStaticPubKey.kid;\n    });\n  },\n\n  /**\n   * Sends a request to the kms\n   * @param {Object} payload\n   * @param {Object} options\n   * @param {Number} options.timeout (internal)\n   * @param {string} options.onBehalfOf Run the request on behalf of another user (UUID), used in compliance scenarios\n   * @returns {Promise<Object>}\n   */\n  request: function request(payload) {\n    var _this10 = this;\n\n    var _ref9 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        timeout = _ref9.timeout,\n        onBehalfOf = _ref9.onBehalfOf;\n\n    timeout = timeout || this.config.kmsInitialTimeout; // Note: this should only happen when we're using the async kms batcher;\n    // once we implement the sync batcher, this'll need to be smarter.\n\n    return this.webex.internal.mercury.connect().then(function () {\n      return _this10.prepareRequest(payload, onBehalfOf);\n    }).then(function (req) {\n      req[_kmsBatcher.TIMEOUT_SYMBOL] = timeout;\n      return _this10.batcher.request(req);\n    }) // High complexity is due to attempt at test mode resiliency\n    // eslint-disable-next-line complexity\n    .catch(function (reason) {\n      if (process.env.NODE_ENV === 'test' && (reason.status === 403 || reason.statusCode === 403) && reason.message.match(/Failed to resolve authorization token in KmsMessage request for user/)) {\n        _this10.logger.warn('kms: rerequested key due to test-mode kms auth failure');\n\n        return _this10.request(payload, {\n          onBehalfOf: onBehalfOf\n        });\n      } // KMS Error. Notify the user\n\n\n      if (reason instanceof _kmsCertificateValidation.KMSError) {\n        _this10.webex.trigger('client:InvalidRequestError');\n\n        return _promise.default.reject(reason);\n      } // Ideally, most or all of the code below would go in kms-batcher, but\n      // but batching needs at least one more round of refactoring for that to\n      // work.\n\n\n      if (!reason.statusCode && !reason.status) {\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production') {\n          /* istanbul ignore next: reason.stack vs stack difficult to control in test */\n          _this10.logger.info('kms: request error', reason.stack || reason);\n        }\n\n        consoleDebug(\"timeout \".concat(timeout));\n        timeout *= 2;\n\n        if (timeout >= _this10.config.ecdhMaxTimeout) {\n          _this10.logger.info('kms: exceeded maximum KMS request retries');\n\n          return _promise.default.reject(reason);\n        } // Peek ahead to make sure we don't reset the timeout if the next timeout\n        // will exceed the maximum timeout for renegotiating ECDH keys.\n\n\n        var nextTimeout = timeout * 2;\n\n        if (timeout >= _this10.config.kmsMaxTimeout && nextTimeout < _this10.config.ecdhMaxTimeout) {\n          _this10.logger.info('kms: exceeded maximum KMS request retries; negotiating new ecdh key');\n          /* istanbul ignore else */\n\n\n          if (process.env.NODE_ENV !== 'production') {\n            _this10.logger.info('kms: timeout/maxtimeout', timeout, _this10.config.kmsMaxTimeout);\n          }\n\n          contexts.delete(_this10);\n          timeout = 0;\n        }\n\n        return _this10.request(payload, {\n          timeout: timeout,\n          onBehalfOf: onBehalfOf\n        });\n      }\n\n      return _promise.default.reject(reason);\n    });\n  },\n\n  /**\n   * @private\n   * @returns {Promise<string>}\n   */\n  _getAuthorization: function _getAuthorization() {\n    return this.webex.credentials.getUserToken('spark:kms').then(function (token) {\n      return token.access_token;\n    });\n  },\n\n  /**\n   * @private\n   * @param {String} onBehalfOf create context on behalf of another user, undefined when this is not necessary\n   * @returns {Promise<Object>}\n   */\n  _getContext: function _getContext() {\n    var _this11 = this;\n\n    var promise = contexts.get(this);\n\n    if (!promise) {\n      promise = this._prepareContext();\n      contexts.set(this, promise);\n      promise.then(function (context) {\n        var expiresIn = context.ephemeralKey.expirationDate - (0, _now.default)() - 30000;\n        (0, _commonTimers.safeSetTimeout)(function () {\n          return contexts.delete(_this11);\n        }, expiresIn);\n      });\n    }\n\n    return _promise.default.all([promise, this._getAuthorization()]).then(function (_ref10) {\n      var _ref11 = (0, _slicedToArray2.default)(_ref10, 2),\n          context = _ref11[0],\n          authorization = _ref11[1];\n\n      context.clientInfo.credential.bearer = authorization;\n      return context;\n    });\n  },\n\n  /**\n   * @private\n   * @returns {Promise<Object>}\n   */\n  _getKMSCluster: function _getKMSCluster() {\n    this.logger.info('kms: retrieving KMS cluster');\n    return this._getKMSDetails().then(function (_ref12) {\n      var kmsCluster = _ref12.kmsCluster;\n      return kmsCluster;\n    });\n  },\n\n  /**\n   * @private\n   * @returns {Promise<Object>}\n   */\n  _getKMSDetails: function _getKMSDetails() {\n    var _this12 = this;\n\n    var details = kmsDetails.get(this);\n\n    if (!details) {\n      this.logger.info('kms: fetching KMS details');\n      details = this.webex.request({\n        service: 'encryption',\n        resource: \"/kms/\".concat(this.webex.internal.device.userId)\n      }).then(function (res) {\n        _this12.logger.info('kms: fetched KMS details');\n\n        var body = res.body;\n        body.rsaPublicKey = JSON.parse(body.rsaPublicKey);\n        return body;\n      }).catch(function (reason) {\n        _this12.logger.error('kms: failed to fetch KMS details', reason);\n\n        return _promise.default.reject(reason);\n      });\n      kmsDetails.set(this, details);\n    }\n\n    return details;\n  },\n\n  /**\n   * @private\n   * @returns {Promise<Object>}\n   */\n  _getKMSStaticPubKey: function _getKMSStaticPubKey() {\n    this.logger.info('kms: retrieving KMS static public key');\n    return this._getKMSDetails().then(function (_ref13) {\n      var rsaPublicKey = _ref13.rsaPublicKey;\n      return rsaPublicKey;\n    });\n  },\n\n  /**\n   * @private\n   * @returns {Promise<Object>}\n   */\n  _prepareContext: function _prepareContext() {\n    var _this13 = this;\n\n    this.logger.info('kms: creating context');\n    var context = new _nodeKms.Context();\n    return _promise.default.all([this._getKMSStaticPubKey().then((0, _kmsCertificateValidation.default)(this.config.caroots)), this._getAuthorization()]).then(function (_ref14) {\n      var _ref15 = (0, _slicedToArray2.default)(_ref14, 2),\n          kmsStaticPubKey = _ref15[0],\n          authorization = _ref15[1];\n\n      context.clientInfo = {\n        clientId: _this13.webex.internal.device.url,\n        credential: {\n          userId: _this13.webex.internal.device.userId,\n          bearer: authorization\n        }\n      };\n      context.serverInfo = {\n        key: kmsStaticPubKey\n      };\n\n      _this13.logger.info('kms: creating local ephemeral key');\n\n      return context.createECDHKey();\n    }).then(function (localECDHKey) {\n      context.ephemeralKey = localECDHKey;\n      partialContexts.set(_this13, context);\n      return _promise.default.all([localECDHKey.asKey(), _this13._getKMSCluster()]);\n    }).then(function (_ref16) {\n      var _ref17 = (0, _slicedToArray2.default)(_ref16, 2),\n          localECDHKey = _ref17[0],\n          cluster = _ref17[1];\n\n      _this13.logger.info('kms: submitting ephemeral key request');\n\n      return _this13.request({\n        uri: \"\".concat(cluster, \"/ecdhe\"),\n        method: 'create',\n        jwk: localECDHKey.toJSON()\n      });\n    }).then(function (res) {\n      _this13.logger.info('kms: deriving final ephemeral key');\n\n      return context.deriveEphemeralKey(res.key);\n    }).then(function (key) {\n      context.ephemeralKey = key;\n      partialContexts.delete(_this13);\n\n      _this13.logger.info('kms: derived final ephemeral key');\n\n      return context;\n    }).catch(function (reason) {\n      _this13.logger.error('kms: failed to negotiate ephemeral key', reason);\n\n      return _promise.default.reject(reason);\n    });\n  },\n\n  /**\n   * KMS 'retrieve' requests can be made on behalf of another user. This is useful\n   * for scenarios such as eDiscovery. i.e. Where an authorized compliance officer is\n   * entitled to retrieve content generated by any organisational user.\n   * As the KMSContext is cached, updating it will affect separate requests. Hence when\n   * making a request onBehalfOf another user create a new context for just this request.\n   * However this context will be 'light' as it only needs to change one field.\n   * @param {Object} originalContext - The base context to 'copy'\n   * @param {String} onBehalfOf - The user specified in the new context\n   * @returns {Context} A 'copy' of the existing context with a new user specified\n   * @private\n   */\n  _contextOnBehalfOf: function _contextOnBehalfOf(originalContext, onBehalfOf) {\n    var context = new _nodeKms.Context();\n    context.clientInfo = context.clientInfo = {\n      clientId: originalContext.clientInfo.clientId,\n      credential: {\n        userId: onBehalfOf,\n        onBehalfOf: onBehalfOf,\n        // Supports running onBehalfOf self. i.e. A CO which calls onBehalfOf with CO.id.\n        bearer: originalContext.clientInfo.credential.bearer\n      }\n    };\n    context.serverInfo = originalContext.serverInfo;\n    context.ephemeralKey = originalContext.ephemeralKey;\n    return context;\n  },\n  version: \"1.154.2\"\n}, ((0, _applyDecoratedDescriptor2.default)(_obj, \"fetchKey\", [_dec], (0, _getOwnPropertyDescriptor.default)(_obj, \"fetchKey\"), _obj), (0, _applyDecoratedDescriptor2.default)(_obj, \"_getContext\", [_common.oneFlight], (0, _getOwnPropertyDescriptor.default)(_obj, \"_getContext\"), _obj)), _obj)));\n\nvar _default = KMS;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["contexts","kmsDetails","partialContexts","consoleDebug","require","KMS","WebexPlugin","extend","keyFactory","uri","onBehalfOf","namespace","children","batcher","KMSBatcher","bindKey","kro","kroUri","key","keyUri","logger","info","_promise","reject","Error","request","method","resourceUri","then","res","_this","createResource","userIds","keyUris","keys","reduce","uris","k","push","length","_this2","resource","addAuthorization","authIds","concat","_this3","authorizations","listAuthorizations","_this4","removeAuthorization","authId","userId","querystring","stringify","_this5","createUnboundKeys","count","_this6","all","map","asKey","fetchKey","_this7","ping","jose","JWK","jwk","prepareRequest","payload","isECDHRequest","includes","resolve","get","_getContext","context","_this8","req","Request","requestContext","_contextOnBehalfOf","wrap","serverKey","process","env","NODE_ENV","util","inspect","JSON","parse","depth","processKmsMessageEvent","event","encryption","kmsMessages","kmsMessage","index","_this9","_isECDHEMessage","isECDHMessage","Response","unwrap","catch","reason","error","stack","decryptKmsMessage","body","_getKMSStaticPubKey","kmsStaticPubKey","fields","split","header","base64url","decode","kid","timeout","config","kmsInitialTimeout","webex","internal","mercury","connect","_this10","TIMEOUT_SYMBOL","status","statusCode","message","match","warn","KMSError","trigger","ecdhMaxTimeout","nextTimeout","kmsMaxTimeout","delete","_getAuthorization","credentials","getUserToken","token","access_token","promise","_prepareContext","set","expiresIn","ephemeralKey","expirationDate","_this11","authorization","clientInfo","credential","bearer","_getKMSCluster","_getKMSDetails","kmsCluster","details","service","device","_this12","rsaPublicKey","Context","caroots","clientId","_this13","url","serverInfo","createECDHKey","localECDHKey","cluster","toJSON","deriveEphemeralKey","originalContext","version","oneFlight"],"sources":["kms.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport querystring from 'querystring';\nimport util from 'util';\n\nimport {safeSetTimeout} from '@webex/common-timers';\nimport {oneFlight} from '@webex/common';\nimport {WebexPlugin} from '@webex/webex-core';\nimport {Context, Request, Response} from 'node-kms';\nimport jose from 'node-jose';\nimport {omit} from 'lodash';\n\nimport KMSBatcher, {TIMEOUT_SYMBOL} from './kms-batcher';\nimport validateKMS, {KMSError} from './kms-certificate-validation';\n\nconst contexts = new WeakMap();\nconst kmsDetails = new WeakMap();\nconst partialContexts = new WeakMap();\n\nconst consoleDebug = require('debug')('kms');\n\n/**\n * @class\n */\nconst KMS = WebexPlugin.extend({\n  namespace: 'Encryption',\n\n  children: {\n    batcher: KMSBatcher\n  },\n\n  /**\n   * Binds a key to a resource\n   * @param {Object} options\n   * @param {KMSResourceObject} options.kro\n   * @param {string} options.kroUri\n   * @param {Key} options.key\n   * @param {string} options.keyUri\n   * @returns {Promise<Key>}\n   */\n  bindKey({\n    kro, kroUri, key, keyUri\n  }) {\n    kroUri = kroUri || kro.uri;\n    keyUri = keyUri || key.uri;\n\n    this.logger.info('kms: binding key to resource');\n\n    /* istanbul ignore if */\n    if (!kroUri) {\n      return Promise.reject(new Error('`kro` or `kroUri` is required'));\n    }\n\n    /* istanbul ignore if */\n    if (!keyUri) {\n      return Promise.reject(new Error('`key` or `keyUri` is required'));\n    }\n\n    return this.request({\n      method: 'update',\n      resourceUri: kroUri,\n      uri: keyUri\n    })\n      .then((res) => {\n        this.logger.info('kms: bound key to resource');\n\n        return res.key;\n      });\n  },\n\n  /**\n   * Creates a new KMS Resource\n   * @param {Object} options\n   * @param {Array<string>} options.userIds\n   * @param {Array<string>} options.keyUris\n   * @param {Key} options.key\n   * @param {Array<Keys>} options.keys\n   * @returns {Promise<KMSResourceObject>}\n   */\n  createResource({\n    userIds, keyUris, key, keys\n  }) {\n    keyUris = keyUris || [];\n    /* istanbul ignore if */\n    if (keys) {\n      keyUris = keys.reduce((uris, k) => {\n        uris.push(k.uri);\n\n        return uris;\n      }, keyUris);\n    }\n\n    /* istanbul ignore else */\n    if (key) {\n      keyUris.push(key.uri);\n    }\n\n    /* istanbul ignore if */\n    if (keyUris.length === 0) {\n      return Promise.reject(new Error('Cannot create KMS Resource without at least one keyUri'));\n    }\n\n    this.logger.info('kms: creating resource');\n\n    return this.request({\n      method: 'create',\n      uri: '/resources',\n      userIds,\n      keyUris\n    })\n      .then((res) => {\n        this.logger.info('kms: created resource');\n\n        return res.resource;\n      });\n  },\n\n  /**\n   * Authorizes a user or KRO to a KRO\n   * @param {Object} options\n   * @param {Array<string>} options.userIds\n   * @param {Array<string>} options.authIds interchangable with userIds\n   * @param {KMSResourceObject} options.kro the target kro\n   * @param {string} options.kroUri\n   * @returns {Promise<KMSAuthorizationObject>}\n   */\n  addAuthorization({\n    userIds, authIds, kro, kroUri\n  }) {\n    userIds = userIds || [];\n    kroUri = kroUri || kro.uri;\n\n    if (authIds) {\n      userIds = userIds.concat(authIds);\n    }\n\n    /* istanbul ignore if */\n    if (userIds.length === 0) {\n      return Promise.reject(new Error('Cannot add authorization without userIds or authIds'));\n    }\n\n    /* istanbul ignore if */\n    if (!kroUri) {\n      return Promise.reject(new Error('`kro` or `kroUri` is required'));\n    }\n\n    this.logger.info('kms: adding authorization to kms resource');\n\n    return this.request({\n      method: 'create',\n      uri: '/authorizations',\n      resourceUri: kroUri,\n      userIds\n    })\n      .then((res) => {\n        this.logger.info('kms: added authorization');\n\n        return res.authorizations;\n      });\n  },\n\n  /**\n   * Retrieve a list of users that have been authorized to the KRO\n   * @param {Object} options\n   * @param {KMSResourceObject} options.kro the target kro\n   * @param {string} options.kroUri\n   * @returns {Array<authId>}\n   */\n  listAuthorizations({kro, kroUri}) {\n    kroUri = kroUri || kro.uri;\n    /* istanbul ignore if */\n    if (!kroUri) {\n      return Promise.reject(new Error('`kro` or `kroUri` is required'));\n    }\n\n    return this.request({\n      method: 'retrieve',\n      uri: `${kroUri}/authorizations`\n    })\n      .then((res) => {\n        this.logger.info('kms: retrieved authorization list');\n\n        return res.authorizations;\n      });\n  },\n\n  /**\n   * Deauthorizes a user or KRO from a KRO\n   * @param {Object} options\n   * @param {string} options.userId\n   * @param {string} options.authId interchangable with userIds\n   * @param {KMSResourceObject} options.kro the target kro\n   * @param {string} options.kroUri\n   * @returns {Promise<KMSAuthorizationObject>}\n   */\n  removeAuthorization({\n    authId, userId, kro, kroUri\n  }) {\n    authId = authId || userId;\n    kroUri = kroUri || kro.uri;\n\n    /* istanbul ignore if */\n    if (!authId) {\n      return Promise.reject(new Error('Cannot remove authorization without authId'));\n    }\n\n    /* istanbul ignore if */\n    if (!kroUri) {\n      return Promise.reject(new Error('`kro` or `kroUri` is required'));\n    }\n\n    this.logger.info('kms: removing authorization from kms resource');\n\n    return this.request({\n      method: 'delete',\n      uri: `${kroUri}/authorizations?${querystring.stringify({authId})}`\n    })\n      .then((res) => {\n        this.logger.info('kms: removed authorization');\n\n        return res.authorizations;\n      });\n  },\n\n  /**\n   * Requests `count` unbound keys from the kms\n   * @param {Object} options\n   * @param {Number} options.count\n   * @returns {Array<Key>}\n   */\n  createUnboundKeys({count}) {\n    this.logger.info(`kms: request ${count} unbound keys`);\n\n    /* istanbul ignore if */\n    if (!count) {\n      return Promise.reject(new Error('`options.count` is required'));\n    }\n\n    return this.request({\n      method: 'create',\n      uri: '/keys',\n      count\n    })\n      .then((res) => {\n        this.logger.info('kms: received unbound keys');\n\n        return Promise.all(res.keys.map(this.asKey));\n      });\n  },\n\n  /**\n   * Fetches the specified key from the kms\n   * @param {Object} options\n   * @param {string} options.uri\n   * @param {string} options.onBehalfOf The id of a user, upon whose behalf, the key is to be retrieved or undefined if retrieval is for the active user\n   * @returns {Promise<Key>}\n   */\n  // Ideally, this would be done via the kms batcher, but other than request id,\n  // there isn't any other userful key in a kms response to match it to a\n  // request. as such, we need the batcher to group requests, but one flight to\n  // make sure we don't make the same request multiple times.\n  @oneFlight({\n    keyFactory: ({uri, onBehalfOf}) => `${uri}/${onBehalfOf}`\n  })\n  fetchKey({uri, onBehalfOf}) {\n    /* istanbul ignore if */\n    if (!uri) {\n      return Promise.reject(new Error('`options.uri` is required'));\n    }\n\n    this.logger.info('kms: fetching key');\n\n    return this.request({\n      method: 'retrieve',\n      uri\n    }, {onBehalfOf})\n      .then((res) => {\n        this.logger.info('kms: fetched key');\n\n        return this.asKey(res.key);\n      });\n  },\n\n  /**\n   * Pings the kms. Mostly for testing\n   * @returns {Promise}\n   */\n  ping() {\n    return this.request({\n      method: 'update',\n      uri: '/ping'\n    });\n  },\n\n  /**\n   * Ensures a key obect is Key instance\n   * @param {Object} key\n   * @returns {Promise<Key>}\n   */\n  asKey(key) {\n    return jose.JWK.asKey(key.jwk)\n      .then((jwk) => {\n        key.jwk = jwk;\n\n        return key;\n      });\n  },\n\n  /**\n   * Adds appropriate metadata to the KMS request\n   * @param {Object} payload\n   * @param {Object} onBehalfOf Optional parameter to prepare the request on behalf of another user\n   * @returns {Promise<KMS.Request>}\n   */\n  prepareRequest(payload, onBehalfOf) {\n    const isECDHRequest = payload.method === 'create' && payload.uri.includes('/ecdhe');\n\n    return Promise.resolve(isECDHRequest ? partialContexts.get(this) : this._getContext())\n      .then((context) => {\n        this.logger.info(`kms: wrapping ${isECDHRequest ? 'ephemeral key' : 'kms'} request`);\n        const req = new Request(payload);\n        let requestContext = context;\n\n        if (onBehalfOf) {\n          requestContext = this._contextOnBehalfOf(context, onBehalfOf);\n        }\n\n        return req.wrap(requestContext, {serverKey: isECDHRequest})\n          .then(() => {\n            /* istanbul ignore else */\n            if (process.env.NODE_ENV !== 'production') {\n              this.logger.info('kms: request payload', util.inspect(omit(JSON.parse(JSON.stringify(req)), 'wrapped'), {depth: null}));\n            }\n\n            return req;\n          });\n      });\n  },\n\n  /**\n   * Accepts a kms message event, decrypts it, and passes it to the batcher\n   * @param {Object} event\n   * @returns {Promise<Object>}\n   */\n  processKmsMessageEvent(event) {\n    this.logger.info('kms: received kms message');\n\n    return Promise.all(event.encryption.kmsMessages.map((kmsMessage, index) => this._isECDHEMessage(kmsMessage)\n      .then((isECDHMessage) => {\n        this.logger.info(`kms: received ${isECDHMessage ? 'ecdhe' : 'normal'} message`);\n        const res = new Response(kmsMessage);\n\n        return Promise.resolve(isECDHMessage ? partialContexts.get(this) : contexts.get(this))\n          // eslint-disable-next-line max-nested-callbacks\n          .then((context) => res.unwrap(context))\n          // eslint-disable-next-line max-nested-callbacks\n          .then(() => {\n            if (process.env.NODE_ENV !== 'production') {\n              this.logger.info('kms: response payload', util.inspect(omit(JSON.parse(JSON.stringify(res)), 'wrapped'), {depth: null}));\n            }\n          })\n          // eslint-disable-next-line max-nested-callbacks\n          .then(() => { event.encryption.kmsMessages[index] = res; })\n          // eslint-disable-next-line max-nested-callbacks\n          .then(() => res);\n      })))\n      .then(() => this.batcher.processKmsMessageEvent(event))\n      .catch((reason) => {\n        this.logger.error('kms: decrypt failed', reason.stack);\n\n        return Promise.reject(reason);\n      })\n      .then(() => event);\n  },\n\n  /**\n   * Decrypts a kms message\n   * @param {Object} kmsMessage\n   * @returns {Promise<Object>}\n   */\n  decryptKmsMessage(kmsMessage) {\n    const res = new Response(kmsMessage);\n\n    return contexts.get(this)\n      .then((context) => res.unwrap(context))\n      .then(() => res.body);\n  },\n\n  /**\n   * Determines if the kms message is an ecdhe message or a normal message\n   * @param {Object} kmsMessage\n   * @returns {Promise<boolean>}\n   */\n  _isECDHEMessage(kmsMessage) {\n    return this._getKMSStaticPubKey()\n      .then((kmsStaticPubKey) => {\n        const fields = kmsMessage.split('.');\n\n        if (fields.length !== 3) {\n          return false;\n        }\n\n        const header = JSON.parse(jose.util.base64url.decode(fields[0]));\n\n        return header.kid === kmsStaticPubKey.kid;\n      });\n  },\n\n  /**\n   * Sends a request to the kms\n   * @param {Object} payload\n   * @param {Object} options\n   * @param {Number} options.timeout (internal)\n   * @param {string} options.onBehalfOf Run the request on behalf of another user (UUID), used in compliance scenarios\n   * @returns {Promise<Object>}\n   */\n  request(payload, {timeout, onBehalfOf} = {}) {\n    timeout = timeout || this.config.kmsInitialTimeout;\n\n    // Note: this should only happen when we're using the async kms batcher;\n    // once we implement the sync batcher, this'll need to be smarter.\n    return this.webex.internal.mercury.connect()\n      .then(() => this.prepareRequest(payload, onBehalfOf))\n      .then((req) => {\n        req[TIMEOUT_SYMBOL] = timeout;\n\n        return this.batcher.request(req);\n      })\n      // High complexity is due to attempt at test mode resiliency\n      // eslint-disable-next-line complexity\n      .catch((reason) => {\n        if (process.env.NODE_ENV === 'test' && (reason.status === 403 || reason.statusCode === 403) && reason.message.match(/Failed to resolve authorization token in KmsMessage request for user/)) {\n          this.logger.warn('kms: rerequested key due to test-mode kms auth failure');\n\n          return this.request(payload, {onBehalfOf});\n        }\n\n        // KMS Error. Notify the user\n        if (reason instanceof KMSError) {\n          this.webex.trigger('client:InvalidRequestError');\n\n          return Promise.reject(reason);\n        }\n\n        // Ideally, most or all of the code below would go in kms-batcher, but\n        // but batching needs at least one more round of refactoring for that to\n        // work.\n        if (!reason.statusCode && !reason.status) {\n          /* istanbul ignore else */\n          if (process.env.NODE_ENV !== 'production') {\n            /* istanbul ignore next: reason.stack vs stack difficult to control in test */\n            this.logger.info('kms: request error', reason.stack || reason);\n          }\n\n          consoleDebug(`timeout ${timeout}`);\n          timeout *= 2;\n\n          if (timeout >= this.config.ecdhMaxTimeout) {\n            this.logger.info('kms: exceeded maximum KMS request retries');\n\n            return Promise.reject(reason);\n          }\n\n          // Peek ahead to make sure we don't reset the timeout if the next timeout\n          // will exceed the maximum timeout for renegotiating ECDH keys.\n          const nextTimeout = timeout * 2;\n\n          if (timeout >= this.config.kmsMaxTimeout && nextTimeout < this.config.ecdhMaxTimeout) {\n            this.logger.info('kms: exceeded maximum KMS request retries; negotiating new ecdh key');\n\n            /* istanbul ignore else */\n            if (process.env.NODE_ENV !== 'production') {\n              this.logger.info('kms: timeout/maxtimeout', timeout, this.config.kmsMaxTimeout);\n            }\n\n            contexts.delete(this);\n            timeout = 0;\n          }\n\n          return this.request(payload, {timeout, onBehalfOf});\n        }\n\n        return Promise.reject(reason);\n      });\n  },\n\n  /**\n   * @private\n   * @returns {Promise<string>}\n   */\n  _getAuthorization() {\n    return this.webex.credentials.getUserToken('spark:kms')\n      .then((token) => token.access_token);\n  },\n\n  @oneFlight\n  /**\n   * @private\n   * @param {String} onBehalfOf create context on behalf of another user, undefined when this is not necessary\n   * @returns {Promise<Object>}\n   */\n  _getContext() {\n    let promise = contexts.get(this);\n\n    if (!promise) {\n      promise = this._prepareContext();\n      contexts.set(this, promise);\n      promise.then((context) => {\n        const expiresIn = context.ephemeralKey.expirationDate - Date.now() - 30000;\n\n        safeSetTimeout(() => contexts.delete(this), expiresIn);\n      });\n    }\n\n    return Promise.all([\n      promise,\n      this._getAuthorization()\n    ])\n      .then(([context, authorization]) => {\n        context.clientInfo.credential.bearer = authorization;\n\n        return context;\n      });\n  },\n\n  /**\n   * @private\n   * @returns {Promise<Object>}\n   */\n  _getKMSCluster() {\n    this.logger.info('kms: retrieving KMS cluster');\n\n    return this._getKMSDetails()\n      .then(({kmsCluster}) => kmsCluster);\n  },\n\n  /**\n   * @private\n   * @returns {Promise<Object>}\n   */\n  _getKMSDetails() {\n    let details = kmsDetails.get(this);\n\n    if (!details) {\n      this.logger.info('kms: fetching KMS details');\n      details = this.webex.request({\n        service: 'encryption',\n        resource: `/kms/${this.webex.internal.device.userId}`\n      })\n        .then((res) => {\n          this.logger.info('kms: fetched KMS details');\n          const {body} = res;\n\n          body.rsaPublicKey = JSON.parse(body.rsaPublicKey);\n\n          return body;\n        })\n        .catch((reason) => {\n          this.logger.error('kms: failed to fetch KMS details', reason);\n\n          return Promise.reject(reason);\n        });\n\n      kmsDetails.set(this, details);\n    }\n\n    return details;\n  },\n\n  /**\n   * @private\n   * @returns {Promise<Object>}\n   */\n  _getKMSStaticPubKey() {\n    this.logger.info('kms: retrieving KMS static public key');\n\n    return this._getKMSDetails()\n      .then(({rsaPublicKey}) => rsaPublicKey);\n  },\n\n  /**\n   * @private\n   * @returns {Promise<Object>}\n   */\n  _prepareContext() {\n    this.logger.info('kms: creating context');\n    const context = new Context();\n\n    return Promise.all([\n      this._getKMSStaticPubKey().then(validateKMS(this.config.caroots)),\n      this._getAuthorization()\n    ])\n      .then(([kmsStaticPubKey, authorization]) => {\n        context.clientInfo = {\n          clientId: this.webex.internal.device.url,\n          credential: {\n            userId: this.webex.internal.device.userId,\n            bearer: authorization\n          }\n        };\n\n        context.serverInfo = {\n          key: kmsStaticPubKey\n        };\n\n        this.logger.info('kms: creating local ephemeral key');\n\n        return context.createECDHKey();\n      })\n      .then((localECDHKey) => {\n        context.ephemeralKey = localECDHKey;\n        partialContexts.set(this, context);\n\n        return Promise.all([localECDHKey.asKey(), this._getKMSCluster()]);\n      })\n      .then(([localECDHKey, cluster]) => {\n        this.logger.info('kms: submitting ephemeral key request');\n\n        return this.request({\n          uri: `${cluster}/ecdhe`,\n          method: 'create',\n          jwk: localECDHKey.toJSON()\n        });\n      })\n      .then((res) => {\n        this.logger.info('kms: deriving final ephemeral key');\n\n        return context.deriveEphemeralKey(res.key);\n      })\n      .then((key) => {\n        context.ephemeralKey = key;\n        partialContexts.delete(this);\n        this.logger.info('kms: derived final ephemeral key');\n\n        return context;\n      })\n      .catch((reason) => {\n        this.logger.error('kms: failed to negotiate ephemeral key', reason);\n\n        return Promise.reject(reason);\n      });\n  },\n\n  /**\n   * KMS 'retrieve' requests can be made on behalf of another user. This is useful\n   * for scenarios such as eDiscovery. i.e. Where an authorized compliance officer is\n   * entitled to retrieve content generated by any organisational user.\n   * As the KMSContext is cached, updating it will affect separate requests. Hence when\n   * making a request onBehalfOf another user create a new context for just this request.\n   * However this context will be 'light' as it only needs to change one field.\n   * @param {Object} originalContext - The base context to 'copy'\n   * @param {String} onBehalfOf - The user specified in the new context\n   * @returns {Context} A 'copy' of the existing context with a new user specified\n   * @private\n   */\n  _contextOnBehalfOf(originalContext, onBehalfOf) {\n    const context = new Context();\n\n    context.clientInfo = context.clientInfo = {\n      clientId: originalContext.clientInfo.clientId,\n      credential: {\n        userId: onBehalfOf,\n        onBehalfOf, // Supports running onBehalfOf self. i.e. A CO which calls onBehalfOf with CO.id.\n        bearer: originalContext.clientInfo.credential.bearer\n      }\n    };\n    context.serverInfo = originalContext.serverInfo;\n    context.ephemeralKey = originalContext.ephemeralKey;\n\n    return context;\n  }\n});\n\nexport default KMS;\n"]},"metadata":{},"sourceType":"script"}