{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime-corejs2/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/asyncToGenerator\"));\n\nvar _defaults2 = _interopRequireDefault(require(\"lodash/defaults\"));\n\nvar _webexCore = require(\"@webex/webex-core\");\n\nvar _uuid = _interopRequireDefault(require(\"uuid\"));\n/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar Support = _webexCore.WebexPlugin.extend({\n  namespace: 'Support',\n  getFeedbackUrl: function getFeedbackUrl(options) {\n    options = options || {};\n    return this.request({\n      method: 'POST',\n      api: 'conversation',\n      resource: 'users/deskFeedbackUrl',\n      body: (0, _defaults2.default)(options, {\n        appVersion: this.config.appVersion,\n        appType: this.config.appType,\n        feedbackId: options.feedbackId || _uuid.default.v4(),\n        languageCode: this.config.languageCode\n      })\n    }).then(function (res) {\n      return res.body.url;\n    });\n  },\n  getSupportUrl: function getSupportUrl() {\n    return this.webex.request({\n      method: 'GET',\n      api: 'conversation',\n      resource: 'users/deskSupportUrl',\n      qs: {\n        languageCode: this.config.languageCode\n      }\n    }).then(function (res) {\n      return res.body.url;\n    });\n  },\n  submitLogs: function submitLogs(metadata, logs) {\n    var _this = this;\n\n    var metadataArray = this._constructFileMetadata(metadata); // this is really testing that Ampersand is fully ready.  once it's ready, these exist\n\n\n    if (!logs && this.webex.logger.sdkBuffer && this.webex.logger.clientBuffer && this.webex.logger.buffer) {\n      logs = this.webex.logger.formatLogs();\n    }\n\n    var filename;\n\n    if (metadata.locusId && metadata.callStart) {\n      filename = \"\".concat(metadata.locusId, \"_\").concat(metadata.callStart, \".txt\");\n    } else {\n      filename = \"\".concat(this.webex.sessionId, \".txt\");\n    }\n\n    var userId;\n    return this.webex.credentials.getUserToken().catch(function () {\n      return _this.webex.credentials.getClientToken();\n    }).then( /*#__PURE__*/function () {\n      var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(token) {\n        var headers, initalOpts, finalOpts, options;\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                headers = {\n                  authorization: token.toString()\n                };\n                initalOpts = {\n                  service: 'clientLogs',\n                  resource: 'logs/urls'\n                };\n                finalOpts = {\n                  service: 'clientLogs',\n                  resource: 'logs/meta'\n                };\n                options = (0, _defaults2.default)(initalOpts, {\n                  file: logs,\n                  shouldAttemptReauth: false,\n                  headers: headers,\n                  phases: {\n                    initialize: {\n                      body: {\n                        file: filename\n                      }\n                    },\n                    upload: {\n                      $uri: function $uri(session) {\n                        return session.tempURL;\n                      }\n                    },\n                    finalize: (0, _defaults2.default)(finalOpts, {\n                      $body: function $body(session) {\n                        userId = session.userId;\n                        return {\n                          filename: session.logFilename,\n                          data: metadataArray,\n                          userId: _this.webex.internal.device.userId || session.userId\n                        };\n                      }\n                    })\n                  }\n                });\n                return _context.abrupt(\"return\", _this.webex.upload(options));\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }()).then(function (body) {\n      if (userId && !body.userId) {\n        body.userId = userId;\n      }\n\n      return body;\n    });\n  },\n  _constructFileMetadata: function _constructFileMetadata(metadata) {\n    var metadataArray = ['locusId', 'callStart', 'feedbackId', 'correlationId', 'meetingId'].map(function (key) {\n      if (metadata[key]) {\n        return {\n          key: key,\n          value: metadata[key]\n        };\n      }\n\n      return null;\n    }).filter(function (entry) {\n      return Boolean(entry);\n    });\n\n    if (this.webex.sessionId) {\n      metadataArray.push({\n        key: 'trackingId',\n        value: this.webex.sessionId\n      });\n    }\n\n    if (this.webex.internal.device.userId) {\n      metadataArray.push({\n        key: 'userId',\n        value: this.webex.internal.device.userId\n      });\n    }\n\n    if (this.webex.internal.device.orgId) {\n      metadataArray.push({\n        key: 'orgId',\n        value: this.webex.internal.device.orgId\n      });\n    }\n\n    return metadataArray;\n  },\n  version: \"1.154.2\"\n});\n\nvar _default = Support;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["Support","WebexPlugin","extend","namespace","getFeedbackUrl","options","request","method","api","resource","body","appVersion","config","appType","feedbackId","uuid","v4","languageCode","then","res","url","getSupportUrl","webex","qs","submitLogs","metadata","logs","metadataArray","_constructFileMetadata","logger","sdkBuffer","clientBuffer","buffer","formatLogs","filename","locusId","callStart","sessionId","userId","credentials","getUserToken","catch","_this","getClientToken","token","headers","authorization","toString","initalOpts","service","finalOpts","file","shouldAttemptReauth","phases","initialize","upload","$uri","session","tempURL","finalize","$body","logFilename","data","internal","device","map","key","value","filter","entry","Boolean","push","orgId","version"],"sources":["support.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {WebexPlugin} from '@webex/webex-core';\nimport {defaults} from 'lodash';\nimport uuid from 'uuid';\n\nconst Support = WebexPlugin.extend({\n  namespace: 'Support',\n\n  getFeedbackUrl(options) {\n    options = options || {};\n\n    return this.request({\n      method: 'POST',\n      api: 'conversation',\n      resource: 'users/deskFeedbackUrl',\n      body: defaults(options, {\n        appVersion: this.config.appVersion,\n        appType: this.config.appType,\n        feedbackId: options.feedbackId || uuid.v4(),\n        languageCode: this.config.languageCode\n      })\n    })\n      .then((res) => res.body.url);\n  },\n\n  getSupportUrl() {\n    return this.webex.request({\n      method: 'GET',\n      api: 'conversation',\n      resource: 'users/deskSupportUrl',\n      qs: {\n        languageCode: this.config.languageCode\n      }\n    })\n      .then((res) => res.body.url);\n  },\n\n  submitLogs(metadata, logs) {\n    const metadataArray = this._constructFileMetadata(metadata);\n\n    // this is really testing that Ampersand is fully ready.  once it's ready, these exist\n    if (!logs && this.webex.logger.sdkBuffer && this.webex.logger.clientBuffer && this.webex.logger.buffer) {\n      logs = this.webex.logger.formatLogs();\n    }\n\n    let filename;\n\n    if (metadata.locusId && metadata.callStart) {\n      filename = `${metadata.locusId}_${metadata.callStart}.txt`;\n    }\n    else {\n      filename = `${this.webex.sessionId}.txt`;\n    }\n\n    let userId;\n\n    return this.webex.credentials.getUserToken()\n      .catch(() => this.webex.credentials.getClientToken())\n      .then(async (token) => {\n        const headers = {authorization: token.toString()};\n\n        const initalOpts = {\n          service: 'clientLogs',\n          resource: 'logs/urls'\n        };\n\n        const finalOpts = {\n          service: 'clientLogs',\n          resource: 'logs/meta'\n        };\n\n        const options = defaults(initalOpts, {\n          file: logs,\n          shouldAttemptReauth: false,\n          headers,\n          phases: {\n            initialize: {\n              body: {\n                file: filename\n              }\n            },\n            upload: {\n              $uri: (session) => session.tempURL\n            },\n            finalize: defaults(finalOpts, {\n              $body: (session) => {\n                userId = session.userId;\n\n                return {\n                  filename: session.logFilename,\n                  data: metadataArray,\n                  userId: this.webex.internal.device.userId || session.userId\n                };\n              }\n            })\n          }\n        });\n\n        return this.webex.upload(options);\n      })\n      .then((body) => {\n        if (userId && !body.userId) {\n          body.userId = userId;\n        }\n\n        return body;\n      });\n  },\n\n  _constructFileMetadata(metadata) {\n    const metadataArray = [\n      'locusId',\n      'callStart',\n      'feedbackId',\n      'correlationId',\n      'meetingId'\n    ].map((key) => {\n      if (metadata[key]) {\n        return {\n          key,\n          value: metadata[key]\n        };\n      }\n\n      return null;\n    })\n      .filter((entry) => Boolean(entry));\n\n    if (this.webex.sessionId) {\n      metadataArray.push({\n        key: 'trackingId',\n        value: this.webex.sessionId\n      });\n    }\n\n    if (this.webex.internal.device.userId) {\n      metadataArray.push({\n        key: 'userId',\n        value: this.webex.internal.device.userId\n      });\n    }\n\n    if (this.webex.internal.device.orgId) {\n      metadataArray.push({\n        key: 'orgId',\n        value: this.webex.internal.device.orgId\n      });\n    }\n\n    return metadataArray;\n  }\n});\n\nexport default Support;\n"]},"metadata":{},"sourceType":"script"}