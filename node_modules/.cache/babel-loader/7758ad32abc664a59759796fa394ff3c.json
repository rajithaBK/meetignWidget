{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/rkanthet/Documents/test_window_object/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"C:/Users/rkanthet/Documents/test_window_object/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/rkanthet/Documents/test_window_object/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/rkanthet/Documents/test_window_object/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _regeneratorRuntime from \"C:\\\\Users\\\\rkanthet\\\\Documents\\\\test_window_object\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\nimport * as asn1js from \"asn1js\";\nimport { getParametersValue, utilConcatBuf, clearProps } from \"pvutils\";\nimport { getOIDByAlgorithm, getRandomValues, getCrypto, getAlgorithmByOID, kdf } from \"./common.js\";\nimport OriginatorInfo from \"./OriginatorInfo.js\";\nimport RecipientInfo from \"./RecipientInfo.js\";\nimport EncryptedContentInfo from \"./EncryptedContentInfo.js\";\nimport Attribute from \"./Attribute.js\";\nimport AlgorithmIdentifier from \"./AlgorithmIdentifier.js\";\nimport RSAESOAEPParams from \"./RSAESOAEPParams.js\";\nimport KeyTransRecipientInfo from \"./KeyTransRecipientInfo.js\";\nimport IssuerAndSerialNumber from \"./IssuerAndSerialNumber.js\";\nimport RecipientKeyIdentifier from \"./RecipientKeyIdentifier.js\";\nimport RecipientEncryptedKey from \"./RecipientEncryptedKey.js\";\nimport KeyAgreeRecipientIdentifier from \"./KeyAgreeRecipientIdentifier.js\";\nimport KeyAgreeRecipientInfo from \"./KeyAgreeRecipientInfo.js\";\nimport RecipientEncryptedKeys from \"./RecipientEncryptedKeys.js\";\nimport KEKRecipientInfo from \"./KEKRecipientInfo.js\";\nimport KEKIdentifier from \"./KEKIdentifier.js\";\nimport PBKDF2Params from \"./PBKDF2Params.js\";\nimport PasswordRecipientinfo from \"./PasswordRecipientinfo.js\";\nimport ECCCMSSharedInfo from \"./ECCCMSSharedInfo.js\";\nimport OriginatorIdentifierOrKey from \"./OriginatorIdentifierOrKey.js\";\nimport OriginatorPublicKey from \"./OriginatorPublicKey.js\"; //**************************************************************************************\n\nvar defaultEncryptionParams = {\n  kdfAlgorithm: \"SHA-512\",\n  kekEncryptionLength: 256\n};\nvar curveLengthByName = {\n  \"P-256\": 256,\n  \"P-384\": 384,\n  \"P-521\": 528\n}; //**************************************************************************************\n\n/**\r\n * Class from RFC5652\r\n */\n\nvar EnvelopedData = /*#__PURE__*/function () {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for EnvelopedData class\r\n   * @param {Object} [parameters={}]\r\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n   */\n  function EnvelopedData() {\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, EnvelopedData);\n\n    //region Internal properties of the object\n\n    /**\r\n     * @type {number}\r\n     * @desc version\r\n     */\n    this.version = getParametersValue(parameters, \"version\", EnvelopedData.defaultValues(\"version\"));\n    if (\"originatorInfo\" in parameters)\n      /**\r\n       * @type {OriginatorInfo}\r\n       * @desc originatorInfo\r\n       */\n      this.originatorInfo = getParametersValue(parameters, \"originatorInfo\", EnvelopedData.defaultValues(\"originatorInfo\"));\n    /**\r\n     * @type {Array.<RecipientInfo>}\r\n     * @desc recipientInfos\r\n     */\n\n    this.recipientInfos = getParametersValue(parameters, \"recipientInfos\", EnvelopedData.defaultValues(\"recipientInfos\"));\n    /**\r\n     * @type {EncryptedContentInfo}\r\n     * @desc encryptedContentInfo\r\n     */\n\n    this.encryptedContentInfo = getParametersValue(parameters, \"encryptedContentInfo\", EnvelopedData.defaultValues(\"encryptedContentInfo\"));\n    if (\"unprotectedAttrs\" in parameters)\n      /**\r\n       * @type {Array.<Attribute>}\r\n       * @desc unprotectedAttrs\r\n       */\n      this.unprotectedAttrs = getParametersValue(parameters, \"unprotectedAttrs\", EnvelopedData.defaultValues(\"unprotectedAttrs\")); //endregion\n    //region If input argument array contains \"schema\" for this object\n\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Return default values for all class members\r\n   * @param {string} memberName String name for a class member\r\n   */\n\n\n  _createClass(EnvelopedData, [{\n    key: \"fromSchema\",\n    value: //**********************************************************************************\n\n    /**\r\n     * Convert parsed asn1js object into current class\r\n     * @param {!Object} schema\r\n     */\n    function fromSchema(schema) {\n      //region Clear input data first\n      clearProps(schema, [\"version\", \"originatorInfo\", \"recipientInfos\", \"encryptedContentInfo\", \"unprotectedAttrs\"]); //endregion\n      //region Check the schema is valid\n\n      var asn1 = asn1js.compareSchema(schema, schema, EnvelopedData.schema({\n        names: {\n          version: \"version\",\n          originatorInfo: \"originatorInfo\",\n          recipientInfos: \"recipientInfos\",\n          encryptedContentInfo: {\n            names: {\n              blockName: \"encryptedContentInfo\"\n            }\n          },\n          unprotectedAttrs: \"unprotectedAttrs\"\n        }\n      }));\n      if (asn1.verified === false) throw new Error(\"Object's schema was not verified against input data for EnvelopedData\"); //endregion\n      //region Get internal properties from parsed schema\n\n      this.version = asn1.result.version.valueBlock.valueDec;\n\n      if (\"originatorInfo\" in asn1.result) {\n        this.originatorInfo = new OriginatorInfo({\n          schema: new asn1js.Sequence({\n            value: asn1.result.originatorInfo.valueBlock.value\n          })\n        });\n      }\n\n      this.recipientInfos = Array.from(asn1.result.recipientInfos, function (element) {\n        return new RecipientInfo({\n          schema: element\n        });\n      });\n      this.encryptedContentInfo = new EncryptedContentInfo({\n        schema: asn1.result.encryptedContentInfo\n      });\n      if (\"unprotectedAttrs\" in asn1.result) this.unprotectedAttrs = Array.from(asn1.result.unprotectedAttrs, function (element) {\n        return new Attribute({\n          schema: element\n        });\n      }); //endregion\n    } //**********************************************************************************\n\n    /**\r\n     * Convert current object to asn1js object and set correct values\r\n     * @returns {Object} asn1js object\r\n     */\n\n  }, {\n    key: \"toSchema\",\n    value: function toSchema() {\n      //region Create array for output sequence\n      var outputArray = [];\n      outputArray.push(new asn1js.Integer({\n        value: this.version\n      }));\n\n      if (\"originatorInfo\" in this) {\n        outputArray.push(new asn1js.Constructed({\n          optional: true,\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: 0 // [0]\n\n          },\n          value: this.originatorInfo.toSchema().valueBlock.value\n        }));\n      }\n\n      outputArray.push(new asn1js.Set({\n        value: Array.from(this.recipientInfos, function (element) {\n          return element.toSchema();\n        })\n      }));\n      outputArray.push(this.encryptedContentInfo.toSchema());\n\n      if (\"unprotectedAttrs\" in this) {\n        outputArray.push(new asn1js.Constructed({\n          optional: true,\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: 1 // [1]\n\n          },\n          value: Array.from(this.unprotectedAttrs, function (element) {\n            return element.toSchema();\n          })\n        }));\n      } //endregion\n      //region Construct and return new ASN.1 schema for this object\n\n\n      return new asn1js.Sequence({\n        value: outputArray\n      }); //endregion\n    } //**********************************************************************************\n\n    /**\r\n     * Convertion for the class to JSON object\r\n     * @returns {Object}\r\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var _object = {\n        version: this.version\n      };\n      if (\"originatorInfo\" in this) _object.originatorInfo = this.originatorInfo.toJSON();\n      _object.recipientInfos = Array.from(this.recipientInfos, function (element) {\n        return element.toJSON();\n      });\n      _object.encryptedContentInfo = this.encryptedContentInfo.toJSON();\n      if (\"unprotectedAttrs\" in this) _object.unprotectedAttrs = Array.from(this.unprotectedAttrs, function (element) {\n        return element.toJSON();\n      });\n      return _object;\n    } //**********************************************************************************\n\n    /**\r\n     * Helpers function for filling \"RecipientInfo\" based on recipient's certificate.\r\n     * Problem with WebCrypto is that for RSA certificates we have only one option - \"key transport\" and\r\n     * for ECC certificates we also have one option - \"key agreement\". As soon as Google will implement\r\n     * DH algorithm it would be possible to use \"key agreement\" also for RSA certificates.\r\n     * @param {Certificate} [certificate] Recipient's certificate\r\n     * @param {Object} [parameters] Additional parameters neccessary for \"fine tunning\" of encryption process\r\n     * @param {number} [variant] Variant = 1 is for \"key transport\", variant = 2 is for \"key agreement\". In fact the \"variant\" is unneccessary now because Google has no DH algorithm implementation. Thus key encryption scheme would be choosen by certificate type only: \"key transport\" for RSA and \"key agreement\" for ECC certificates.\r\n     */\n\n  }, {\n    key: \"addRecipientByCertificate\",\n    value: function addRecipientByCertificate(certificate, parameters, variant) {\n      //region Initialize encryption parameters\n      var encryptionParameters = Object.assign({\n        useOAEP: true,\n        oaepHashAlgorithm: \"SHA-512\"\n      }, defaultEncryptionParams, parameters || {}); //endregion\n      //region Check type of certificate\n\n      if (certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf(\"1.2.840.113549\") !== -1) variant = 1; // For the moment it is the only variant for RSA-based certificates\n      else {\n        if (certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf(\"1.2.840.10045\") !== -1) variant = 2; // For the moment it is the only variant for ECC-based certificates\n        else throw new Error(\"Unknown type of certificate's public key: \".concat(certificate.subjectPublicKeyInfo.algorithm.algorithmId));\n      } //endregion\n      //region Add new \"recipient\" depends on \"variant\" and certificate type\n\n      switch (variant) {\n        case 1:\n          // Key transport scheme\n          {\n            var algorithmId;\n            var algorithmParams;\n\n            if (encryptionParameters.useOAEP === true) {\n              //region keyEncryptionAlgorithm\n              algorithmId = getOIDByAlgorithm({\n                name: \"RSA-OAEP\"\n              });\n              if (algorithmId === \"\") throw new Error(\"Can not find OID for RSA-OAEP\"); //endregion\n              //region RSAES-OAEP-params\n\n              var hashOID = getOIDByAlgorithm({\n                name: encryptionParameters.oaepHashAlgorithm\n              });\n              if (hashOID === \"\") throw new Error(\"Unknown OAEP hash algorithm: \".concat(encryptionParameters.oaepHashAlgorithm));\n              var hashAlgorithm = new AlgorithmIdentifier({\n                algorithmId: hashOID,\n                algorithmParams: new asn1js.Null()\n              });\n              var rsaOAEPParams = new RSAESOAEPParams({\n                hashAlgorithm: hashAlgorithm,\n                maskGenAlgorithm: new AlgorithmIdentifier({\n                  algorithmId: \"1.2.840.113549.1.1.8\",\n                  // id-mgf1\n                  algorithmParams: hashAlgorithm.toSchema()\n                })\n              });\n              algorithmParams = rsaOAEPParams.toSchema(); //endregion\n            } else // Use old RSAES-PKCS1-v1_5 schema instead\n              {\n                //region keyEncryptionAlgorithm\n                algorithmId = getOIDByAlgorithm({\n                  name: \"RSAES-PKCS1-v1_5\"\n                });\n                if (algorithmId === \"\") throw new Error(\"Can not find OID for RSAES-PKCS1-v1_5\"); //endregion\n\n                algorithmParams = new asn1js.Null();\n              } //region KeyTransRecipientInfo\n\n\n            var keyInfo = new KeyTransRecipientInfo({\n              version: 0,\n              rid: new IssuerAndSerialNumber({\n                issuer: certificate.issuer,\n                serialNumber: certificate.serialNumber\n              }),\n              keyEncryptionAlgorithm: new AlgorithmIdentifier({\n                algorithmId: algorithmId,\n                algorithmParams: algorithmParams\n              }),\n              recipientCertificate: certificate // \"encryptedKey\" will be calculated in \"encrypt\" function\n\n            }); //endregion\n            //region Final values for \"CMS_ENVELOPED_DATA\"\n\n            this.recipientInfos.push(new RecipientInfo({\n              variant: 1,\n              value: keyInfo\n            })); //endregion\n          }\n          break;\n\n        case 2:\n          // Key agreement scheme\n          {\n            var recipientIdentifier = new KeyAgreeRecipientIdentifier({\n              variant: 1,\n              value: new IssuerAndSerialNumber({\n                issuer: certificate.issuer,\n                serialNumber: certificate.serialNumber\n              })\n            });\n\n            this._addKeyAgreeRecipientInfo(recipientIdentifier, encryptionParameters, {\n              recipientCertificate: certificate\n            });\n          }\n          break;\n\n        default:\n          throw new Error(\"Unknown \\\"variant\\\" value: \".concat(variant));\n      } //endregion\n\n\n      return true;\n    } //**********************************************************************************\n\n    /**\r\n     * Add recipient based on pre-defined data like password or KEK\r\n     * @param {ArrayBuffer} preDefinedData ArrayBuffer with pre-defined data\r\n     * @param {Object} parameters Additional parameters neccessary for \"fine tunning\" of encryption process\r\n     * @param {number} variant Variant = 1 for pre-defined \"key encryption key\" (KEK). Variant = 2 for password-based encryption.\r\n     */\n\n  }, {\n    key: \"addRecipientByPreDefinedData\",\n    value: function addRecipientByPreDefinedData(preDefinedData, parameters, variant) {\n      //region Initial variables\n      var encryptionParameters = parameters || {}; //endregion\n      //region Check initial parameters\n\n      if (preDefinedData instanceof ArrayBuffer === false) throw new Error(\"Please pass \\\"preDefinedData\\\" in ArrayBuffer type\");\n      if (preDefinedData.byteLength === 0) throw new Error(\"Pre-defined data could have zero length\"); //endregion\n      //region Initialize encryption parameters\n\n      if (\"keyIdentifier\" in encryptionParameters === false) {\n        var keyIdentifierBuffer = new ArrayBuffer(16);\n        var keyIdentifierView = new Uint8Array(keyIdentifierBuffer);\n        getRandomValues(keyIdentifierView);\n        encryptionParameters.keyIdentifier = keyIdentifierBuffer;\n      }\n\n      if (\"hmacHashAlgorithm\" in encryptionParameters === false) encryptionParameters.hmacHashAlgorithm = \"SHA-512\";\n      if (\"iterationCount\" in encryptionParameters === false) encryptionParameters.iterationCount = 2048;\n\n      if (\"keyEncryptionAlgorithm\" in encryptionParameters === false) {\n        encryptionParameters.keyEncryptionAlgorithm = {\n          name: \"AES-KW\",\n          length: 256\n        };\n      }\n\n      if (\"keyEncryptionAlgorithmParams\" in encryptionParameters === false) encryptionParameters.keyEncryptionAlgorithmParams = new asn1js.Null(); //endregion\n      //region Add new recipient based on passed variant\n\n      switch (variant) {\n        case 1:\n          // KEKRecipientInfo\n          {\n            //region keyEncryptionAlgorithm\n            var kekOID = getOIDByAlgorithm(encryptionParameters.keyEncryptionAlgorithm);\n            if (kekOID === \"\") throw new Error(\"Incorrect value for \\\"keyEncryptionAlgorithm\\\"\"); //endregion\n            //region KEKRecipientInfo\n\n            var keyInfo = new KEKRecipientInfo({\n              version: 4,\n              kekid: new KEKIdentifier({\n                keyIdentifier: new asn1js.OctetString({\n                  valueHex: encryptionParameters.keyIdentifier\n                })\n              }),\n              keyEncryptionAlgorithm: new AlgorithmIdentifier({\n                algorithmId: kekOID,\n\n                /*\r\n                 For AES-KW params are NULL, but for other algorithm could another situation.\r\n                 */\n                algorithmParams: encryptionParameters.keyEncryptionAlgorithmParams\n              }),\n              preDefinedKEK: preDefinedData // \"encryptedKey\" would be set in \"ecrypt\" function\n\n            }); //endregion\n            //region Final values for \"CMS_ENVELOPED_DATA\"\n\n            this.recipientInfos.push(new RecipientInfo({\n              variant: 3,\n              value: keyInfo\n            })); //endregion\n          }\n          break;\n\n        case 2:\n          // PasswordRecipientinfo\n          {\n            //region keyDerivationAlgorithm\n            var pbkdf2OID = getOIDByAlgorithm({\n              name: \"PBKDF2\"\n            });\n            if (pbkdf2OID === \"\") throw new Error(\"Can not find OID for PBKDF2\"); //endregion\n            //region Salt\n\n            var saltBuffer = new ArrayBuffer(64);\n            var saltView = new Uint8Array(saltBuffer);\n            getRandomValues(saltView); //endregion\n            //region HMAC-based algorithm\n\n            var hmacOID = getOIDByAlgorithm({\n              name: \"HMAC\",\n              hash: {\n                name: encryptionParameters.hmacHashAlgorithm\n              }\n            });\n            if (hmacOID === \"\") throw new Error(\"Incorrect value for \\\"hmacHashAlgorithm\\\": \".concat(encryptionParameters.hmacHashAlgorithm)); //endregion\n            //region PBKDF2-params\n\n            var pbkdf2Params = new PBKDF2Params({\n              salt: new asn1js.OctetString({\n                valueHex: saltBuffer\n              }),\n              iterationCount: encryptionParameters.iterationCount,\n              prf: new AlgorithmIdentifier({\n                algorithmId: hmacOID,\n                algorithmParams: new asn1js.Null()\n              })\n            }); //endregion\n            //region keyEncryptionAlgorithm\n\n            var _kekOID = getOIDByAlgorithm(encryptionParameters.keyEncryptionAlgorithm);\n\n            if (_kekOID === \"\") throw new Error(\"Incorrect value for \\\"keyEncryptionAlgorithm\\\"\"); //endregion\n            //region PasswordRecipientinfo\n\n            var _keyInfo = new PasswordRecipientinfo({\n              version: 0,\n              keyDerivationAlgorithm: new AlgorithmIdentifier({\n                algorithmId: pbkdf2OID,\n                algorithmParams: pbkdf2Params.toSchema()\n              }),\n              keyEncryptionAlgorithm: new AlgorithmIdentifier({\n                algorithmId: _kekOID,\n\n                /*\r\n                 For AES-KW params are NULL, but for other algorithm could be another situation.\r\n                 */\n                algorithmParams: encryptionParameters.keyEncryptionAlgorithmParams\n              }),\n              password: preDefinedData // \"encryptedKey\" would be set in \"ecrypt\" function\n\n            }); //endregion\n            //region Final values for \"CMS_ENVELOPED_DATA\"\n\n\n            this.recipientInfos.push(new RecipientInfo({\n              variant: 4,\n              value: _keyInfo\n            })); //endregion\n          }\n          break;\n\n        default:\n          throw new Error(\"Unknown value for \\\"variant\\\": \".concat(variant));\n      } //endregion\n\n    } //**********************************************************************************\n\n    /**\r\n     * Add a \"RecipientInfo\" using a KeyAgreeRecipientInfo of type RecipientKeyIdentifier.\r\n     * @param {CryptoKey} [key] Recipient's public key\r\n     * @param {ArrayBuffer} [keyId] The id for the recipient's public key\r\n     * @param {Object} [parameters] Additional parameters for \"fine tuning\" the encryption process\r\n     */\n\n  }, {\n    key: \"addRecipientByKeyIdentifier\",\n    value: function addRecipientByKeyIdentifier(key, keyId, parameters) {\n      //region Initialize encryption parameters\n      var encryptionParameters = Object.assign({}, defaultEncryptionParams, parameters || {}); //endregion\n\n      var recipientIdentifier = new KeyAgreeRecipientIdentifier({\n        variant: 2,\n        value: new RecipientKeyIdentifier({\n          subjectKeyIdentifier: new asn1js.OctetString({\n            valueHex: keyId\n          })\n        })\n      });\n\n      this._addKeyAgreeRecipientInfo(recipientIdentifier, encryptionParameters, {\n        recipientPublicKey: key\n      });\n    } //**********************************************************************************\n\n    /**\r\n     * Add a \"RecipientInfo\" using a KeyAgreeRecipientInfo of type RecipientKeyIdentifier.\r\n     * @param {KeyAgreeRecipientIdentifier} [recipientIdentifier] Recipient identifier\r\n     * @param {Object} [encryptionParameters] Additional parameters for \"fine tuning\" the encryption process\r\n     * @param {Object} [extraRecipientInfoParams] Additional params for KeyAgreeRecipientInfo\r\n     */\n\n  }, {\n    key: \"_addKeyAgreeRecipientInfo\",\n    value: function _addKeyAgreeRecipientInfo(recipientIdentifier, encryptionParameters, extraRecipientInfoParams) {\n      //region RecipientEncryptedKey\n      var encryptedKey = new RecipientEncryptedKey({\n        rid: recipientIdentifier // \"encryptedKey\" will be calculated in \"encrypt\" function\n\n      }); //endregion\n      //region keyEncryptionAlgorithm\n\n      var aesKWoid = getOIDByAlgorithm({\n        name: \"AES-KW\",\n        length: encryptionParameters.kekEncryptionLength\n      });\n      if (aesKWoid === \"\") throw new Error(\"Unknown length for key encryption algorithm: \".concat(encryptionParameters.kekEncryptionLength));\n      var aesKW = new AlgorithmIdentifier({\n        algorithmId: aesKWoid\n      }); //endregion\n      //region KeyAgreeRecipientInfo\n\n      var ecdhOID = getOIDByAlgorithm({\n        name: \"ECDH\",\n        kdf: encryptionParameters.kdfAlgorithm\n      });\n      if (ecdhOID === \"\") throw new Error(\"Unknown KDF algorithm: \".concat(encryptionParameters.kdfAlgorithm)); // In fact there is no need in so long UKM, but RFC2631\n      // has requirement that \"UserKeyMaterial\" must be 512 bits long\n\n      var ukmBuffer = new ArrayBuffer(64);\n      var ukmView = new Uint8Array(ukmBuffer);\n      getRandomValues(ukmView); // Generate random values in 64 bytes long buffer\n\n      var recipientInfoParams = {\n        version: 3,\n        // \"originator\" will be calculated in \"encrypt\" function because ephemeral key would be generated there\n        ukm: new asn1js.OctetString({\n          valueHex: ukmBuffer\n        }),\n        keyEncryptionAlgorithm: new AlgorithmIdentifier({\n          algorithmId: ecdhOID,\n          algorithmParams: aesKW.toSchema()\n        }),\n        recipientEncryptedKeys: new RecipientEncryptedKeys({\n          encryptedKeys: [encryptedKey]\n        })\n      };\n      var keyInfo = new KeyAgreeRecipientInfo(Object.assign(recipientInfoParams, extraRecipientInfoParams)); //endregion\n      //region Final values for \"CMS_ENVELOPED_DATA\"\n\n      this.recipientInfos.push(new RecipientInfo({\n        variant: 2,\n        value: keyInfo\n      })); //endregion\n    } //**********************************************************************************\n\n    /**\r\n     * Create a new CMS Enveloped Data content with encrypted data\r\n     * @param {Object} contentEncryptionAlgorithm WebCrypto algorithm. For the moment here could be only \"AES-CBC\" or \"AES-GCM\" algorithms.\r\n     * @param {ArrayBuffer} contentToEncrypt Content to encrypt\r\n     * @returns {Promise}\r\n     */\n\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(contentEncryptionAlgorithm, contentToEncrypt) {\n      var _this2 = this;\n\n      //region Initial variables\n      var sequence = Promise.resolve();\n      var ivBuffer = new ArrayBuffer(16); // For AES we need IV 16 bytes long\n\n      var ivView = new Uint8Array(ivBuffer);\n      getRandomValues(ivView);\n      var contentView = new Uint8Array(contentToEncrypt);\n      var sessionKey;\n      var encryptedContent;\n      var exportedSessionKey;\n      var recipientsPromises = [];\n\n      var _this = this; //endregion\n      //region Check for input parameters\n\n\n      var contentEncryptionOID = getOIDByAlgorithm(contentEncryptionAlgorithm);\n      if (contentEncryptionOID === \"\") return Promise.reject(\"Wrong \\\"contentEncryptionAlgorithm\\\" value\"); //endregion\n      //region Get a \"crypto\" extension\n\n      var crypto = getCrypto();\n      if (typeof crypto === \"undefined\") return Promise.reject(\"Unable to create WebCrypto object\"); //endregion\n      //region Generate new content encryption key\n\n      sequence = sequence.then(function () {\n        return crypto.generateKey(contentEncryptionAlgorithm, true, [\"encrypt\"]);\n      }); //endregion\n      //region Encrypt content\n\n      sequence = sequence.then(function (result) {\n        sessionKey = result;\n        return crypto.encrypt({\n          name: contentEncryptionAlgorithm.name,\n          iv: ivView\n        }, sessionKey, contentView);\n      }, function (error) {\n        return Promise.reject(error);\n      }); //endregion\n      //region Export raw content of content encryption key\n\n      sequence = sequence.then(function (result) {\n        //region Create output OCTETSTRING with encrypted content\n        encryptedContent = result; //endregion\n\n        return crypto.exportKey(\"raw\", sessionKey);\n      }, function (error) {\n        return Promise.reject(error);\n      }).then(function (result) {\n        exportedSessionKey = result;\n        return true;\n      }, function (error) {\n        return Promise.reject(error);\n      }); //endregion\n      //region Append common information to CMS_ENVELOPED_DATA\n\n      sequence = sequence.then(function () {\n        _this2.version = 2;\n        _this2.encryptedContentInfo = new EncryptedContentInfo({\n          contentType: \"1.2.840.113549.1.7.1\",\n          // \"data\"\n          contentEncryptionAlgorithm: new AlgorithmIdentifier({\n            algorithmId: contentEncryptionOID,\n            algorithmParams: new asn1js.OctetString({\n              valueHex: ivBuffer\n            })\n          }),\n          encryptedContent: new asn1js.OctetString({\n            valueHex: encryptedContent\n          })\n        });\n      }, function (error) {\n        return Promise.reject(error);\n      }); //endregion\n      //region Special sub-functions to work with each recipient's type\n\n      function SubKeyAgreeRecipientInfo(index) {\n        //region Initial variables\n        var currentSequence = Promise.resolve();\n        var recipientInfo = _this.recipientInfos[index];\n        var ecdhPublicKey;\n        var ecdhPrivateKey;\n        var recipientPublicKey;\n        var recipientCurve;\n        var recipientCurveLength;\n        var exportedECDHPublicKey; //endregion\n        //region Get public key and named curve from recipient's certificate or public key\n\n        currentSequence = currentSequence.then(function () {\n          if (recipientInfo.value.recipientPublicKey) {\n            recipientCurve = recipientInfo.value.recipientPublicKey.algorithm.namedCurve;\n            return recipientInfo.value.recipientPublicKey;\n          } else {\n            var curveObject = recipientInfo.value.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;\n            if (curveObject.constructor.blockName() !== asn1js.ObjectIdentifier.blockName()) return Promise.reject(\"Incorrect \\\"recipientCertificate\\\" for index \".concat(index));\n            var curveOID = curveObject.valueBlock.toString();\n\n            switch (curveOID) {\n              case \"1.2.840.10045.3.1.7\":\n                recipientCurve = \"P-256\";\n                break;\n\n              case \"1.3.132.0.34\":\n                recipientCurve = \"P-384\";\n                break;\n\n              case \"1.3.132.0.35\":\n                recipientCurve = \"P-521\";\n                break;\n\n              default:\n                return Promise.reject(\"Incorrect curve OID for index \".concat(index));\n            }\n\n            return recipientInfo.value.recipientCertificate.getPublicKey({\n              algorithm: {\n                algorithm: {\n                  name: \"ECDH\",\n                  namedCurve: recipientCurve\n                },\n                usages: []\n              }\n            });\n          }\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n        //region Generate ephemeral ECDH key\n\n        currentSequence = currentSequence.then(function (result) {\n          recipientPublicKey = result;\n          recipientCurveLength = curveLengthByName[recipientCurve];\n          return crypto.generateKey({\n            name: \"ECDH\",\n            namedCurve: recipientCurve\n          }, true, [\"deriveBits\"]);\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n        //region Export public key of ephemeral ECDH key pair\n\n        currentSequence = currentSequence.then(function (result) {\n          ecdhPublicKey = result.publicKey;\n          ecdhPrivateKey = result.privateKey;\n          return crypto.exportKey(\"spki\", ecdhPublicKey);\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n        //region Save public key of ephemeral ECDH key pair\n\n        currentSequence = currentSequence.then(function (result) {\n          exportedECDHPublicKey = result;\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n        //region Create shared secret\n\n        currentSequence = currentSequence.then(function () {\n          return crypto.deriveBits({\n            name: \"ECDH\",\n            public: recipientPublicKey\n          }, ecdhPrivateKey, recipientCurveLength);\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n        //region Apply KDF function to shared secret\n\n        currentSequence = currentSequence.then(\n        /**\r\n         * @param {ArrayBuffer} result\r\n         */\n        function (result) {\n          //region Get length of used AES-KW algorithm\n          var aesKWAlgorithm = new AlgorithmIdentifier({\n            schema: recipientInfo.value.keyEncryptionAlgorithm.algorithmParams\n          });\n          var KWalgorithm = getAlgorithmByOID(aesKWAlgorithm.algorithmId);\n          if (\"name\" in KWalgorithm === false) return Promise.reject(\"Incorrect OID for key encryption algorithm: \".concat(aesKWAlgorithm.algorithmId)); //endregion\n          //region Translate AES-KW length to ArrayBuffer\n\n          var kwLength = KWalgorithm.length;\n          var kwLengthBuffer = new ArrayBuffer(4);\n          var kwLengthView = new Uint8Array(kwLengthBuffer);\n\n          for (var j = 3; j >= 0; j--) {\n            kwLengthView[j] = kwLength;\n            kwLength >>= 8;\n          } //endregion\n          //region Create and encode \"ECC-CMS-SharedInfo\" structure\n\n\n          var eccInfo = new ECCCMSSharedInfo({\n            keyInfo: new AlgorithmIdentifier({\n              algorithmId: aesKWAlgorithm.algorithmId\n            }),\n            entityUInfo: recipientInfo.value.ukm,\n            suppPubInfo: new asn1js.OctetString({\n              valueHex: kwLengthBuffer\n            })\n          });\n          var encodedInfo = eccInfo.toSchema().toBER(false); //endregion\n          //region Get SHA algorithm used together with ECDH\n\n          var ecdhAlgorithm = getAlgorithmByOID(recipientInfo.value.keyEncryptionAlgorithm.algorithmId);\n          if (\"name\" in ecdhAlgorithm === false) return Promise.reject(\"Incorrect OID for key encryption algorithm: \".concat(recipientInfo.value.keyEncryptionAlgorithm.algorithmId)); //endregion\n\n          return kdf(ecdhAlgorithm.kdf, result, KWalgorithm.length, encodedInfo);\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n        //region Import AES-KW key from result of KDF function\n\n        currentSequence = currentSequence.then(function (result) {\n          return crypto.importKey(\"raw\", result, {\n            name: \"AES-KW\"\n          }, true, [\"wrapKey\"]);\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n        //region Finally wrap session key by using AES-KW algorithm\n\n        currentSequence = currentSequence.then(function (result) {\n          return crypto.wrapKey(\"raw\", sessionKey, result, {\n            name: \"AES-KW\"\n          });\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n        //region Append all neccessary data to current CMS_RECIPIENT_INFO object\n\n        currentSequence = currentSequence.then(function (result) {\n          //region OriginatorIdentifierOrKey\n          var asn1 = asn1js.fromBER(exportedECDHPublicKey);\n          var originator = new OriginatorIdentifierOrKey();\n          originator.variant = 3;\n          originator.value = new OriginatorPublicKey({\n            schema: asn1.result\n          });\n          recipientInfo.value.originator = originator; //endregion\n          //region RecipientEncryptedKey\n\n          /*\r\n           We will not support using of same ephemeral key for many recipients\r\n           */\n\n          recipientInfo.value.recipientEncryptedKeys.encryptedKeys[0].encryptedKey = new asn1js.OctetString({\n            valueHex: result\n          }); //endregion\n\n          return {\n            ecdhPrivateKey: ecdhPrivateKey\n          };\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n\n        return currentSequence;\n      }\n\n      function SubKeyTransRecipientInfo(_x) {\n        return _SubKeyTransRecipientInfo.apply(this, arguments);\n      }\n\n      function _SubKeyTransRecipientInfo() {\n        _SubKeyTransRecipientInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(index) {\n          var algorithmParameters, schema, rsaOAEPParams, publicKey, encryptedKey, jjj;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  algorithmParameters = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\n\n                  if (!(\"name\" in algorithmParameters === false)) {\n                    _context.next = 3;\n                    break;\n                  }\n\n                  throw new Error(\"Unknown keyEncryptionAlgorithm: \".concat(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId));\n\n                case 3:\n                  if (!(algorithmParameters.name === \"RSA-OAEP\")) {\n                    _context.next = 9;\n                    break;\n                  }\n\n                  schema = _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams;\n                  rsaOAEPParams = new RSAESOAEPParams({\n                    schema: schema\n                  });\n                  algorithmParameters.hash = getAlgorithmByOID(rsaOAEPParams.hashAlgorithm.algorithmId);\n\n                  if (!(\"name\" in algorithmParameters.hash === false)) {\n                    _context.next = 9;\n                    break;\n                  }\n\n                  throw new Error(\"Incorrect OID for hash algorithm: \".concat(rsaOAEPParams.hashAlgorithm.algorithmId));\n\n                case 9:\n                  _context.prev = 9;\n                  _context.next = 12;\n                  return _this.recipientInfos[index].value.recipientCertificate.getPublicKey({\n                    algorithm: {\n                      algorithm: algorithmParameters,\n                      usages: [\"encrypt\", \"wrapKey\"]\n                    }\n                  });\n\n                case 12:\n                  publicKey = _context.sent;\n                  _context.next = 15;\n                  return crypto.encrypt(publicKey.algorithm, publicKey, exportedSessionKey);\n\n                case 15:\n                  encryptedKey = _context.sent;\n                  //region RecipientEncryptedKey\n                  _this.recipientInfos[index].value.encryptedKey = new asn1js.OctetString({\n                    valueHex: encryptedKey\n                  }); //endregion\n\n                  _context.next = 22;\n                  break;\n\n                case 19:\n                  _context.prev = 19;\n                  _context.t0 = _context[\"catch\"](9);\n                  jjj = 0;\n\n                case 22:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[9, 19]]);\n        }));\n        return _SubKeyTransRecipientInfo.apply(this, arguments);\n      }\n\n      function SubKEKRecipientInfo(index) {\n        //region Initial variables\n        var currentSequence = Promise.resolve();\n        var kekAlgorithm; //endregion\n        //region Import KEK from pre-defined data\n\n        currentSequence = currentSequence.then(function () {\n          //region Get WebCrypto form of \"keyEncryptionAlgorithm\"\n          kekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\n          if (\"name\" in kekAlgorithm === false) return Promise.reject(\"Incorrect OID for \\\"keyEncryptionAlgorithm\\\": \".concat(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId)); //endregion\n\n          return crypto.importKey(\"raw\", new Uint8Array(_this.recipientInfos[index].value.preDefinedKEK), kekAlgorithm, true, [\"wrapKey\"]); // Too specific for AES-KW\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n        //region Wrap previously exported session key\n\n        currentSequence = currentSequence.then(function (result) {\n          return crypto.wrapKey(\"raw\", sessionKey, result, kekAlgorithm);\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n        //region Append all neccessary data to current CMS_RECIPIENT_INFO object\n\n        currentSequence = currentSequence.then(function (result) {\n          //region RecipientEncryptedKey\n          _this.recipientInfos[index].value.encryptedKey = new asn1js.OctetString({\n            valueHex: result\n          }); //endregion\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n\n        return currentSequence;\n      }\n\n      function SubPasswordRecipientinfo(index) {\n        //region Initial variables\n        var currentSequence = Promise.resolve();\n        var pbkdf2Params;\n        var kekAlgorithm; //endregion\n        //region Check that we have encoded \"keyDerivationAlgorithm\" plus \"PBKDF2_params\" in there\n\n        currentSequence = currentSequence.then(function () {\n          if (\"keyDerivationAlgorithm\" in _this.recipientInfos[index].value === false) return Promise.reject(\"Please append encoded \\\"keyDerivationAlgorithm\\\"\");\n          if (\"algorithmParams\" in _this.recipientInfos[index].value.keyDerivationAlgorithm === false) return Promise.reject(\"Incorrectly encoded \\\"keyDerivationAlgorithm\\\"\");\n\n          try {\n            pbkdf2Params = new PBKDF2Params({\n              schema: _this.recipientInfos[index].value.keyDerivationAlgorithm.algorithmParams\n            });\n          } catch (ex) {\n            return Promise.reject(\"Incorrectly encoded \\\"keyDerivationAlgorithm\\\"\");\n          }\n\n          return Promise.resolve();\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n        //region Derive PBKDF2 key from \"password\" buffer\n\n        currentSequence = currentSequence.then(function () {\n          var passwordView = new Uint8Array(_this.recipientInfos[index].value.password);\n          return crypto.importKey(\"raw\", passwordView, \"PBKDF2\", false, [\"deriveKey\"]);\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n        //region Derive key for \"keyEncryptionAlgorithm\"\n\n        currentSequence = currentSequence.then(function (result) {\n          //region Get WebCrypto form of \"keyEncryptionAlgorithm\"\n          kekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\n          if (\"name\" in kekAlgorithm === false) return Promise.reject(\"Incorrect OID for \\\"keyEncryptionAlgorithm\\\": \".concat(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId)); //endregion\n          //region Get HMAC hash algorithm\n\n          var hmacHashAlgorithm = \"SHA-1\";\n\n          if (\"prf\" in pbkdf2Params) {\n            var algorithm = getAlgorithmByOID(pbkdf2Params.prf.algorithmId);\n            if (\"name\" in algorithm === false) return Promise.reject(\"Incorrect OID for HMAC hash algorithm\");\n            hmacHashAlgorithm = algorithm.hash.name;\n          } //endregion\n          //region Get PBKDF2 \"salt\" value\n\n\n          var saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex); //endregion\n          //region Get PBKDF2 iterations count\n\n          var iterations = pbkdf2Params.iterationCount; //endregion\n\n          return crypto.deriveKey({\n            name: \"PBKDF2\",\n            hash: {\n              name: hmacHashAlgorithm\n            },\n            salt: saltView,\n            iterations: iterations\n          }, result, kekAlgorithm, true, [\"wrapKey\"]); // Usages are too specific for KEK algorithm\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n        //region Wrap previously exported session key (Also too specific for KEK algorithm)\n\n        currentSequence = currentSequence.then(function (result) {\n          return crypto.wrapKey(\"raw\", sessionKey, result, kekAlgorithm);\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n        //region Append all neccessary data to current CMS_RECIPIENT_INFO object\n\n        currentSequence = currentSequence.then(function (result) {\n          //region RecipientEncryptedKey\n          _this.recipientInfos[index].value.encryptedKey = new asn1js.OctetString({\n            valueHex: result\n          }); //endregion\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n\n        return currentSequence;\n      } //endregion\n      //region Create special routines for each \"recipient\"\n\n\n      sequence = sequence.then(function () {\n        for (var i = 0; i < _this2.recipientInfos.length; i++) {\n          //region Initial variables\n          var currentSequence = Promise.resolve(); //endregion\n\n          switch (_this2.recipientInfos[i].variant) {\n            case 1:\n              // KeyTransRecipientInfo\n              currentSequence = SubKeyTransRecipientInfo(i);\n              break;\n\n            case 2:\n              // KeyAgreeRecipientInfo\n              currentSequence = SubKeyAgreeRecipientInfo(i);\n              break;\n\n            case 3:\n              // KEKRecipientInfo\n              currentSequence = SubKEKRecipientInfo(i);\n              break;\n\n            case 4:\n              // PasswordRecipientinfo\n              currentSequence = SubPasswordRecipientinfo(i);\n              break;\n\n            default:\n              return Promise.reject(\"Uknown recipient type in array with index \".concat(i));\n          }\n\n          recipientsPromises.push(currentSequence);\n        }\n\n        return Promise.all(recipientsPromises);\n      }, function (error) {\n        return Promise.reject(error);\n      }); //endregion\n\n      return sequence;\n    } //**********************************************************************************\n\n    /**\r\n     * Decrypt existing CMS Enveloped Data content\r\n     * @param {number} recipientIndex Index of recipient\r\n     * @param {Object} parameters Additional parameters\r\n     * @returns {Promise}\r\n     */\n\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(recipientIndex, parameters) {\n      var _this3 = this;\n\n      //region Initial variables\n      var sequence = Promise.resolve();\n      var decryptionParameters = parameters || {};\n\n      var _this = this; //endregion\n      //region Check for input parameters\n\n\n      if (recipientIndex + 1 > this.recipientInfos.length) return Promise.reject(\"Maximum value for \\\"index\\\" is: \".concat(this.recipientInfos.length - 1)); //endregion\n      //region Get a \"crypto\" extension\n\n      var crypto = getCrypto();\n      if (typeof crypto === \"undefined\") return Promise.reject(\"Unable to create WebCrypto object\"); //endregion\n      //region Special sub-functions to work with each recipient's type\n\n      function SubKeyAgreeRecipientInfo(index) {\n        //region Initial variables\n        var currentSequence = Promise.resolve();\n        var recipientCurve;\n        var recipientCurveLength;\n        var curveOID;\n        var ecdhPrivateKey; //endregion\n\n        var originator = _this.recipientInfos[index].value.originator; //region Get \"namedCurve\" parameter from recipient's certificate\n\n        currentSequence = currentSequence.then(function () {\n          if (\"recipientCertificate\" in decryptionParameters) {\n            var curveObject = decryptionParameters.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;\n\n            if (curveObject.constructor.blockName() !== asn1js.ObjectIdentifier.blockName()) {\n              return Promise.reject(\"Incorrect \\\"recipientCertificate\\\" for index \".concat(index));\n            }\n\n            curveOID = curveObject.valueBlock.toString();\n          } else if (\"algorithmParams\" in originator.value.algorithm) {\n            var _curveObject = originator.value.algorithm.algorithmParams;\n\n            if (_curveObject.constructor.blockName() !== asn1js.ObjectIdentifier.blockName()) {\n              return Promise.reject(\"Incorrect originator for index \".concat(index));\n            }\n\n            curveOID = _curveObject.valueBlock.toString();\n          } else {\n            return Promise.reject(\"Parameter \\\"recipientCertificate\\\" is mandatory for \\\"KeyAgreeRecipientInfo\\\" if algorithm params are missing from originator\");\n          }\n\n          if (\"recipientPrivateKey\" in decryptionParameters === false) return Promise.reject(\"Parameter \\\"recipientPrivateKey\\\" is mandatory for \\\"KeyAgreeRecipientInfo\\\"\");\n\n          switch (curveOID) {\n            case \"1.2.840.10045.3.1.7\":\n              recipientCurve = \"P-256\";\n              recipientCurveLength = 256;\n              break;\n\n            case \"1.3.132.0.34\":\n              recipientCurve = \"P-384\";\n              recipientCurveLength = 384;\n              break;\n\n            case \"1.3.132.0.35\":\n              recipientCurve = \"P-521\";\n              recipientCurveLength = 528;\n              break;\n\n            default:\n              return Promise.reject(\"Incorrect curve OID for index \".concat(index));\n          }\n\n          return crypto.importKey(\"pkcs8\", decryptionParameters.recipientPrivateKey, {\n            name: \"ECDH\",\n            namedCurve: recipientCurve\n          }, true, [\"deriveBits\"]);\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n        //region Import sender's ephemeral public key\n\n        currentSequence = currentSequence.then(function (result) {\n          ecdhPrivateKey = result; //region Change \"OriginatorPublicKey\" if \"curve\" parameter absent\n\n          if (\"algorithmParams\" in originator.value.algorithm === false) originator.value.algorithm.algorithmParams = new asn1js.ObjectIdentifier({\n            value: curveOID\n          }); //endregion\n          //region Create ArrayBuffer with sender's public key\n\n          var buffer = originator.value.toSchema().toBER(false); //endregion\n\n          return crypto.importKey(\"spki\", buffer, {\n            name: \"ECDH\",\n            namedCurve: recipientCurve\n          }, true, []);\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n        //region Create shared secret\n\n        currentSequence = currentSequence.then(function (result) {\n          return crypto.deriveBits({\n            name: \"ECDH\",\n            public: result\n          }, ecdhPrivateKey, recipientCurveLength);\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n        //region Apply KDF function to shared secret\n\n        function applyKDF(includeAlgorithmParams) {\n          includeAlgorithmParams = includeAlgorithmParams || false; //region Get length of used AES-KW algorithm\n\n          var aesKWAlgorithm = new AlgorithmIdentifier({\n            schema: _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams\n          });\n          var KWalgorithm = getAlgorithmByOID(aesKWAlgorithm.algorithmId);\n          if (\"name\" in KWalgorithm === false) return Promise.reject(\"Incorrect OID for key encryption algorithm: \".concat(aesKWAlgorithm.algorithmId)); //endregion\n          //region Translate AES-KW length to ArrayBuffer\n\n          var kwLength = KWalgorithm.length;\n          var kwLengthBuffer = new ArrayBuffer(4);\n          var kwLengthView = new Uint8Array(kwLengthBuffer);\n\n          for (var j = 3; j >= 0; j--) {\n            kwLengthView[j] = kwLength;\n            kwLength >>= 8;\n          } //endregion\n          //region Create and encode \"ECC-CMS-SharedInfo\" structure\n\n\n          var keyInfoAlgorithm = {\n            algorithmId: aesKWAlgorithm.algorithmId\n          };\n\n          if (includeAlgorithmParams) {\n            keyInfoAlgorithm.algorithmParams = new asn1js.Null();\n          }\n\n          var eccInfo = new ECCCMSSharedInfo({\n            keyInfo: new AlgorithmIdentifier(keyInfoAlgorithm),\n            entityUInfo: _this.recipientInfos[index].value.ukm,\n            suppPubInfo: new asn1js.OctetString({\n              valueHex: kwLengthBuffer\n            })\n          });\n          var encodedInfo = eccInfo.toSchema().toBER(false); //endregion\n          //region Get SHA algorithm used together with ECDH\n\n          var ecdhAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\n          if (\"name\" in ecdhAlgorithm === false) return Promise.reject(\"Incorrect OID for key encryption algorithm: \".concat(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId)); //endregion\n\n          return kdf(ecdhAlgorithm.kdf, sharedSecret, KWalgorithm.length, encodedInfo);\n        }\n\n        var sharedSecret;\n        currentSequence = currentSequence.then(\n        /**\r\n         * @param {ArrayBuffer} result\r\n         */\n        function (result) {\n          sharedSecret = result;\n          return applyKDF();\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n        //region Import AES-KW key from result of KDF function\n\n        function importAesKwKey(kdfResult) {\n          return crypto.importKey(\"raw\", kdfResult, {\n            name: \"AES-KW\"\n          }, true, [\"unwrapKey\"]);\n        }\n\n        currentSequence = currentSequence.then(importAesKwKey, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n        //region Finally unwrap session key\n\n        function unwrapSessionKey(aesKwKey) {\n          //region Get WebCrypto form of content encryption algorithm\n          var contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\n          if (\"name\" in contentEncryptionAlgorithm === false) return Promise.reject(\"Incorrect \\\"contentEncryptionAlgorithm\\\": \".concat(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId)); //endregion\n\n          return crypto.unwrapKey(\"raw\", _this.recipientInfos[index].value.recipientEncryptedKeys.encryptedKeys[0].encryptedKey.valueBlock.valueHex, aesKwKey, {\n            name: \"AES-KW\"\n          }, contentEncryptionAlgorithm, true, [\"decrypt\"]);\n        }\n\n        currentSequence = currentSequence.then(function (result) {\n          return unwrapSessionKey(result).catch(function () {\n            return applyKDF(true).then(importAesKwKey).then(unwrapSessionKey);\n          });\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n\n        return currentSequence;\n      }\n\n      function SubKeyTransRecipientInfo(_x2) {\n        return _SubKeyTransRecipientInfo2.apply(this, arguments);\n      }\n\n      function _SubKeyTransRecipientInfo2() {\n        _SubKeyTransRecipientInfo2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(index) {\n          var algorithmParameters, schema, rsaOAEPParams, privateKey, sessionKey, contentEncryptionAlgorithm;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (!(\"recipientPrivateKey\" in decryptionParameters === false)) {\n                    _context2.next = 2;\n                    break;\n                  }\n\n                  throw new Error(\"Parameter \\\"recipientPrivateKey\\\" is mandatory for \\\"KeyTransRecipientInfo\\\"\");\n\n                case 2:\n                  algorithmParameters = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\n\n                  if (!(\"name\" in algorithmParameters === false)) {\n                    _context2.next = 5;\n                    break;\n                  }\n\n                  throw new Error(\"Unknown keyEncryptionAlgorithm: \".concat(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId));\n\n                case 5:\n                  if (!(algorithmParameters.name === \"RSA-OAEP\")) {\n                    _context2.next = 11;\n                    break;\n                  }\n\n                  schema = _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams;\n                  rsaOAEPParams = new RSAESOAEPParams({\n                    schema: schema\n                  });\n                  algorithmParameters.hash = getAlgorithmByOID(rsaOAEPParams.hashAlgorithm.algorithmId);\n\n                  if (!(\"name\" in algorithmParameters.hash === false)) {\n                    _context2.next = 11;\n                    break;\n                  }\n\n                  throw new Error(\"Incorrect OID for hash algorithm: \".concat(rsaOAEPParams.hashAlgorithm.algorithmId));\n\n                case 11:\n                  _context2.next = 13;\n                  return crypto.importKey(\"pkcs8\", decryptionParameters.recipientPrivateKey, algorithmParameters, true, [\"decrypt\"]);\n\n                case 13:\n                  privateKey = _context2.sent;\n                  _context2.next = 16;\n                  return crypto.decrypt(privateKey.algorithm, privateKey, _this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex);\n\n                case 16:\n                  sessionKey = _context2.sent;\n                  //region Get WebCrypto form of content encryption algorithm\n                  contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\n\n                  if (!(\"name\" in contentEncryptionAlgorithm === false)) {\n                    _context2.next = 20;\n                    break;\n                  }\n\n                  throw new Error(\"Incorrect \\\"contentEncryptionAlgorithm\\\": \".concat(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId));\n\n                case 20:\n                  return _context2.abrupt(\"return\", crypto.importKey(\"raw\", sessionKey, contentEncryptionAlgorithm, true, [\"decrypt\"]));\n\n                case 21:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n        return _SubKeyTransRecipientInfo2.apply(this, arguments);\n      }\n\n      function SubKEKRecipientInfo(index) {\n        //region Initial variables\n        var currentSequence = Promise.resolve();\n        var kekAlgorithm; //endregion\n        //region Import KEK from pre-defined data\n\n        currentSequence = currentSequence.then(function () {\n          if (\"preDefinedData\" in decryptionParameters === false) return Promise.reject(\"Parameter \\\"preDefinedData\\\" is mandatory for \\\"KEKRecipientInfo\\\"\"); //region Get WebCrypto form of \"keyEncryptionAlgorithm\"\n\n          kekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\n          if (\"name\" in kekAlgorithm === false) return Promise.reject(\"Incorrect OID for \\\"keyEncryptionAlgorithm\\\": \".concat(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId)); //endregion\n\n          return crypto.importKey(\"raw\", decryptionParameters.preDefinedData, kekAlgorithm, true, [\"unwrapKey\"]); // Too specific for AES-KW\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n        //region Unwrap previously exported session key\n\n        currentSequence = currentSequence.then(function (result) {\n          //region Get WebCrypto form of content encryption algorithm\n          var contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\n          if (\"name\" in contentEncryptionAlgorithm === false) return Promise.reject(\"Incorrect \\\"contentEncryptionAlgorithm\\\": \".concat(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId)); //endregion\n\n          return crypto.unwrapKey(\"raw\", _this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex, result, kekAlgorithm, contentEncryptionAlgorithm, true, [\"decrypt\"]);\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n\n        return currentSequence;\n      }\n\n      function SubPasswordRecipientinfo(index) {\n        //region Initial variables\n        var currentSequence = Promise.resolve();\n        var pbkdf2Params;\n        var kekAlgorithm; //endregion\n        //region Derive PBKDF2 key from \"password\" buffer\n\n        currentSequence = currentSequence.then(function () {\n          if (\"preDefinedData\" in decryptionParameters === false) return Promise.reject(\"Parameter \\\"preDefinedData\\\" is mandatory for \\\"KEKRecipientInfo\\\"\");\n          if (\"keyDerivationAlgorithm\" in _this.recipientInfos[index].value === false) return Promise.reject(\"Please append encoded \\\"keyDerivationAlgorithm\\\"\");\n          if (\"algorithmParams\" in _this.recipientInfos[index].value.keyDerivationAlgorithm === false) return Promise.reject(\"Incorrectly encoded \\\"keyDerivationAlgorithm\\\"\");\n\n          try {\n            pbkdf2Params = new PBKDF2Params({\n              schema: _this.recipientInfos[index].value.keyDerivationAlgorithm.algorithmParams\n            });\n          } catch (ex) {\n            return Promise.reject(\"Incorrectly encoded \\\"keyDerivationAlgorithm\\\"\");\n          }\n\n          return crypto.importKey(\"raw\", decryptionParameters.preDefinedData, \"PBKDF2\", false, [\"deriveKey\"]);\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n        //region Derive key for \"keyEncryptionAlgorithm\"\n\n        currentSequence = currentSequence.then(function (result) {\n          //region Get WebCrypto form of \"keyEncryptionAlgorithm\"\n          kekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\n          if (\"name\" in kekAlgorithm === false) return Promise.reject(\"Incorrect OID for \\\"keyEncryptionAlgorithm\\\": \".concat(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId)); //endregion\n          //region Get HMAC hash algorithm\n\n          var hmacHashAlgorithm = \"SHA-1\";\n\n          if (\"prf\" in pbkdf2Params) {\n            var algorithm = getAlgorithmByOID(pbkdf2Params.prf.algorithmId);\n            if (\"name\" in algorithm === false) return Promise.reject(\"Incorrect OID for HMAC hash algorithm\");\n            hmacHashAlgorithm = algorithm.hash.name;\n          } //endregion\n          //region Get PBKDF2 \"salt\" value\n\n\n          var saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex); //endregion\n          //region Get PBKDF2 iterations count\n\n          var iterations = pbkdf2Params.iterationCount; //endregion\n\n          return crypto.deriveKey({\n            name: \"PBKDF2\",\n            hash: {\n              name: hmacHashAlgorithm\n            },\n            salt: saltView,\n            iterations: iterations\n          }, result, kekAlgorithm, true, [\"unwrapKey\"]); // Usages are too specific for KEK algorithm\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n        //region Unwrap previously exported session key\n\n        currentSequence = currentSequence.then(function (result) {\n          //region Get WebCrypto form of content encryption algorithm\n          var contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\n          if (\"name\" in contentEncryptionAlgorithm === false) return Promise.reject(\"Incorrect \\\"contentEncryptionAlgorithm\\\": \".concat(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId)); //endregion\n\n          return crypto.unwrapKey(\"raw\", _this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex, result, kekAlgorithm, contentEncryptionAlgorithm, true, [\"decrypt\"]);\n        }, function (error) {\n          return Promise.reject(error);\n        }); //endregion\n\n        return currentSequence;\n      } //endregion\n      //region Perform steps, specific to each type of session key encryption\n\n\n      sequence = sequence.then(function () {\n        //region Initial variables\n        var currentSequence = Promise.resolve(); //endregion\n\n        switch (_this3.recipientInfos[recipientIndex].variant) {\n          case 1:\n            // KeyTransRecipientInfo\n            currentSequence = SubKeyTransRecipientInfo(recipientIndex);\n            break;\n\n          case 2:\n            // KeyAgreeRecipientInfo\n            currentSequence = SubKeyAgreeRecipientInfo(recipientIndex);\n            break;\n\n          case 3:\n            // KEKRecipientInfo\n            currentSequence = SubKEKRecipientInfo(recipientIndex);\n            break;\n\n          case 4:\n            // PasswordRecipientinfo\n            currentSequence = SubPasswordRecipientinfo(recipientIndex);\n            break;\n\n          default:\n            return Promise.reject(\"Uknown recipient type in array with index \".concat(recipientIndex));\n        }\n\n        return currentSequence;\n      }, function (error) {\n        return Promise.reject(error);\n      }); //endregion\n      //region Finally decrypt data by session key\n\n      sequence = sequence.then(function (result) {\n        //region Get WebCrypto form of content encryption algorithm\n        var contentEncryptionAlgorithm = getAlgorithmByOID(_this3.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\n        if (\"name\" in contentEncryptionAlgorithm === false) return Promise.reject(\"Incorrect \\\"contentEncryptionAlgorithm\\\": \".concat(_this3.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId)); //endregion\n        //region Get \"intialization vector\" for content encryption algorithm\n\n        var ivBuffer = _this3.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams.valueBlock.valueHex;\n        var ivView = new Uint8Array(ivBuffer); //endregion\n        //region Create correct data block for decryption\n\n        var dataBuffer = new ArrayBuffer(0);\n        if (_this3.encryptedContentInfo.encryptedContent.idBlock.isConstructed === false) dataBuffer = _this3.encryptedContentInfo.encryptedContent.valueBlock.valueHex;else {\n          var _iterator = _createForOfIteratorHelper(_this3.encryptedContentInfo.encryptedContent.valueBlock.value),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var content = _step.value;\n              dataBuffer = utilConcatBuf(dataBuffer, content.valueBlock.valueHex);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        } //endregion\n\n        return crypto.decrypt({\n          name: contentEncryptionAlgorithm.name,\n          iv: ivView\n        }, result, dataBuffer);\n      }, function (error) {\n        return Promise.reject(error);\n      }); //endregion\n\n      return sequence;\n    } //**********************************************************************************\n\n  }], [{\n    key: \"defaultValues\",\n    value: function defaultValues(memberName) {\n      switch (memberName) {\n        case \"version\":\n          return 0;\n\n        case \"originatorInfo\":\n          return new OriginatorInfo();\n\n        case \"recipientInfos\":\n          return [];\n\n        case \"encryptedContentInfo\":\n          return new EncryptedContentInfo();\n\n        case \"unprotectedAttrs\":\n          return [];\n\n        default:\n          throw new Error(\"Invalid member name for EnvelopedData class: \".concat(memberName));\n      }\n    } //**********************************************************************************\n\n    /**\r\n     * Compare values with default values for all class members\r\n     * @param {string} memberName String name for a class member\r\n     * @param {*} memberValue Value to compare with default value\r\n     */\n\n  }, {\n    key: \"compareWithDefault\",\n    value: function compareWithDefault(memberName, memberValue) {\n      switch (memberName) {\n        case \"version\":\n          return memberValue === EnvelopedData.defaultValues(memberName);\n\n        case \"originatorInfo\":\n          return memberValue.certs.certificates.length === 0 && memberValue.crls.crls.length === 0;\n\n        case \"recipientInfos\":\n        case \"unprotectedAttrs\":\n          return memberValue.length === 0;\n\n        case \"encryptedContentInfo\":\n          return EncryptedContentInfo.compareWithDefault(\"contentType\", memberValue.contentType) && EncryptedContentInfo.compareWithDefault(\"contentEncryptionAlgorithm\", memberValue.contentEncryptionAlgorithm) && EncryptedContentInfo.compareWithDefault(\"encryptedContent\", memberValue.encryptedContent);\n\n        default:\n          throw new Error(\"Invalid member name for EnvelopedData class: \".concat(memberName));\n      }\n    } //**********************************************************************************\n\n    /**\r\n     * Return value of pre-defined ASN.1 schema for current class\r\n     *\r\n     * ASN.1 schema:\r\n     * ```asn1\r\n     * EnvelopedData ::= SEQUENCE {\r\n     *    version CMSVersion,\r\n     *    originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,\r\n     *    recipientInfos RecipientInfos,\r\n     *    encryptedContentInfo EncryptedContentInfo,\r\n     *    unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL }\r\n     * ```\r\n     *\r\n     * @param {Object} parameters Input parameters for the schema\r\n     * @returns {Object} asn1js schema object\r\n     */\n\n  }, {\n    key: \"schema\",\n    value: function schema() {\n      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      /**\r\n       * @type {Object}\r\n       * @property {string} [blockName]\r\n       * @property {string} [version]\r\n       * @property {string} [originatorInfo]\r\n       * @property {string} [recipientInfos]\r\n       * @property {string} [encryptedContentInfo]\r\n       * @property {string} [unprotectedAttrs]\r\n       */\n      var names = getParametersValue(parameters, \"names\", {});\n      return new asn1js.Sequence({\n        name: names.blockName || \"\",\n        value: [new asn1js.Integer({\n          name: names.version || \"\"\n        }), new asn1js.Constructed({\n          name: names.originatorInfo || \"\",\n          optional: true,\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: 0 // [0]\n\n          },\n          value: OriginatorInfo.schema().valueBlock.value\n        }), new asn1js.Set({\n          value: [new asn1js.Repeated({\n            name: names.recipientInfos || \"\",\n            value: RecipientInfo.schema()\n          })]\n        }), EncryptedContentInfo.schema(names.encryptedContentInfo || {}), new asn1js.Constructed({\n          optional: true,\n          idBlock: {\n            tagClass: 3,\n            // CONTEXT-SPECIFIC\n            tagNumber: 1 // [1]\n\n          },\n          value: [new asn1js.Repeated({\n            name: names.unprotectedAttrs || \"\",\n            value: Attribute.schema()\n          })]\n        })]\n      });\n    }\n  }]);\n\n  return EnvelopedData;\n}(); //**************************************************************************************\n\n\nexport { EnvelopedData as default };","map":{"version":3,"sources":["C:/Users/rkanthet/Documents/test_window_object/node_modules/pkijs/src/EnvelopedData.js"],"names":["asn1js","getParametersValue","utilConcatBuf","clearProps","getOIDByAlgorithm","getRandomValues","getCrypto","getAlgorithmByOID","kdf","OriginatorInfo","RecipientInfo","EncryptedContentInfo","Attribute","AlgorithmIdentifier","RSAESOAEPParams","KeyTransRecipientInfo","IssuerAndSerialNumber","RecipientKeyIdentifier","RecipientEncryptedKey","KeyAgreeRecipientIdentifier","KeyAgreeRecipientInfo","RecipientEncryptedKeys","KEKRecipientInfo","KEKIdentifier","PBKDF2Params","PasswordRecipientinfo","ECCCMSSharedInfo","OriginatorIdentifierOrKey","OriginatorPublicKey","defaultEncryptionParams","kdfAlgorithm","kekEncryptionLength","curveLengthByName","EnvelopedData","parameters","version","defaultValues","originatorInfo","recipientInfos","encryptedContentInfo","unprotectedAttrs","fromSchema","schema","asn1","compareSchema","names","blockName","verified","Error","result","valueBlock","valueDec","Sequence","value","Array","from","element","outputArray","push","Integer","Constructed","optional","idBlock","tagClass","tagNumber","toSchema","Set","_object","toJSON","certificate","variant","encryptionParameters","Object","assign","useOAEP","oaepHashAlgorithm","subjectPublicKeyInfo","algorithm","algorithmId","indexOf","algorithmParams","name","hashOID","hashAlgorithm","Null","rsaOAEPParams","maskGenAlgorithm","keyInfo","rid","issuer","serialNumber","keyEncryptionAlgorithm","recipientCertificate","recipientIdentifier","_addKeyAgreeRecipientInfo","preDefinedData","ArrayBuffer","byteLength","keyIdentifierBuffer","keyIdentifierView","Uint8Array","keyIdentifier","hmacHashAlgorithm","iterationCount","length","keyEncryptionAlgorithmParams","kekOID","kekid","OctetString","valueHex","preDefinedKEK","pbkdf2OID","saltBuffer","saltView","hmacOID","hash","pbkdf2Params","salt","prf","keyDerivationAlgorithm","password","key","keyId","subjectKeyIdentifier","recipientPublicKey","extraRecipientInfoParams","encryptedKey","aesKWoid","aesKW","ecdhOID","ukmBuffer","ukmView","recipientInfoParams","ukm","recipientEncryptedKeys","encryptedKeys","contentEncryptionAlgorithm","contentToEncrypt","sequence","Promise","resolve","ivBuffer","ivView","contentView","sessionKey","encryptedContent","exportedSessionKey","recipientsPromises","_this","contentEncryptionOID","reject","crypto","then","generateKey","encrypt","iv","error","exportKey","contentType","SubKeyAgreeRecipientInfo","index","currentSequence","recipientInfo","ecdhPublicKey","ecdhPrivateKey","recipientCurve","recipientCurveLength","exportedECDHPublicKey","namedCurve","curveObject","constructor","ObjectIdentifier","curveOID","toString","getPublicKey","usages","publicKey","privateKey","deriveBits","public","aesKWAlgorithm","KWalgorithm","kwLength","kwLengthBuffer","kwLengthView","j","eccInfo","entityUInfo","suppPubInfo","encodedInfo","toBER","ecdhAlgorithm","importKey","wrapKey","fromBER","originator","SubKeyTransRecipientInfo","algorithmParameters","jjj","SubKEKRecipientInfo","kekAlgorithm","SubPasswordRecipientinfo","ex","passwordView","iterations","deriveKey","i","all","recipientIndex","decryptionParameters","recipientPrivateKey","buffer","applyKDF","includeAlgorithmParams","keyInfoAlgorithm","sharedSecret","importAesKwKey","kdfResult","unwrapSessionKey","aesKwKey","unwrapKey","catch","decrypt","dataBuffer","isConstructed","content","memberName","memberValue","certs","certificates","crls","compareWithDefault","Repeated"],"mappings":"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","sourcesContent":["import * as asn1js from \"asn1js\";\r\nimport { getParametersValue, utilConcatBuf, clearProps } from \"pvutils\";\r\nimport { getOIDByAlgorithm, getRandomValues, getCrypto, getAlgorithmByOID, kdf } from \"./common.js\";\r\nimport OriginatorInfo from \"./OriginatorInfo.js\";\r\nimport RecipientInfo from \"./RecipientInfo.js\";\r\nimport EncryptedContentInfo from \"./EncryptedContentInfo.js\";\r\nimport Attribute from \"./Attribute.js\";\r\nimport AlgorithmIdentifier from \"./AlgorithmIdentifier.js\";\r\nimport RSAESOAEPParams from \"./RSAESOAEPParams.js\";\r\nimport KeyTransRecipientInfo from \"./KeyTransRecipientInfo.js\";\r\nimport IssuerAndSerialNumber from \"./IssuerAndSerialNumber.js\";\r\nimport RecipientKeyIdentifier from \"./RecipientKeyIdentifier.js\";\r\nimport RecipientEncryptedKey from \"./RecipientEncryptedKey.js\";\r\nimport KeyAgreeRecipientIdentifier from \"./KeyAgreeRecipientIdentifier.js\";\r\nimport KeyAgreeRecipientInfo from \"./KeyAgreeRecipientInfo.js\";\r\nimport RecipientEncryptedKeys from \"./RecipientEncryptedKeys.js\";\r\nimport KEKRecipientInfo from \"./KEKRecipientInfo.js\";\r\nimport KEKIdentifier from \"./KEKIdentifier.js\";\r\nimport PBKDF2Params from \"./PBKDF2Params.js\";\r\nimport PasswordRecipientinfo from \"./PasswordRecipientinfo.js\";\r\nimport ECCCMSSharedInfo from \"./ECCCMSSharedInfo.js\";\r\nimport OriginatorIdentifierOrKey from \"./OriginatorIdentifierOrKey.js\";\r\nimport OriginatorPublicKey from \"./OriginatorPublicKey.js\";\r\n//**************************************************************************************\r\nconst defaultEncryptionParams = {\r\n\tkdfAlgorithm: \"SHA-512\",\r\n\tkekEncryptionLength: 256\r\n};\r\nconst curveLengthByName = {\r\n\t\"P-256\": 256,\r\n\t\"P-384\": 384,\r\n\t\"P-521\": 528\r\n};\r\n//**************************************************************************************\r\n/**\r\n * Class from RFC5652\r\n */\r\nexport default class EnvelopedData\r\n{\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Constructor for EnvelopedData class\r\n\t * @param {Object} [parameters={}]\r\n\t * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\r\n\t */\r\n\tconstructor(parameters = {})\r\n\t{\r\n\t\t//region Internal properties of the object\r\n\t\t/**\r\n\t\t * @type {number}\r\n\t\t * @desc version\r\n\t\t */\r\n\t\tthis.version = getParametersValue(parameters, \"version\", EnvelopedData.defaultValues(\"version\"));\r\n\r\n\t\tif(\"originatorInfo\" in parameters)\r\n\t\t\t/**\r\n\t\t\t * @type {OriginatorInfo}\r\n\t\t\t * @desc originatorInfo\r\n\t\t\t */\r\n\t\t\tthis.originatorInfo = getParametersValue(parameters, \"originatorInfo\", EnvelopedData.defaultValues(\"originatorInfo\"));\r\n\r\n\t\t/**\r\n\t\t * @type {Array.<RecipientInfo>}\r\n\t\t * @desc recipientInfos\r\n\t\t */\r\n\t\tthis.recipientInfos = getParametersValue(parameters, \"recipientInfos\", EnvelopedData.defaultValues(\"recipientInfos\"));\r\n\t\t/**\r\n\t\t * @type {EncryptedContentInfo}\r\n\t\t * @desc encryptedContentInfo\r\n\t\t */\r\n\t\tthis.encryptedContentInfo = getParametersValue(parameters, \"encryptedContentInfo\", EnvelopedData.defaultValues(\"encryptedContentInfo\"));\r\n\r\n\t\tif(\"unprotectedAttrs\" in parameters)\r\n\t\t\t/**\r\n\t\t\t * @type {Array.<Attribute>}\r\n\t\t\t * @desc unprotectedAttrs\r\n\t\t\t */\r\n\t\t\tthis.unprotectedAttrs = getParametersValue(parameters, \"unprotectedAttrs\", EnvelopedData.defaultValues(\"unprotectedAttrs\"));\r\n\t\t//endregion\r\n\r\n\t\t//region If input argument array contains \"schema\" for this object\r\n\t\tif(\"schema\" in parameters)\r\n\t\t\tthis.fromSchema(parameters.schema);\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Return default values for all class members\r\n\t * @param {string} memberName String name for a class member\r\n\t */\r\n\tstatic defaultValues(memberName)\r\n\t{\r\n\t\tswitch(memberName)\r\n\t\t{\r\n\t\t\tcase \"version\":\r\n\t\t\t\treturn 0;\r\n\t\t\tcase \"originatorInfo\":\r\n\t\t\t\treturn new OriginatorInfo();\r\n\t\t\tcase \"recipientInfos\":\r\n\t\t\t\treturn [];\r\n\t\t\tcase \"encryptedContentInfo\":\r\n\t\t\t\treturn new EncryptedContentInfo();\r\n\t\t\tcase \"unprotectedAttrs\":\r\n\t\t\t\treturn [];\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Invalid member name for EnvelopedData class: ${memberName}`);\r\n\t\t}\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Compare values with default values for all class members\r\n\t * @param {string} memberName String name for a class member\r\n\t * @param {*} memberValue Value to compare with default value\r\n\t */\r\n\tstatic compareWithDefault(memberName, memberValue)\r\n\t{\r\n\t\tswitch(memberName)\r\n\t\t{\r\n\t\t\tcase \"version\":\r\n\t\t\t\treturn (memberValue === EnvelopedData.defaultValues(memberName));\r\n\t\t\tcase \"originatorInfo\":\r\n\t\t\t\treturn ((memberValue.certs.certificates.length === 0) && (memberValue.crls.crls.length === 0));\r\n\t\t\tcase \"recipientInfos\":\r\n\t\t\tcase \"unprotectedAttrs\":\r\n\t\t\t\treturn (memberValue.length === 0);\r\n\t\t\tcase \"encryptedContentInfo\":\r\n\t\t\t\treturn ((EncryptedContentInfo.compareWithDefault(\"contentType\", memberValue.contentType)) &&\r\n\t\t\t\t(EncryptedContentInfo.compareWithDefault(\"contentEncryptionAlgorithm\", memberValue.contentEncryptionAlgorithm) &&\r\n\t\t\t\t(EncryptedContentInfo.compareWithDefault(\"encryptedContent\", memberValue.encryptedContent))));\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Invalid member name for EnvelopedData class: ${memberName}`);\r\n\t\t}\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Return value of pre-defined ASN.1 schema for current class\r\n\t *\r\n\t * ASN.1 schema:\r\n\t * ```asn1\r\n\t * EnvelopedData ::= SEQUENCE {\r\n\t *    version CMSVersion,\r\n\t *    originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,\r\n\t *    recipientInfos RecipientInfos,\r\n\t *    encryptedContentInfo EncryptedContentInfo,\r\n\t *    unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL }\r\n\t * ```\r\n\t *\r\n\t * @param {Object} parameters Input parameters for the schema\r\n\t * @returns {Object} asn1js schema object\r\n\t */\r\n\tstatic schema(parameters = {})\r\n\t{\r\n\t\t/**\r\n\t\t * @type {Object}\r\n\t\t * @property {string} [blockName]\r\n\t\t * @property {string} [version]\r\n\t\t * @property {string} [originatorInfo]\r\n\t\t * @property {string} [recipientInfos]\r\n\t\t * @property {string} [encryptedContentInfo]\r\n\t\t * @property {string} [unprotectedAttrs]\r\n\t\t */\r\n\t\tconst names = getParametersValue(parameters, \"names\", {});\r\n\r\n\t\treturn (new asn1js.Sequence({\r\n\t\t\tname: (names.blockName || \"\"),\r\n\t\t\tvalue: [\r\n\t\t\t\tnew asn1js.Integer({ name: (names.version || \"\") }),\r\n\t\t\t\tnew asn1js.Constructed({\r\n\t\t\t\t\tname: (names.originatorInfo || \"\"),\r\n\t\t\t\t\toptional: true,\r\n\t\t\t\t\tidBlock: {\r\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\r\n\t\t\t\t\t\ttagNumber: 0 // [0]\r\n\t\t\t\t\t},\r\n\t\t\t\t\tvalue: OriginatorInfo.schema().valueBlock.value\r\n\t\t\t\t}),\r\n\t\t\t\tnew asn1js.Set({\r\n\t\t\t\t\tvalue: [\r\n\t\t\t\t\t\tnew asn1js.Repeated({\r\n\t\t\t\t\t\t\tname: (names.recipientInfos || \"\"),\r\n\t\t\t\t\t\t\tvalue: RecipientInfo.schema()\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t]\r\n\t\t\t\t}),\r\n\t\t\t\tEncryptedContentInfo.schema(names.encryptedContentInfo || {}),\r\n\t\t\t\tnew asn1js.Constructed({\r\n\t\t\t\t\toptional: true,\r\n\t\t\t\t\tidBlock: {\r\n\t\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\r\n\t\t\t\t\t\ttagNumber: 1 // [1]\r\n\t\t\t\t\t},\r\n\t\t\t\t\tvalue: [\r\n\t\t\t\t\t\tnew asn1js.Repeated({\r\n\t\t\t\t\t\t\tname: (names.unprotectedAttrs || \"\"),\r\n\t\t\t\t\t\t\tvalue: Attribute.schema()\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t]\r\n\t\t\t\t})\r\n\t\t\t]\r\n\t\t}));\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convert parsed asn1js object into current class\r\n\t * @param {!Object} schema\r\n\t */\r\n\tfromSchema(schema)\r\n\t{\r\n\t\t//region Clear input data first\r\n\t\tclearProps(schema, [\r\n\t\t\t\"version\",\r\n\t\t\t\"originatorInfo\",\r\n\t\t\t\"recipientInfos\",\r\n\t\t\t\"encryptedContentInfo\",\r\n\t\t\t\"unprotectedAttrs\"\r\n\t\t]);\r\n\t\t//endregion\r\n\r\n\t\t//region Check the schema is valid\r\n\t\tconst asn1 = asn1js.compareSchema(schema,\r\n\t\t\tschema,\r\n\t\t\tEnvelopedData.schema({\r\n\t\t\t\tnames: {\r\n\t\t\t\t\tversion: \"version\",\r\n\t\t\t\t\toriginatorInfo: \"originatorInfo\",\r\n\t\t\t\t\trecipientInfos: \"recipientInfos\",\r\n\t\t\t\t\tencryptedContentInfo: {\r\n\t\t\t\t\t\tnames: {\r\n\t\t\t\t\t\t\tblockName: \"encryptedContentInfo\"\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tunprotectedAttrs: \"unprotectedAttrs\"\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t);\r\n\r\n\t\tif(asn1.verified === false)\r\n\t\t\tthrow new Error(\"Object's schema was not verified against input data for EnvelopedData\");\r\n\t\t//endregion\r\n\r\n\t\t//region Get internal properties from parsed schema\r\n\t\tthis.version = asn1.result.version.valueBlock.valueDec;\r\n\r\n\t\tif(\"originatorInfo\" in asn1.result)\r\n\t\t{\r\n\t\t\tthis.originatorInfo = new OriginatorInfo({\r\n\t\t\t\tschema: new asn1js.Sequence({\r\n\t\t\t\t\tvalue: asn1.result.originatorInfo.valueBlock.value\r\n\t\t\t\t})\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis.recipientInfos = Array.from(asn1.result.recipientInfos, element => new RecipientInfo({ schema: element }));\r\n\t\tthis.encryptedContentInfo = new EncryptedContentInfo({ schema: asn1.result.encryptedContentInfo });\r\n\r\n\t\tif(\"unprotectedAttrs\" in asn1.result)\r\n\t\t\tthis.unprotectedAttrs = Array.from(asn1.result.unprotectedAttrs, element => new Attribute({ schema: element }));\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convert current object to asn1js object and set correct values\r\n\t * @returns {Object} asn1js object\r\n\t */\r\n\ttoSchema()\r\n\t{\r\n\t\t//region Create array for output sequence\r\n\t\tconst outputArray = [];\r\n\r\n\t\toutputArray.push(new asn1js.Integer({ value: this.version }));\r\n\r\n\t\tif(\"originatorInfo\" in this)\r\n\t\t{\r\n\t\t\toutputArray.push(new asn1js.Constructed({\r\n\t\t\t\toptional: true,\r\n\t\t\t\tidBlock: {\r\n\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\r\n\t\t\t\t\ttagNumber: 0 // [0]\r\n\t\t\t\t},\r\n\t\t\t\tvalue: this.originatorInfo.toSchema().valueBlock.value\r\n\t\t\t}));\r\n\t\t}\r\n\r\n\t\toutputArray.push(new asn1js.Set({\r\n\t\t\tvalue: Array.from(this.recipientInfos, element => element.toSchema())\r\n\t\t}));\r\n\r\n\t\toutputArray.push(this.encryptedContentInfo.toSchema());\r\n\r\n\t\tif(\"unprotectedAttrs\" in this)\r\n\t\t{\r\n\t\t\toutputArray.push(new asn1js.Constructed({\r\n\t\t\t\toptional: true,\r\n\t\t\t\tidBlock: {\r\n\t\t\t\t\ttagClass: 3, // CONTEXT-SPECIFIC\r\n\t\t\t\t\ttagNumber: 1 // [1]\r\n\t\t\t\t},\r\n\t\t\t\tvalue: Array.from(this.unprotectedAttrs, element => element.toSchema())\r\n\t\t\t}));\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\t//region Construct and return new ASN.1 schema for this object\r\n\t\treturn (new asn1js.Sequence({\r\n\t\t\tvalue: outputArray\r\n\t\t}));\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Convertion for the class to JSON object\r\n\t * @returns {Object}\r\n\t */\r\n\ttoJSON()\r\n\t{\r\n\t\tconst _object = {\r\n\t\t\tversion: this.version\r\n\t\t};\r\n\r\n\t\tif(\"originatorInfo\" in this)\r\n\t\t\t_object.originatorInfo = this.originatorInfo.toJSON();\r\n\r\n\t\t_object.recipientInfos = Array.from(this.recipientInfos, element => element.toJSON());\r\n\t\t_object.encryptedContentInfo = this.encryptedContentInfo.toJSON();\r\n\r\n\t\tif(\"unprotectedAttrs\" in this)\r\n\t\t\t_object.unprotectedAttrs = Array.from(this.unprotectedAttrs, element => element.toJSON());\r\n\r\n\t\treturn _object;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Helpers function for filling \"RecipientInfo\" based on recipient's certificate.\r\n\t * Problem with WebCrypto is that for RSA certificates we have only one option - \"key transport\" and\r\n\t * for ECC certificates we also have one option - \"key agreement\". As soon as Google will implement\r\n\t * DH algorithm it would be possible to use \"key agreement\" also for RSA certificates.\r\n\t * @param {Certificate} [certificate] Recipient's certificate\r\n\t * @param {Object} [parameters] Additional parameters neccessary for \"fine tunning\" of encryption process\r\n\t * @param {number} [variant] Variant = 1 is for \"key transport\", variant = 2 is for \"key agreement\". In fact the \"variant\" is unneccessary now because Google has no DH algorithm implementation. Thus key encryption scheme would be choosen by certificate type only: \"key transport\" for RSA and \"key agreement\" for ECC certificates.\r\n\t */\r\n\taddRecipientByCertificate(certificate, parameters, variant)\r\n\t{\r\n\t\t//region Initialize encryption parameters\r\n\t\tconst encryptionParameters = Object.assign(\r\n\t\t\t{ useOAEP: true, oaepHashAlgorithm: \"SHA-512\" },\r\n\t\t\tdefaultEncryptionParams,\r\n\t\t\tparameters || {}\r\n\t\t);\r\n\t\t//endregion\r\n\r\n\t\t//region Check type of certificate\r\n\t\tif(certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf(\"1.2.840.113549\") !== (-1))\r\n\t\t\tvariant = 1; // For the moment it is the only variant for RSA-based certificates\r\n\t\telse\r\n\t\t{\r\n\t\t\tif(certificate.subjectPublicKeyInfo.algorithm.algorithmId.indexOf(\"1.2.840.10045\") !== (-1))\r\n\t\t\t\tvariant = 2; // For the moment it is the only variant for ECC-based certificates\r\n\t\t\telse\r\n\t\t\t\tthrow new Error(`Unknown type of certificate's public key: ${certificate.subjectPublicKeyInfo.algorithm.algorithmId}`);\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\t//region Add new \"recipient\" depends on \"variant\" and certificate type\r\n\t\tswitch(variant)\r\n\t\t{\r\n\t\t\tcase 1: // Key transport scheme\r\n\t\t\t\t{\r\n\t\t\t\t\tlet algorithmId;\r\n\t\t\t\t\tlet algorithmParams;\r\n\r\n\t\t\t\t\tif(encryptionParameters.useOAEP === true)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t//region keyEncryptionAlgorithm\r\n\t\t\t\t\t\talgorithmId = getOIDByAlgorithm({\r\n\t\t\t\t\t\t\tname: \"RSA-OAEP\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tif(algorithmId === \"\")\r\n\t\t\t\t\t\t\tthrow new Error(\"Can not find OID for RSA-OAEP\");\r\n\t\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t\t//region RSAES-OAEP-params\r\n\t\t\t\t\t\tconst hashOID = getOIDByAlgorithm({\r\n\t\t\t\t\t\t\tname: encryptionParameters.oaepHashAlgorithm\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tif(hashOID === \"\")\r\n\t\t\t\t\t\t\tthrow new Error(`Unknown OAEP hash algorithm: ${encryptionParameters.oaepHashAlgorithm}`);\r\n\r\n\t\t\t\t\t\tconst hashAlgorithm = new AlgorithmIdentifier({\r\n\t\t\t\t\t\t\talgorithmId: hashOID,\r\n\t\t\t\t\t\t\talgorithmParams: new asn1js.Null()\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\tconst rsaOAEPParams = new RSAESOAEPParams({\r\n\t\t\t\t\t\t\thashAlgorithm,\r\n\t\t\t\t\t\t\tmaskGenAlgorithm: new AlgorithmIdentifier({\r\n\t\t\t\t\t\t\t\talgorithmId: \"1.2.840.113549.1.1.8\", // id-mgf1\r\n\t\t\t\t\t\t\t\talgorithmParams: hashAlgorithm.toSchema()\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\talgorithmParams = rsaOAEPParams.toSchema();\r\n\t\t\t\t\t\t//endregion\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse // Use old RSAES-PKCS1-v1_5 schema instead\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t//region keyEncryptionAlgorithm\r\n\t\t\t\t\t\talgorithmId = getOIDByAlgorithm({\r\n\t\t\t\t\t\t\tname: \"RSAES-PKCS1-v1_5\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tif(algorithmId === \"\")\r\n\t\t\t\t\t\t\tthrow new Error(\"Can not find OID for RSAES-PKCS1-v1_5\");\r\n\t\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t\talgorithmParams = new asn1js.Null();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//region KeyTransRecipientInfo\r\n\t\t\t\t\tconst keyInfo = new KeyTransRecipientInfo({\r\n\t\t\t\t\t\tversion: 0,\r\n\t\t\t\t\t\trid: new IssuerAndSerialNumber({\r\n\t\t\t\t\t\t\tissuer: certificate.issuer,\r\n\t\t\t\t\t\t\tserialNumber: certificate.serialNumber\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t\tkeyEncryptionAlgorithm: new AlgorithmIdentifier({\r\n\t\t\t\t\t\t\talgorithmId,\r\n\t\t\t\t\t\t\talgorithmParams\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t\trecipientCertificate: certificate\r\n\t\t\t\t\t\t// \"encryptedKey\" will be calculated in \"encrypt\" function\r\n\t\t\t\t\t});\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region Final values for \"CMS_ENVELOPED_DATA\"\r\n\t\t\t\t\tthis.recipientInfos.push(new RecipientInfo({\r\n\t\t\t\t\t\tvariant: 1,\r\n\t\t\t\t\t\tvalue: keyInfo\r\n\t\t\t\t\t}));\r\n\t\t\t\t\t//endregion\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2: // Key agreement scheme\r\n\t\t\t\t{\r\n\t\t\t\t\tconst recipientIdentifier = new KeyAgreeRecipientIdentifier({\r\n\t\t\t\t\t\tvariant: 1,\r\n\t\t\t\t\t\tvalue: new IssuerAndSerialNumber({\r\n\t\t\t\t\t\t\tissuer: certificate.issuer,\r\n\t\t\t\t\t\t\tserialNumber: certificate.serialNumber\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t});\r\n\t\t\t\t\tthis._addKeyAgreeRecipientInfo(\r\n\t\t\t\t\t\trecipientIdentifier,\r\n\t\t\t\t\t\tencryptionParameters,\r\n\t\t\t\t\t\t{recipientCertificate: certificate}\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Unknown \"variant\" value: ${variant}`);\r\n\t\t}\r\n\t\t//endregion\r\n\r\n\t\treturn true;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Add recipient based on pre-defined data like password or KEK\r\n\t * @param {ArrayBuffer} preDefinedData ArrayBuffer with pre-defined data\r\n\t * @param {Object} parameters Additional parameters neccessary for \"fine tunning\" of encryption process\r\n\t * @param {number} variant Variant = 1 for pre-defined \"key encryption key\" (KEK). Variant = 2 for password-based encryption.\r\n\t */\r\n\taddRecipientByPreDefinedData(preDefinedData, parameters, variant)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tconst encryptionParameters = parameters || {};\r\n\t\t//endregion\r\n\r\n\t\t//region Check initial parameters\r\n\t\tif((preDefinedData instanceof ArrayBuffer) === false)\r\n\t\t\tthrow new Error(\"Please pass \\\"preDefinedData\\\" in ArrayBuffer type\");\r\n\r\n\t\tif(preDefinedData.byteLength === 0)\r\n\t\t\tthrow new Error(\"Pre-defined data could have zero length\");\r\n\t\t//endregion\r\n\r\n\t\t//region Initialize encryption parameters\r\n\t\tif((\"keyIdentifier\" in encryptionParameters) === false)\r\n\t\t{\r\n\t\t\tconst keyIdentifierBuffer = new ArrayBuffer(16);\r\n\t\t\tconst keyIdentifierView = new Uint8Array(keyIdentifierBuffer);\r\n\t\t\tgetRandomValues(keyIdentifierView);\r\n\r\n\t\t\tencryptionParameters.keyIdentifier = keyIdentifierBuffer;\r\n\t\t}\r\n\r\n\t\tif((\"hmacHashAlgorithm\" in encryptionParameters) === false)\r\n\t\t\tencryptionParameters.hmacHashAlgorithm = \"SHA-512\";\r\n\r\n\t\tif((\"iterationCount\" in encryptionParameters) === false)\r\n\t\t\tencryptionParameters.iterationCount = 2048;\r\n\r\n\t\tif((\"keyEncryptionAlgorithm\" in encryptionParameters) === false)\r\n\t\t{\r\n\t\t\tencryptionParameters.keyEncryptionAlgorithm = {\r\n\t\t\t\tname: \"AES-KW\",\r\n\t\t\t\tlength: 256\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tif((\"keyEncryptionAlgorithmParams\" in encryptionParameters) === false)\r\n\t\t\tencryptionParameters.keyEncryptionAlgorithmParams = new asn1js.Null();\r\n\t\t//endregion\r\n\r\n\t\t//region Add new recipient based on passed variant\r\n\t\tswitch(variant)\r\n\t\t{\r\n\t\t\tcase 1: // KEKRecipientInfo\r\n\t\t\t\t{\r\n\t\t\t\t\t//region keyEncryptionAlgorithm\r\n\t\t\t\t\tconst kekOID = getOIDByAlgorithm(encryptionParameters.keyEncryptionAlgorithm);\r\n\t\t\t\t\tif(kekOID === \"\")\r\n\t\t\t\t\t\tthrow new Error(\"Incorrect value for \\\"keyEncryptionAlgorithm\\\"\");\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region KEKRecipientInfo\r\n\t\t\t\t\tconst keyInfo = new KEKRecipientInfo({\r\n\t\t\t\t\t\tversion: 4,\r\n\t\t\t\t\t\tkekid: new KEKIdentifier({\r\n\t\t\t\t\t\t\tkeyIdentifier: new asn1js.OctetString({ valueHex: encryptionParameters.keyIdentifier })\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t\tkeyEncryptionAlgorithm: new AlgorithmIdentifier({\r\n\t\t\t\t\t\t\talgorithmId: kekOID,\r\n\t\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t\t For AES-KW params are NULL, but for other algorithm could another situation.\r\n\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\talgorithmParams: encryptionParameters.keyEncryptionAlgorithmParams\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t\tpreDefinedKEK: preDefinedData\r\n\t\t\t\t\t// \"encryptedKey\" would be set in \"ecrypt\" function\r\n\t\t\t\t\t});\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region Final values for \"CMS_ENVELOPED_DATA\"\r\n\t\t\t\t\tthis.recipientInfos.push(new RecipientInfo({\r\n\t\t\t\t\t\tvariant: 3,\r\n\t\t\t\t\t\tvalue: keyInfo\r\n\t\t\t\t\t}));\r\n\t\t\t\t\t//endregion\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2: // PasswordRecipientinfo\r\n\t\t\t\t{\r\n\t\t\t\t\t//region keyDerivationAlgorithm\r\n\t\t\t\t\tconst pbkdf2OID = getOIDByAlgorithm({\r\n\t\t\t\t\t\tname: \"PBKDF2\"\r\n\t\t\t\t\t});\r\n\t\t\t\t\tif(pbkdf2OID === \"\")\r\n\t\t\t\t\t\tthrow new Error(\"Can not find OID for PBKDF2\");\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region Salt\r\n\t\t\t\t\tconst saltBuffer = new ArrayBuffer(64);\r\n\t\t\t\t\tconst saltView = new Uint8Array(saltBuffer);\r\n\t\t\t\t\tgetRandomValues(saltView);\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region HMAC-based algorithm\r\n\t\t\t\t\tconst hmacOID = getOIDByAlgorithm({\r\n\t\t\t\t\t\tname: \"HMAC\",\r\n\t\t\t\t\t\thash: {\r\n\t\t\t\t\t\t\tname: encryptionParameters.hmacHashAlgorithm\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\tif(hmacOID === \"\")\r\n\t\t\t\t\t\tthrow new Error(`Incorrect value for \"hmacHashAlgorithm\": ${encryptionParameters.hmacHashAlgorithm}`);\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region PBKDF2-params\r\n\t\t\t\t\tconst pbkdf2Params = new PBKDF2Params({\r\n\t\t\t\t\t\tsalt: new asn1js.OctetString({ valueHex: saltBuffer }),\r\n\t\t\t\t\t\titerationCount: encryptionParameters.iterationCount,\r\n\t\t\t\t\t\tprf: new AlgorithmIdentifier({\r\n\t\t\t\t\t\t\talgorithmId: hmacOID,\r\n\t\t\t\t\t\t\talgorithmParams: new asn1js.Null()\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t});\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region keyEncryptionAlgorithm\r\n\t\t\t\t\tconst kekOID = getOIDByAlgorithm(encryptionParameters.keyEncryptionAlgorithm);\r\n\t\t\t\t\tif(kekOID === \"\")\r\n\t\t\t\t\t\tthrow new Error(\"Incorrect value for \\\"keyEncryptionAlgorithm\\\"\");\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region PasswordRecipientinfo\r\n\t\t\t\t\tconst keyInfo = new PasswordRecipientinfo({\r\n\t\t\t\t\t\tversion: 0,\r\n\t\t\t\t\t\tkeyDerivationAlgorithm: new AlgorithmIdentifier({\r\n\t\t\t\t\t\t\talgorithmId: pbkdf2OID,\r\n\t\t\t\t\t\t\talgorithmParams: pbkdf2Params.toSchema()\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t\tkeyEncryptionAlgorithm: new AlgorithmIdentifier({\r\n\t\t\t\t\t\t\talgorithmId: kekOID,\r\n\t\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t\t For AES-KW params are NULL, but for other algorithm could be another situation.\r\n\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\talgorithmParams: encryptionParameters.keyEncryptionAlgorithmParams\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t\tpassword: preDefinedData\r\n\t\t\t\t\t// \"encryptedKey\" would be set in \"ecrypt\" function\r\n\t\t\t\t\t});\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region Final values for \"CMS_ENVELOPED_DATA\"\r\n\t\t\t\t\tthis.recipientInfos.push(new RecipientInfo({\r\n\t\t\t\t\t\tvariant: 4,\r\n\t\t\t\t\t\tvalue: keyInfo\r\n\t\t\t\t\t}));\r\n\t\t\t\t\t//endregion\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Unknown value for \"variant\": ${variant}`);\r\n\t\t}\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Add a \"RecipientInfo\" using a KeyAgreeRecipientInfo of type RecipientKeyIdentifier.\r\n\t * @param {CryptoKey} [key] Recipient's public key\r\n\t * @param {ArrayBuffer} [keyId] The id for the recipient's public key\r\n\t * @param {Object} [parameters] Additional parameters for \"fine tuning\" the encryption process\r\n\t */\r\n\taddRecipientByKeyIdentifier(key, keyId, parameters)\r\n\t{\r\n\t\t//region Initialize encryption parameters\r\n\t\tconst encryptionParameters = Object.assign({}, defaultEncryptionParams, parameters || {});\r\n\t\t//endregion\r\n\r\n\t\tconst recipientIdentifier = new KeyAgreeRecipientIdentifier({\r\n\t\t\tvariant: 2,\r\n\t\t\tvalue: new RecipientKeyIdentifier({\r\n\t\t\t\tsubjectKeyIdentifier: new asn1js.OctetString({valueHex: keyId}),\r\n\t\t\t})\r\n\t\t});\r\n\t\tthis._addKeyAgreeRecipientInfo(\r\n\t\t\trecipientIdentifier,\r\n\t\t\tencryptionParameters,\r\n\t\t\t{recipientPublicKey: key}\r\n\t\t);\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Add a \"RecipientInfo\" using a KeyAgreeRecipientInfo of type RecipientKeyIdentifier.\r\n\t * @param {KeyAgreeRecipientIdentifier} [recipientIdentifier] Recipient identifier\r\n\t * @param {Object} [encryptionParameters] Additional parameters for \"fine tuning\" the encryption process\r\n\t * @param {Object} [extraRecipientInfoParams] Additional params for KeyAgreeRecipientInfo\r\n\t */\r\n\t_addKeyAgreeRecipientInfo(recipientIdentifier, encryptionParameters, extraRecipientInfoParams)\r\n\t{\r\n\t\t//region RecipientEncryptedKey\r\n\t\tconst encryptedKey = new RecipientEncryptedKey({\r\n\t\t\trid: recipientIdentifier\r\n\t\t\t// \"encryptedKey\" will be calculated in \"encrypt\" function\r\n\t\t});\r\n\t\t//endregion\r\n\r\n\t\t//region keyEncryptionAlgorithm\r\n\t\tconst aesKWoid = getOIDByAlgorithm({\r\n\t\t\tname: \"AES-KW\",\r\n\t\t\tlength: encryptionParameters.kekEncryptionLength\r\n\t\t});\r\n\t\tif (aesKWoid === \"\")\r\n\t\t\tthrow new Error(`Unknown length for key encryption algorithm: ${encryptionParameters.kekEncryptionLength}`);\r\n\r\n\t\tconst aesKW = new AlgorithmIdentifier({\r\n\t\t\talgorithmId: aesKWoid,\r\n\t\t});\r\n\t\t//endregion\r\n\r\n\t\t//region KeyAgreeRecipientInfo\r\n\t\tconst ecdhOID = getOIDByAlgorithm({\r\n\t\t\tname: \"ECDH\",\r\n\t\t\tkdf: encryptionParameters.kdfAlgorithm\r\n\t\t});\r\n\t\tif (ecdhOID === \"\")\r\n\t\t\tthrow new Error(`Unknown KDF algorithm: ${encryptionParameters.kdfAlgorithm}`);\r\n\r\n\t\t// In fact there is no need in so long UKM, but RFC2631\r\n\t\t// has requirement that \"UserKeyMaterial\" must be 512 bits long\r\n\t\tconst ukmBuffer = new ArrayBuffer(64);\r\n\t\tconst ukmView = new Uint8Array(ukmBuffer);\r\n\t\tgetRandomValues(ukmView); // Generate random values in 64 bytes long buffer\r\n\r\n\t\tconst recipientInfoParams = {\r\n\t\t\tversion: 3,\r\n\t\t\t// \"originator\" will be calculated in \"encrypt\" function because ephemeral key would be generated there\r\n\t\t\tukm: new asn1js.OctetString({valueHex: ukmBuffer}),\r\n\t\t\tkeyEncryptionAlgorithm: new AlgorithmIdentifier({\r\n\t\t\t\talgorithmId: ecdhOID,\r\n\t\t\t\talgorithmParams: aesKW.toSchema()\r\n\t\t\t}),\r\n\t\t\trecipientEncryptedKeys: new RecipientEncryptedKeys({\r\n\t\t\t\tencryptedKeys: [encryptedKey]\r\n\t\t\t})\r\n\t\t};\r\n\t\tconst keyInfo = new KeyAgreeRecipientInfo(Object.assign(recipientInfoParams, extraRecipientInfoParams));\r\n\t\t//endregion\r\n\r\n\t\t//region Final values for \"CMS_ENVELOPED_DATA\"\r\n\t\tthis.recipientInfos.push(new RecipientInfo({\r\n\t\t\tvariant: 2,\r\n\t\t\tvalue: keyInfo\r\n\t\t}));\r\n\t\t//endregion\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Create a new CMS Enveloped Data content with encrypted data\r\n\t * @param {Object} contentEncryptionAlgorithm WebCrypto algorithm. For the moment here could be only \"AES-CBC\" or \"AES-GCM\" algorithms.\r\n\t * @param {ArrayBuffer} contentToEncrypt Content to encrypt\r\n\t * @returns {Promise}\r\n\t */\r\n\tencrypt(contentEncryptionAlgorithm, contentToEncrypt)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tlet sequence = Promise.resolve();\r\n\r\n\t\tconst ivBuffer = new ArrayBuffer(16); // For AES we need IV 16 bytes long\r\n\t\tconst ivView = new Uint8Array(ivBuffer);\r\n\t\tgetRandomValues(ivView);\r\n\r\n\t\tconst contentView = new Uint8Array(contentToEncrypt);\r\n\r\n\t\tlet sessionKey;\r\n\t\tlet encryptedContent;\r\n\t\tlet exportedSessionKey;\r\n\r\n\t\tconst recipientsPromises = [];\r\n\r\n\t\tconst _this = this;\r\n\t\t//endregion\r\n\r\n\t\t//region Check for input parameters\r\n\t\tconst contentEncryptionOID = getOIDByAlgorithm(contentEncryptionAlgorithm);\r\n\t\tif(contentEncryptionOID === \"\")\r\n\t\t\treturn Promise.reject(\"Wrong \\\"contentEncryptionAlgorithm\\\" value\");\r\n\t\t//endregion\r\n\r\n\t\t//region Get a \"crypto\" extension\r\n\t\tconst crypto = getCrypto();\r\n\t\tif(typeof crypto === \"undefined\")\r\n\t\t\treturn Promise.reject(\"Unable to create WebCrypto object\");\r\n\t\t//endregion\r\n\r\n\t\t//region Generate new content encryption key\r\n\t\tsequence = sequence.then(() =>\r\n\t\t\tcrypto.generateKey(contentEncryptionAlgorithm, true, [\"encrypt\"]));\r\n\t\t//endregion\r\n\t\t//region Encrypt content\r\n\t\tsequence = sequence.then(result =>\r\n\t\t{\r\n\t\t\tsessionKey = result;\r\n\r\n\t\t\treturn crypto.encrypt({\r\n\t\t\t\tname: contentEncryptionAlgorithm.name,\r\n\t\t\t\tiv: ivView\r\n\t\t\t},\r\n\t\t\tsessionKey,\r\n\t\t\tcontentView);\r\n\t\t}, error =>\r\n\t\t\tPromise.reject(error));\r\n\t\t//endregion\r\n\t\t//region Export raw content of content encryption key\r\n\t\tsequence = sequence.then(result =>\r\n\t\t{\r\n\t\t\t//region Create output OCTETSTRING with encrypted content\r\n\t\t\tencryptedContent = result;\r\n\t\t\t//endregion\r\n\r\n\t\t\treturn crypto.exportKey(\"raw\", sessionKey);\r\n\t\t}, error =>\r\n\t\t\tPromise.reject(error)\r\n\t\t).then(result =>\r\n\t\t{\r\n\t\t\texportedSessionKey = result;\r\n\r\n\t\t\treturn true;\r\n\t\t}, error =>\r\n\t\t\tPromise.reject(error));\r\n\t\t//endregion\r\n\t\t//region Append common information to CMS_ENVELOPED_DATA\r\n\t\tsequence = sequence.then(() =>\r\n\t\t{\r\n\t\t\tthis.version = 2;\r\n\t\t\tthis.encryptedContentInfo = new EncryptedContentInfo({\r\n\t\t\t\tcontentType: \"1.2.840.113549.1.7.1\", // \"data\"\r\n\t\t\t\tcontentEncryptionAlgorithm: new AlgorithmIdentifier({\r\n\t\t\t\t\talgorithmId: contentEncryptionOID,\r\n\t\t\t\t\talgorithmParams: new asn1js.OctetString({ valueHex: ivBuffer })\r\n\t\t\t\t}),\r\n\t\t\t\tencryptedContent: new asn1js.OctetString({ valueHex: encryptedContent })\r\n\t\t\t});\r\n\t\t}, error =>\r\n\t\t\tPromise.reject(error));\r\n\t\t//endregion\r\n\r\n\t\t//region Special sub-functions to work with each recipient's type\r\n\t\tfunction SubKeyAgreeRecipientInfo(index)\r\n\t\t{\r\n\t\t\t//region Initial variables\r\n\t\t\tlet currentSequence = Promise.resolve();\r\n\r\n\t\t\tconst recipientInfo = _this.recipientInfos[index];\r\n\r\n\t\t\tlet ecdhPublicKey;\r\n\t\t\tlet ecdhPrivateKey;\r\n\r\n\t\t\tlet recipientPublicKey;\r\n\t\t\tlet recipientCurve;\r\n\t\t\tlet recipientCurveLength;\r\n\r\n\t\t\tlet exportedECDHPublicKey;\r\n\t\t\t//endregion\r\n\r\n\t\t\t//region Get public key and named curve from recipient's certificate or public key\r\n\t\t\tcurrentSequence = currentSequence.then(() =>\r\n\t\t\t{\r\n\t\t\t\tif (recipientInfo.value.recipientPublicKey) {\r\n\t\t\t\t\trecipientCurve = recipientInfo.value.recipientPublicKey.algorithm.namedCurve;\r\n\t\t\t\t\treturn recipientInfo.value.recipientPublicKey;\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconst curveObject = recipientInfo.value.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;\r\n\r\n\t\t\t\t\tif (curveObject.constructor.blockName() !== asn1js.ObjectIdentifier.blockName())\r\n\t\t\t\t\t\treturn Promise.reject(`Incorrect \"recipientCertificate\" for index ${index}`);\r\n\r\n\t\t\t\t\tconst curveOID = curveObject.valueBlock.toString();\r\n\r\n\t\t\t\t\tswitch (curveOID) {\r\n\t\t\t\t\t\tcase \"1.2.840.10045.3.1.7\":\r\n\t\t\t\t\t\t\trecipientCurve = \"P-256\";\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"1.3.132.0.34\":\r\n\t\t\t\t\t\t\trecipientCurve = \"P-384\";\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"1.3.132.0.35\":\r\n\t\t\t\t\t\t\trecipientCurve = \"P-521\";\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\treturn Promise.reject(`Incorrect curve OID for index ${index}`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn recipientInfo.value.recipientCertificate.getPublicKey({\r\n\t\t\t\t\t\talgorithm: {\r\n\t\t\t\t\t\t\talgorithm: {\r\n\t\t\t\t\t\t\t\tname: \"ECDH\",\r\n\t\t\t\t\t\t\t\tnamedCurve: recipientCurve\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tusages: []\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error));\r\n\t\t\t//endregion\r\n\r\n\t\t\t//region Generate ephemeral ECDH key\r\n\t\t\tcurrentSequence = currentSequence.then(result => {\r\n\t\t\t\trecipientPublicKey = result;\r\n\t\t\t\trecipientCurveLength = curveLengthByName[recipientCurve];\r\n\r\n\t\t\t\treturn crypto.generateKey(\r\n\t\t\t\t\t{name: \"ECDH\", namedCurve: recipientCurve},\r\n\t\t\t\t\ttrue,\r\n\t\t\t\t\t[\"deriveBits\"]\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\terror =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Export public key of ephemeral ECDH key pair\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t{\r\n\t\t\t\tecdhPublicKey = result.publicKey;\r\n\t\t\t\tecdhPrivateKey = result.privateKey;\r\n\r\n\t\t\t\treturn crypto.exportKey(\"spki\", ecdhPublicKey);\r\n\t\t\t},\r\n\t\t\terror =>\r\n\t\t\t\tPromise.reject(error));\r\n\t\t\t//endregion\r\n\r\n\t\t\t//region Save public key of ephemeral ECDH key pair\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t{\r\n\t\t\t\texportedECDHPublicKey = result;\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error));\r\n\t\t\t//endregion\r\n\t\t\t//region Create shared secret\r\n\t\t\tcurrentSequence = currentSequence.then(() => crypto.deriveBits({\r\n\t\t\t\tname: \"ECDH\",\r\n\t\t\t\tpublic: recipientPublicKey\r\n\t\t\t},\r\n\t\t\tecdhPrivateKey,\r\n\t\t\trecipientCurveLength),\r\n\t\t\terror =>\r\n\t\t\t\tPromise.reject(error));\r\n\t\t\t//endregion\r\n\r\n\t\t\t//region Apply KDF function to shared secret\r\n\t\t\tcurrentSequence = currentSequence.then(\r\n\t\t\t\t/**\r\n\t\t\t\t * @param {ArrayBuffer} result\r\n\t\t\t\t */\r\n\t\t\t\tresult =>\r\n\t\t\t\t{\r\n\t\t\t\t\t//region Get length of used AES-KW algorithm\r\n\t\t\t\t\tconst aesKWAlgorithm = new AlgorithmIdentifier({ schema: recipientInfo.value.keyEncryptionAlgorithm.algorithmParams });\r\n\r\n\t\t\t\t\tconst KWalgorithm = getAlgorithmByOID(aesKWAlgorithm.algorithmId);\r\n\t\t\t\t\tif((\"name\" in KWalgorithm) === false)\r\n\t\t\t\t\t\treturn Promise.reject(`Incorrect OID for key encryption algorithm: ${aesKWAlgorithm.algorithmId}`);\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region Translate AES-KW length to ArrayBuffer\r\n\t\t\t\t\tlet kwLength = KWalgorithm.length;\r\n\r\n\t\t\t\t\tconst kwLengthBuffer = new ArrayBuffer(4);\r\n\t\t\t\t\tconst kwLengthView = new Uint8Array(kwLengthBuffer);\r\n\r\n\t\t\t\t\tfor(let j = 3; j >= 0; j--)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tkwLengthView[j] = kwLength;\r\n\t\t\t\t\t\tkwLength >>= 8;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region Create and encode \"ECC-CMS-SharedInfo\" structure\r\n\t\t\t\t\tconst eccInfo = new ECCCMSSharedInfo({\r\n\t\t\t\t\t\tkeyInfo: new AlgorithmIdentifier({\r\n\t\t\t\t\t\t\talgorithmId: aesKWAlgorithm.algorithmId\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t\tentityUInfo: recipientInfo.value.ukm,\r\n\t\t\t\t\t\tsuppPubInfo: new asn1js.OctetString({ valueHex: kwLengthBuffer })\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tconst encodedInfo = eccInfo.toSchema().toBER(false);\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\t//region Get SHA algorithm used together with ECDH\r\n\t\t\t\t\tconst ecdhAlgorithm = getAlgorithmByOID(recipientInfo.value.keyEncryptionAlgorithm.algorithmId);\r\n\t\t\t\t\tif((\"name\" in ecdhAlgorithm) === false)\r\n\t\t\t\t\t\treturn Promise.reject(`Incorrect OID for key encryption algorithm: ${recipientInfo.value.keyEncryptionAlgorithm.algorithmId}`);\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\t\treturn kdf(ecdhAlgorithm.kdf, result, KWalgorithm.length, encodedInfo);\r\n\t\t\t\t},\r\n\t\t\t\terror =>\r\n\t\t\t\t\tPromise.reject(error));\r\n\t\t\t//endregion\r\n\t\t\t//region Import AES-KW key from result of KDF function\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t\tcrypto.importKey(\"raw\", result, { name: \"AES-KW\" }, true, [\"wrapKey\"]),\r\n\t\t\terror =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Finally wrap session key by using AES-KW algorithm\r\n\t\t\tcurrentSequence = currentSequence.then(result => crypto.wrapKey(\"raw\", sessionKey, result, { name: \"AES-KW\" }),\r\n\t\t\t\terror =>\r\n\t\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Append all neccessary data to current CMS_RECIPIENT_INFO object\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t{\r\n\t\t\t\t//region OriginatorIdentifierOrKey\r\n\t\t\t\tconst asn1 = asn1js.fromBER(exportedECDHPublicKey);\r\n\r\n\t\t\t\tconst originator = new OriginatorIdentifierOrKey();\r\n\t\t\t\toriginator.variant = 3;\r\n\t\t\t\toriginator.value = new OriginatorPublicKey({ schema: asn1.result });\r\n\r\n\t\t\t\trecipientInfo.value.originator = originator;\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\t//region RecipientEncryptedKey\r\n\t\t\t\t/*\r\n\t\t\t\t We will not support using of same ephemeral key for many recipients\r\n\t\t\t\t */\r\n\t\t\t\trecipientInfo.value.recipientEncryptedKeys.encryptedKeys[0].encryptedKey = new asn1js.OctetString({ valueHex: result });\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\treturn {ecdhPrivateKey};\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\r\n\t\t\treturn currentSequence;\r\n\t\t}\r\n\r\n\t\tasync function SubKeyTransRecipientInfo(index)\r\n\t\t{\r\n\t\t\tconst algorithmParameters = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\r\n\t\t\tif(\"name\" in algorithmParameters === false)\r\n\t\t\t\tthrow new Error(`Unknown keyEncryptionAlgorithm: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);\r\n\r\n\t\t\t//region RSA-OAEP case\r\n\t\t\tif(algorithmParameters.name === \"RSA-OAEP\")\r\n\t\t\t{\r\n\t\t\t\tconst schema = _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams;\r\n\t\t\t\tconst rsaOAEPParams = new RSAESOAEPParams({ schema });\r\n\r\n\t\t\t\talgorithmParameters.hash = getAlgorithmByOID(rsaOAEPParams.hashAlgorithm.algorithmId);\r\n\t\t\t\tif((\"name\" in algorithmParameters.hash) === false)\r\n\t\t\t\t\tthrow new Error(`Incorrect OID for hash algorithm: ${rsaOAEPParams.hashAlgorithm.algorithmId}`);\r\n\t\t\t}\r\n\t\t\t//endregion\r\n\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tconst publicKey = await _this.recipientInfos[index].value.recipientCertificate.getPublicKey({\r\n\t\t\t\t\talgorithm: {\r\n\t\t\t\t\t\talgorithm: algorithmParameters,\r\n\t\t\t\t\t\tusages: [\"encrypt\", \"wrapKey\"]\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tconst encryptedKey = await crypto.encrypt(publicKey.algorithm, publicKey, exportedSessionKey);\r\n\r\n\t\t\t\t//region RecipientEncryptedKey\r\n\t\t\t\t_this.recipientInfos[index].value.encryptedKey = new asn1js.OctetString({valueHex: encryptedKey});\r\n\t\t\t\t//endregion\r\n\t\t\t}\r\n\t\t\tcatch(ex)\r\n\t\t\t{\r\n\t\t\t\tconst jjj = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction SubKEKRecipientInfo(index)\r\n\t\t{\r\n\t\t\t//region Initial variables\r\n\t\t\tlet currentSequence = Promise.resolve();\r\n\t\t\tlet kekAlgorithm;\r\n\t\t\t//endregion\r\n\r\n\t\t\t//region Import KEK from pre-defined data\r\n\t\t\tcurrentSequence = currentSequence.then(() =>\r\n\t\t\t{\r\n\t\t\t\t//region Get WebCrypto form of \"keyEncryptionAlgorithm\"\r\n\t\t\t\tkekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\r\n\t\t\t\tif((\"name\" in kekAlgorithm) === false)\r\n\t\t\t\t\treturn Promise.reject(`Incorrect OID for \"keyEncryptionAlgorithm\": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\treturn crypto.importKey(\"raw\",\r\n\t\t\t\t\tnew Uint8Array(_this.recipientInfos[index].value.preDefinedKEK),\r\n\t\t\t\t\tkekAlgorithm,\r\n\t\t\t\t\ttrue,\r\n\t\t\t\t\t[\"wrapKey\"]); // Too specific for AES-KW\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\r\n\t\t\t//region Wrap previously exported session key\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t\tcrypto.wrapKey(\"raw\", sessionKey, result, kekAlgorithm),\r\n\t\t\terror =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Append all neccessary data to current CMS_RECIPIENT_INFO object\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t{\r\n\t\t\t\t//region RecipientEncryptedKey\r\n\t\t\t\t_this.recipientInfos[index].value.encryptedKey = new asn1js.OctetString({ valueHex: result });\r\n\t\t\t\t//endregion\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\r\n\t\t\treturn currentSequence;\r\n\t\t}\r\n\r\n\t\tfunction SubPasswordRecipientinfo(index)\r\n\t\t{\r\n\t\t\t//region Initial variables\r\n\t\t\tlet currentSequence = Promise.resolve();\r\n\t\t\tlet pbkdf2Params;\r\n\t\t\tlet kekAlgorithm;\r\n\t\t\t//endregion\r\n\r\n\t\t\t//region Check that we have encoded \"keyDerivationAlgorithm\" plus \"PBKDF2_params\" in there\r\n\t\t\tcurrentSequence = currentSequence.then(() =>\r\n\t\t\t{\r\n\t\t\t\tif((\"keyDerivationAlgorithm\" in _this.recipientInfos[index].value) === false)\r\n\t\t\t\t\treturn Promise.reject(\"Please append encoded \\\"keyDerivationAlgorithm\\\"\");\r\n\r\n\t\t\t\tif((\"algorithmParams\" in _this.recipientInfos[index].value.keyDerivationAlgorithm) === false)\r\n\t\t\t\t\treturn Promise.reject(\"Incorrectly encoded \\\"keyDerivationAlgorithm\\\"\");\r\n\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tpbkdf2Params = new PBKDF2Params({ schema: _this.recipientInfos[index].value.keyDerivationAlgorithm.algorithmParams });\r\n\t\t\t\t}\r\n\t\t\t\tcatch(ex)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn Promise.reject(\"Incorrectly encoded \\\"keyDerivationAlgorithm\\\"\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn Promise.resolve();\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Derive PBKDF2 key from \"password\" buffer\r\n\t\t\tcurrentSequence = currentSequence.then(() =>\r\n\t\t\t{\r\n\t\t\t\tconst passwordView = new Uint8Array(_this.recipientInfos[index].value.password);\r\n\r\n\t\t\t\treturn crypto.importKey(\"raw\",\r\n\t\t\t\t\tpasswordView,\r\n\t\t\t\t\t\"PBKDF2\",\r\n\t\t\t\t\tfalse,\r\n\t\t\t\t\t[\"deriveKey\"]);\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Derive key for \"keyEncryptionAlgorithm\"\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t{\r\n\t\t\t\t//region Get WebCrypto form of \"keyEncryptionAlgorithm\"\r\n\t\t\t\tkekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\r\n\t\t\t\tif((\"name\" in kekAlgorithm) === false)\r\n\t\t\t\t\treturn Promise.reject(`Incorrect OID for \"keyEncryptionAlgorithm\": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\t//region Get HMAC hash algorithm\r\n\t\t\t\tlet hmacHashAlgorithm = \"SHA-1\";\r\n\r\n\t\t\t\tif(\"prf\" in pbkdf2Params)\r\n\t\t\t\t{\r\n\t\t\t\t\tconst algorithm = getAlgorithmByOID(pbkdf2Params.prf.algorithmId);\r\n\t\t\t\t\tif((\"name\" in algorithm) === false)\r\n\t\t\t\t\t\treturn Promise.reject(\"Incorrect OID for HMAC hash algorithm\");\r\n\r\n\t\t\t\t\thmacHashAlgorithm = algorithm.hash.name;\r\n\t\t\t\t}\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\t//region Get PBKDF2 \"salt\" value\r\n\t\t\t\tconst saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex);\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\t//region Get PBKDF2 iterations count\r\n\t\t\t\tconst iterations = pbkdf2Params.iterationCount;\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\treturn crypto.deriveKey({\r\n\t\t\t\t\tname: \"PBKDF2\",\r\n\t\t\t\t\thash: {\r\n\t\t\t\t\t\tname: hmacHashAlgorithm\r\n\t\t\t\t\t},\r\n\t\t\t\t\tsalt: saltView,\r\n\t\t\t\t\titerations\r\n\t\t\t\t},\r\n\t\t\t\tresult,\r\n\t\t\t\tkekAlgorithm,\r\n\t\t\t\ttrue,\r\n\t\t\t\t[\"wrapKey\"]); // Usages are too specific for KEK algorithm\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Wrap previously exported session key (Also too specific for KEK algorithm)\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t\tcrypto.wrapKey(\"raw\", sessionKey, result, kekAlgorithm),\r\n\t\t\terror =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Append all neccessary data to current CMS_RECIPIENT_INFO object\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t{\r\n\t\t\t\t//region RecipientEncryptedKey\r\n\t\t\t\t_this.recipientInfos[index].value.encryptedKey = new asn1js.OctetString({ valueHex: result });\r\n\t\t\t\t//endregion\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\r\n\t\t\treturn currentSequence;\r\n\t\t}\r\n\r\n\t\t//endregion\r\n\r\n\t\t//region Create special routines for each \"recipient\"\r\n\t\tsequence = sequence.then(() =>\r\n\t\t{\r\n\t\t\tfor(let i = 0; i < this.recipientInfos.length; i++)\r\n\t\t\t{\r\n\t\t\t\t//region Initial variables\r\n\t\t\t\tlet currentSequence = Promise.resolve();\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\tswitch(this.recipientInfos[i].variant)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase 1: // KeyTransRecipientInfo\r\n\t\t\t\t\t\tcurrentSequence = SubKeyTransRecipientInfo(i);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 2: // KeyAgreeRecipientInfo\r\n\t\t\t\t\t\tcurrentSequence = SubKeyAgreeRecipientInfo(i);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 3: // KEKRecipientInfo\r\n\t\t\t\t\t\tcurrentSequence = SubKEKRecipientInfo(i);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 4: // PasswordRecipientinfo\r\n\t\t\t\t\t\tcurrentSequence = SubPasswordRecipientinfo(i);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\treturn Promise.reject(`Uknown recipient type in array with index ${i}`);\r\n\t\t\t\t}\r\n\r\n\t\t\t\trecipientsPromises.push(currentSequence);\r\n\t\t\t}\r\n\r\n\t\t\treturn Promise.all(recipientsPromises);\r\n\t\t}, error =>\r\n\t\t\tPromise.reject(error)\r\n\t\t);\r\n\t\t//endregion\r\n\r\n\t\treturn sequence;\r\n\t}\r\n\t//**********************************************************************************\r\n\t/**\r\n\t * Decrypt existing CMS Enveloped Data content\r\n\t * @param {number} recipientIndex Index of recipient\r\n\t * @param {Object} parameters Additional parameters\r\n\t * @returns {Promise}\r\n\t */\r\n\tdecrypt(recipientIndex, parameters)\r\n\t{\r\n\t\t//region Initial variables\r\n\t\tlet sequence = Promise.resolve();\r\n\r\n\t\tconst decryptionParameters = parameters || {};\r\n\r\n\t\tconst _this = this;\r\n\t\t//endregion\r\n\r\n\t\t//region Check for input parameters\r\n\t\tif((recipientIndex + 1) > this.recipientInfos.length)\r\n\t\t\treturn Promise.reject(`Maximum value for \"index\" is: ${this.recipientInfos.length - 1}`);\r\n\t\t//endregion\r\n\r\n\t\t//region Get a \"crypto\" extension\r\n\t\tconst crypto = getCrypto();\r\n\t\tif(typeof crypto === \"undefined\")\r\n\t\t\treturn Promise.reject(\"Unable to create WebCrypto object\");\r\n\t\t//endregion\r\n\r\n\t\t//region Special sub-functions to work with each recipient's type\r\n\t\tfunction SubKeyAgreeRecipientInfo(index)\r\n\t\t{\r\n\t\t\t//region Initial variables\r\n\t\t\tlet currentSequence = Promise.resolve();\r\n\r\n\t\t\tlet recipientCurve;\r\n\t\t\tlet recipientCurveLength;\r\n\r\n\t\t\tlet curveOID;\r\n\r\n\t\t\tlet ecdhPrivateKey;\r\n\t\t\t//endregion\r\n\r\n\t\t\tconst originator = _this.recipientInfos[index].value.originator;\r\n\r\n\t\t\t//region Get \"namedCurve\" parameter from recipient's certificate\r\n\t\t\tcurrentSequence = currentSequence.then(() =>\r\n\t\t\t{\r\n\t\t\t\tif (\"recipientCertificate\" in decryptionParameters) {\r\n\t\t\t\t\tconst curveObject = decryptionParameters.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;\r\n\t\t\t\t\tif(curveObject.constructor.blockName() !== asn1js.ObjectIdentifier.blockName()) {\r\n\t\t\t\t\t\treturn Promise.reject(`Incorrect \"recipientCertificate\" for index ${index}`);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcurveOID = curveObject.valueBlock.toString();\r\n\t\t\t\t} else if (\"algorithmParams\" in originator.value.algorithm) {\r\n\t\t\t\t\tconst curveObject = originator.value.algorithm.algorithmParams;\r\n\t\t\t\t\tif(curveObject.constructor.blockName() !== asn1js.ObjectIdentifier.blockName()) {\r\n\t\t\t\t\t\treturn Promise.reject(`Incorrect originator for index ${index}`);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcurveOID = curveObject.valueBlock.toString();\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn Promise.reject(\"Parameter \\\"recipientCertificate\\\" is mandatory for \\\"KeyAgreeRecipientInfo\\\" if algorithm params are missing from originator\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif((\"recipientPrivateKey\" in decryptionParameters) === false)\r\n\t\t\t\t\treturn Promise.reject(\"Parameter \\\"recipientPrivateKey\\\" is mandatory for \\\"KeyAgreeRecipientInfo\\\"\");\r\n\r\n\t\t\t\tswitch(curveOID)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase \"1.2.840.10045.3.1.7\":\r\n\t\t\t\t\t\trecipientCurve = \"P-256\";\r\n\t\t\t\t\t\trecipientCurveLength = 256;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"1.3.132.0.34\":\r\n\t\t\t\t\t\trecipientCurve = \"P-384\";\r\n\t\t\t\t\t\trecipientCurveLength = 384;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"1.3.132.0.35\":\r\n\t\t\t\t\t\trecipientCurve = \"P-521\";\r\n\t\t\t\t\t\trecipientCurveLength = 528;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\treturn Promise.reject(`Incorrect curve OID for index ${index}`);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn crypto.importKey(\"pkcs8\",\r\n\t\t\t\t\tdecryptionParameters.recipientPrivateKey,\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tname: \"ECDH\",\r\n\t\t\t\t\t\tnamedCurve: recipientCurve\r\n\t\t\t\t\t},\r\n\t\t\t\t\ttrue,\r\n\t\t\t\t\t[\"deriveBits\"]\r\n\t\t\t\t);\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Import sender's ephemeral public key\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t{\r\n\t\t\t\tecdhPrivateKey = result;\r\n\r\n\t\t\t\t//region Change \"OriginatorPublicKey\" if \"curve\" parameter absent\r\n\t\t\t\tif((\"algorithmParams\" in originator.value.algorithm) === false)\r\n\t\t\t\t\toriginator.value.algorithm.algorithmParams = new asn1js.ObjectIdentifier({ value: curveOID });\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\t//region Create ArrayBuffer with sender's public key\r\n\t\t\t\tconst buffer = originator.value.toSchema().toBER(false);\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\treturn crypto.importKey(\"spki\",\r\n\t\t\t\t\tbuffer,\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tname: \"ECDH\",\r\n\t\t\t\t\t\tnamedCurve: recipientCurve\r\n\t\t\t\t\t},\r\n\t\t\t\t\ttrue,\r\n\t\t\t\t\t[]);\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Create shared secret\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t\tcrypto.deriveBits({\r\n\t\t\t\t\tname: \"ECDH\",\r\n\t\t\t\t\tpublic: result\r\n\t\t\t\t},\r\n\t\t\t\tecdhPrivateKey,\r\n\t\t\t\trecipientCurveLength),\r\n\t\t\terror =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Apply KDF function to shared secret\r\n\t\t\tfunction applyKDF(includeAlgorithmParams) {\r\n\t\t\t\tincludeAlgorithmParams = includeAlgorithmParams || false;\r\n\r\n\t\t\t\t//region Get length of used AES-KW algorithm\r\n\t\t\t\tconst aesKWAlgorithm = new AlgorithmIdentifier({ schema: _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams });\r\n\r\n\t\t\t\tconst KWalgorithm = getAlgorithmByOID(aesKWAlgorithm.algorithmId);\r\n\t\t\t\tif((\"name\" in KWalgorithm) === false)\r\n\t\t\t\t\treturn Promise.reject(`Incorrect OID for key encryption algorithm: ${aesKWAlgorithm.algorithmId}`);\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\t//region Translate AES-KW length to ArrayBuffer\r\n\t\t\t\tlet kwLength = KWalgorithm.length;\r\n\r\n\t\t\t\tconst kwLengthBuffer = new ArrayBuffer(4);\r\n\t\t\t\tconst kwLengthView = new Uint8Array(kwLengthBuffer);\r\n\r\n\t\t\t\tfor(let j = 3; j >= 0; j--)\r\n\t\t\t\t{\r\n\t\t\t\t\tkwLengthView[j] = kwLength;\r\n\t\t\t\t\tkwLength >>= 8;\r\n\t\t\t\t}\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\t//region Create and encode \"ECC-CMS-SharedInfo\" structure\r\n\t\t\t\tconst keyInfoAlgorithm = {\r\n\t\t\t\t\talgorithmId: aesKWAlgorithm.algorithmId\r\n\t\t\t\t};\r\n\t\t\t\tif (includeAlgorithmParams) {\r\n\t\t\t\t\tkeyInfoAlgorithm.algorithmParams = new asn1js.Null();\r\n\t\t\t\t}\r\n\t\t\t\tconst eccInfo = new ECCCMSSharedInfo({\r\n\t\t\t\t\tkeyInfo: new AlgorithmIdentifier(keyInfoAlgorithm),\r\n\t\t\t\t\tentityUInfo: _this.recipientInfos[index].value.ukm,\r\n\t\t\t\t\tsuppPubInfo: new asn1js.OctetString({ valueHex: kwLengthBuffer })\r\n\t\t\t\t});\r\n\r\n\t\t\t\tconst encodedInfo = eccInfo.toSchema().toBER(false);\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\t//region Get SHA algorithm used together with ECDH\r\n\t\t\t\tconst ecdhAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\r\n\t\t\t\tif((\"name\" in ecdhAlgorithm) === false)\r\n\t\t\t\t\treturn Promise.reject(`Incorrect OID for key encryption algorithm: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\treturn kdf(ecdhAlgorithm.kdf, sharedSecret, KWalgorithm.length, encodedInfo);\r\n\t\t\t}\r\n\t\t\tlet sharedSecret;\r\n\t\t\tcurrentSequence = currentSequence.then(\r\n\t\t\t\t/**\r\n\t\t\t\t * @param {ArrayBuffer} result\r\n\t\t\t\t */\r\n\t\t\t\tresult =>\r\n\t\t\t\t{\r\n\t\t\t\t\tsharedSecret = result;\r\n\t\t\t\t\treturn applyKDF();\r\n\t\t\t\t},\r\n\t\t\t\terror =>\r\n\t\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Import AES-KW key from result of KDF function\r\n\t\t\tfunction importAesKwKey(kdfResult) {\r\n\t\t\t\treturn crypto.importKey(\"raw\",\r\n\t\t\t\t\tkdfResult,\r\n\t\t\t\t\t{ name: \"AES-KW\" },\r\n\t\t\t\t\ttrue,\r\n\t\t\t\t\t[\"unwrapKey\"]\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tcurrentSequence = currentSequence.then(\r\n\t\t\t\timportAesKwKey,\r\n\t\t\t\terror => Promise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Finally unwrap session key\r\n\t\t\tfunction unwrapSessionKey(aesKwKey) {\r\n\t\t\t\t//region Get WebCrypto form of content encryption algorithm\r\n\t\t\t\tconst contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\r\n\t\t\t\tif((\"name\" in contentEncryptionAlgorithm) === false)\r\n\t\t\t\t\treturn Promise.reject(`Incorrect \"contentEncryptionAlgorithm\": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\treturn crypto.unwrapKey(\"raw\",\r\n\t\t\t\t\t_this.recipientInfos[index].value.recipientEncryptedKeys.encryptedKeys[0].encryptedKey.valueBlock.valueHex,\r\n\t\t\t\t\taesKwKey,\r\n\t\t\t\t\t{ name: \"AES-KW\" },\r\n\t\t\t\t\tcontentEncryptionAlgorithm,\r\n\t\t\t\t\ttrue,\r\n\t\t\t\t\t[\"decrypt\"]);\r\n\t\t\t}\r\n\t\t\tcurrentSequence = currentSequence.then(\r\n\t\t\t\tresult => unwrapSessionKey(result).catch(() => applyKDF(true).then(importAesKwKey).then(unwrapSessionKey)),\r\n\t\t\t\terror => Promise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\r\n\t\t\treturn currentSequence;\r\n\t\t}\r\n\r\n\t\tasync function SubKeyTransRecipientInfo(index)\r\n\t\t{\r\n\t\t\tif((\"recipientPrivateKey\" in decryptionParameters) === false)\r\n\t\t\t\tthrow new Error(\"Parameter \\\"recipientPrivateKey\\\" is mandatory for \\\"KeyTransRecipientInfo\\\"\");\r\n\r\n\t\t\tconst algorithmParameters = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\r\n\t\t\tif(\"name\" in algorithmParameters === false)\r\n\t\t\t\tthrow new Error(`Unknown keyEncryptionAlgorithm: ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);\r\n\r\n\t\t\t//region RSA-OAEP case\r\n\t\t\tif(algorithmParameters.name === \"RSA-OAEP\")\r\n\t\t\t{\r\n\t\t\t\tconst schema = _this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmParams;\r\n\t\t\t\tconst rsaOAEPParams = new RSAESOAEPParams({ schema });\r\n\r\n\t\t\t\talgorithmParameters.hash = getAlgorithmByOID(rsaOAEPParams.hashAlgorithm.algorithmId);\r\n\t\t\t\tif((\"name\" in algorithmParameters.hash) === false)\r\n\t\t\t\t\tthrow new Error(`Incorrect OID for hash algorithm: ${rsaOAEPParams.hashAlgorithm.algorithmId}`);\r\n\t\t\t}\r\n\t\t\t//endregion\r\n\r\n\t\t\tconst privateKey = await crypto.importKey(\r\n\t\t\t\t\"pkcs8\",\r\n\t\t\t\tdecryptionParameters.recipientPrivateKey,\r\n\t\t\t\talgorithmParameters,\r\n\t\t\t\ttrue,\r\n\t\t\t\t[\"decrypt\"]\r\n\t\t\t);\r\n\r\n\t\t\tconst sessionKey = await crypto.decrypt(\r\n\t\t\t\tprivateKey.algorithm,\r\n\t\t\t\tprivateKey,\r\n\t\t\t\t_this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex\r\n\t\t\t);\r\n\r\n\t\t\t//region Get WebCrypto form of content encryption algorithm\r\n\t\t\tconst contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\r\n\t\t\tif((\"name\" in contentEncryptionAlgorithm) === false)\r\n\t\t\t\tthrow new Error(`Incorrect \"contentEncryptionAlgorithm\": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);\r\n\t\t\t//endregion\r\n\r\n\t\t\treturn crypto.importKey(\"raw\",\r\n\t\t\t\tsessionKey,\r\n\t\t\t\tcontentEncryptionAlgorithm,\r\n\t\t\t\ttrue,\r\n\t\t\t\t[\"decrypt\"]\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tfunction SubKEKRecipientInfo(index)\r\n\t\t{\r\n\t\t\t//region Initial variables\r\n\t\t\tlet currentSequence = Promise.resolve();\r\n\t\t\tlet kekAlgorithm;\r\n\t\t\t//endregion\r\n\r\n\t\t\t//region Import KEK from pre-defined data\r\n\t\t\tcurrentSequence = currentSequence.then(() =>\r\n\t\t\t{\r\n\t\t\t\tif((\"preDefinedData\" in decryptionParameters) === false)\r\n\t\t\t\t\treturn Promise.reject(\"Parameter \\\"preDefinedData\\\" is mandatory for \\\"KEKRecipientInfo\\\"\");\r\n\r\n\t\t\t\t//region Get WebCrypto form of \"keyEncryptionAlgorithm\"\r\n\t\t\t\tkekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\r\n\t\t\t\tif((\"name\" in kekAlgorithm) === false)\r\n\t\t\t\t\treturn Promise.reject(`Incorrect OID for \"keyEncryptionAlgorithm\": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\treturn crypto.importKey(\"raw\",\r\n\t\t\t\t\tdecryptionParameters.preDefinedData,\r\n\t\t\t\t\tkekAlgorithm,\r\n\t\t\t\t\ttrue,\r\n\t\t\t\t\t[\"unwrapKey\"]); // Too specific for AES-KW\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Unwrap previously exported session key\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t{\r\n\t\t\t\t//region Get WebCrypto form of content encryption algorithm\r\n\t\t\t\tconst contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\r\n\t\t\t\tif((\"name\" in contentEncryptionAlgorithm) === false)\r\n\t\t\t\t\treturn Promise.reject(`Incorrect \"contentEncryptionAlgorithm\": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\treturn crypto.unwrapKey(\"raw\",\r\n\t\t\t\t\t_this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex,\r\n\t\t\t\t\tresult,\r\n\t\t\t\t\tkekAlgorithm,\r\n\t\t\t\t\tcontentEncryptionAlgorithm,\r\n\t\t\t\t\ttrue,\r\n\t\t\t\t\t[\"decrypt\"]);\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\r\n\t\t\treturn currentSequence;\r\n\t\t}\r\n\r\n\t\tfunction SubPasswordRecipientinfo(index)\r\n\t\t{\r\n\t\t\t//region Initial variables\r\n\t\t\tlet currentSequence = Promise.resolve();\r\n\t\t\tlet pbkdf2Params;\r\n\t\t\tlet kekAlgorithm;\r\n\t\t\t//endregion\r\n\r\n\t\t\t//region Derive PBKDF2 key from \"password\" buffer\r\n\t\t\tcurrentSequence = currentSequence.then(() =>\r\n\t\t\t{\r\n\t\t\t\tif((\"preDefinedData\" in decryptionParameters) === false)\r\n\t\t\t\t\treturn Promise.reject(\"Parameter \\\"preDefinedData\\\" is mandatory for \\\"KEKRecipientInfo\\\"\");\r\n\r\n\t\t\t\tif((\"keyDerivationAlgorithm\" in _this.recipientInfos[index].value) === false)\r\n\t\t\t\t\treturn Promise.reject(\"Please append encoded \\\"keyDerivationAlgorithm\\\"\");\r\n\r\n\t\t\t\tif((\"algorithmParams\" in _this.recipientInfos[index].value.keyDerivationAlgorithm) === false)\r\n\t\t\t\t\treturn Promise.reject(\"Incorrectly encoded \\\"keyDerivationAlgorithm\\\"\");\r\n\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tpbkdf2Params = new PBKDF2Params({ schema: _this.recipientInfos[index].value.keyDerivationAlgorithm.algorithmParams });\r\n\t\t\t\t}\r\n\t\t\t\tcatch(ex)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn Promise.reject(\"Incorrectly encoded \\\"keyDerivationAlgorithm\\\"\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn crypto.importKey(\"raw\",\r\n\t\t\t\t\tdecryptionParameters.preDefinedData,\r\n\t\t\t\t\t\"PBKDF2\",\r\n\t\t\t\t\tfalse,\r\n\t\t\t\t\t[\"deriveKey\"]);\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Derive key for \"keyEncryptionAlgorithm\"\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t{\r\n\t\t\t\t//region Get WebCrypto form of \"keyEncryptionAlgorithm\"\r\n\t\t\t\tkekAlgorithm = getAlgorithmByOID(_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId);\r\n\t\t\t\tif((\"name\" in kekAlgorithm) === false)\r\n\t\t\t\t\treturn Promise.reject(`Incorrect OID for \"keyEncryptionAlgorithm\": ${_this.recipientInfos[index].value.keyEncryptionAlgorithm.algorithmId}`);\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\t//region Get HMAC hash algorithm\r\n\t\t\t\tlet hmacHashAlgorithm = \"SHA-1\";\r\n\r\n\t\t\t\tif(\"prf\" in pbkdf2Params)\r\n\t\t\t\t{\r\n\t\t\t\t\tconst algorithm = getAlgorithmByOID(pbkdf2Params.prf.algorithmId);\r\n\t\t\t\t\tif((\"name\" in algorithm) === false)\r\n\t\t\t\t\t\treturn Promise.reject(\"Incorrect OID for HMAC hash algorithm\");\r\n\r\n\t\t\t\t\thmacHashAlgorithm = algorithm.hash.name;\r\n\t\t\t\t}\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\t//region Get PBKDF2 \"salt\" value\r\n\t\t\t\tconst saltView = new Uint8Array(pbkdf2Params.salt.valueBlock.valueHex);\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\t//region Get PBKDF2 iterations count\r\n\t\t\t\tconst iterations = pbkdf2Params.iterationCount;\r\n\t\t\t\t//endregion\r\n\r\n\t\t\t\treturn crypto.deriveKey({\r\n\t\t\t\t\tname: \"PBKDF2\",\r\n\t\t\t\t\thash: {\r\n\t\t\t\t\t\tname: hmacHashAlgorithm\r\n\t\t\t\t\t},\r\n\t\t\t\t\tsalt: saltView,\r\n\t\t\t\t\titerations\r\n\t\t\t\t},\r\n\t\t\t\tresult,\r\n\t\t\t\tkekAlgorithm,\r\n\t\t\t\ttrue,\r\n\t\t\t\t[\"unwrapKey\"]); // Usages are too specific for KEK algorithm\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\t\t\t//region Unwrap previously exported session key\r\n\t\t\tcurrentSequence = currentSequence.then(result =>\r\n\t\t\t{\r\n\t\t\t\t//region Get WebCrypto form of content encryption algorithm\r\n\t\t\t\tconst contentEncryptionAlgorithm = getAlgorithmByOID(_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\r\n\t\t\t\tif((\"name\" in contentEncryptionAlgorithm) === false)\r\n\t\t\t\t\treturn Promise.reject(`Incorrect \"contentEncryptionAlgorithm\": ${_this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);\r\n\t\t\t\t\t//endregion\r\n\r\n\t\t\t\treturn crypto.unwrapKey(\"raw\",\r\n\t\t\t\t\t_this.recipientInfos[index].value.encryptedKey.valueBlock.valueHex,\r\n\t\t\t\t\tresult,\r\n\t\t\t\t\tkekAlgorithm,\r\n\t\t\t\t\tcontentEncryptionAlgorithm,\r\n\t\t\t\t\ttrue,\r\n\t\t\t\t\t[\"decrypt\"]);\r\n\t\t\t}, error =>\r\n\t\t\t\tPromise.reject(error)\r\n\t\t\t);\r\n\t\t\t//endregion\r\n\r\n\t\t\treturn currentSequence;\r\n\t\t}\r\n\r\n\t\t//endregion\r\n\r\n\t\t//region Perform steps, specific to each type of session key encryption\r\n\t\tsequence = sequence.then(() =>\r\n\t\t{\r\n\t\t\t//region Initial variables\r\n\t\t\tlet currentSequence = Promise.resolve();\r\n\t\t\t//endregion\r\n\r\n\t\t\tswitch(this.recipientInfos[recipientIndex].variant)\r\n\t\t\t{\r\n\t\t\t\tcase 1: // KeyTransRecipientInfo\r\n\t\t\t\t\tcurrentSequence = SubKeyTransRecipientInfo(recipientIndex);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 2: // KeyAgreeRecipientInfo\r\n\t\t\t\t\tcurrentSequence = SubKeyAgreeRecipientInfo(recipientIndex);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 3: // KEKRecipientInfo\r\n\t\t\t\t\tcurrentSequence = SubKEKRecipientInfo(recipientIndex);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 4: // PasswordRecipientinfo\r\n\t\t\t\t\tcurrentSequence = SubPasswordRecipientinfo(recipientIndex);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn Promise.reject(`Uknown recipient type in array with index ${recipientIndex}`);\r\n\t\t\t}\r\n\r\n\t\t\treturn currentSequence;\r\n\t\t}, error =>\r\n\t\t\tPromise.reject(error)\r\n\t\t);\r\n\t\t//endregion\r\n\r\n\t\t//region Finally decrypt data by session key\r\n\t\tsequence = sequence.then(result =>\r\n\t\t{\r\n\t\t\t//region Get WebCrypto form of content encryption algorithm\r\n\t\t\tconst contentEncryptionAlgorithm = getAlgorithmByOID(this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);\r\n\t\t\tif((\"name\" in contentEncryptionAlgorithm) === false)\r\n\t\t\t\treturn Promise.reject(`Incorrect \"contentEncryptionAlgorithm\": ${this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);\r\n\t\t\t//endregion\r\n\r\n\t\t\t//region Get \"intialization vector\" for content encryption algorithm\r\n\t\t\tconst ivBuffer = this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams.valueBlock.valueHex;\r\n\t\t\tconst ivView = new Uint8Array(ivBuffer);\r\n\t\t\t//endregion\r\n\r\n\t\t\t//region Create correct data block for decryption\r\n\t\t\tlet dataBuffer = new ArrayBuffer(0);\r\n\r\n\t\t\tif(this.encryptedContentInfo.encryptedContent.idBlock.isConstructed === false)\r\n\t\t\t\tdataBuffer = this.encryptedContentInfo.encryptedContent.valueBlock.valueHex;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tfor(const content of this.encryptedContentInfo.encryptedContent.valueBlock.value)\r\n\t\t\t\t\tdataBuffer = utilConcatBuf(dataBuffer, content.valueBlock.valueHex);\r\n\t\t\t}\r\n\t\t\t//endregion\r\n\r\n\t\t\treturn crypto.decrypt({\r\n\t\t\t\tname: contentEncryptionAlgorithm.name,\r\n\t\t\t\tiv: ivView\r\n\t\t\t},\r\n\t\t\tresult,\r\n\t\t\tdataBuffer);\r\n\t\t}, error =>\r\n\t\t\tPromise.reject(error)\r\n\t\t);\r\n\t\t//endregion\r\n\r\n\t\treturn sequence;\r\n\t}\r\n\t//**********************************************************************************\r\n}\r\n//**************************************************************************************\r\n"]},"metadata":{},"sourceType":"module"}