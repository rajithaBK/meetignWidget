{"ast":null,"code":"\"use strict\";\n\nvar _Reflect$construct = require(\"@babel/runtime-corejs2/core-js/reflect/construct\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/createClass\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/getPrototypeOf\"));\n\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/json/stringify\"));\n\nvar _webexCore = require(\"@webex/webex-core\");\n\nvar _loggerProxy = _interopRequireDefault(require(\"../common/logs/logger-proxy\"));\n\nvar _constants = require(\"../constants\");\n\nvar _metrics = _interopRequireDefault(require(\"../metrics\"));\n\nvar _util = _interopRequireDefault(require(\"./util\"));\n\nvar _collection = _interopRequireDefault(require(\"./collection\"));\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2.default)(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;\n      result = _Reflect$construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0, _possibleConstructorReturn2.default)(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false;\n  if (_Reflect$construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar checkForAndHandleErrors = function checkForAndHandleErrors(action, meeting, correlationId) {\n  if (action && action.type) {\n    if (action.msg && action.msg.messageType && action.msg.errorType) {\n      if (_util.default.findError(action.msg.messageType, action.msg.errorType, action.type)) {\n        _util.default.handleError(meeting.mediaProperties.peerConnection).then(function (res) {\n          if (res) {\n            _collection.default.deleteSessionSequence(correlationId, action.msg.seq);\n          }\n        }).catch(function (err) {\n          _loggerProxy.default.logger.warn(\"Roap:handler#checkForAndHandleErrors --> Cannot reset the peer connection with error: \".concat(err));\n        });\n\n        return true;\n      }\n    }\n\n    if (!_util.default.ensureMeeting(meeting, action.type)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nvar compareWithLastRoapMessage = function compareWithLastRoapMessage(lastRoapMessage, currentRoapMessage) {\n  var _lastRoapMessage$msg, _lastRoapMessage$msg2;\n\n  return (lastRoapMessage === null || lastRoapMessage === void 0 ? void 0 : (_lastRoapMessage$msg = lastRoapMessage.msg) === null || _lastRoapMessage$msg === void 0 ? void 0 : _lastRoapMessage$msg.seq) === currentRoapMessage.msg.seq && (lastRoapMessage === null || lastRoapMessage === void 0 ? void 0 : (_lastRoapMessage$msg2 = lastRoapMessage.msg) === null || _lastRoapMessage$msg2 === void 0 ? void 0 : _lastRoapMessage$msg2.messageType) === currentRoapMessage.msg.messageType;\n};\n\nvar handleSessionStep = function handleSessionStep(_ref) {\n  var roap = _ref.roap,\n      session = _ref.session,\n      locusUrl = _ref.locusUrl,\n      correlationId = _ref.correlationId;\n  var _roap$msg = roap.msg,\n      sequenceId = _roap$msg.seq,\n      messageType = _roap$msg.messageType;\n\n  if (session.OFFER && messageType === _constants._OFFER_) {\n    session.GLARE_OFFER = roap.msg;\n    session.GLARE_OFFER.remote = !!roap.remote;\n    var metricName = _constants.BEHAVIORAL_METRICS.ROAP_GLARE_CONDITION;\n    var data = {\n      correlation_id: correlationId,\n      locus_id: locusUrl.split('/').pop(),\n      sequence: sequenceId\n    };\n\n    _metrics.default.sendBehavioralMetric(metricName, data);\n\n    _loggerProxy.default.logger.warn(\"Roap:handler#handleSessionStep --> Glare condition occurred with new mercury event, sequenceId: \".concat(sequenceId));\n  } else {\n    _loggerProxy.default.logger.info(\"Roap:handler#handleSessionStep --> Save OFFER/ANSWER seq:\".concat(sequenceId, \" new mercury event \").concat(messageType, \"local state: \").concat((0, _stringify.default)(session.state.state, null, 2)));\n\n    session[messageType] = roap.msg;\n    session[messageType].remote = !!roap.remote;\n  }\n};\n/**\n * @class RoapHandler\n */\n\n\nvar RoapHandler = /*#__PURE__*/function (_StatelessWebexPlugin) {\n  (0, _inherits2.default)(RoapHandler, _StatelessWebexPlugin);\n\n  var _super = _createSuper(RoapHandler);\n\n  function RoapHandler(attrs, options, roapOk, roapAnswer, roapFinished) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, RoapHandler);\n    _this = _super.call(this, {}, options);\n    _this.attrs = attrs;\n    _this.options = options;\n    _this.roapOk = roapOk;\n    _this.roapFinished = roapFinished;\n    _this.roapAnswer = roapAnswer;\n    _this.lastRoapMessage = null;\n    return _this;\n  }\n  /**\n   *\n   * @param {Object} session\n   * @param {Meeting} meeting\n   * @param {Object} action\n   * @returns {null}\n   */\n\n\n  (0, _createClass2.default)(RoapHandler, [{\n    key: \"perform\",\n    value: function perform(session, meeting, action) {\n      var _this2 = this;\n\n      switch (session.state.state) {\n        case _constants.ROAP.ROAP_STATE.INIT:\n          this.roapFinished(meeting.correlationId, action.msg.seq);\n          break;\n        // TODO:  (important )handle roap state for sending offers as well\n        // case ROAP.ROAP_STATE.WAIT_RX_OFFER:\n        // case ROAP.ROAP_STATE.WAIT_RX_ANSWER:\n        // case ROAP.ROAP_STATE.WAIT_RX_OK:\n\n        case _constants.ROAP.ROAP_STATE.WAIT_TX_ANSWER:\n          // eslint-disable-next-line no-warning-comments\n          // TODO: sometime the you get an answer while you are creating an offer so SKIP\n          // Server will send the mercury event comes back\n          if (_util.default.shouldHandleMedia(meeting)) {\n            _util.default.updatePeerConnection(meeting, session).then(function (answerSdps) {\n              _this2.roapAnswer({\n                locusId: meeting.locusId,\n                locusSelfId: meeting.locusInfo.self.id,\n                mediaId: meeting.mediaId,\n                sdps: answerSdps,\n                seq: session.OFFER.seq,\n                correlationId: meeting.correlationId,\n                audioMuted: meeting.isAudioMuted(),\n                videoMuted: meeting.isVideoMuted()\n              });\n            }).catch(function (error) {\n              var metricName = _constants.BEHAVIORAL_METRICS.ROAP_ANSWER_FAILURE;\n              var data = {\n                correlation_id: meeting.correlationId,\n                locus_id: meeting.locusUrl.split('/').pop(),\n                reason: error.message,\n                stack: error.stack\n              };\n              var metadata = {\n                type: error.name\n              };\n\n              _metrics.default.sendBehavioralMetric(metricName, data, metadata);\n\n              _loggerProxy.default.logger.error(\"Roap:handler#perform --> Error occured during wait receive answer, continuing, \".concat(error));\n            });\n          }\n\n          break;\n\n        case _constants.ROAP.ROAP_STATE.WAIT_TX_OK:\n          if (!_util.default.shouldHandleMedia(meeting)) {\n            _util.default.setRemoteDescription(meeting, session).then(function (res) {\n              _this2.roapOk(res);\n            });\n          }\n\n          break;\n        // case ROAP.ROAP_STATE.IDLE_LOCAL_OFFER:\n\n        case _constants.ROAP.ROAP_STATE.ERROR:\n          _loggerProxy.default.logger.error(\"Roap:handler#perform --> Roap State ERROR for session: \".concat(session));\n\n          break;\n\n        case _constants.ROAP.ROAP_STATE.GLARE:\n          session.GLARE_OFFER.tieBreaker = session.GLARE_OFFER.tieBreaker || 0;\n          session.OFFER.tieBreaker = session.OFFER.tieBreaker || 0;\n\n          _loggerProxy.default.logger.warn('Roap:handler#perform --> Roap State resolved the GLARE condition.');\n\n          if (session.GLARE_OFFER.tieBreaker < session.OFFER.tieBreaker) {\n            // 2\n            _loggerProxy.default.logger.log('Roap:handler#perform --> Roap State local offer won after GLARE.');\n          } else {\n            _loggerProxy.default.logger.log('Roap:handler#perform --> Roap State remote offer won after GLARE.');\n          }\n\n          session.state.step(_constants.ROAP.ROAP_SIGNAL.GLARE_RESOLVED, meeting, action);\n          this.perform(session, meeting);\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\n     *\n     * @param {String} signal\n     * @param {Object} session\n     * @param {Object} action\n     * @param {Meeting} meeting\n     * @param {String} prefix\n     * @returns {null}\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute(signal, session, action, meeting, prefix) {\n      if (session && session.state) {\n        handleSessionStep({\n          roap: action,\n          locusUrl: meeting.locusUrl,\n          correlationId: meeting.correlationId,\n          session: session\n        });\n        signal = _constants.ROAP.ROAP_SIGNAL[\"\".concat(prefix).concat(action.msg.messageType)];\n        session.state.step(signal, meeting, action);\n        this.perform(session, meeting, action);\n      }\n    }\n    /**\n     *\n     * @param {Object} session\n     * @param {Object} action\n     * @param {Meeting} meeting\n     * @param {String} correlationId\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"handleAction\",\n    value: function handleAction(session, action, meeting, correlationId) {\n      var signal;\n\n      switch (action.type) {\n        case _constants.ROAP.RECEIVE_ROAP_MSG:\n          _loggerProxy.default.logger.log(\"Roap:handler#handleAction --> RECEIVE_ROAP_MSG event captured, reciving a roap message : \".concat((0, _stringify.default)(action)));\n\n          if (compareWithLastRoapMessage(this.lastRoapMessage, action)) {\n            _loggerProxy.default.logger.warn(\"Roap:handler#handleAction --> duplicate roap offer from server: \".concat(action.msg.seq));\n          } else {\n            this.lastRoapMessage = action;\n            action.remote = true;\n            this.execute(signal, session, action, meeting, _constants.ROAP.RX_);\n          }\n\n          break;\n\n        case _constants.ROAP.SEND_ROAP_MSG:\n          _loggerProxy.default.logger.log(\"Roap:handler#handleAction --> SEND_ROAP_MSG event captured, sending roap message \".concat((0, _stringify.default)(action)));\n\n          action.local = true;\n          this.execute(signal, session, action, meeting, _constants.ROAP.TX_);\n          break;\n\n        case _constants.ROAP.SEND_ROAP_MSG_SUCCESS:\n          // NOTE: When server send back an answer via mercury the\n          // remote SDP is already saved sent and ok message is sent back\n          // We dont have to indicate the roapHandler about the RX_ANSWER via SEND_ROAP_MSG_SUCCESS\n          break;\n\n        case _constants.ROAP.RECEIVE_CALL_LEAVE:\n          _collection.default.deleteSession(correlationId);\n\n          _loggerProxy.default.logger.log(\"Roap:handler#handleAction --> RECEIVE_CALL_LEAVE event captured, cleaning up the RoapHandler for correlationId: \".concat(correlationId));\n\n          break;\n\n        case _constants.ROAP.RESET_ROAP_STATE:\n          _collection.default.deleteSessionSequence(correlationId, action.msg.seq);\n\n          _loggerProxy.default.logger.log(\"Roap:handler#handleAction --> RESET_ROAP_STATE event captured, resetting the RoapHandler state based on sequenceId: \".concat(action.msg.seq));\n\n          break;\n\n        default:\n          return true;\n      }\n\n      return true;\n    }\n    /**\n     *\n     * @param {Object} action\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"submit\",\n    value: function submit(action) {\n      var correlationId = action.correlationId;\n      var seq = action.seq;\n\n      if (!seq && action.msg) {\n        seq = action.msg.seq;\n      }\n\n      var session = _collection.default.getSessionSequence(correlationId, seq);\n\n      var meeting = this.webex.meetings.meetingCollection.getByKey('correlationId', correlationId);\n\n      if (checkForAndHandleErrors(action, meeting, correlationId)) {\n        return true;\n      }\n\n      return this.handleAction(session, action, meeting, correlationId);\n    }\n  }]);\n  return RoapHandler;\n}(_webexCore.StatelessWebexPlugin);\n\nexports.default = RoapHandler;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;AAEA;;AACA;;AACA;;AAEA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA,IAAMA,uBAAuB,GAAG,SAA1BA,uBAA0B,CAACC,MAAD,EAASC,OAAT,EAAkBC,aAAlB,EAAoC;AAClE,MAAIF,MAAM,IAAIA,MAAM,CAACG,IAArB,EAA2B;AACzB,QAAIH,MAAM,CAACI,GAAPJ,IAAcA,MAAM,CAACI,GAAPJ,CAAWK,WAAzBL,IAAwCA,MAAM,CAACI,GAAPJ,CAAWM,SAAvD,EAAkE;AAChE,UAAIC,cAASC,SAATD,CAAmBP,MAAM,CAACI,GAAPJ,CAAWK,WAA9BE,EAA2CP,MAAM,CAACI,GAAPJ,CAAWM,SAAtDC,EAAiEP,MAAM,CAACG,IAAxEI,CAAJ,EAAmF;AACjFA,sBAASE,WAATF,CAAqBN,OAAO,CAACS,eAART,CAAwBU,cAA7CJ,EACGK,IADHL,CACQ,UAACM,GAAD,EAAS;AACb,cAAIA,GAAJ,EAAS;AACPC,gCAAeC,qBAAfD,CAAqCZ,aAArCY,EAAoDd,MAAM,CAACI,GAAPJ,CAAWgB,GAA/DF;AACD;AAJL,WAMGG,KANHV,CAMS,UAACW,GAAD,EAAS;AACdC,+BAAYC,MAAZD,CAAmBE,IAAnBF,iGAAiHD,GAAjH;AAPJ;;AAUA,eAAO,IAAP;AACD;AACF;;AACD,QAAI,CAACX,cAASe,aAATf,CAAuBN,OAAvBM,EAAgCP,MAAM,CAACG,IAAvCI,CAAL,EAAmD;AACjD,aAAO,IAAP;AACD;AACF;;AAED,SAAO,KAAP;AAtBF;;AAyBA,IAAMgB,0BAA0B,GAAG,SAA7BA,0BAA6B,CAACC,eAAD,EAAkBC,kBAAlB;AAAA;;AAAA,SAAyC,gBAAe,SAAfD,mBAAe,WAAfA,mDAAe,CAAEpB,GAAjB,8EAAsBY,GAAtB,MAA8BS,kBAAkB,CAACrB,GAAnBqB,CAAuBT,GAArD,IAA4D,gBAAe,SAAfQ,mBAAe,WAAfA,oDAAe,CAAEpB,GAAjB,gFAAsBC,WAAtB,MAAsCoB,kBAAkB,CAACrB,GAAnBqB,CAAuBpB,WAAlK;AAAnC;;AAEA,IAAMqB,iBAAiB,GAAG,SAApBA,iBAAoB,OAEpB;AAAA,MADJC,IACI,QADJA,IACI;AAAA,MADEC,OACF,QADEA,OACF;AAAA,MADWC,QACX,QADWA,QACX;AAAA,MADqB3B,aACrB,QADqBA,aACrB;AACJ,kBAAuCyB,IAAI,CAACvB,GAA5C;AAAA,MAAY0B,UAAZ,aAAOd,GAAP;AAAA,MAAwBX,WAAxB,aAAwBA,WAAxB;;AAEA,MAAIuB,OAAO,CAACG,KAARH,IAAiBvB,WAAW,KAAK2B,kBAArC,EAA8C;AAC5CJ,WAAO,CAACK,WAARL,GAAsBD,IAAI,CAACvB,GAA3BwB;AACAA,WAAO,CAACK,WAARL,CAAoBM,MAApBN,GAA6B,CAAC,CAACD,IAAI,CAACO,MAApCN;AACA,QAAMO,UAAU,GAAGC,8BAAmBC,oBAAtC;AACA,QAAMC,IAAI,GAAG;AACXC,oBAAc,EAAErC,aADL;AAEXsC,cAAQ,EAAEX,QAAQ,CAACY,KAATZ,CAAe,GAAfA,EAAoBa,GAApBb,EAFC;AAGXc,cAAQ,EAAEb;AAHC,KAAb;;AAMAc,qBAAQC,oBAARD,CAA6BT,UAA7BS,EAAyCN,IAAzCM;;AAEAzB,yBAAYC,MAAZD,CAAmBE,IAAnBF,2GAA2HW,UAA3H;AAZF,SAcK;AACHX,yBAAYC,MAAZD,CAAmB2B,IAAnB3B,oEAAoFW,UAApF,gCAAoHzB,WAApH,0BAA+I,wBAAeuB,OAAO,CAACmB,KAARnB,CAAcmB,KAA7B,EAAoC,IAApC,EAA0C,CAA1C,CAA/I;;AACAnB,WAAO,CAACvB,WAAD,CAAPuB,GAAuBD,IAAI,CAACvB,GAA5BwB;AACAA,WAAO,CAACvB,WAAD,CAAPuB,CAAqBM,MAArBN,GAA8B,CAAC,CAACD,IAAI,CAACO,MAArCN;AACD;AAvBH;AA0BA;AACA;AACA;;;IACqBoB,W;;;;;AACnB,uBAAYC,KAAZ,EAAmBC,OAAnB,EAA4BC,MAA5B,EAAoCC,UAApC,EAAgDC,YAAhD,EAA8D;AAAA;;AAAA;AAC5DC,8BAAM,EAAN,EAAUJ,OAAV;AACAI,UAAKL,KAAL,GAAaA,KAAb;AACAK,UAAKJ,OAAL,GAAeA,OAAf;AACAI,UAAKH,MAAL,GAAcA,MAAd;AACAG,UAAKD,YAAL,GAAoBA,YAApB;AACAC,UAAKF,UAAL,GAAkBA,UAAlB;AACAE,UAAK9B,eAAL,GAAuB,IAAvB;AAP4D;AAQ7D;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;;WACE,iBAAQI,OAAR,EAAiB3B,OAAjB,EAA0BD,MAA1B,EAAkC;AAAA;;AAChC,cAAQ4B,OAAO,CAACmB,KAARnB,CAAcmB,KAAtB;AACE,aAAKQ,gBAAKC,UAALD,CAAgBE,IAArB;AACE,eAAKJ,YAAL,CAAkBpD,OAAO,CAACC,aAA1B,EAAyCF,MAAM,CAACI,GAAPJ,CAAWgB,GAApD;AACA;AAEA;AACF;AACA;AACA;;AACA,aAAKuC,gBAAKC,UAALD,CAAgBG,cAArB;AACE;AACA;AACA;AACA,cAAInD,cAASoD,iBAATpD,CAA2BN,OAA3BM,CAAJ,EAAyC;AACvCA,0BAASqD,oBAATrD,CAA8BN,OAA9BM,EAAuCqB,OAAvCrB,EACGK,IADHL,CACQ,UAACsD,UAAD,EAAgB;AACpBC,oBAAI,CAACV,UAAL,CAAgB;AACdW,uBAAO,EAAE9D,OAAO,CAAC8D,OADH;AAEdC,2BAAW,EAAE/D,OAAO,CAACgE,SAARhE,CAAkBiE,IAAlBjE,CAAuBkE,EAFtB;AAGdC,uBAAO,EAAEnE,OAAO,CAACmE,OAHH;AAIdC,oBAAI,EAAER,UAJQ;AAKd7C,mBAAG,EAAEY,OAAO,CAACG,KAARH,CAAcZ,GALL;AAMdd,6BAAa,EAAED,OAAO,CAACC,aANT;AAOdoE,0BAAU,EAAErE,OAAO,CAACsE,YAARtE,EAPE;AAQduE,0BAAU,EAAEvE,OAAO,CAACwE,YAARxE;AARE,eAAhB;AAFJ,eAaGgB,KAbHV,CAaS,UAACmE,KAAD,EAAW;AAChB,kBAAMvC,UAAU,GAAGC,8BAAmBuC,mBAAtC;AACA,kBAAMrC,IAAI,GAAG;AACXC,8BAAc,EAAEtC,OAAO,CAACC,aADb;AAEXsC,wBAAQ,EAAEvC,OAAO,CAAC4B,QAAR5B,CAAiBwC,KAAjBxC,CAAuB,GAAvBA,EAA4ByC,GAA5BzC,EAFC;AAGX2E,sBAAM,EAAEF,KAAK,CAACG,OAHH;AAIXC,qBAAK,EAAEJ,KAAK,CAACI;AAJF,eAAb;AAMA,kBAAMC,QAAQ,GAAG;AACf5E,oBAAI,EAAEuE,KAAK,CAACM;AADG,eAAjB;;AAIApC,+BAAQC,oBAARD,CAA6BT,UAA7BS,EAAyCN,IAAzCM,EAA+CmC,QAA/CnC;;AACAzB,mCAAYC,MAAZD,CAAmBuD,KAAnBvD,0FAA2GuD,KAA3G;AA1BJ;AA4BD;;AACD;;AACF,aAAKnB,gBAAKC,UAALD,CAAgB0B,UAArB;AACE,cAAI,CAAC1E,cAASoD,iBAATpD,CAA2BN,OAA3BM,CAAL,EAA0C;AACxCA,0BAAS2E,oBAAT3E,CAA8BN,OAA9BM,EAAuCqB,OAAvCrB,EAAgDK,IAAhDL,CAAqD,UAACM,GAAD,EAAS;AAC5DiD,oBAAI,CAACX,MAAL,CAAYtC,GAAZ;AADF;AAGD;;AACD;AACF;;AACA,aAAK0C,gBAAKC,UAALD,CAAgB4B,KAArB;AACEhE,+BAAYC,MAAZD,CAAmBuD,KAAnBvD,kEAAmFS,OAAnF;;AACA;;AACF,aAAK2B,gBAAKC,UAALD,CAAgB6B,KAArB;AACExD,iBAAO,CAACK,WAARL,CAAoByD,UAApBzD,GAAiCA,OAAO,CAACK,WAARL,CAAoByD,UAApBzD,IAAkC,CAAnEA;AACAA,iBAAO,CAACG,KAARH,CAAcyD,UAAdzD,GAA2BA,OAAO,CAACG,KAARH,CAAcyD,UAAdzD,IAA4B,CAAvDA;;AACAT,+BAAYC,MAAZD,CAAmBE,IAAnBF,CAAwB,mEAAxBA;;AACA,cAAIS,OAAO,CAACK,WAARL,CAAoByD,UAApBzD,GAAiCA,OAAO,CAACG,KAARH,CAAcyD,UAAnD,EAA+D;AAC7D;AACAlE,iCAAYC,MAAZD,CAAmBmE,GAAnBnE,CAAuB,kEAAvBA;AAFF,iBAIK;AACHA,iCAAYC,MAAZD,CAAmBmE,GAAnBnE,CAAuB,mEAAvBA;AACD;;AACDS,iBAAO,CAACmB,KAARnB,CAAc2D,IAAd3D,CAAmB2B,gBAAKiC,WAALjC,CAAiBkC,cAApC7D,EAAoD3B,OAApD2B,EAA6D5B,MAA7D4B;AACA,eAAK8D,OAAL,CAAa9D,OAAb,EAAsB3B,OAAtB;AACA;;AACF;AACE;AAtEJ;AAwED;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,iBAAQ0F,MAAR,EAAgB/D,OAAhB,EAAyB5B,MAAzB,EAAiCC,OAAjC,EAA0C2F,MAA1C,EAAkD;AAChD,UAAIhE,OAAO,IAAIA,OAAO,CAACmB,KAAvB,EAA8B;AAC5BrB,yBAAiB,CAAC;AAChBC,cAAI,EAAE3B,MADU;AAEhB6B,kBAAQ,EAAE5B,OAAO,CAAC4B,QAFF;AAGhB3B,uBAAa,EAAED,OAAO,CAACC,aAHP;AAIhB0B,iBAAO,EAAPA;AAJgB,SAAD,CAAjBF;AAMAiE,cAAM,GAAGpC,gBAAKiC,WAALjC,WAAoBqC,MAApB,SAA6B5F,MAAM,CAACI,GAAPJ,CAAWK,WAAxC,EAATsF;AACA/D,eAAO,CAACmB,KAARnB,CAAc2D,IAAd3D,CAAmB+D,MAAnB/D,EAA2B3B,OAA3B2B,EAAoC5B,MAApC4B;AACA,aAAK8D,OAAL,CAAa9D,OAAb,EAAsB3B,OAAtB,EAA+BD,MAA/B;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,sBAAa4B,OAAb,EAAsB5B,MAAtB,EAA8BC,OAA9B,EAAuCC,aAAvC,EAAsD;AACpD,UAAIyF,MAAJ;;AAGA,cAAQ3F,MAAM,CAACG,IAAf;AACE,aAAKoD,gBAAKsC,gBAAV;AACE1E,+BAAYC,MAAZD,CAAmBmE,GAAnBnE,oGAAmH,wBAAenB,MAAf,CAAnH;;AACA,cAAIuB,0BAA0B,CAAC,KAAKC,eAAN,EAAuBxB,MAAvB,CAA9B,EAA8D;AAC5DmB,iCAAYC,MAAZD,CAAmBE,IAAnBF,2EAA2FnB,MAAM,CAACI,GAAPJ,CAAWgB,GAAtG;AADF,iBAGK;AACH,iBAAKQ,eAAL,GAAuBxB,MAAvB;AACAA,kBAAM,CAACkC,MAAPlC,GAAgB,IAAhBA;AACA,iBAAK8F,OAAL,CAAaH,MAAb,EAAqB/D,OAArB,EAA8B5B,MAA9B,EAAsCC,OAAtC,EAA+CsD,gBAAKwC,GAApD;AACD;;AACD;;AACF,aAAKxC,gBAAKyC,aAAV;AACE7E,+BAAYC,MAAZD,CAAmBmE,GAAnBnE,4FAA2G,wBAAenB,MAAf,CAA3G;;AAEAA,gBAAM,CAACiG,KAAPjG,GAAe,IAAfA;AACA,eAAK8F,OAAL,CAAaH,MAAb,EAAqB/D,OAArB,EAA8B5B,MAA9B,EAAsCC,OAAtC,EAA+CsD,gBAAK2C,GAApD;AACA;;AACF,aAAK3C,gBAAK4C,qBAAV;AACE;AACA;AACA;AACA;;AACF,aAAK5C,gBAAK6C,kBAAV;AACEtF,8BAAeuF,aAAfvF,CAA6BZ,aAA7BY;;AACAK,+BAAYC,MAAZD,CAAmBmE,GAAnBnE,2HAA0IjB,aAA1I;;AAA4J;;AAC9J,aAAKqD,gBAAK+C,gBAAV;AACExF,8BAAeC,qBAAfD,CAAqCZ,aAArCY,EAAoDd,MAAM,CAACI,GAAPJ,CAAWgB,GAA/DF;;AACAK,+BAAYC,MAAZD,CAAmBmE,GAAnBnE,+HAA8InB,MAAM,CAACI,GAAPJ,CAAWgB,GAAzJ;;AAAiK;;AACnK;AACE,iBAAO,IAAP;AA9BJ;;AAiCA,aAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;;WACE,gBAAOhB,MAAP,EAAe;AACb,UAAOE,aAAP,GAAwBF,MAAxB,CAAOE,aAAP;AACA,UAAKc,GAAL,GAAYhB,MAAZ,CAAKgB,GAAL;;AAEA,UAAI,CAACA,GAAD,IAAQhB,MAAM,CAACI,GAAnB,EAAwB;AACtBY,WAAG,GAAGhB,MAAM,CAACI,GAAPJ,CAAWgB,GAAjBA;AACD;;AACD,UAAMY,OAAO,GAAGd,oBAAeyF,kBAAfzF,CAAkCZ,aAAlCY,EAAiDE,GAAjDF,CAAhB;;AACA,UAAMb,OAAO,GAAG,KAAKuG,KAAL,CAAWC,QAAX,CAAoBC,iBAApB,CAAsCC,QAAtC,CAA+C,eAA/C,EAAgEzG,aAAhE,CAAhB;;AAEA,UAAIH,uBAAuB,CAACC,MAAD,EAASC,OAAT,EAAkBC,aAAlB,CAA3B,EAA6D;AAC3D,eAAO,IAAP;AACD;;AAED,aAAO,KAAK0G,YAAL,CAAkBhF,OAAlB,EAA2B5B,MAA3B,EAAmCC,OAAnC,EAA4CC,aAA5C,CAAP;AACD;;;EAxLsC2G,+B","names":["checkForAndHandleErrors","action","meeting","correlationId","type","msg","messageType","errorType","RoapUtil","findError","handleError","mediaProperties","peerConnection","then","res","RoapCollection","deleteSessionSequence","seq","catch","err","LoggerProxy","logger","warn","ensureMeeting","compareWithLastRoapMessage","lastRoapMessage","currentRoapMessage","handleSessionStep","roap","session","locusUrl","sequenceId","OFFER","_OFFER_","GLARE_OFFER","remote","metricName","BEHAVIORAL_METRICS","ROAP_GLARE_CONDITION","data","correlation_id","locus_id","split","pop","sequence","Metrics","sendBehavioralMetric","info","state","RoapHandler","attrs","options","roapOk","roapAnswer","roapFinished","_this","ROAP","ROAP_STATE","INIT","WAIT_TX_ANSWER","shouldHandleMedia","updatePeerConnection","answerSdps","_this2","locusId","locusSelfId","locusInfo","self","id","mediaId","sdps","audioMuted","isAudioMuted","videoMuted","isVideoMuted","error","ROAP_ANSWER_FAILURE","reason","message","stack","metadata","name","WAIT_TX_OK","setRemoteDescription","ERROR","GLARE","tieBreaker","log","step","ROAP_SIGNAL","GLARE_RESOLVED","perform","signal","prefix","RECEIVE_ROAP_MSG","execute","RX_","SEND_ROAP_MSG","local","TX_","SEND_ROAP_MSG_SUCCESS","RECEIVE_CALL_LEAVE","deleteSession","RESET_ROAP_STATE","getSessionSequence","webex","meetings","meetingCollection","getByKey","handleAction","StatelessWebexPlugin"],"sources":["handler.js"],"sourcesContent":["/* no-param-reassign */\nimport {StatelessWebexPlugin} from '@webex/webex-core';\n\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport {ROAP, _OFFER_, BEHAVIORAL_METRICS} from '../constants';\nimport Metrics from '../metrics';\n\nimport RoapUtil from './util';\nimport RoapCollection from './collection';\n\n\nconst checkForAndHandleErrors = (action, meeting, correlationId) => {\n  if (action && action.type) {\n    if (action.msg && action.msg.messageType && action.msg.errorType) {\n      if (RoapUtil.findError(action.msg.messageType, action.msg.errorType, action.type)) {\n        RoapUtil.handleError(meeting.mediaProperties.peerConnection)\n          .then((res) => {\n            if (res) {\n              RoapCollection.deleteSessionSequence(correlationId, action.msg.seq);\n            }\n          })\n          .catch((err) => {\n            LoggerProxy.logger.warn(`Roap:handler#checkForAndHandleErrors --> Cannot reset the peer connection with error: ${err}`);\n          });\n\n        return true;\n      }\n    }\n    if (!RoapUtil.ensureMeeting(meeting, action.type)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst compareWithLastRoapMessage = (lastRoapMessage, currentRoapMessage) => lastRoapMessage?.msg?.seq === currentRoapMessage.msg.seq && lastRoapMessage?.msg?.messageType === currentRoapMessage.msg.messageType;\n\nconst handleSessionStep = ({\n  roap, session, locusUrl, correlationId\n}) => {\n  const {seq: sequenceId, messageType} = roap.msg;\n\n  if (session.OFFER && messageType === _OFFER_) {\n    session.GLARE_OFFER = roap.msg;\n    session.GLARE_OFFER.remote = !!roap.remote;\n    const metricName = BEHAVIORAL_METRICS.ROAP_GLARE_CONDITION;\n    const data = {\n      correlation_id: correlationId,\n      locus_id: locusUrl.split('/').pop(),\n      sequence: sequenceId\n    };\n\n    Metrics.sendBehavioralMetric(metricName, data);\n\n    LoggerProxy.logger.warn(`Roap:handler#handleSessionStep --> Glare condition occurred with new mercury event, sequenceId: ${sequenceId}`);\n  }\n  else {\n    LoggerProxy.logger.info(`Roap:handler#handleSessionStep --> Save OFFER/ANSWER seq:${sequenceId} new mercury event ${messageType}local state: ${JSON.stringify(session.state.state, null, 2)}`);\n    session[messageType] = roap.msg;\n    session[messageType].remote = !!roap.remote;\n  }\n};\n\n/**\n * @class RoapHandler\n */\nexport default class RoapHandler extends StatelessWebexPlugin {\n  constructor(attrs, options, roapOk, roapAnswer, roapFinished) {\n    super({}, options);\n    this.attrs = attrs;\n    this.options = options;\n    this.roapOk = roapOk;\n    this.roapFinished = roapFinished;\n    this.roapAnswer = roapAnswer;\n    this.lastRoapMessage = null;\n  }\n\n  /**\n   *\n   * @param {Object} session\n   * @param {Meeting} meeting\n   * @param {Object} action\n   * @returns {null}\n   */\n  perform(session, meeting, action) {\n    switch (session.state.state) {\n      case ROAP.ROAP_STATE.INIT:\n        this.roapFinished(meeting.correlationId, action.msg.seq);\n        break;\n\n        // TODO:  (important )handle roap state for sending offers as well\n      // case ROAP.ROAP_STATE.WAIT_RX_OFFER:\n      // case ROAP.ROAP_STATE.WAIT_RX_ANSWER:\n      // case ROAP.ROAP_STATE.WAIT_RX_OK:\n      case ROAP.ROAP_STATE.WAIT_TX_ANSWER:\n        // eslint-disable-next-line no-warning-comments\n        // TODO: sometime the you get an answer while you are creating an offer so SKIP\n        // Server will send the mercury event comes back\n        if (RoapUtil.shouldHandleMedia(meeting)) {\n          RoapUtil.updatePeerConnection(meeting, session)\n            .then((answerSdps) => {\n              this.roapAnswer({\n                locusId: meeting.locusId,\n                locusSelfId: meeting.locusInfo.self.id,\n                mediaId: meeting.mediaId,\n                sdps: answerSdps,\n                seq: session.OFFER.seq,\n                correlationId: meeting.correlationId,\n                audioMuted: meeting.isAudioMuted(),\n                videoMuted: meeting.isVideoMuted()\n              });\n            })\n            .catch((error) => {\n              const metricName = BEHAVIORAL_METRICS.ROAP_ANSWER_FAILURE;\n              const data = {\n                correlation_id: meeting.correlationId,\n                locus_id: meeting.locusUrl.split('/').pop(),\n                reason: error.message,\n                stack: error.stack\n              };\n              const metadata = {\n                type: error.name\n              };\n\n              Metrics.sendBehavioralMetric(metricName, data, metadata);\n              LoggerProxy.logger.error(`Roap:handler#perform --> Error occured during wait receive answer, continuing, ${error}`);\n            });\n        }\n        break;\n      case ROAP.ROAP_STATE.WAIT_TX_OK:\n        if (!RoapUtil.shouldHandleMedia(meeting)) {\n          RoapUtil.setRemoteDescription(meeting, session).then((res) => {\n            this.roapOk(res);\n          });\n        }\n        break;\n      // case ROAP.ROAP_STATE.IDLE_LOCAL_OFFER:\n      case ROAP.ROAP_STATE.ERROR:\n        LoggerProxy.logger.error(`Roap:handler#perform --> Roap State ERROR for session: ${session}`);\n        break;\n      case ROAP.ROAP_STATE.GLARE:\n        session.GLARE_OFFER.tieBreaker = session.GLARE_OFFER.tieBreaker || 0;\n        session.OFFER.tieBreaker = session.OFFER.tieBreaker || 0;\n        LoggerProxy.logger.warn('Roap:handler#perform --> Roap State resolved the GLARE condition.');\n        if (session.GLARE_OFFER.tieBreaker < session.OFFER.tieBreaker) {\n          // 2\n          LoggerProxy.logger.log('Roap:handler#perform --> Roap State local offer won after GLARE.');\n        }\n        else {\n          LoggerProxy.logger.log('Roap:handler#perform --> Roap State remote offer won after GLARE.');\n        }\n        session.state.step(ROAP.ROAP_SIGNAL.GLARE_RESOLVED, meeting, action);\n        this.perform(session, meeting);\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   *\n   * @param {String} signal\n   * @param {Object} session\n   * @param {Object} action\n   * @param {Meeting} meeting\n   * @param {String} prefix\n   * @returns {null}\n   */\n  execute(signal, session, action, meeting, prefix) {\n    if (session && session.state) {\n      handleSessionStep({\n        roap: action,\n        locusUrl: meeting.locusUrl,\n        correlationId: meeting.correlationId,\n        session\n      });\n      signal = ROAP.ROAP_SIGNAL[`${prefix}${action.msg.messageType}`];\n      session.state.step(signal, meeting, action);\n      this.perform(session, meeting, action);\n    }\n  }\n\n  /**\n   *\n   * @param {Object} session\n   * @param {Object} action\n   * @param {Meeting} meeting\n   * @param {String} correlationId\n   * @returns {Boolean}\n   */\n  handleAction(session, action, meeting, correlationId) {\n    let signal;\n\n\n    switch (action.type) {\n      case ROAP.RECEIVE_ROAP_MSG:\n        LoggerProxy.logger.log(`Roap:handler#handleAction --> RECEIVE_ROAP_MSG event captured, reciving a roap message : ${JSON.stringify(action)}`);\n        if (compareWithLastRoapMessage(this.lastRoapMessage, action)) {\n          LoggerProxy.logger.warn(`Roap:handler#handleAction --> duplicate roap offer from server: ${action.msg.seq}`);\n        }\n        else {\n          this.lastRoapMessage = action;\n          action.remote = true;\n          this.execute(signal, session, action, meeting, ROAP.RX_);\n        }\n        break;\n      case ROAP.SEND_ROAP_MSG:\n        LoggerProxy.logger.log(`Roap:handler#handleAction --> SEND_ROAP_MSG event captured, sending roap message ${JSON.stringify(action)}`);\n\n        action.local = true;\n        this.execute(signal, session, action, meeting, ROAP.TX_);\n        break;\n      case ROAP.SEND_ROAP_MSG_SUCCESS:\n        // NOTE: When server send back an answer via mercury the\n        // remote SDP is already saved sent and ok message is sent back\n        // We dont have to indicate the roapHandler about the RX_ANSWER via SEND_ROAP_MSG_SUCCESS\n        break;\n      case ROAP.RECEIVE_CALL_LEAVE:\n        RoapCollection.deleteSession(correlationId);\n        LoggerProxy.logger.log(`Roap:handler#handleAction --> RECEIVE_CALL_LEAVE event captured, cleaning up the RoapHandler for correlationId: ${correlationId}`); break;\n      case ROAP.RESET_ROAP_STATE:\n        RoapCollection.deleteSessionSequence(correlationId, action.msg.seq);\n        LoggerProxy.logger.log(`Roap:handler#handleAction --> RESET_ROAP_STATE event captured, resetting the RoapHandler state based on sequenceId: ${action.msg.seq}`); break;\n      default:\n        return true;\n    }\n\n    return true;\n  }\n\n  /**\n   *\n   * @param {Object} action\n   * @returns {Boolean}\n   */\n  submit(action) {\n    const {correlationId} = action;\n    let {seq} = action;\n\n    if (!seq && action.msg) {\n      seq = action.msg.seq;\n    }\n    const session = RoapCollection.getSessionSequence(correlationId, seq);\n    const meeting = this.webex.meetings.meetingCollection.getByKey('correlationId', correlationId);\n\n    if (checkForAndHandleErrors(action, meeting, correlationId)) {\n      return true;\n    }\n\n    return this.handleAction(session, action, meeting, correlationId);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}