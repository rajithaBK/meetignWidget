{"ast":null,"code":"\"use strict\";\n\nvar _Object$keys = require(\"@babel/runtime-corejs2/core-js/object/keys\");\n\nvar _Object$getOwnPropertySymbols = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\");\n\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\");\n\nvar _Object$getOwnPropertyDescriptors = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\");\n\nvar _Object$defineProperties = require(\"@babel/runtime-corejs2/core-js/object/define-properties\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _Array$from = require(\"@babel/runtime-corejs2/core-js/array/from\");\n\nvar _Symbol = require(\"@babel/runtime-corejs2/core-js/symbol\");\n\nvar _Symbol$iterator = require(\"@babel/runtime-corejs2/core-js/symbol/iterator\");\n\nvar _Array$isArray = require(\"@babel/runtime-corejs2/core-js/array/is-array\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime-corejs2/regenerator\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/json/stringify\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/defineProperty\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/asyncToGenerator\"));\n\nvar _cloneDeep2 = _interopRequireDefault(require(\"lodash/cloneDeep\"));\n\nvar _webexCore = require(\"@webex/webex-core\");\n\nvar _common = require(\"@webex/common\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof _Symbol !== \"undefined\" && o[_Symbol$iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (_Array$isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return _Array$from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = _Object$keys(object);\n\n  if (_Object$getOwnPropertySymbols) {\n    var symbols = _Object$getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return _Object$getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (_Object$getOwnPropertyDescriptors) {\n      _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar debug = require('debug')('rooms');\n/**\n * @typedef {Object} RoomObject\n * @property {string} id - (server generated) Unique identifier for the room\n * @property {string} title - The display name for the room. All room members\n * will see the title so make it something good\n * @property {string} teamId - (optional) The ID of the team to which the room\n * belongs\n * @property {isoDate} created - (server generated) The date and time that the\n * room was created\n */\n\n/**\n * Rooms are virtual meeting places for getting stuff done. This resource\n * represents the room itself. Check out the {@link Memberships} API to learn\n * how to add and remove people from rooms and the {@link Messages} API for\n * posting and managing content.\n * @class\n * @name Rooms\n */\n\n\nvar Rooms = _webexCore.WebexPlugin.extend({\n  /**\n   * Register to listen for incoming rooms events\n   * This is an alternate approach to registering for rooms webhooks.\n   * The events passed to any registered handlers will be similar to the webhook JSON,\n   * but will omit webhook specific fields such as name, secret, url, etc.\n   * To utilize the `listen()` method, the authorization token used\n   * will need to have `spark:all` and `spark:kms` scopes enabled.\n   * Note that by configuring your application to enable or disable `spark:all`\n   * via its configuration page will also enable or disable `spark:kms`.\n   * See the <a href=\"https://js.samples.s4d.io/browser-socket/\">Sample App</a>\n   * for more details.\n   * @instance\n   * @memberof Rooms\n   * @returns {Promise}\n   * @example\n   * webex.rooms.listen()\n   *   .then(() => {\n   *     console.log('listening to room events');\n   *     webex.rooms.on('created', (event) => console.log(`Got a room:created event:\\n${event}`);\n   *     webex.rooms.on('updated', (event) => console.log(`Got a room:updated event:\\n${event}`);\n   *   })\n   *   .catch((e) => console.error(`Unable to register for room events: ${e}`));\n   * // Some app logic...\n   * // WHen it is time to cleanup\n   * webex.rooms.stopListening();\n   * webex.rooms.off('created');\n   * webex.rooms.off('updated');\n   */\n  listen: function listen() {\n    var _this = this;\n\n    return (0, _common.createEventEnvelope)(this.webex, _common.SDK_EVENT.EXTERNAL.RESOURCE.ROOMS).then(function (envelope) {\n      _this.eventEnvelope = envelope;\n      return _this.webex.internal.mercury.connect().then(function () {\n        _this.listenTo(_this.webex.internal.mercury, _common.SDK_EVENT.INTERNAL.WEBEX_ACTIVITY, function (event) {\n          return _this.onWebexApiEvent(event);\n        });\n      });\n    });\n  },\n\n  /**\n   * Creates a new room. The authenticated user is automatically added as a\n   * member of the room. See the {@link Memberships} API to learn how to add\n   * more people to the room.\n   * @instance\n   * @memberof Rooms\n   * @param {RoomObject} room\n   * @returns {Promise<RoomObject>}\n   * @example\n   * webex.rooms.create({title: 'Create Room Example'})\n   *   .then(function(room) {\n   *     var assert = require('assert')\n   *     assert(typeof room.created === 'string');\n   *     assert(typeof room.id === 'string');\n   *     assert(room.title === 'Create Room Example');\n   *     console.log(room.title);\n   *     return 'success';\n   *   });\n   *   // => success\n   */\n  create: function create(room) {\n    return this.request({\n      method: 'POST',\n      service: 'hydra',\n      resource: 'rooms',\n      body: room\n    }).then(function (res) {\n      return res.body;\n    });\n  },\n\n  /**\n   * Returns a single room.\n   * @instance\n   * @memberof Rooms\n   * @param {RoomObject|string} room\n   * @param {Object} options\n   * @returns {Promise<RoomObject>}\n   * @example\n   * var room;\n   * webex.rooms.create({title: 'Get Room Example'})\n   *   .then(function(r) {\n   *     room = r\n   *     return webex.rooms.get(room.id)\n   *   })\n   *   .then(function(r) {\n   *     var assert = require('assert');\n   *     assert.deepEqual(r, room);\n   *     return 'success';\n   *   });\n   *   // => success\n   */\n  get: function get(room, options) {\n    var id = room.id || room;\n    return this.request({\n      service: 'hydra',\n      resource: \"rooms/\".concat(id),\n      qs: options\n    }).then(function (res) {\n      return res.body.items || res.body;\n    });\n  },\n\n  /**\n   * Returns a list of rooms. In most cases the results will only contain rooms\n   * that the authentiated user is a member of.\n   * @instance\n   * @memberof Rooms\n   * @param {Object} options\n   * @param {Object} options.max Limit the maximum number of rooms in the\n   * response.\n   * @returns {Promise<Page<RoomObject>>}\n   * @example\n   * var createdRooms;\n   * Promise.all([\n   *   webex.rooms.create({title: 'List Rooms Example 1'}),\n   *   webex.rooms.create({title: 'List Rooms Example 2'}),\n   *   webex.rooms.create({title: 'List Rooms Example 3'})\n   * ])\n   *   .then(function(r) {\n   *     createdRooms = r;\n   *     return webex.rooms.list({max: 3})\n   *       .then(function(rooms) {\n   *         var assert = require('assert');\n   *         assert(rooms.length === 3);\n   *         for (var i = 0; i < rooms.items.length; i+= 1) {\n   *           assert(createdRooms.filter(function(room) {\n   *             return room.id === rooms.items[i].id;\n   *           }).length === 1);\n   *         }\n   *         return 'success';\n   *       });\n   *   });\n   *   // => success\n   */\n  list: function list(options) {\n    var _this2 = this;\n\n    return this.request({\n      service: 'hydra',\n      resource: 'rooms/',\n      qs: options\n    }).then(function (res) {\n      return new _webexCore.Page(res, _this2.webex);\n    });\n  },\n\n  /**\n   * Returns a list of rooms with details about the data of the last\n   * actvity in the room, and the date of the users last presences in\n   * the room. The list is sorted with this with most recent activity first\n   *\n   * For rooms where lastActivityDate > lastSeenDate the space\n   * can be considerd to be \"unread\"\n   *\n   * This differs from the rooms.list() function in the following ways:\n   *  -- when called with no parameters it returns an array of all\n   *     spaces, up to 1000, that the user is a member of\n   *  -- pagination is not supported. ALL rooms are returned which\n   *     can result in a large payload\n   *  -- For users with hundreds of spaces, this API can take some time to\n   *     to return, for this reason it supports an optional maxRecent parameter.\n   *     If set this will return only the specified number of spaces with activity\n   *     in the last two weeks.  Reccomended value is 30.  Max supported is 100.\n   *  -- only \"id\", \"type\", \"lastActivityDate\", and \"lastSeenDate\" are\n   *     guaranteed to be available for each room in the list\n   *  -- \"title\" is usually returned, but not guaranteed\n   *\n   * In general this function should be used only when the client needs to\n   * access read status info, for example on startup.\n   * After startup, clients should track message and membership:seen events\n   * to maintain read status client side.\n   *\n   * Since this API can take some time to return up to 1000 spaces, it is\n   * recommended that custom clients call this first with the maxRecent parameter\n   * set to 30, so that they can display some of the more recents spaces.  Calling\n   * this API a second time with no parameters will return all the spaces.\n   *\n   * Not all spaces may be returned, for example when users in more than 1000\n   * spaces, or when a new spaces is added after this function is called,\n   * but before it returns. Custom clients should be prepared to gracefully\n   * andle cases where an event occurs in a space not returned by this call,\n   * by querying rooms.getWithReadStatus() with the id of the room in question\n   *\n   * This function may be deprecated when this info is provided in the membership\n   * objects returned in the list function.\n   * @instance\n   * @param {int} maxRecent\n   * @memberof Rooms\n   * @returns {Promise<RoomInfoObjectList>}\n   */\n  listWithReadStatus: function listWithReadStatus() {\n    var _arguments = arguments,\n        _this3 = this;\n\n    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {\n      var maxRecent, now, options;\n      return _regenerator.default.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              maxRecent = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : 0;\n              now = new Date();\n              options = {\n                activitiesLimit: 0,\n                computeTitleIfEmpty: true,\n                conversationsLimit: 1000,\n                isActive: true\n              };\n\n              if (!(maxRecent > 0)) {\n                _context.next = 8;\n                break;\n              }\n\n              options.conversationsLimit = maxRecent;\n              options.sinceDate = now.setDate(now.getDate() - 14);\n              _context.next = 10;\n              break;\n\n            case 8:\n              if (!(maxRecent < 0 || maxRecent > 100)) {\n                _context.next = 10;\n                break;\n              }\n\n              return _context.abrupt(\"return\", _promise.default.reject(new Error('rooms.listWithReadStatus: ' + 'optional maxRecent parameter must be an integer between 1 and 100')));\n\n            case 10:\n              return _context.abrupt(\"return\", _this3.webex.internal.services.waitForCatalog('postauth').then(function () {\n                return _this3.webex.internal.conversation.list(options);\n              }).then(function (conversations) {\n                return buildRoomInfoList(_this3.webex, conversations);\n              }));\n\n            case 11:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }))();\n  },\n\n  /**\n   * Returns a single room object with details about the data of the last\n   * actvity in the room, and the date of the users last presence in\n   * the room.\n   *\n   * For rooms where lastActivityDate > lastSeenDate the room\n   * can be considerd to be \"unread\"\n   *\n   * This differs from the rooms.get() function in the following ways:\n   *  -- it takes a single roomId parameter to fetch\n   *  -- no other options are considered\n   *  -- only \"id\", \"type\", \"lastActivityDate\", and \"lastSeenDate\" are\n   *     guaranteed to be available in the return object\n   *  -- \"title\" is usually returned, but not guaranteed\n   *\n   * In general clients should use the listWithReadStatus() method on startup\n   * to get the initial roomStatus and then update their client side copy by\n   * responding to message, membership and room events.\n    * This function allows a custom client to be \"nimble\" if it is responding\n   * to an event with a roomId that was not in the original fetch.  The\n   * anticipated behavior is that getWithReadStats is called \"just in time\",\n   * with the resulting room object being added to the list of cached room\n   * objects on the client side.\n   *\n   * This function may be deprecated when this info is provided in the room\n   * object returned in the get function.\n   * @instance\n   * @memberof Rooms\n   * @param {string} roomId\n   * @returns {Promise<RoomInfoObject>}\n   */\n  getWithReadStatus: function getWithReadStatus(roomId) {\n    var _this4 = this;\n\n    var deconstructedId = (0, _common.deconstructHydraId)(roomId);\n    var conversation = {\n      id: deconstructedId.id,\n      cluster: deconstructedId.cluster\n    };\n    return this.webex.internal.services.waitForCatalog('postauth').then(function () {\n      return _this4.webex.internal.conversation.get(conversation, {\n        computeTitleIfEmpty: true,\n        activitiesLimit: 0 // don't send the whole history of activity\n\n      }).then(function (convo) {\n        return buildRoomInfo(_this4.webex, convo);\n      });\n    });\n  },\n\n  /**\n   * Deletes a single room.\n   * @instance\n   * @memberof Rooms\n   * @param {RoomObject|string} room\n   * @returns {Promise}\n   * @example\n   * var room;\n   * webex.rooms.create({title: 'Remove Room Example'})\n   *  .then(function(r) {\n   *    room = r;\n   *    return webex.rooms.remove(room.id);\n   *  })\n   *  .then(function() {\n   *    return webex.rooms.get(room.id);\n   *  })\n   *  .then(function() {\n   *    var assert = require('assert');\n   *    assert(false, 'the previous get should have failed');\n   *  })\n   *  .catch(function(reason) {\n   *    var assert = require('assert');\n   *    assert.equal(reason.statusCode, 404);\n   *    return 'success'\n   *  });\n   *  // => success\n   */\n  remove: function remove(room) {\n    var id = room.id || room;\n    return this.request({\n      method: 'DELETE',\n      service: 'hydra',\n      resource: \"rooms/\".concat(id)\n    }).then(function (res) {\n      // Firefox has some issues with 204s and/or DELETE. This should move to\n      // http-core\n      if (res.statusCode === 204) {\n        return undefined;\n      }\n\n      return res.body;\n    });\n  },\n\n  /**\n   * Used to update a single room's properties.\n   * @instance\n   * @memberof Rooms\n   * @param {RoomObject} room\n   * @returns {Promise<RoomObject>}\n   * @example\n   * var room;\n   * webex.rooms.update({title: 'Update Room Example'})\n   *   .then(function(r) {\n   *     room = r;\n   *     room.title = 'Update Room Example (Updated Title)';\n   *     return webex.rooms.update(room);\n   *   })\n   *   .then(function() {\n   *     return webex.rooms.get(room.id);\n   *   })\n   *   .then(function(room) {\n   *    var assert = require('assert');\n   *     assert.equal(room.title, 'Update Room Example (Updated Title)');\n   *     return 'success';\n   *   });\n   *   // => success\n   */\n  update: function update(room) {\n    var id = room.id;\n    return this.request({\n      method: 'PUT',\n      service: 'hydra',\n      resource: \"rooms/\".concat(id),\n      body: room\n    }).then(function (res) {\n      return res.body;\n    });\n  },\n\n  /**\n   * This function is called when an internal membership events fires,\n   * if the user registered for these events with the listen() function.\n   * External users of the SDK should not call this function\n   * @private\n   * @memberof Rooms\n   * @param {Object} event\n   * @returns {void}\n   */\n  onWebexApiEvent: function onWebexApiEvent(event) {\n    var activity = event.data.activity;\n    /* eslint-disable no-case-declarations */\n\n    switch (activity.verb) {\n      case _common.SDK_EVENT.INTERNAL.ACTIVITY_VERB.CREATE:\n        var roomCreatedEvent = this.getRoomEvent(this.webex, activity, _common.SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED);\n\n        if (roomCreatedEvent) {\n          debug(\"room \\\"created\\\" payload:             \".concat((0, _stringify.default)(roomCreatedEvent)));\n          this.trigger(_common.SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED, roomCreatedEvent);\n        }\n\n        break;\n\n      case _common.SDK_EVENT.INTERNAL.ACTIVITY_VERB.UPDATE:\n      case _common.SDK_EVENT.INTERNAL.ACTIVITY_VERB.LOCK:\n      case _common.SDK_EVENT.INTERNAL.ACTIVITY_VERB.UNLOCK:\n        debug(\"generating a rooms:updated based on \".concat(activity.verb, \" activity\"));\n        var roomUpdatedEvent = this.getRoomEvent(this.webex, activity, _common.SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED);\n\n        if (roomUpdatedEvent) {\n          debug(\"room \\\"updated\\\" payload:             \".concat((0, _stringify.default)(roomUpdatedEvent)));\n          this.trigger(_common.SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED, roomUpdatedEvent);\n        }\n\n        break;\n\n      default:\n        break;\n    }\n  },\n\n  /**\n   * Constructs the data object for an event on the rooms resource,\n   * adhering to Hydra's Webehook data structure.\n   * External users of the SDK should not call this function\n   * @private\n   * @memberof Rooms\n   * @param {Object} webex sdk instance\n   * @param {Object} activity from mercury\n   * @param {Object} event type of \"webhook\" event\n   * @returns {Object} constructed event\n   */\n  getRoomEvent: function getRoomEvent(webex, activity, event) {\n    try {\n      var sdkEvent = (0, _cloneDeep2.default)(this.eventEnvelope);\n      var cluster = (0, _common.getHydraClusterString)(webex, activity.url);\n      var tags = activity.object.tags;\n      sdkEvent.event = event;\n      sdkEvent.data.created = activity.published;\n      sdkEvent.actorId = (0, _common.buildHydraPersonId)(activity.actor.entryUUID, cluster);\n\n      if (activity.object.id) {\n        sdkEvent.data.id = (0, _common.buildHydraRoomId)(activity.object.id, cluster);\n      } else {\n        sdkEvent.data.id = (0, _common.buildHydraRoomId)(activity.target.id, cluster);\n      }\n\n      if (event === _common.SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED) {\n        sdkEvent.data.creatorId = (0, _common.buildHydraPersonId)(activity.actor.entryUUID, cluster);\n        sdkEvent.data.lastActivity = activity.published;\n      } else if (event === _common.SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED) {\n        if (activity.verb === 'update') {\n          // For some reason the tags are not in the object for an update activity\n          tags = activity.target.tags;\n        }\n\n        if (activity.object.creatorUUID) {\n          // This seems to be set in lock/unlock activities but not updated...\n          debug(\"Found a creatorId: \".concat(activity.object.creatorUUID, \" in a \").concat(activity.verb, \" event\"));\n          sdkEvent.data.creatorId = (0, _common.buildHydraPersonId)(activity.object.creatorUUID, cluster);\n        } // Webhook engine team sets this based on lastReadableActivityDate\n        // in the activity.target object.  See: hydra/HydraRoom.java#L51\n        // This elements seems to be missing from the activity that the SDK is getting\n        // sdkEvent.data.lastActivity = activity.target.lastReadableActivityDate;\n\n      } else {\n        throw new Error('unexpected event type');\n      }\n\n      sdkEvent.data.type = (0, _common.getHydraRoomType)(tags);\n      sdkEvent.data.isLocked = tags.includes(_common.SDK_EVENT.INTERNAL.ACTIVITY_TAG.LOCKED);\n      return sdkEvent;\n    } catch (e) {\n      this.webex.logger.error(\"Unable to generate SDK event from mercury socket activity for rooms:\".concat(event, \" event: \").concat(e.message));\n      return null;\n    }\n  },\n  version: \"1.154.2\"\n});\n\nvar _default = Rooms;\n/**\n * Helper method to build a roomInfo object from a conversation object\n * @param {Object} webex sdk object\n * @param {Conversation~ConversationObject} conversation\n * @returns {Promise<RoomInfoObject>}\n */\n\nexports.default = _default;\n\nfunction buildRoomInfo(_x, _x2) {\n  return _buildRoomInfo.apply(this, arguments);\n}\n/**\n * Helper method to build a list of roomInfo object from conversation list\n * @param {Object} webex sdk object\n * @param {Conversation~ConversationObjectList} conversations\n * @returns {Promise<RoomInfoList>}\n */\n\n\nfunction _buildRoomInfo() {\n  _buildRoomInfo = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(webex, conversation) {\n    var type, cluster, title, lastActivityDate, roomInfo;\n    return _regenerator.default.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            type = (0, _common.getHydraRoomType)(conversation.tags);\n            cluster = (0, _common.getHydraClusterString)(webex, conversation.url);\n            title = conversation.displayName ? conversation.displayName : conversation.computedTitle;\n            lastActivityDate = conversation.lastReadableActivityDate ? conversation.lastReadableActivityDate : conversation.lastRelevantActivityDate;\n            roomInfo = _objectSpread(_objectSpread(_objectSpread({\n              id: (0, _common.buildHydraRoomId)(conversation.id, cluster),\n              type: type\n            }, title && {\n              title: conversation.displayName\n            }), lastActivityDate && {\n              lastActivityDate: lastActivityDate\n            }), {}, {\n              lastSeenActivityDate: conversation.lastSeenActivityDate ? conversation.lastSeenActivityDate : // If user has never been seen set the date to \"a long time ago\"\n              new Date(0).toISOString()\n            });\n            return _context2.abrupt(\"return\", _promise.default.resolve(roomInfo));\n\n          case 9:\n            _context2.prev = 9;\n            _context2.t0 = _context2[\"catch\"](0);\n            return _context2.abrupt(\"return\", _promise.default.reject(_context2.t0));\n\n          case 12:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[0, 9]]);\n  }));\n  return _buildRoomInfo.apply(this, arguments);\n}\n\nfunction buildRoomInfoList(_x3, _x4) {\n  return _buildRoomInfoList.apply(this, arguments);\n}\n\nfunction _buildRoomInfoList() {\n  _buildRoomInfoList = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(webex, conversations) {\n    var roomReadInfo, roomInfoPromises, _iterator, _step, conversation;\n\n    return _regenerator.default.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            // Convert each Conversation into a roomInfo object\n            roomReadInfo = {\n              items: []\n            };\n            roomInfoPromises = [];\n            _iterator = _createForOfIteratorHelper(conversations);\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                conversation = _step.value;\n                roomInfoPromises.push(buildRoomInfo(webex, conversation));\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n\n            return _context3.abrupt(\"return\", _promise.default.all(roomInfoPromises).then(function (roomInfoList) {\n              roomReadInfo.items = roomInfoList;\n              roomReadInfo.items.sort(function (a, b) {\n                return a.lastActivityDate < b.lastActivityDate ? 1 : -1;\n              });\n              return roomReadInfo;\n            }));\n\n          case 5:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _buildRoomInfoList.apply(this, arguments);\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA,IAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAPA,CAAiB,OAAjBA,CAAd;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMC,KAAK,GAAGC,uBAAYC,MAAZD,CAAmB;AAC/B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEE,QA7B+B,oBA6BtB;AAAA;;AACP,WAAO,iCAAoB,KAAKC,KAAzB,EAAgCC,kBAAUC,QAAVD,CAAmBE,QAAnBF,CAA4BG,KAA5D,EACJC,IADI,CACC,UAACC,QAAD,EAAc;AAClBC,WAAI,CAACC,aAAL,GAAqBF,QAArB;AAEA,aAAOC,KAAI,CAACP,KAAL,CAAWS,QAAX,CAAoBC,OAApB,CAA4BC,OAA5B,GAAsCN,IAAtC,CAA2C,YAAM;AACtDE,aAAI,CAACK,QAAL,CAAcL,KAAI,CAACP,KAAL,CAAWS,QAAX,CAAoBC,OAAlC,EACET,kBAAUY,QAAVZ,CAAmBa,cADrB,EAEE,UAACC,KAAD;AAAA,iBAAWR,KAAI,CAACS,eAAL,CAAqBD,KAArB,CAAX;AAFF;AADK,QAAP;AAJG,MAAP;AA9B6B;;AA0C/B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEE,QA9D+B,kBA8DxBC,IA9DwB,EA8DlB;AACX,WAAO,KAAKC,OAAL,CAAa;AAClBC,YAAM,EAAE,MADU;AAElBC,aAAO,EAAE,OAFS;AAGlBC,cAAQ,EAAE,OAHQ;AAIlBC,UAAI,EAAEL;AAJY,KAAb,EAMJb,IANI,CAMC,UAACmB,GAAD;AAAA,aAASA,GAAG,CAACD,IAAb;AAND,MAAP;AA/D6B;;AAwE/B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEE,KA7F+B,eA6F3BP,IA7F2B,EA6FrBQ,OA7FqB,EA6FZ;AACjB,QAAMC,EAAE,GAAGT,IAAI,CAACS,EAALT,IAAWA,IAAtB;AAEA,WAAO,KAAKC,OAAL,CAAa;AAClBE,aAAO,EAAE,OADS;AAElBC,cAAQ,kBAAWK,EAAX,CAFU;AAGlBC,QAAE,EAAEF;AAHc,KAAb,EAKJrB,IALI,CAKC,UAACmB,GAAD;AAAA,aAASA,GAAG,CAACD,IAAJC,CAASK,KAATL,IAAkBA,GAAG,CAACD,IAA/B;AALD,MAAP;AAhG6B;;AAwG/B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEO,MAxI+B,gBAwI1BJ,OAxI0B,EAwIjB;AAAA;;AACZ,WAAO,KAAKP,OAAL,CAAa;AAClBE,aAAO,EAAE,OADS;AAElBC,cAAQ,EAAE,QAFQ;AAGlBM,QAAE,EAAEF;AAHc,KAAb,EAKJrB,IALI,CAKC,UAACmB,GAAD;AAAA,aAAS,IAAIO,eAAJ,CAASP,GAAT,EAAcQ,MAAI,CAAChC,KAAnB,CAAT;AALD,MAAP;AAzI6B;;AAiJ/B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACQiC,oBA7LyB,gCA6LS;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;A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","names":["debug","require","Rooms","WebexPlugin","extend","listen","webex","SDK_EVENT","EXTERNAL","RESOURCE","ROOMS","then","envelope","_this","eventEnvelope","internal","mercury","connect","listenTo","INTERNAL","WEBEX_ACTIVITY","event","onWebexApiEvent","create","room","request","method","service","resource","body","res","get","options","id","qs","items","list","Page","_this2","listWithReadStatus","maxRecent","now","Date","activitiesLimit","computeTitleIfEmpty","conversationsLimit","isActive","_context","sinceDate","setDate","getDate","_promise","reject","Error","_this3","services","waitForCatalog","conversation","conversations","buildRoomInfoList","getWithReadStatus","roomId","deconstructedId","cluster","_this4","convo","buildRoomInfo","remove","statusCode","undefined","update","activity","data","verb","ACTIVITY_VERB","CREATE","roomCreatedEvent","getRoomEvent","EVENT_TYPE","CREATED","trigger","UPDATE","LOCK","UNLOCK","roomUpdatedEvent","UPDATED","sdkEvent","url","tags","object","created","published","actorId","actor","entryUUID","target","creatorId","lastActivity","creatorUUID","type","isLocked","includes","ACTIVITY_TAG","LOCKED","e","logger","error","message","version","_context2","title","displayName","computedTitle","lastActivityDate","lastReadableActivityDate","lastRelevantActivityDate","roomInfo","lastSeenActivityDate","toISOString","resolve","roomReadInfo","roomInfoPromises","_iterator","push","all","roomInfoList","sort","a","b"],"sources":["rooms.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {WebexPlugin, Page} from '@webex/webex-core';\nimport {cloneDeep} from 'lodash';\nimport {\n  SDK_EVENT,\n  createEventEnvelope,\n  buildHydraPersonId,\n  buildHydraRoomId,\n  getHydraClusterString,\n  getHydraRoomType,\n  deconstructHydraId\n} from '@webex/common';\n\nconst debug = require('debug')('rooms');\n\n/**\n * @typedef {Object} RoomObject\n * @property {string} id - (server generated) Unique identifier for the room\n * @property {string} title - The display name for the room. All room members\n * will see the title so make it something good\n * @property {string} teamId - (optional) The ID of the team to which the room\n * belongs\n * @property {isoDate} created - (server generated) The date and time that the\n * room was created\n */\n\n/**\n * Rooms are virtual meeting places for getting stuff done. This resource\n * represents the room itself. Check out the {@link Memberships} API to learn\n * how to add and remove people from rooms and the {@link Messages} API for\n * posting and managing content.\n * @class\n * @name Rooms\n */\nconst Rooms = WebexPlugin.extend({\n  /**\n   * Register to listen for incoming rooms events\n   * This is an alternate approach to registering for rooms webhooks.\n   * The events passed to any registered handlers will be similar to the webhook JSON,\n   * but will omit webhook specific fields such as name, secret, url, etc.\n   * To utilize the `listen()` method, the authorization token used\n   * will need to have `spark:all` and `spark:kms` scopes enabled.\n   * Note that by configuring your application to enable or disable `spark:all`\n   * via its configuration page will also enable or disable `spark:kms`.\n   * See the <a href=\"https://js.samples.s4d.io/browser-socket/\">Sample App</a>\n   * for more details.\n   * @instance\n   * @memberof Rooms\n   * @returns {Promise}\n   * @example\n   * webex.rooms.listen()\n   *   .then(() => {\n   *     console.log('listening to room events');\n   *     webex.rooms.on('created', (event) => console.log(`Got a room:created event:\\n${event}`);\n   *     webex.rooms.on('updated', (event) => console.log(`Got a room:updated event:\\n${event}`);\n   *   })\n   *   .catch((e) => console.error(`Unable to register for room events: ${e}`));\n   * // Some app logic...\n   * // WHen it is time to cleanup\n   * webex.rooms.stopListening();\n   * webex.rooms.off('created');\n   * webex.rooms.off('updated');\n   */\n  listen() {\n    return createEventEnvelope(this.webex, SDK_EVENT.EXTERNAL.RESOURCE.ROOMS)\n      .then((envelope) => {\n        this.eventEnvelope = envelope;\n\n        return this.webex.internal.mercury.connect().then(() => {\n          this.listenTo(this.webex.internal.mercury,\n            SDK_EVENT.INTERNAL.WEBEX_ACTIVITY,\n            (event) => this.onWebexApiEvent(event));\n        });\n      });\n  },\n\n  /**\n   * Creates a new room. The authenticated user is automatically added as a\n   * member of the room. See the {@link Memberships} API to learn how to add\n   * more people to the room.\n   * @instance\n   * @memberof Rooms\n   * @param {RoomObject} room\n   * @returns {Promise<RoomObject>}\n   * @example\n   * webex.rooms.create({title: 'Create Room Example'})\n   *   .then(function(room) {\n   *     var assert = require('assert')\n   *     assert(typeof room.created === 'string');\n   *     assert(typeof room.id === 'string');\n   *     assert(room.title === 'Create Room Example');\n   *     console.log(room.title);\n   *     return 'success';\n   *   });\n   *   // => success\n   */\n  create(room) {\n    return this.request({\n      method: 'POST',\n      service: 'hydra',\n      resource: 'rooms',\n      body: room\n    })\n      .then((res) => res.body);\n  },\n\n  /**\n   * Returns a single room.\n   * @instance\n   * @memberof Rooms\n   * @param {RoomObject|string} room\n   * @param {Object} options\n   * @returns {Promise<RoomObject>}\n   * @example\n   * var room;\n   * webex.rooms.create({title: 'Get Room Example'})\n   *   .then(function(r) {\n   *     room = r\n   *     return webex.rooms.get(room.id)\n   *   })\n   *   .then(function(r) {\n   *     var assert = require('assert');\n   *     assert.deepEqual(r, room);\n   *     return 'success';\n   *   });\n   *   // => success\n   */\n  get(room, options) {\n    const id = room.id || room;\n\n    return this.request({\n      service: 'hydra',\n      resource: `rooms/${id}`,\n      qs: options\n    })\n      .then((res) => res.body.items || res.body);\n  },\n\n  /**\n   * Returns a list of rooms. In most cases the results will only contain rooms\n   * that the authentiated user is a member of.\n   * @instance\n   * @memberof Rooms\n   * @param {Object} options\n   * @param {Object} options.max Limit the maximum number of rooms in the\n   * response.\n   * @returns {Promise<Page<RoomObject>>}\n   * @example\n   * var createdRooms;\n   * Promise.all([\n   *   webex.rooms.create({title: 'List Rooms Example 1'}),\n   *   webex.rooms.create({title: 'List Rooms Example 2'}),\n   *   webex.rooms.create({title: 'List Rooms Example 3'})\n   * ])\n   *   .then(function(r) {\n   *     createdRooms = r;\n   *     return webex.rooms.list({max: 3})\n   *       .then(function(rooms) {\n   *         var assert = require('assert');\n   *         assert(rooms.length === 3);\n   *         for (var i = 0; i < rooms.items.length; i+= 1) {\n   *           assert(createdRooms.filter(function(room) {\n   *             return room.id === rooms.items[i].id;\n   *           }).length === 1);\n   *         }\n   *         return 'success';\n   *       });\n   *   });\n   *   // => success\n   */\n  list(options) {\n    return this.request({\n      service: 'hydra',\n      resource: 'rooms/',\n      qs: options\n    })\n      .then((res) => new Page(res, this.webex));\n  },\n\n  /**\n   * Returns a list of rooms with details about the data of the last\n   * actvity in the room, and the date of the users last presences in\n   * the room. The list is sorted with this with most recent activity first\n   *\n   * For rooms where lastActivityDate > lastSeenDate the space\n   * can be considerd to be \"unread\"\n   *\n   * This differs from the rooms.list() function in the following ways:\n   *  -- when called with no parameters it returns an array of all\n   *     spaces, up to 1000, that the user is a member of\n   *  -- pagination is not supported. ALL rooms are returned which\n   *     can result in a large payload\n   *  -- For users with hundreds of spaces, this API can take some time to\n   *     to return, for this reason it supports an optional maxRecent parameter.\n   *     If set this will return only the specified number of spaces with activity\n   *     in the last two weeks.  Reccomended value is 30.  Max supported is 100.\n   *  -- only \"id\", \"type\", \"lastActivityDate\", and \"lastSeenDate\" are\n   *     guaranteed to be available for each room in the list\n   *  -- \"title\" is usually returned, but not guaranteed\n   *\n   * In general this function should be used only when the client needs to\n   * access read status info, for example on startup.\n   * After startup, clients should track message and membership:seen events\n   * to maintain read status client side.\n   *\n   * Since this API can take some time to return up to 1000 spaces, it is\n   * recommended that custom clients call this first with the maxRecent parameter\n   * set to 30, so that they can display some of the more recents spaces.  Calling\n   * this API a second time with no parameters will return all the spaces.\n   *\n   * Not all spaces may be returned, for example when users in more than 1000\n   * spaces, or when a new spaces is added after this function is called,\n   * but before it returns. Custom clients should be prepared to gracefully\n   * andle cases where an event occurs in a space not returned by this call,\n   * by querying rooms.getWithReadStatus() with the id of the room in question\n   *\n   * This function may be deprecated when this info is provided in the membership\n   * objects returned in the list function.\n   * @instance\n   * @param {int} maxRecent\n   * @memberof Rooms\n   * @returns {Promise<RoomInfoObjectList>}\n   */\n  async listWithReadStatus(maxRecent = 0) {\n    const now = new Date();\n    const options = {\n      activitiesLimit: 0,\n      computeTitleIfEmpty: true,\n      conversationsLimit: 1000,\n      isActive: true\n    };\n\n    if (maxRecent > 0) {\n      options.conversationsLimit = maxRecent;\n      options.sinceDate = now.setDate(now.getDate() - 14);\n    }\n    else if ((maxRecent < 0) || (maxRecent > 100)) {\n      return Promise.reject(new Error('rooms.listWithReadStatus: ' +\n        'optional maxRecent parameter must be an integer between 1 and 100'));\n    }\n\n    return this.webex.internal.services.waitForCatalog('postauth')\n      .then(() => this.webex.internal.conversation.list(options))\n      .then((conversations) => buildRoomInfoList(this.webex, conversations));\n  },\n\n  /**\n   * Returns a single room object with details about the data of the last\n   * actvity in the room, and the date of the users last presence in\n   * the room.\n   *\n   * For rooms where lastActivityDate > lastSeenDate the room\n   * can be considerd to be \"unread\"\n   *\n   * This differs from the rooms.get() function in the following ways:\n   *  -- it takes a single roomId parameter to fetch\n   *  -- no other options are considered\n   *  -- only \"id\", \"type\", \"lastActivityDate\", and \"lastSeenDate\" are\n   *     guaranteed to be available in the return object\n   *  -- \"title\" is usually returned, but not guaranteed\n   *\n   * In general clients should use the listWithReadStatus() method on startup\n   * to get the initial roomStatus and then update their client side copy by\n   * responding to message, membership and room events.\n\n   * This function allows a custom client to be \"nimble\" if it is responding\n   * to an event with a roomId that was not in the original fetch.  The\n   * anticipated behavior is that getWithReadStats is called \"just in time\",\n   * with the resulting room object being added to the list of cached room\n   * objects on the client side.\n   *\n   * This function may be deprecated when this info is provided in the room\n   * object returned in the get function.\n   * @instance\n   * @memberof Rooms\n   * @param {string} roomId\n   * @returns {Promise<RoomInfoObject>}\n   */\n  getWithReadStatus(roomId) {\n    const deconstructedId = deconstructHydraId(roomId);\n    const conversation = {\n      id: deconstructedId.id,\n      cluster: deconstructedId.cluster\n    };\n\n    return this.webex.internal.services.waitForCatalog('postauth')\n      .then(() => this.webex.internal.conversation.get(conversation,\n        {\n          computeTitleIfEmpty: true,\n          activitiesLimit: 0 // don't send the whole history of activity\n        })\n        .then((convo) => buildRoomInfo(this.webex, convo)));\n  },\n\n  /**\n   * Deletes a single room.\n   * @instance\n   * @memberof Rooms\n   * @param {RoomObject|string} room\n   * @returns {Promise}\n   * @example\n   * var room;\n   * webex.rooms.create({title: 'Remove Room Example'})\n   *  .then(function(r) {\n   *    room = r;\n   *    return webex.rooms.remove(room.id);\n   *  })\n   *  .then(function() {\n   *    return webex.rooms.get(room.id);\n   *  })\n   *  .then(function() {\n   *    var assert = require('assert');\n   *    assert(false, 'the previous get should have failed');\n   *  })\n   *  .catch(function(reason) {\n   *    var assert = require('assert');\n   *    assert.equal(reason.statusCode, 404);\n   *    return 'success'\n   *  });\n   *  // => success\n   */\n  remove(room) {\n    const id = room.id || room;\n\n    return this.request({\n      method: 'DELETE',\n      service: 'hydra',\n      resource: `rooms/${id}`\n    })\n      .then((res) => {\n        // Firefox has some issues with 204s and/or DELETE. This should move to\n        // http-core\n        if (res.statusCode === 204) {\n          return undefined;\n        }\n\n        return res.body;\n      });\n  },\n\n  /**\n   * Used to update a single room's properties.\n   * @instance\n   * @memberof Rooms\n   * @param {RoomObject} room\n   * @returns {Promise<RoomObject>}\n   * @example\n   * var room;\n   * webex.rooms.update({title: 'Update Room Example'})\n   *   .then(function(r) {\n   *     room = r;\n   *     room.title = 'Update Room Example (Updated Title)';\n   *     return webex.rooms.update(room);\n   *   })\n   *   .then(function() {\n   *     return webex.rooms.get(room.id);\n   *   })\n   *   .then(function(room) {\n   *    var assert = require('assert');\n   *     assert.equal(room.title, 'Update Room Example (Updated Title)');\n   *     return 'success';\n   *   });\n   *   // => success\n   */\n  update(room) {\n    const {id} = room;\n\n    return this.request({\n      method: 'PUT',\n      service: 'hydra',\n      resource: `rooms/${id}`,\n      body: room\n    })\n      .then((res) => res.body);\n  },\n\n  /**\n   * This function is called when an internal membership events fires,\n   * if the user registered for these events with the listen() function.\n   * External users of the SDK should not call this function\n   * @private\n   * @memberof Rooms\n   * @param {Object} event\n   * @returns {void}\n   */\n  onWebexApiEvent(event) {\n    const {activity} = event.data;\n\n    /* eslint-disable no-case-declarations */\n    switch (activity.verb) {\n      case SDK_EVENT.INTERNAL.ACTIVITY_VERB.CREATE:\n        const roomCreatedEvent =\n          this.getRoomEvent(this.webex, activity, SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED);\n\n        if (roomCreatedEvent) {\n          debug(`room \"created\" payload: \\\n            ${JSON.stringify(roomCreatedEvent)}`);\n          this.trigger(SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED, roomCreatedEvent);\n        }\n        break;\n\n      case SDK_EVENT.INTERNAL.ACTIVITY_VERB.UPDATE:\n      case SDK_EVENT.INTERNAL.ACTIVITY_VERB.LOCK:\n      case SDK_EVENT.INTERNAL.ACTIVITY_VERB.UNLOCK:\n        debug(`generating a rooms:updated based on ${activity.verb} activity`);\n        const roomUpdatedEvent =\n          this.getRoomEvent(this.webex, activity, SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED);\n\n        if (roomUpdatedEvent) {\n          debug(`room \"updated\" payload: \\\n            ${JSON.stringify(roomUpdatedEvent)}`);\n          this.trigger(SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED, roomUpdatedEvent);\n        }\n        break;\n\n      default:\n        break;\n    }\n  },\n\n  /**\n   * Constructs the data object for an event on the rooms resource,\n   * adhering to Hydra's Webehook data structure.\n   * External users of the SDK should not call this function\n   * @private\n   * @memberof Rooms\n   * @param {Object} webex sdk instance\n   * @param {Object} activity from mercury\n   * @param {Object} event type of \"webhook\" event\n   * @returns {Object} constructed event\n   */\n  getRoomEvent(webex, activity, event) {\n    try {\n      const sdkEvent = cloneDeep(this.eventEnvelope);\n      const cluster = getHydraClusterString(webex, activity.url);\n      let {tags} = activity.object;\n\n      sdkEvent.event = event;\n      sdkEvent.data.created = activity.published;\n      sdkEvent.actorId = buildHydraPersonId(activity.actor.entryUUID, cluster);\n      if (activity.object.id) {\n        sdkEvent.data.id = buildHydraRoomId(activity.object.id, cluster);\n      }\n      else {\n        sdkEvent.data.id = buildHydraRoomId(activity.target.id, cluster);\n      }\n\n      if (event === SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED) {\n        sdkEvent.data.creatorId = buildHydraPersonId(activity.actor.entryUUID, cluster);\n        sdkEvent.data.lastActivity = activity.published;\n      }\n      else if (event === SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED) {\n        if (activity.verb === 'update') {\n          // For some reason the tags are not in the object for an update activity\n          tags = activity.target.tags;\n        }\n        if (activity.object.creatorUUID) {\n          // This seems to be set in lock/unlock activities but not updated...\n          debug(`Found a creatorId: ${activity.object.creatorUUID} in a ${activity.verb} event`);\n          sdkEvent.data.creatorId = buildHydraPersonId(activity.object.creatorUUID, cluster);\n        }\n        // Webhook engine team sets this based on lastReadableActivityDate\n        // in the activity.target object.  See: hydra/HydraRoom.java#L51\n        // This elements seems to be missing from the activity that the SDK is getting\n        // sdkEvent.data.lastActivity = activity.target.lastReadableActivityDate;\n      }\n      else {\n        throw new Error('unexpected event type');\n      }\n      sdkEvent.data.type = getHydraRoomType(tags);\n      sdkEvent.data.isLocked =\n        tags.includes(SDK_EVENT.INTERNAL.ACTIVITY_TAG.LOCKED);\n\n      return sdkEvent;\n    }\n    catch (e) {\n      this.webex.logger.error(`Unable to generate SDK event from mercury socket activity for rooms:${event} event: ${e.message}`);\n\n      return null;\n    }\n  }\n\n});\n\nexport default Rooms;\n\n/**\n * Helper method to build a roomInfo object from a conversation object\n * @param {Object} webex sdk object\n * @param {Conversation~ConversationObject} conversation\n * @returns {Promise<RoomInfoObject>}\n */\nasync function buildRoomInfo(webex, conversation) {\n  try {\n    const type = getHydraRoomType(conversation.tags);\n    const cluster = getHydraClusterString(webex, conversation.url);\n    const title = conversation.displayName ?\n      conversation.displayName : conversation.computedTitle;\n    const lastActivityDate = conversation.lastReadableActivityDate ?\n      conversation.lastReadableActivityDate :\n      conversation.lastRelevantActivityDate;\n\n    const roomInfo = {\n      id: buildHydraRoomId(conversation.id, cluster),\n      type,\n      ...(title && {title: conversation.displayName}),\n      ...(lastActivityDate && {lastActivityDate}),\n      lastSeenActivityDate: conversation.lastSeenActivityDate ?\n        conversation.lastSeenActivityDate :\n        // If user has never been seen set the date to \"a long time ago\"\n        new Date(0).toISOString()\n    };\n\n    return Promise.resolve(roomInfo);\n  }\n  catch (e) {\n    return Promise.reject(e);\n  }\n}\n\n/**\n * Helper method to build a list of roomInfo object from conversation list\n * @param {Object} webex sdk object\n * @param {Conversation~ConversationObjectList} conversations\n * @returns {Promise<RoomInfoList>}\n */\nasync function buildRoomInfoList(webex, conversations) {\n  // Convert each Conversation into a roomInfo object\n  const roomReadInfo = {items: []};\n  const roomInfoPromises = [];\n\n  for (const conversation of conversations) {\n    roomInfoPromises.push(buildRoomInfo(webex, conversation));\n  }\n\n  return Promise.all(roomInfoPromises)\n    .then((roomInfoList) => {\n      roomReadInfo.items = roomInfoList;\n      roomReadInfo.items.sort((a, b) => (a.lastActivityDate < b.lastActivityDate ? 1 : -1));\n\n      return roomReadInfo;\n    });\n}\n"]},"metadata":{},"sourceType":"script"}