{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"C:/Users/rkanthet/Documents/test_window_object/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar stringify = configure(); // @ts-expect-error\n\nstringify.configure = configure; // @ts-expect-error\n\nstringify.stringify = stringify; // @ts-expect-error\n\nstringify.default = stringify; // @ts-expect-error used for named export\n\nexports.stringify = stringify; // @ts-expect-error used for named export\n\nexports.configure = configure;\nmodule.exports = stringify; // eslint-disable-next-line\n\nvar strEscapeSequencesRegExp = /[\\u0000-\\u001f\\u0022\\u005c\\ud800-\\udfff]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?:[^\\ud800-\\udbff]|^)[\\udc00-\\udfff]/; // eslint-disable-next-line\n\nvar strEscapeSequencesReplacer = /[\\u0000-\\u001f\\u0022\\u005c\\ud800-\\udfff]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?:[^\\ud800-\\udbff]|^)[\\udc00-\\udfff]/g; // Escaped special characters. Use empty strings to fill up unused entries.\n\nvar meta = [\"\\\\u0000\", \"\\\\u0001\", \"\\\\u0002\", \"\\\\u0003\", \"\\\\u0004\", \"\\\\u0005\", \"\\\\u0006\", \"\\\\u0007\", '\\\\b', '\\\\t', '\\\\n', \"\\\\u000b\", '\\\\f', '\\\\r', \"\\\\u000e\", \"\\\\u000f\", \"\\\\u0010\", \"\\\\u0011\", \"\\\\u0012\", \"\\\\u0013\", \"\\\\u0014\", \"\\\\u0015\", \"\\\\u0016\", \"\\\\u0017\", \"\\\\u0018\", \"\\\\u0019\", \"\\\\u001a\", \"\\\\u001b\", \"\\\\u001c\", \"\\\\u001d\", \"\\\\u001e\", \"\\\\u001f\", '', '', '\\\\\"', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '\\\\\\\\'];\n\nfunction escapeFn(str) {\n  if (str.length === 2) {\n    var _charCode = str.charCodeAt(1);\n\n    return \"\".concat(str[0], \"\\\\u\").concat(_charCode.toString(16));\n  }\n\n  var charCode = str.charCodeAt(0);\n  return meta.length > charCode ? meta[charCode] : \"\\\\u\".concat(charCode.toString(16));\n} // Escape C0 control characters, double quotes, the backslash and every code\n// unit with a numeric value in the inclusive range 0xD800 to 0xDFFF.\n\n\nfunction strEscape(str) {\n  // Some magic numbers that worked out fine while benchmarking with v8 8.0\n  if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {\n    return str;\n  }\n\n  if (str.length > 100) {\n    return str.replace(strEscapeSequencesReplacer, escapeFn);\n  }\n\n  var result = '';\n  var last = 0;\n\n  for (var i = 0; i < str.length; i++) {\n    var point = str.charCodeAt(i);\n\n    if (point === 34 || point === 92 || point < 32) {\n      result += \"\".concat(str.slice(last, i)).concat(meta[point]);\n      last = i + 1;\n    } else if (point >= 0xd800 && point <= 0xdfff) {\n      if (point <= 0xdbff && i + 1 < str.length) {\n        var _point = str.charCodeAt(i + 1);\n\n        if (_point >= 0xdc00 && _point <= 0xdfff) {\n          i++;\n          continue;\n        }\n      }\n\n      result += \"\".concat(str.slice(last, i), \"\\\\u\".concat(point.toString(16)));\n      last = i + 1;\n    }\n  }\n\n  result += str.slice(last);\n  return result;\n}\n\nfunction insertSort(array) {\n  // Insertion sort is very efficient for small input sizes but it has a bad\n  // worst case complexity. Thus, use native array sort for bigger values.\n  if (array.length > 2e2) {\n    return array.sort();\n  }\n\n  for (var i = 1; i < array.length; i++) {\n    var currentValue = array[i];\n    var position = i;\n\n    while (position !== 0 && array[position - 1] > currentValue) {\n      array[position] = array[position - 1];\n      position--;\n    }\n\n    array[position] = currentValue;\n  }\n\n  return array;\n}\n\nvar typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())), Symbol.toStringTag).get;\n\nfunction isTypedArrayWithEntries(value) {\n  return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0;\n}\n\nfunction stringifyTypedArray(array, separator, maximumBreadth) {\n  if (array.length < maximumBreadth) {\n    maximumBreadth = array.length;\n  }\n\n  var whitespace = separator === ',' ? '' : ' ';\n  var res = \"\\\"0\\\":\".concat(whitespace).concat(array[0]);\n\n  for (var i = 1; i < maximumBreadth; i++) {\n    res += \"\".concat(separator, \"\\\"\").concat(i, \"\\\":\").concat(whitespace).concat(array[i]);\n  }\n\n  return res;\n}\n\nfunction getCircularValueOption(options) {\n  if (options && Object.prototype.hasOwnProperty.call(options, 'circularValue')) {\n    var circularValue = options.circularValue;\n\n    if (typeof circularValue === 'string') {\n      return \"\\\"\".concat(circularValue, \"\\\"\");\n    }\n\n    if (circularValue == null) {\n      return circularValue;\n    }\n\n    if (circularValue === Error || circularValue === TypeError) {\n      return {\n        toString: function toString() {\n          throw new TypeError('Converting circular structure to JSON');\n        }\n      };\n    }\n\n    throw new TypeError('The \"circularValue\" argument must be of type string or the value null or undefined');\n  }\n\n  return '\"[Circular]\"';\n}\n\nfunction getBooleanOption(options, key) {\n  if (options && Object.prototype.hasOwnProperty.call(options, key)) {\n    var value = options[key];\n\n    if (typeof value !== 'boolean') {\n      throw new TypeError(\"The \\\"\".concat(key, \"\\\" argument must be of type boolean\"));\n    }\n  }\n\n  return value === undefined ? true : value;\n}\n\nfunction getPositiveIntegerOption(options, key) {\n  if (options && Object.prototype.hasOwnProperty.call(options, key)) {\n    var value = options[key];\n\n    if (typeof value !== 'number') {\n      throw new TypeError(\"The \\\"\".concat(key, \"\\\" argument must be of type number\"));\n    }\n\n    if (!Number.isInteger(value)) {\n      throw new TypeError(\"The \\\"\".concat(key, \"\\\" argument must be an integer\"));\n    }\n\n    if (value < 1) {\n      throw new RangeError(\"The \\\"\".concat(key, \"\\\" argument must be >= 1\"));\n    }\n  }\n\n  return value === undefined ? Infinity : value;\n}\n\nfunction getItemCount(number) {\n  if (number === 1) {\n    return '1 item';\n  }\n\n  return \"\".concat(number, \" items\");\n}\n\nfunction getUniqueReplacerSet(replacerArray) {\n  var replacerSet = new Set();\n\n  var _iterator = _createForOfIteratorHelper(replacerArray),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var value = _step.value;\n\n      if (typeof value === 'string') {\n        replacerSet.add(value);\n      } else if (typeof value === 'number') {\n        replacerSet.add(String(value));\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return replacerSet;\n}\n\nfunction configure(options) {\n  var circularValue = getCircularValueOption(options);\n  var bigint = getBooleanOption(options, 'bigint');\n  var deterministic = getBooleanOption(options, 'deterministic');\n  var maximumDepth = getPositiveIntegerOption(options, 'maximumDepth');\n  var maximumBreadth = getPositiveIntegerOption(options, 'maximumBreadth');\n\n  function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {\n    var value = parent[key];\n\n    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {\n      value = value.toJSON(key);\n    }\n\n    value = replacer.call(parent, key, value);\n\n    switch (typeof value) {\n      case 'string':\n        return \"\\\"\".concat(strEscape(value), \"\\\"\");\n\n      case 'object':\n        {\n          if (value === null) {\n            return 'null';\n          }\n\n          if (stack.indexOf(value) !== -1) {\n            return circularValue;\n          }\n\n          var res = '';\n          var join = ',';\n          var originalIndentation = indentation;\n\n          if (Array.isArray(value)) {\n            if (value.length === 0) {\n              return '[]';\n            }\n\n            if (maximumDepth < stack.length + 1) {\n              return '\"[Array]\"';\n            }\n\n            stack.push(value);\n\n            if (spacer !== '') {\n              indentation += spacer;\n              res += \"\\n\".concat(indentation);\n              join = \",\\n\".concat(indentation);\n            }\n\n            var maximumValuesToStringify = Math.min(value.length, maximumBreadth);\n            var i = 0;\n\n            for (; i < maximumValuesToStringify - 1; i++) {\n              var _tmp = stringifyFnReplacer(i, value, stack, replacer, spacer, indentation);\n\n              res += _tmp !== undefined ? _tmp : 'null';\n              res += join;\n            }\n\n            var tmp = stringifyFnReplacer(i, value, stack, replacer, spacer, indentation);\n            res += tmp !== undefined ? tmp : 'null';\n\n            if (value.length - 1 > maximumBreadth) {\n              var removedKeys = value.length - maximumBreadth - 1;\n              res += \"\".concat(join, \"\\\"... \").concat(getItemCount(removedKeys), \" not stringified\\\"\");\n            }\n\n            if (spacer !== '') {\n              res += \"\\n\".concat(originalIndentation);\n            }\n\n            stack.pop();\n            return \"[\".concat(res, \"]\");\n          }\n\n          var keys = Object.keys(value);\n          var keyLength = keys.length;\n\n          if (keyLength === 0) {\n            return '{}';\n          }\n\n          if (maximumDepth < stack.length + 1) {\n            return '\"[Object]\"';\n          }\n\n          var whitespace = '';\n          var separator = '';\n\n          if (spacer !== '') {\n            indentation += spacer;\n            join = \",\\n\".concat(indentation);\n            whitespace = ' ';\n          }\n\n          var maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);\n\n          if (isTypedArrayWithEntries(value)) {\n            res += stringifyTypedArray(value, join, maximumBreadth);\n            keys = keys.slice(value.length);\n            maximumPropertiesToStringify -= value.length;\n            separator = join;\n          }\n\n          if (deterministic) {\n            keys = insertSort(keys);\n          }\n\n          stack.push(value);\n\n          for (var _i = 0; _i < maximumPropertiesToStringify; _i++) {\n            var _key = keys[_i];\n\n            var _tmp2 = stringifyFnReplacer(_key, value, stack, replacer, spacer, indentation);\n\n            if (_tmp2 !== undefined) {\n              res += \"\".concat(separator, \"\\\"\").concat(strEscape(_key), \"\\\":\").concat(whitespace).concat(_tmp2);\n              separator = join;\n            }\n          }\n\n          if (keyLength > maximumBreadth) {\n            var _removedKeys = keyLength - maximumBreadth;\n\n            res += \"\".concat(separator, \"\\\"...\\\":\").concat(whitespace, \"\\\"\").concat(getItemCount(_removedKeys), \" not stringified\\\"\");\n            separator = join;\n          }\n\n          if (spacer !== '' && separator.length > 1) {\n            res = \"\\n\".concat(indentation).concat(res, \"\\n\").concat(originalIndentation);\n          }\n\n          stack.pop();\n          return \"{\".concat(res, \"}\");\n        }\n\n      case 'number':\n        return isFinite(value) ? String(value) : 'null';\n\n      case 'boolean':\n        return value === true ? 'true' : 'false';\n\n      case 'bigint':\n        return bigint ? String(value) : undefined;\n    }\n  }\n\n  function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {\n    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {\n      value = value.toJSON(key);\n    }\n\n    switch (typeof value) {\n      case 'string':\n        return \"\\\"\".concat(strEscape(value), \"\\\"\");\n\n      case 'object':\n        {\n          if (value === null) {\n            return 'null';\n          }\n\n          if (stack.indexOf(value) !== -1) {\n            return circularValue;\n          }\n\n          var originalIndentation = indentation;\n          var res = '';\n          var join = ',';\n\n          if (Array.isArray(value)) {\n            if (value.length === 0) {\n              return '[]';\n            }\n\n            if (maximumDepth < stack.length + 1) {\n              return '\"[Array]\"';\n            }\n\n            stack.push(value);\n\n            if (spacer !== '') {\n              indentation += spacer;\n              res += \"\\n\".concat(indentation);\n              join = \",\\n\".concat(indentation);\n            }\n\n            var maximumValuesToStringify = Math.min(value.length, maximumBreadth);\n            var i = 0;\n\n            for (; i < maximumValuesToStringify - 1; i++) {\n              var _tmp3 = stringifyArrayReplacer(i, value[i], stack, replacer, spacer, indentation);\n\n              res += _tmp3 !== undefined ? _tmp3 : 'null';\n              res += join;\n            }\n\n            var tmp = stringifyArrayReplacer(i, value[i], stack, replacer, spacer, indentation);\n            res += tmp !== undefined ? tmp : 'null';\n\n            if (value.length - 1 > maximumBreadth) {\n              var removedKeys = value.length - maximumBreadth - 1;\n              res += \"\".concat(join, \"\\\"... \").concat(getItemCount(removedKeys), \" not stringified\\\"\");\n            }\n\n            if (spacer !== '') {\n              res += \"\\n\".concat(originalIndentation);\n            }\n\n            stack.pop();\n            return \"[\".concat(res, \"]\");\n          }\n\n          if (replacer.size === 0) {\n            return '{}';\n          }\n\n          stack.push(value);\n          var whitespace = '';\n\n          if (spacer !== '') {\n            indentation += spacer;\n            join = \",\\n\".concat(indentation);\n            whitespace = ' ';\n          }\n\n          var separator = '';\n\n          var _iterator2 = _createForOfIteratorHelper(replacer),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _key2 = _step2.value;\n\n              var _tmp4 = stringifyArrayReplacer(_key2, value[_key2], stack, replacer, spacer, indentation);\n\n              if (_tmp4 !== undefined) {\n                res += \"\".concat(separator, \"\\\"\").concat(strEscape(_key2), \"\\\":\").concat(whitespace).concat(_tmp4);\n                separator = join;\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          if (spacer !== '' && separator.length > 1) {\n            res = \"\\n\".concat(indentation).concat(res, \"\\n\").concat(originalIndentation);\n          }\n\n          stack.pop();\n          return \"{\".concat(res, \"}\");\n        }\n\n      case 'number':\n        return isFinite(value) ? String(value) : 'null';\n\n      case 'boolean':\n        return value === true ? 'true' : 'false';\n\n      case 'bigint':\n        return bigint ? String(value) : undefined;\n    }\n  }\n\n  function stringifyIndent(key, value, stack, spacer, indentation) {\n    switch (typeof value) {\n      case 'string':\n        return \"\\\"\".concat(strEscape(value), \"\\\"\");\n\n      case 'object':\n        {\n          if (value === null) {\n            return 'null';\n          }\n\n          if (typeof value.toJSON === 'function') {\n            value = value.toJSON(key); // Prevent calling `toJSON` again.\n\n            if (typeof value !== 'object') {\n              return stringifyIndent(key, value, stack, spacer, indentation);\n            }\n\n            if (value === null) {\n              return 'null';\n            }\n          }\n\n          if (stack.indexOf(value) !== -1) {\n            return circularValue;\n          }\n\n          var originalIndentation = indentation;\n\n          if (Array.isArray(value)) {\n            if (value.length === 0) {\n              return '[]';\n            }\n\n            if (maximumDepth < stack.length + 1) {\n              return '\"[Array]\"';\n            }\n\n            stack.push(value);\n            indentation += spacer;\n\n            var _res = \"\\n\".concat(indentation);\n\n            var _join = \",\\n\".concat(indentation);\n\n            var maximumValuesToStringify = Math.min(value.length, maximumBreadth);\n            var i = 0;\n\n            for (; i < maximumValuesToStringify - 1; i++) {\n              var _tmp5 = stringifyIndent(i, value[i], stack, spacer, indentation);\n\n              _res += _tmp5 !== undefined ? _tmp5 : 'null';\n              _res += _join;\n            }\n\n            var tmp = stringifyIndent(i, value[i], stack, spacer, indentation);\n            _res += tmp !== undefined ? tmp : 'null';\n\n            if (value.length - 1 > maximumBreadth) {\n              var removedKeys = value.length - maximumBreadth - 1;\n              _res += \"\".concat(_join, \"\\\"... \").concat(getItemCount(removedKeys), \" not stringified\\\"\");\n            }\n\n            _res += \"\\n\".concat(originalIndentation);\n            stack.pop();\n            return \"[\".concat(_res, \"]\");\n          }\n\n          var keys = Object.keys(value);\n          var keyLength = keys.length;\n\n          if (keyLength === 0) {\n            return '{}';\n          }\n\n          if (maximumDepth < stack.length + 1) {\n            return '\"[Object]\"';\n          }\n\n          indentation += spacer;\n          var join = \",\\n\".concat(indentation);\n          var res = '';\n          var separator = '';\n          var maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);\n\n          if (isTypedArrayWithEntries(value)) {\n            res += stringifyTypedArray(value, join, maximumBreadth);\n            keys = keys.slice(value.length);\n            maximumPropertiesToStringify -= value.length;\n            separator = join;\n          }\n\n          if (deterministic) {\n            keys = insertSort(keys);\n          }\n\n          stack.push(value);\n\n          for (var _i2 = 0; _i2 < maximumPropertiesToStringify; _i2++) {\n            var _key3 = keys[_i2];\n\n            var _tmp6 = stringifyIndent(_key3, value[_key3], stack, spacer, indentation);\n\n            if (_tmp6 !== undefined) {\n              res += \"\".concat(separator, \"\\\"\").concat(strEscape(_key3), \"\\\": \").concat(_tmp6);\n              separator = join;\n            }\n          }\n\n          if (keyLength > maximumBreadth) {\n            var _removedKeys2 = keyLength - maximumBreadth;\n\n            res += \"\".concat(separator, \"\\\"...\\\": \\\"\").concat(getItemCount(_removedKeys2), \" not stringified\\\"\");\n            separator = join;\n          }\n\n          if (separator !== '') {\n            res = \"\\n\".concat(indentation).concat(res, \"\\n\").concat(originalIndentation);\n          }\n\n          stack.pop();\n          return \"{\".concat(res, \"}\");\n        }\n\n      case 'number':\n        return isFinite(value) ? String(value) : 'null';\n\n      case 'boolean':\n        return value === true ? 'true' : 'false';\n\n      case 'bigint':\n        return bigint ? String(value) : undefined;\n    }\n  }\n\n  function stringifySimple(key, value, stack) {\n    switch (typeof value) {\n      case 'string':\n        return \"\\\"\".concat(strEscape(value), \"\\\"\");\n\n      case 'object':\n        {\n          if (value === null) {\n            return 'null';\n          }\n\n          if (typeof value.toJSON === 'function') {\n            value = value.toJSON(key); // Prevent calling `toJSON` again\n\n            if (typeof value !== 'object') {\n              return stringifySimple(key, value, stack);\n            }\n\n            if (value === null) {\n              return 'null';\n            }\n          }\n\n          if (stack.indexOf(value) !== -1) {\n            return circularValue;\n          }\n\n          var res = '';\n\n          if (Array.isArray(value)) {\n            if (value.length === 0) {\n              return '[]';\n            }\n\n            if (maximumDepth < stack.length + 1) {\n              return '\"[Array]\"';\n            }\n\n            stack.push(value);\n            var maximumValuesToStringify = Math.min(value.length, maximumBreadth);\n            var i = 0;\n\n            for (; i < maximumValuesToStringify - 1; i++) {\n              var _tmp7 = stringifySimple(i, value[i], stack);\n\n              res += _tmp7 !== undefined ? _tmp7 : 'null';\n              res += ',';\n            }\n\n            var tmp = stringifySimple(i, value[i], stack);\n            res += tmp !== undefined ? tmp : 'null';\n\n            if (value.length - 1 > maximumBreadth) {\n              var removedKeys = value.length - maximumBreadth - 1;\n              res += \",\\\"... \".concat(getItemCount(removedKeys), \" not stringified\\\"\");\n            }\n\n            stack.pop();\n            return \"[\".concat(res, \"]\");\n          }\n\n          var keys = Object.keys(value);\n          var keyLength = keys.length;\n\n          if (keyLength === 0) {\n            return '{}';\n          }\n\n          if (maximumDepth < stack.length + 1) {\n            return '\"[Object]\"';\n          }\n\n          var separator = '';\n          var maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);\n\n          if (isTypedArrayWithEntries(value)) {\n            res += stringifyTypedArray(value, ',', maximumBreadth);\n            keys = keys.slice(value.length);\n            maximumPropertiesToStringify -= value.length;\n            separator = ',';\n          }\n\n          if (deterministic) {\n            keys = insertSort(keys);\n          }\n\n          stack.push(value);\n\n          for (var _i3 = 0; _i3 < maximumPropertiesToStringify; _i3++) {\n            var _key4 = keys[_i3];\n\n            var _tmp8 = stringifySimple(_key4, value[_key4], stack);\n\n            if (_tmp8 !== undefined) {\n              res += \"\".concat(separator, \"\\\"\").concat(strEscape(_key4), \"\\\":\").concat(_tmp8);\n              separator = ',';\n            }\n          }\n\n          if (keyLength > maximumBreadth) {\n            var _removedKeys3 = keyLength - maximumBreadth;\n\n            res += \"\".concat(separator, \"\\\"...\\\":\\\"\").concat(getItemCount(_removedKeys3), \" not stringified\\\"\");\n          }\n\n          stack.pop();\n          return \"{\".concat(res, \"}\");\n        }\n\n      case 'number':\n        return isFinite(value) ? String(value) : 'null';\n\n      case 'boolean':\n        return value === true ? 'true' : 'false';\n\n      case 'bigint':\n        return bigint ? String(value) : undefined;\n    }\n  }\n\n  function stringify(value, replacer, space) {\n    if (arguments.length > 1) {\n      var spacer = '';\n\n      if (typeof space === 'number') {\n        spacer = ' '.repeat(Math.min(space, 10));\n      } else if (typeof space === 'string') {\n        spacer = space.slice(0, 10);\n      }\n\n      if (replacer != null) {\n        if (typeof replacer === 'function') {\n          return stringifyFnReplacer('', {\n            '': value\n          }, [], replacer, spacer, '');\n        }\n\n        if (Array.isArray(replacer)) {\n          return stringifyArrayReplacer('', value, [], getUniqueReplacerSet(replacer), spacer, '');\n        }\n      }\n\n      if (spacer.length !== 0) {\n        return stringifyIndent('', value, [], spacer, '');\n      }\n    }\n\n    return stringifySimple('', value, []);\n  }\n\n  return stringify;\n}","map":{"version":3,"sources":["C:/Users/rkanthet/Documents/test_window_object/node_modules/safe-stable-stringify/index.js"],"names":["stringify","configure","default","exports","module","strEscapeSequencesRegExp","strEscapeSequencesReplacer","meta","escapeFn","str","length","charCode","charCodeAt","toString","strEscape","test","replace","result","last","i","point","slice","insertSort","array","sort","currentValue","position","typedArrayPrototypeGetSymbolToStringTag","Object","getOwnPropertyDescriptor","getPrototypeOf","Uint8Array","Symbol","toStringTag","get","isTypedArrayWithEntries","value","call","undefined","stringifyTypedArray","separator","maximumBreadth","whitespace","res","getCircularValueOption","options","prototype","hasOwnProperty","circularValue","Error","TypeError","getBooleanOption","key","getPositiveIntegerOption","Number","isInteger","RangeError","Infinity","getItemCount","number","getUniqueReplacerSet","replacerArray","replacerSet","Set","add","String","bigint","deterministic","maximumDepth","stringifyFnReplacer","parent","stack","replacer","spacer","indentation","toJSON","indexOf","join","originalIndentation","Array","isArray","push","maximumValuesToStringify","Math","min","tmp","removedKeys","pop","keys","keyLength","maximumPropertiesToStringify","isFinite","stringifyArrayReplacer","size","stringifyIndent","stringifySimple","space","arguments","repeat"],"mappings":"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","sourcesContent":["'use strict'\n\nconst stringify = configure()\n\n// @ts-expect-error\nstringify.configure = configure\n// @ts-expect-error\nstringify.stringify = stringify\n\n// @ts-expect-error\nstringify.default = stringify\n\n// @ts-expect-error used for named export\nexports.stringify = stringify\n// @ts-expect-error used for named export\nexports.configure = configure\n\nmodule.exports = stringify\n\n// eslint-disable-next-line\nconst strEscapeSequencesRegExp = /[\\u0000-\\u001f\\u0022\\u005c\\ud800-\\udfff]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?:[^\\ud800-\\udbff]|^)[\\udc00-\\udfff]/\n// eslint-disable-next-line\nconst strEscapeSequencesReplacer = /[\\u0000-\\u001f\\u0022\\u005c\\ud800-\\udfff]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?:[^\\ud800-\\udbff]|^)[\\udc00-\\udfff]/g\n\n// Escaped special characters. Use empty strings to fill up unused entries.\nconst meta = [\n  '\\\\u0000', '\\\\u0001', '\\\\u0002', '\\\\u0003', '\\\\u0004',\n  '\\\\u0005', '\\\\u0006', '\\\\u0007', '\\\\b', '\\\\t',\n  '\\\\n', '\\\\u000b', '\\\\f', '\\\\r', '\\\\u000e',\n  '\\\\u000f', '\\\\u0010', '\\\\u0011', '\\\\u0012', '\\\\u0013',\n  '\\\\u0014', '\\\\u0015', '\\\\u0016', '\\\\u0017', '\\\\u0018',\n  '\\\\u0019', '\\\\u001a', '\\\\u001b', '\\\\u001c', '\\\\u001d',\n  '\\\\u001e', '\\\\u001f', '', '', '\\\\\"',\n  '', '', '', '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '', '\\\\\\\\'\n]\n\nfunction escapeFn (str) {\n  if (str.length === 2) {\n    const charCode = str.charCodeAt(1)\n    return `${str[0]}\\\\u${charCode.toString(16)}`\n  }\n  const charCode = str.charCodeAt(0)\n  return meta.length > charCode\n    ? meta[charCode]\n    : `\\\\u${charCode.toString(16)}`\n}\n\n// Escape C0 control characters, double quotes, the backslash and every code\n// unit with a numeric value in the inclusive range 0xD800 to 0xDFFF.\nfunction strEscape (str) {\n  // Some magic numbers that worked out fine while benchmarking with v8 8.0\n  if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {\n    return str\n  }\n  if (str.length > 100) {\n    return str.replace(strEscapeSequencesReplacer, escapeFn)\n  }\n  let result = ''\n  let last = 0\n  for (let i = 0; i < str.length; i++) {\n    const point = str.charCodeAt(i)\n    if (point === 34 || point === 92 || point < 32) {\n      result += `${str.slice(last, i)}${meta[point]}`\n      last = i + 1\n    } else if (point >= 0xd800 && point <= 0xdfff) {\n      if (point <= 0xdbff && i + 1 < str.length) {\n        const point = str.charCodeAt(i + 1)\n        if (point >= 0xdc00 && point <= 0xdfff) {\n          i++\n          continue\n        }\n      }\n      result += `${str.slice(last, i)}${`\\\\u${point.toString(16)}`}`\n      last = i + 1\n    }\n  }\n  result += str.slice(last)\n  return result\n}\n\nfunction insertSort (array) {\n  // Insertion sort is very efficient for small input sizes but it has a bad\n  // worst case complexity. Thus, use native array sort for bigger values.\n  if (array.length > 2e2) {\n    return array.sort()\n  }\n  for (let i = 1; i < array.length; i++) {\n    const currentValue = array[i]\n    let position = i\n    while (position !== 0 && array[position - 1] > currentValue) {\n      array[position] = array[position - 1]\n      position--\n    }\n    array[position] = currentValue\n  }\n  return array\n}\n\nconst typedArrayPrototypeGetSymbolToStringTag =\n  Object.getOwnPropertyDescriptor(\n    Object.getPrototypeOf(\n      Object.getPrototypeOf(\n        new Uint8Array()\n      )\n    ),\n    Symbol.toStringTag\n  ).get\n\nfunction isTypedArrayWithEntries (value) {\n  return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0\n}\n\nfunction stringifyTypedArray (array, separator, maximumBreadth) {\n  if (array.length < maximumBreadth) {\n    maximumBreadth = array.length\n  }\n  const whitespace = separator === ',' ? '' : ' '\n  let res = `\"0\":${whitespace}${array[0]}`\n  for (let i = 1; i < maximumBreadth; i++) {\n    res += `${separator}\"${i}\":${whitespace}${array[i]}`\n  }\n  return res\n}\n\nfunction getCircularValueOption (options) {\n  if (options && Object.prototype.hasOwnProperty.call(options, 'circularValue')) {\n    var circularValue = options.circularValue\n    if (typeof circularValue === 'string') {\n      return `\"${circularValue}\"`\n    }\n    if (circularValue == null) {\n      return circularValue\n    }\n    if (circularValue === Error || circularValue === TypeError) {\n      return {\n        toString () {\n          throw new TypeError('Converting circular structure to JSON')\n        }\n      }\n    }\n    throw new TypeError('The \"circularValue\" argument must be of type string or the value null or undefined')\n  }\n  return '\"[Circular]\"'\n}\n\nfunction getBooleanOption (options, key) {\n  if (options && Object.prototype.hasOwnProperty.call(options, key)) {\n    var value = options[key]\n    if (typeof value !== 'boolean') {\n      throw new TypeError(`The \"${key}\" argument must be of type boolean`)\n    }\n  }\n  return value === undefined ? true : value\n}\n\nfunction getPositiveIntegerOption (options, key) {\n  if (options && Object.prototype.hasOwnProperty.call(options, key)) {\n    var value = options[key]\n    if (typeof value !== 'number') {\n      throw new TypeError(`The \"${key}\" argument must be of type number`)\n    }\n    if (!Number.isInteger(value)) {\n      throw new TypeError(`The \"${key}\" argument must be an integer`)\n    }\n    if (value < 1) {\n      throw new RangeError(`The \"${key}\" argument must be >= 1`)\n    }\n  }\n  return value === undefined ? Infinity : value\n}\n\nfunction getItemCount (number) {\n  if (number === 1) {\n    return '1 item'\n  }\n  return `${number} items`\n}\n\nfunction getUniqueReplacerSet (replacerArray) {\n  const replacerSet = new Set()\n  for (const value of replacerArray) {\n    if (typeof value === 'string') {\n      replacerSet.add(value)\n    } else if (typeof value === 'number') {\n      replacerSet.add(String(value))\n    }\n  }\n  return replacerSet\n}\n\nfunction configure (options) {\n  const circularValue = getCircularValueOption(options)\n  const bigint = getBooleanOption(options, 'bigint')\n  const deterministic = getBooleanOption(options, 'deterministic')\n  const maximumDepth = getPositiveIntegerOption(options, 'maximumDepth')\n  const maximumBreadth = getPositiveIntegerOption(options, 'maximumBreadth')\n\n  function stringifyFnReplacer (key, parent, stack, replacer, spacer, indentation) {\n    let value = parent[key]\n\n    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {\n      value = value.toJSON(key)\n    }\n    value = replacer.call(parent, key, value)\n\n    switch (typeof value) {\n      case 'string':\n        return `\"${strEscape(value)}\"`\n      case 'object': {\n        if (value === null) {\n          return 'null'\n        }\n        if (stack.indexOf(value) !== -1) {\n          return circularValue\n        }\n\n        let res = ''\n        let join = ','\n        const originalIndentation = indentation\n\n        if (Array.isArray(value)) {\n          if (value.length === 0) {\n            return '[]'\n          }\n          if (maximumDepth < stack.length + 1) {\n            return '\"[Array]\"'\n          }\n          stack.push(value)\n          if (spacer !== '') {\n            indentation += spacer\n            res += `\\n${indentation}`\n            join = `,\\n${indentation}`\n          }\n          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)\n          let i = 0\n          for (; i < maximumValuesToStringify - 1; i++) {\n            const tmp = stringifyFnReplacer(i, value, stack, replacer, spacer, indentation)\n            res += tmp !== undefined ? tmp : 'null'\n            res += join\n          }\n          const tmp = stringifyFnReplacer(i, value, stack, replacer, spacer, indentation)\n          res += tmp !== undefined ? tmp : 'null'\n          if (value.length - 1 > maximumBreadth) {\n            const removedKeys = value.length - maximumBreadth - 1\n            res += `${join}\"... ${getItemCount(removedKeys)} not stringified\"`\n          }\n          if (spacer !== '') {\n            res += `\\n${originalIndentation}`\n          }\n          stack.pop()\n          return `[${res}]`\n        }\n\n        let keys = Object.keys(value)\n        const keyLength = keys.length\n        if (keyLength === 0) {\n          return '{}'\n        }\n        if (maximumDepth < stack.length + 1) {\n          return '\"[Object]\"'\n        }\n        let whitespace = ''\n        let separator = ''\n        if (spacer !== '') {\n          indentation += spacer\n          join = `,\\n${indentation}`\n          whitespace = ' '\n        }\n        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)\n        if (isTypedArrayWithEntries(value)) {\n          res += stringifyTypedArray(value, join, maximumBreadth)\n          keys = keys.slice(value.length)\n          maximumPropertiesToStringify -= value.length\n          separator = join\n        }\n        if (deterministic) {\n          keys = insertSort(keys)\n        }\n        stack.push(value)\n        for (let i = 0; i < maximumPropertiesToStringify; i++) {\n          const key = keys[i]\n          const tmp = stringifyFnReplacer(key, value, stack, replacer, spacer, indentation)\n          if (tmp !== undefined) {\n            res += `${separator}\"${strEscape(key)}\":${whitespace}${tmp}`\n            separator = join\n          }\n        }\n        if (keyLength > maximumBreadth) {\n          const removedKeys = keyLength - maximumBreadth\n          res += `${separator}\"...\":${whitespace}\"${getItemCount(removedKeys)} not stringified\"`\n          separator = join\n        }\n        if (spacer !== '' && separator.length > 1) {\n          res = `\\n${indentation}${res}\\n${originalIndentation}`\n        }\n        stack.pop()\n        return `{${res}}`\n      }\n      case 'number':\n        return isFinite(value) ? String(value) : 'null'\n      case 'boolean':\n        return value === true ? 'true' : 'false'\n      case 'bigint':\n        return bigint ? String(value) : undefined\n    }\n  }\n\n  function stringifyArrayReplacer (key, value, stack, replacer, spacer, indentation) {\n    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {\n      value = value.toJSON(key)\n    }\n\n    switch (typeof value) {\n      case 'string':\n        return `\"${strEscape(value)}\"`\n      case 'object': {\n        if (value === null) {\n          return 'null'\n        }\n        if (stack.indexOf(value) !== -1) {\n          return circularValue\n        }\n\n        const originalIndentation = indentation\n        let res = ''\n        let join = ','\n\n        if (Array.isArray(value)) {\n          if (value.length === 0) {\n            return '[]'\n          }\n          if (maximumDepth < stack.length + 1) {\n            return '\"[Array]\"'\n          }\n          stack.push(value)\n          if (spacer !== '') {\n            indentation += spacer\n            res += `\\n${indentation}`\n            join = `,\\n${indentation}`\n          }\n          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)\n          let i = 0\n          for (; i < maximumValuesToStringify - 1; i++) {\n            const tmp = stringifyArrayReplacer(i, value[i], stack, replacer, spacer, indentation)\n            res += tmp !== undefined ? tmp : 'null'\n            res += join\n          }\n          const tmp = stringifyArrayReplacer(i, value[i], stack, replacer, spacer, indentation)\n          res += tmp !== undefined ? tmp : 'null'\n          if (value.length - 1 > maximumBreadth) {\n            const removedKeys = value.length - maximumBreadth - 1\n            res += `${join}\"... ${getItemCount(removedKeys)} not stringified\"`\n          }\n          if (spacer !== '') {\n            res += `\\n${originalIndentation}`\n          }\n          stack.pop()\n          return `[${res}]`\n        }\n        if (replacer.size === 0) {\n          return '{}'\n        }\n        stack.push(value)\n        let whitespace = ''\n        if (spacer !== '') {\n          indentation += spacer\n          join = `,\\n${indentation}`\n          whitespace = ' '\n        }\n        let separator = ''\n        for (const key of replacer) {\n          const tmp = stringifyArrayReplacer(key, value[key], stack, replacer, spacer, indentation)\n          if (tmp !== undefined) {\n            res += `${separator}\"${strEscape(key)}\":${whitespace}${tmp}`\n            separator = join\n          }\n        }\n        if (spacer !== '' && separator.length > 1) {\n          res = `\\n${indentation}${res}\\n${originalIndentation}`\n        }\n        stack.pop()\n        return `{${res}}`\n      }\n      case 'number':\n        return isFinite(value) ? String(value) : 'null'\n      case 'boolean':\n        return value === true ? 'true' : 'false'\n      case 'bigint':\n        return bigint ? String(value) : undefined\n    }\n  }\n\n  function stringifyIndent (key, value, stack, spacer, indentation) {\n    switch (typeof value) {\n      case 'string':\n        return `\"${strEscape(value)}\"`\n      case 'object': {\n        if (value === null) {\n          return 'null'\n        }\n        if (typeof value.toJSON === 'function') {\n          value = value.toJSON(key)\n          // Prevent calling `toJSON` again.\n          if (typeof value !== 'object') {\n            return stringifyIndent(key, value, stack, spacer, indentation)\n          }\n          if (value === null) {\n            return 'null'\n          }\n        }\n        if (stack.indexOf(value) !== -1) {\n          return circularValue\n        }\n        const originalIndentation = indentation\n\n        if (Array.isArray(value)) {\n          if (value.length === 0) {\n            return '[]'\n          }\n          if (maximumDepth < stack.length + 1) {\n            return '\"[Array]\"'\n          }\n          stack.push(value)\n          indentation += spacer\n          let res = `\\n${indentation}`\n          const join = `,\\n${indentation}`\n          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)\n          let i = 0\n          for (; i < maximumValuesToStringify - 1; i++) {\n            const tmp = stringifyIndent(i, value[i], stack, spacer, indentation)\n            res += tmp !== undefined ? tmp : 'null'\n            res += join\n          }\n          const tmp = stringifyIndent(i, value[i], stack, spacer, indentation)\n          res += tmp !== undefined ? tmp : 'null'\n          if (value.length - 1 > maximumBreadth) {\n            const removedKeys = value.length - maximumBreadth - 1\n            res += `${join}\"... ${getItemCount(removedKeys)} not stringified\"`\n          }\n          res += `\\n${originalIndentation}`\n          stack.pop()\n          return `[${res}]`\n        }\n\n        let keys = Object.keys(value)\n        const keyLength = keys.length\n        if (keyLength === 0) {\n          return '{}'\n        }\n        if (maximumDepth < stack.length + 1) {\n          return '\"[Object]\"'\n        }\n        indentation += spacer\n        const join = `,\\n${indentation}`\n        let res = ''\n        let separator = ''\n        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)\n        if (isTypedArrayWithEntries(value)) {\n          res += stringifyTypedArray(value, join, maximumBreadth)\n          keys = keys.slice(value.length)\n          maximumPropertiesToStringify -= value.length\n          separator = join\n        }\n        if (deterministic) {\n          keys = insertSort(keys)\n        }\n        stack.push(value)\n        for (let i = 0; i < maximumPropertiesToStringify; i++) {\n          const key = keys[i]\n          const tmp = stringifyIndent(key, value[key], stack, spacer, indentation)\n          if (tmp !== undefined) {\n            res += `${separator}\"${strEscape(key)}\": ${tmp}`\n            separator = join\n          }\n        }\n        if (keyLength > maximumBreadth) {\n          const removedKeys = keyLength - maximumBreadth\n          res += `${separator}\"...\": \"${getItemCount(removedKeys)} not stringified\"`\n          separator = join\n        }\n        if (separator !== '') {\n          res = `\\n${indentation}${res}\\n${originalIndentation}`\n        }\n        stack.pop()\n        return `{${res}}`\n      }\n      case 'number':\n        return isFinite(value) ? String(value) : 'null'\n      case 'boolean':\n        return value === true ? 'true' : 'false'\n      case 'bigint':\n        return bigint ? String(value) : undefined\n    }\n  }\n\n  function stringifySimple (key, value, stack) {\n    switch (typeof value) {\n      case 'string':\n        return `\"${strEscape(value)}\"`\n      case 'object': {\n        if (value === null) {\n          return 'null'\n        }\n        if (typeof value.toJSON === 'function') {\n          value = value.toJSON(key)\n          // Prevent calling `toJSON` again\n          if (typeof value !== 'object') {\n            return stringifySimple(key, value, stack)\n          }\n          if (value === null) {\n            return 'null'\n          }\n        }\n        if (stack.indexOf(value) !== -1) {\n          return circularValue\n        }\n\n        let res = ''\n\n        if (Array.isArray(value)) {\n          if (value.length === 0) {\n            return '[]'\n          }\n          if (maximumDepth < stack.length + 1) {\n            return '\"[Array]\"'\n          }\n          stack.push(value)\n          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)\n          let i = 0\n          for (; i < maximumValuesToStringify - 1; i++) {\n            const tmp = stringifySimple(i, value[i], stack)\n            res += tmp !== undefined ? tmp : 'null'\n            res += ','\n          }\n          const tmp = stringifySimple(i, value[i], stack)\n          res += tmp !== undefined ? tmp : 'null'\n          if (value.length - 1 > maximumBreadth) {\n            const removedKeys = value.length - maximumBreadth - 1\n            res += `,\"... ${getItemCount(removedKeys)} not stringified\"`\n          }\n          stack.pop()\n          return `[${res}]`\n        }\n\n        let keys = Object.keys(value)\n        const keyLength = keys.length\n        if (keyLength === 0) {\n          return '{}'\n        }\n        if (maximumDepth < stack.length + 1) {\n          return '\"[Object]\"'\n        }\n        let separator = ''\n        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)\n        if (isTypedArrayWithEntries(value)) {\n          res += stringifyTypedArray(value, ',', maximumBreadth)\n          keys = keys.slice(value.length)\n          maximumPropertiesToStringify -= value.length\n          separator = ','\n        }\n        if (deterministic) {\n          keys = insertSort(keys)\n        }\n        stack.push(value)\n        for (let i = 0; i < maximumPropertiesToStringify; i++) {\n          const key = keys[i]\n          const tmp = stringifySimple(key, value[key], stack)\n          if (tmp !== undefined) {\n            res += `${separator}\"${strEscape(key)}\":${tmp}`\n            separator = ','\n          }\n        }\n        if (keyLength > maximumBreadth) {\n          const removedKeys = keyLength - maximumBreadth\n          res += `${separator}\"...\":\"${getItemCount(removedKeys)} not stringified\"`\n        }\n        stack.pop()\n        return `{${res}}`\n      }\n      case 'number':\n        return isFinite(value) ? String(value) : 'null'\n      case 'boolean':\n        return value === true ? 'true' : 'false'\n      case 'bigint':\n        return bigint ? String(value) : undefined\n    }\n  }\n\n  function stringify (value, replacer, space) {\n    if (arguments.length > 1) {\n      let spacer = ''\n      if (typeof space === 'number') {\n        spacer = ' '.repeat(Math.min(space, 10))\n      } else if (typeof space === 'string') {\n        spacer = space.slice(0, 10)\n      }\n      if (replacer != null) {\n        if (typeof replacer === 'function') {\n          return stringifyFnReplacer('', { '': value }, [], replacer, spacer, '')\n        }\n        if (Array.isArray(replacer)) {\n          return stringifyArrayReplacer('', value, [], getUniqueReplacerSet(replacer), spacer, '')\n        }\n      }\n      if (spacer.length !== 0) {\n        return stringifyIndent('', value, [], spacer, '')\n      }\n    }\n    return stringifySimple('', value, [])\n  }\n\n  return stringify\n}\n"]},"metadata":{},"sourceType":"script"}