{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _deleteProperty = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/reflect/delete-property\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _assign = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/assign\"));\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/keys\"));\n\nvar _getOwnPropertyDescriptor = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/slicedToArray\"));\n\nvar _applyDecoratedDescriptor2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/applyDecoratedDescriptor\"));\n\nvar _get2 = _interopRequireDefault(require(\"lodash/get\"));\n\nvar _common = require(\"@webex/common\");\n\nvar _webexCore = require(\"@webex/webex-core\");\n\nvar _obj;\n\nvar Search = _webexCore.WebexPlugin.extend((_obj = {\n  namespace: 'Search',\n  people: function people(options) {\n    options = options || {};\n\n    if (!options.queryString && options.query) {\n      options.queryString = options.query;\n      (0, _deleteProperty.default)(options, 'query');\n    }\n\n    if (!options.queryString) {\n      return _promise.default.reject(new Error('`options.query` is required'));\n    }\n\n    return this.request({\n      api: 'argonaut',\n      resource: 'directory',\n      method: 'POST',\n      body: options\n    }).then(function (res) {\n      return res.body;\n    });\n  },\n  bindSearchKey: function bindSearchKey() {\n    var _this = this;\n\n    return this.webex.internal.encryption.kms.createUnboundKeys({\n      count: 1\n    }).then(function (_ref) {\n      var _ref2 = (0, _slicedToArray2.default)(_ref, 1),\n          key = _ref2[0];\n\n      return _this.webex.internal.encryption.kms.createResource({\n        key: key,\n        userIds: [_this.webex.internal.device.userId]\n      }).then(function () {\n        return _this.webex.internal.device.set('searchEncryptionKeyUrl', key.uri);\n      });\n    });\n  },\n\n  /**\n  * Fetches search result activities\n  * @param {Object} options\n  * @param {boolean} options.includeRemoteClusterReferences when true,\n  * includes search results from remote clusters\n  * @returns {Promise<Array>} Resolves with the activities\n  */\n  search: function search(options) {\n    var _this2 = this;\n    /* eslint max-nested-callbacks: [0] */\n\n\n    options = options || {};\n\n    var promise = _promise.default.resolve();\n\n    if (!this.webex.internal.device.searchEncryptionKeyUrl) {\n      promise = this.bindSearchKey();\n    }\n\n    return promise.then(function () {\n      return _this2.webex.request({\n        service: 'argonaut',\n        resource: 'search',\n        method: 'POST',\n        body: (0, _assign.default)(options, {\n          searchEncryptionKeyUrl: _this2.webex.internal.device.searchEncryptionKeyUrl\n        })\n      });\n    }).then(function (res) {\n      var resActivities = (0, _get2.default)(res, 'body.activities.items', []);\n\n      if (options.includeRemoteClusterReferences && res.body.breadcrumbs) {\n        var breadcrumbs = res.body.breadcrumbs;\n        var promises = [];\n        (0, _keys.default)(breadcrumbs).forEach(function (cluster) {\n          // Map activity URLs to their cluster\n          var editedCluster = \"\".concat(cluster, \":identityLookup\");\n          var clusterActivityUrls = breadcrumbs[cluster].items.map(function (activity) {\n            return activity.activityUrl;\n          }); // Find activities per cluster\n\n          var bulkActivitiesPromise = _this2.webex.internal.conversation.bulkActivitiesFetch(clusterActivityUrls, {\n            cluster: editedCluster\n          }).catch(function (err) {\n            _this2.logger.warn('search: error fetching from remote clusters', err);\n\n            return _promise.default.resolve([]);\n          });\n\n          promises.push(bulkActivitiesPromise);\n        });\n        return _promise.default.all(promises).then(function (clusterResults) {\n          return clusterResults.reduce(function (accumulator, clusterResult) {\n            return accumulator.concat(clusterResult);\n          }, resActivities);\n        });\n      }\n\n      return resActivities;\n    });\n  },\n  version: \"1.154.2\"\n}, (0, _applyDecoratedDescriptor2.default)(_obj, \"bindSearchKey\", [_common.oneFlight], (0, _getOwnPropertyDescriptor.default)(_obj, \"bindSearchKey\"), _obj), _obj));\n\nvar _default = Search;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["Search","WebexPlugin","extend","namespace","people","options","queryString","query","_promise","reject","Error","request","api","resource","method","body","then","res","bindSearchKey","webex","internal","encryption","kms","createUnboundKeys","count","key","_this","createResource","userIds","device","userId","set","uri","search","promise","resolve","searchEncryptionKeyUrl","_this2","service","resActivities","includeRemoteClusterReferences","breadcrumbs","promises","forEach","cluster","editedCluster","clusterActivityUrls","items","map","activity","activityUrl","bulkActivitiesPromise","conversation","bulkActivitiesFetch","catch","err","logger","warn","push","all","clusterResults","reduce","accumulator","clusterResult","concat","version","oneFlight"],"sources":["search.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {get} from 'lodash';\nimport {oneFlight} from '@webex/common';\nimport {WebexPlugin} from '@webex/webex-core';\n\nconst Search = WebexPlugin.extend({\n  namespace: 'Search',\n\n  people(options) {\n    options = options || {};\n\n    if (!options.queryString && options.query) {\n      options.queryString = options.query;\n      Reflect.deleteProperty(options, 'query');\n    }\n\n    if (!options.queryString) {\n      return Promise.reject(new Error('`options.query` is required'));\n    }\n\n    return this.request({\n      api: 'argonaut',\n      resource: 'directory',\n      method: 'POST',\n      body: options\n    })\n      .then((res) => res.body);\n  },\n\n  @oneFlight\n  bindSearchKey() {\n    return this.webex.internal.encryption.kms.createUnboundKeys({count: 1})\n      .then(([key]) => this.webex.internal.encryption.kms.createResource({\n        key,\n        userIds: [this.webex.internal.device.userId]\n      })\n        .then(() => this.webex.internal.device.set('searchEncryptionKeyUrl', key.uri)));\n  },\n\n  /**\n  * Fetches search result activities\n  * @param {Object} options\n  * @param {boolean} options.includeRemoteClusterReferences when true,\n  * includes search results from remote clusters\n  * @returns {Promise<Array>} Resolves with the activities\n  */\n  search(options) {\n    /* eslint max-nested-callbacks: [0] */\n    options = options || {};\n\n    let promise = Promise.resolve();\n\n    if (!this.webex.internal.device.searchEncryptionKeyUrl) {\n      promise = this.bindSearchKey();\n    }\n\n    return promise\n      .then(() => this.webex.request({\n        service: 'argonaut',\n        resource: 'search',\n        method: 'POST',\n        body: Object.assign(options, {\n          searchEncryptionKeyUrl: this.webex.internal.device.searchEncryptionKeyUrl\n        })\n      }))\n      .then((res) => {\n        const resActivities = get(res, 'body.activities.items', []);\n\n        if (options.includeRemoteClusterReferences && res.body.breadcrumbs) {\n          const {breadcrumbs} = res.body;\n          const promises = [];\n\n          Object.keys(breadcrumbs).forEach((cluster) => {\n            // Map activity URLs to their cluster\n            const editedCluster = `${cluster}:identityLookup`;\n            const clusterActivityUrls = breadcrumbs[cluster].items.map(\n              (activity) => activity.activityUrl\n            );\n\n            // Find activities per cluster\n            const bulkActivitiesPromise = this.webex.internal.conversation.bulkActivitiesFetch(\n              clusterActivityUrls,\n              {cluster: editedCluster}\n            )\n              .catch((err) => {\n                this.logger.warn(\n                  'search: error fetching from remote clusters',\n                  err\n                );\n\n                return Promise.resolve([]);\n              });\n\n            promises.push(bulkActivitiesPromise);\n          });\n\n          return Promise.all(promises).then(\n            (clusterResults) => clusterResults.reduce(\n              (accumulator, clusterResult) => accumulator.concat(clusterResult),\n              resActivities\n            )\n          );\n        }\n\n        return resActivities;\n      });\n  }\n\n});\n\nexport default Search;\n"]},"metadata":{},"sourceType":"script"}