{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/rkanthet/Documents/test_window_object/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _get from \"C:/Users/rkanthet/Documents/test_window_object/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/rkanthet/Documents/test_window_object/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/rkanthet/Documents/test_window_object/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/rkanthet/Documents/test_window_object/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"C:/Users/rkanthet/Documents/test_window_object/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/rkanthet/Documents/test_window_object/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/* eslint-disable indent */\n\n/*\n * Copyright (c) 2016-2018, Peculiar Ventures\n * All rights reserved.\n *\n * Author 2016-2018, Yury Strozhevsky <www.strozhevsky.com>.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its contributors\n *    may be used to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\n * OF SUCH DAMAGE.\n *\n */\n//**************************************************************************************\nimport { getParametersValue, padNumber, isEqualBuffer, bufferToHexCodes, checkBufferParams, utilToBase, utilFromBase, utilEncodeTC, utilDecodeTC, utilConcatBuf, utilConcatView } from \"pvutils\"; //**************************************************************************************\n//region Other utility functions\n//**************************************************************************************\n\nfunction assertBigInt() {\n  if (typeof BigInt === \"undefined\") {\n    throw new Error(\"BigInt is not defined. Your environment doesn't implement BigInt.\");\n  }\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of global variables\n//**************************************************************************************\n\n\nvar powers2 = [new Uint8Array([1])];\nvar digitsString = \"0123456789\"; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration for \"LocalBaseBlock\" class\n//**************************************************************************************\n\n/**\n * Class used as a base block for all remaining ASN.1 classes\n * @typedef LocalBaseBlock\n * @interface\n * @property {number} blockLength\n * @property {string} error\n * @property {Array.<string>} warnings\n * @property {ArrayBuffer} valueBeforeDecode\n */\n\nvar LocalBaseBlock = /*#__PURE__*/function () {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalBaseBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueBeforeDecode]\n   */\n  function LocalBaseBlock() {\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LocalBaseBlock);\n\n    /**\n     * @type {number} blockLength\n     */\n    this.blockLength = getParametersValue(parameters, \"blockLength\", 0);\n    /**\n     * @type {string} error\n     */\n\n    this.error = getParametersValue(parameters, \"error\", \"\");\n    /**\n     * @type {Array.<string>} warnings\n     */\n\n    this.warnings = getParametersValue(parameters, \"warnings\", []); //noinspection JSCheckFunctionSignatures\n\n    /**\n     * @type {ArrayBuffer} valueBeforeDecode\n     */\n\n    if (\"valueBeforeDecode\" in parameters) this.valueBeforeDecode = parameters.valueBeforeDecode.slice(0);else this.valueBeforeDecode = new ArrayBuffer(0);\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(LocalBaseBlock, [{\n    key: \"toJSON\",\n    value: //**********************************************************************************\n\n    /**\n     * Convertion for the block to JSON object\n     * @returns {{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n     */\n    function toJSON() {\n      return {\n        blockName: this.constructor.blockName(),\n        blockLength: this.blockLength,\n        error: this.error,\n        warnings: this.warnings,\n        valueBeforeDecode: bufferToHexCodes(this.valueBeforeDecode, 0, this.valueBeforeDecode.byteLength)\n      };\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"baseBlock\";\n    }\n  }]);\n\n  return LocalBaseBlock;\n}(); //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Description for \"HexBlock\" class\n//**************************************************************************************\n\n/**\n * Class used as a base block for all remaining ASN.1 classes\n * @extends LocalBaseBlock\n * @typedef HexBlock\n * @property {number} blockLength\n * @property {string} error\n * @property {Array.<string>} warnings\n * @property {ArrayBuffer} valueBeforeDecode\n * @property {boolean} isHexOnly\n * @property {ArrayBuffer} valueHex\n */\n//noinspection JSUnusedLocalSymbols\n\n\nexport var HexBlock = function HexBlock(BaseClass) {\n  return /*#__PURE__*/function (_BaseClass) {\n    _inherits(LocalHexBlockMixin, _BaseClass);\n\n    var _super = _createSuper(LocalHexBlockMixin);\n\n    //**********************************************************************************\n    //noinspection JSUnusedGlobalSymbols\n\n    /**\n     * Constructor for \"HexBlock\" class\n     * @param {Object} [parameters={}]\n     * @property {ArrayBuffer} [valueHex]\n     */\n    function LocalHexBlockMixin() {\n      var _this;\n\n      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _classCallCheck(this, LocalHexBlockMixin);\n\n      _this = _super.call(this, parameters);\n      /**\n       * @type {boolean}\n       */\n\n      _this.isHexOnly = getParametersValue(parameters, \"isHexOnly\", false);\n      /**\n       * @type {ArrayBuffer}\n       */\n\n      if (\"valueHex\" in parameters) _this.valueHex = parameters.valueHex.slice(0);else _this.valueHex = new ArrayBuffer(0);\n      return _this;\n    } //**********************************************************************************\n\n    /**\n     * Aux function, need to get a block name. Need to have it here for inhiritence\n     * @returns {string}\n     */\n\n\n    _createClass(LocalHexBlockMixin, [{\n      key: \"fromBER\",\n      value: //**********************************************************************************\n\n      /**\n       * Base function for converting block from BER encoded array of bytes\n       * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n       * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n       * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n       * @returns {number} Offset after least decoded byte\n       */\n      function fromBER(inputBuffer, inputOffset, inputLength) {\n        //region Basic check for parameters\n        //noinspection JSCheckFunctionSignatures\n        if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n        //region Getting Uint8Array from ArrayBuffer\n\n        var intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n        //region Initial checks\n\n        if (intBuffer.length === 0) {\n          this.warnings.push(\"Zero buffer length\");\n          return inputOffset;\n        } //endregion\n        //region Copy input buffer to internal buffer\n\n\n        this.valueHex = inputBuffer.slice(inputOffset, inputOffset + inputLength); //endregion\n\n        this.blockLength = inputLength;\n        return inputOffset + inputLength;\n      } //**********************************************************************************\n\n      /**\n       * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n       * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n       * @returns {ArrayBuffer}\n       */\n\n    }, {\n      key: \"toBER\",\n      value: function toBER() {\n        var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n        if (this.isHexOnly !== true) {\n          this.error = \"Flag \\\"isHexOnly\\\" is not set, abort\";\n          return new ArrayBuffer(0);\n        }\n\n        if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength); //noinspection JSCheckFunctionSignatures\n\n        return this.valueHex.slice(0);\n      } //**********************************************************************************\n\n      /**\n       * Convertion for the block to JSON object\n       * @returns {Object}\n       */\n\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n        try {\n          object = _get(_getPrototypeOf(LocalHexBlockMixin.prototype), \"toJSON\", this).call(this);\n        } catch (ex) {} //endregion\n\n\n        object.blockName = this.constructor.blockName();\n        object.isHexOnly = this.isHexOnly;\n        object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n        return object;\n      } //**********************************************************************************\n\n    }], [{\n      key: \"blockName\",\n      value: function blockName() {\n        return \"hexBlock\";\n      }\n    }]);\n\n    return LocalHexBlockMixin;\n  }(BaseClass);\n}; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of identification block class\n//**************************************************************************************\n\nvar LocalIdentificationBlock = /*#__PURE__*/function (_HexBlock) {\n  _inherits(LocalIdentificationBlock, _HexBlock);\n\n  var _super2 = _createSuper(LocalIdentificationBlock);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalBaseBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {Object} [idBlock]\n   */\n  function LocalIdentificationBlock() {\n    var _this2;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LocalIdentificationBlock);\n\n    _this2 = _super2.call(this);\n\n    if (\"idBlock\" in parameters) {\n      //region Properties from hexBlock class\n      _this2.isHexOnly = getParametersValue(parameters.idBlock, \"isHexOnly\", false);\n      _this2.valueHex = getParametersValue(parameters.idBlock, \"valueHex\", new ArrayBuffer(0)); //endregion\n\n      _this2.tagClass = getParametersValue(parameters.idBlock, \"tagClass\", -1);\n      _this2.tagNumber = getParametersValue(parameters.idBlock, \"tagNumber\", -1);\n      _this2.isConstructed = getParametersValue(parameters.idBlock, \"isConstructed\", false);\n    } else {\n      _this2.tagClass = -1;\n      _this2.tagNumber = -1;\n      _this2.isConstructed = false;\n    }\n\n    return _this2;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(LocalIdentificationBlock, [{\n    key: \"toBER\",\n    value: //**********************************************************************************\n\n    /**\n     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n     * @returns {ArrayBuffer}\n     */\n    function toBER() {\n      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      //region Initial variables\n      var firstOctet = 0;\n      var retBuf;\n      var retView; //endregion\n\n      switch (this.tagClass) {\n        case 1:\n          firstOctet |= 0x00; // UNIVERSAL\n\n          break;\n\n        case 2:\n          firstOctet |= 0x40; // APPLICATION\n\n          break;\n\n        case 3:\n          firstOctet |= 0x80; // CONTEXT-SPECIFIC\n\n          break;\n\n        case 4:\n          firstOctet |= 0xC0; // PRIVATE\n\n          break;\n\n        default:\n          this.error = \"Unknown tag class\";\n          return new ArrayBuffer(0);\n      }\n\n      if (this.isConstructed) firstOctet |= 0x20;\n\n      if (this.tagNumber < 31 && !this.isHexOnly) {\n        retBuf = new ArrayBuffer(1);\n        retView = new Uint8Array(retBuf);\n\n        if (!sizeOnly) {\n          var number = this.tagNumber;\n          number &= 0x1F;\n          firstOctet |= number;\n          retView[0] = firstOctet;\n        }\n\n        return retBuf;\n      }\n\n      if (this.isHexOnly === false) {\n        var encodedBuf = utilToBase(this.tagNumber, 7);\n        var encodedView = new Uint8Array(encodedBuf);\n        var size = encodedBuf.byteLength;\n        retBuf = new ArrayBuffer(size + 1);\n        retView = new Uint8Array(retBuf);\n        retView[0] = firstOctet | 0x1F;\n\n        if (!sizeOnly) {\n          for (var i = 0; i < size - 1; i++) {\n            retView[i + 1] = encodedView[i] | 0x80;\n          }\n\n          retView[size] = encodedView[size - 1];\n        }\n\n        return retBuf;\n      }\n\n      retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);\n      retView = new Uint8Array(retBuf);\n      retView[0] = firstOctet | 0x1F;\n\n      if (sizeOnly === false) {\n        var curView = new Uint8Array(this.valueHex);\n\n        for (var _i = 0; _i < curView.length - 1; _i++) {\n          retView[_i + 1] = curView[_i] | 0x80;\n        }\n\n        retView[this.valueHex.byteLength] = curView[curView.length - 1];\n      }\n\n      return retBuf;\n    } //**********************************************************************************\n\n    /**\n     * Base function for converting block from BER encoded array of bytes\n     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n     * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n     * @returns {number}\n     */\n\n  }, {\n    key: \"fromBER\",\n    value: function fromBER(inputBuffer, inputOffset, inputLength) {\n      //region Basic check for parameters\n      //noinspection JSCheckFunctionSignatures\n      if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n      //region Getting Uint8Array from ArrayBuffer\n\n      var intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n      //region Initial checks\n\n      if (intBuffer.length === 0) {\n        this.error = \"Zero buffer length\";\n        return -1;\n      } //endregion\n      //region Find tag class\n\n\n      var tagClassMask = intBuffer[0] & 0xC0;\n\n      switch (tagClassMask) {\n        case 0x00:\n          this.tagClass = 1; // UNIVERSAL\n\n          break;\n\n        case 0x40:\n          this.tagClass = 2; // APPLICATION\n\n          break;\n\n        case 0x80:\n          this.tagClass = 3; // CONTEXT-SPECIFIC\n\n          break;\n\n        case 0xC0:\n          this.tagClass = 4; // PRIVATE\n\n          break;\n\n        default:\n          this.error = \"Unknown tag class\";\n          return -1;\n      } //endregion\n      //region Find it's constructed or not\n\n\n      this.isConstructed = (intBuffer[0] & 0x20) === 0x20; //endregion\n      //region Find tag number\n\n      this.isHexOnly = false;\n      var tagNumberMask = intBuffer[0] & 0x1F; //region Simple case (tag number < 31)\n\n      if (tagNumberMask !== 0x1F) {\n        this.tagNumber = tagNumberMask;\n        this.blockLength = 1;\n      } //endregion\n      //region Tag number bigger or equal to 31\n      else {\n        var count = 1;\n        this.valueHex = new ArrayBuffer(255);\n        var tagNumberBufferMaxLength = 255;\n        var intTagNumberBuffer = new Uint8Array(this.valueHex); //noinspection JSBitwiseOperatorUsage\n\n        while (intBuffer[count] & 0x80) {\n          intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\n          count++;\n\n          if (count >= intBuffer.length) {\n            this.error = \"End of input reached before message was fully decoded\";\n            return -1;\n          } //region In case if tag number length is greater than 255 bytes (rare but possible case)\n\n\n          if (count === tagNumberBufferMaxLength) {\n            tagNumberBufferMaxLength += 255;\n\n            var _tempBuffer = new ArrayBuffer(tagNumberBufferMaxLength);\n\n            var _tempBufferView = new Uint8Array(_tempBuffer);\n\n            for (var i = 0; i < intTagNumberBuffer.length; i++) {\n              _tempBufferView[i] = intTagNumberBuffer[i];\n            }\n\n            this.valueHex = new ArrayBuffer(tagNumberBufferMaxLength);\n            intTagNumberBuffer = new Uint8Array(this.valueHex);\n          } //endregion\n\n        }\n\n        this.blockLength = count + 1;\n        intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F; // Write last byte to buffer\n        //region Cut buffer\n\n        var tempBuffer = new ArrayBuffer(count);\n        var tempBufferView = new Uint8Array(tempBuffer);\n\n        for (var _i2 = 0; _i2 < count; _i2++) {\n          tempBufferView[_i2] = intTagNumberBuffer[_i2];\n        }\n\n        this.valueHex = new ArrayBuffer(count);\n        intTagNumberBuffer = new Uint8Array(this.valueHex);\n        intTagNumberBuffer.set(tempBufferView); //endregion\n        //region Try to convert long tag number to short form\n\n        if (this.blockLength <= 9) this.tagNumber = utilFromBase(intTagNumberBuffer, 7);else {\n          this.isHexOnly = true;\n          this.warnings.push(\"Tag too long, represented as hex-coded\");\n        } //endregion\n      } //endregion\n      //endregion\n      //region Check if constructed encoding was using for primitive type\n\n\n      if (this.tagClass === 1 && this.isConstructed) {\n        switch (this.tagNumber) {\n          case 1: // Boolean\n\n          case 2: // REAL\n\n          case 5: // Null\n\n          case 6: // OBJECT IDENTIFIER\n\n          case 9: // REAL\n\n          case 13: // RELATIVE OBJECT IDENTIFIER\n\n          case 14: // Time\n\n          case 23:\n          case 24:\n          case 31:\n          case 32:\n          case 33:\n          case 34:\n            this.error = \"Constructed encoding used for primitive type\";\n            return -1;\n\n          default:\n        }\n      } //endregion\n\n\n      return inputOffset + this.blockLength; // Return current offset in input buffer\n    } //**********************************************************************************\n\n    /**\n     * Convertion for the block to JSON object\n     * @returns {{blockName: string,\n     *  tagClass: number,\n     *  tagNumber: number,\n     *  isConstructed: boolean,\n     *  isHexOnly: boolean,\n     *  valueHex: ArrayBuffer,\n     *  blockLength: number,\n     *  error: string, warnings: Array.<string>,\n     *  valueBeforeDecode: string}}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n      try {\n        object = _get(_getPrototypeOf(LocalIdentificationBlock.prototype), \"toJSON\", this).call(this);\n      } catch (ex) {} //endregion\n\n\n      object.blockName = this.constructor.blockName();\n      object.tagClass = this.tagClass;\n      object.tagNumber = this.tagNumber;\n      object.isConstructed = this.isConstructed;\n      return object;\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"identificationBlock\";\n    }\n  }]);\n\n  return LocalIdentificationBlock;\n}(HexBlock(LocalBaseBlock)); //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of length block class\n//**************************************************************************************\n\n\nvar LocalLengthBlock = /*#__PURE__*/function (_LocalBaseBlock) {\n  _inherits(LocalLengthBlock, _LocalBaseBlock);\n\n  var _super3 = _createSuper(LocalLengthBlock);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalLengthBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {Object} [lenBlock]\n   */\n  function LocalLengthBlock() {\n    var _this3;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LocalLengthBlock);\n\n    _this3 = _super3.call(this);\n\n    if (\"lenBlock\" in parameters) {\n      _this3.isIndefiniteForm = getParametersValue(parameters.lenBlock, \"isIndefiniteForm\", false);\n      _this3.longFormUsed = getParametersValue(parameters.lenBlock, \"longFormUsed\", false);\n      _this3.length = getParametersValue(parameters.lenBlock, \"length\", 0);\n    } else {\n      _this3.isIndefiniteForm = false;\n      _this3.longFormUsed = false;\n      _this3.length = 0;\n    }\n\n    return _this3;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(LocalLengthBlock, [{\n    key: \"fromBER\",\n    value: //**********************************************************************************\n\n    /**\n     * Base function for converting block from BER encoded array of bytes\n     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n     * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n     * @returns {number}\n     */\n    function fromBER(inputBuffer, inputOffset, inputLength) {\n      //region Basic check for parameters\n      //noinspection JSCheckFunctionSignatures\n      if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n      //region Getting Uint8Array from ArrayBuffer\n\n      var intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n      //region Initial checks\n\n      if (intBuffer.length === 0) {\n        this.error = \"Zero buffer length\";\n        return -1;\n      }\n\n      if (intBuffer[0] === 0xFF) {\n        this.error = \"Length block 0xFF is reserved by standard\";\n        return -1;\n      } //endregion\n      //region Check for length form type\n\n\n      this.isIndefiniteForm = intBuffer[0] === 0x80; //endregion\n      //region Stop working in case of indefinite length form\n\n      if (this.isIndefiniteForm === true) {\n        this.blockLength = 1;\n        return inputOffset + this.blockLength;\n      } //endregion\n      //region Check is long form of length encoding using\n\n\n      this.longFormUsed = !!(intBuffer[0] & 0x80); //endregion\n      //region Stop working in case of short form of length value\n\n      if (this.longFormUsed === false) {\n        this.length = intBuffer[0];\n        this.blockLength = 1;\n        return inputOffset + this.blockLength;\n      } //endregion\n      //region Calculate length value in case of long form\n\n\n      var count = intBuffer[0] & 0x7F;\n\n      if (count > 8) // Too big length value\n        {\n          this.error = \"Too big integer\";\n          return -1;\n        }\n\n      if (count + 1 > intBuffer.length) {\n        this.error = \"End of input reached before message was fully decoded\";\n        return -1;\n      }\n\n      var lengthBufferView = new Uint8Array(count);\n\n      for (var i = 0; i < count; i++) {\n        lengthBufferView[i] = intBuffer[i + 1];\n      }\n\n      if (lengthBufferView[count - 1] === 0x00) this.warnings.push(\"Needlessly long encoded length\");\n      this.length = utilFromBase(lengthBufferView, 8);\n      if (this.longFormUsed && this.length <= 127) this.warnings.push(\"Unnecessary usage of long length form\");\n      this.blockLength = count + 1; //endregion\n\n      return inputOffset + this.blockLength; // Return current offset in input buffer\n    } //**********************************************************************************\n\n    /**\n     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n     * @returns {ArrayBuffer}\n     */\n\n  }, {\n    key: \"toBER\",\n    value: function toBER() {\n      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      //region Initial variables\n      var retBuf;\n      var retView; //endregion\n\n      if (this.length > 127) this.longFormUsed = true;\n\n      if (this.isIndefiniteForm) {\n        retBuf = new ArrayBuffer(1);\n\n        if (sizeOnly === false) {\n          retView = new Uint8Array(retBuf);\n          retView[0] = 0x80;\n        }\n\n        return retBuf;\n      }\n\n      if (this.longFormUsed === true) {\n        var encodedBuf = utilToBase(this.length, 8);\n\n        if (encodedBuf.byteLength > 127) {\n          this.error = \"Too big length\";\n          return new ArrayBuffer(0);\n        }\n\n        retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);\n        if (sizeOnly === true) return retBuf;\n        var encodedView = new Uint8Array(encodedBuf);\n        retView = new Uint8Array(retBuf);\n        retView[0] = encodedBuf.byteLength | 0x80;\n\n        for (var i = 0; i < encodedBuf.byteLength; i++) {\n          retView[i + 1] = encodedView[i];\n        }\n\n        return retBuf;\n      }\n\n      retBuf = new ArrayBuffer(1);\n\n      if (sizeOnly === false) {\n        retView = new Uint8Array(retBuf);\n        retView[0] = this.length;\n      }\n\n      return retBuf;\n    } //**********************************************************************************\n\n    /**\n     * Convertion for the block to JSON object\n     * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n      try {\n        object = _get(_getPrototypeOf(LocalLengthBlock.prototype), \"toJSON\", this).call(this);\n      } catch (ex) {} //endregion\n\n\n      object.blockName = this.constructor.blockName();\n      object.isIndefiniteForm = this.isIndefiniteForm;\n      object.longFormUsed = this.longFormUsed;\n      object.length = this.length;\n      return object;\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"lengthBlock\";\n    }\n  }]);\n\n  return LocalLengthBlock;\n}(LocalBaseBlock); //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of value block class\n//**************************************************************************************\n\n\nexport var ValueBlock = /*#__PURE__*/function (_LocalBaseBlock2) {\n  _inherits(ValueBlock, _LocalBaseBlock2);\n\n  var _super4 = _createSuper(ValueBlock);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"ValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n  function ValueBlock() {\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, ValueBlock);\n\n    return _super4.call(this, parameters);\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(ValueBlock, [{\n    key: \"fromBER\",\n    value: //**********************************************************************************\n    //noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols,JSUnusedLocalSymbols\n\n    /**\n     * Base function for converting block from BER encoded array of bytes\n     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n     * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n     * @returns {number}\n     */\n    function fromBER(inputBuffer, inputOffset, inputLength) {\n      //region Throw an exception for a function which needs to be specified in extended classes\n      throw TypeError(\"User need to make a specific function in a class which extends \\\"ValueBlock\\\"\"); //endregion\n    } //**********************************************************************************\n    //noinspection JSUnusedLocalSymbols\n\n    /**\n     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n     * @returns {ArrayBuffer}\n     */\n\n  }, {\n    key: \"toBER\",\n    value: function toBER() {\n      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      //region Throw an exception for a function which needs to be specified in extended classes\n      throw TypeError(\"User need to make a specific function in a class which extends \\\"ValueBlock\\\"\"); //endregion\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"valueBlock\";\n    }\n  }]);\n\n  return ValueBlock;\n}(LocalBaseBlock); //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic ASN.1 block class\n//**************************************************************************************\n\nexport var BaseBlock = /*#__PURE__*/function (_LocalBaseBlock3) {\n  _inherits(BaseBlock, _LocalBaseBlock3);\n\n  var _super5 = _createSuper(BaseBlock);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"BaseBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {Object} [primitiveSchema]\n   * @property {string} [name]\n   * @property {boolean} [optional]\n   * @param valueBlockType Type of value block\n   */\n  function BaseBlock() {\n    var _this4;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var valueBlockType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ValueBlock;\n\n    _classCallCheck(this, BaseBlock);\n\n    _this4 = _super5.call(this, parameters);\n    if (\"name\" in parameters) _this4.name = parameters.name;\n    if (\"optional\" in parameters) _this4.optional = parameters.optional;\n    if (\"primitiveSchema\" in parameters) _this4.primitiveSchema = parameters.primitiveSchema;\n    _this4.idBlock = new LocalIdentificationBlock(parameters);\n    _this4.lenBlock = new LocalLengthBlock(parameters);\n    _this4.valueBlock = new valueBlockType(parameters);\n    return _this4;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(BaseBlock, [{\n    key: \"fromBER\",\n    value: //**********************************************************************************\n\n    /**\n     * Base function for converting block from BER encoded array of bytes\n     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n     * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n     * @returns {number}\n     */\n    function fromBER(inputBuffer, inputOffset, inputLength) {\n      var resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n      if (resultOffset === -1) {\n        this.error = this.valueBlock.error;\n        return resultOffset;\n      }\n\n      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n      if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n      return resultOffset;\n    } //**********************************************************************************\n\n    /**\n     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n     * @returns {ArrayBuffer}\n     */\n\n  }, {\n    key: \"toBER\",\n    value: function toBER() {\n      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var retBuf;\n      var idBlockBuf = this.idBlock.toBER(sizeOnly);\n      var valueBlockSizeBuf = this.valueBlock.toBER(true);\n      this.lenBlock.length = valueBlockSizeBuf.byteLength;\n      var lenBlockBuf = this.lenBlock.toBER(sizeOnly);\n      retBuf = utilConcatBuf(idBlockBuf, lenBlockBuf);\n      var valueBlockBuf;\n      if (sizeOnly === false) valueBlockBuf = this.valueBlock.toBER(sizeOnly);else valueBlockBuf = new ArrayBuffer(this.lenBlock.length);\n      retBuf = utilConcatBuf(retBuf, valueBlockBuf);\n\n      if (this.lenBlock.isIndefiniteForm === true) {\n        var indefBuf = new ArrayBuffer(2);\n\n        if (sizeOnly === false) {\n          var indefView = new Uint8Array(indefBuf);\n          indefView[0] = 0x00;\n          indefView[1] = 0x00;\n        }\n\n        retBuf = utilConcatBuf(retBuf, indefBuf);\n      }\n\n      return retBuf;\n    } //**********************************************************************************\n\n    /**\n     * Convertion for the block to JSON object\n     * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n      try {\n        object = _get(_getPrototypeOf(BaseBlock.prototype), \"toJSON\", this).call(this);\n      } catch (ex) {} //endregion\n\n\n      object.idBlock = this.idBlock.toJSON();\n      object.lenBlock = this.lenBlock.toJSON();\n      object.valueBlock = this.valueBlock.toJSON();\n      if (\"name\" in this) object.name = this.name;\n      if (\"optional\" in this) object.optional = this.optional;\n      if (\"primitiveSchema\" in this) object.primitiveSchema = this.primitiveSchema.toJSON();\n      return object;\n    } //**********************************************************************************\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.constructor.blockName(), \" : \").concat(bufferToHexCodes(this.valueBlock.valueHex));\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"BaseBlock\";\n    }\n  }]);\n\n  return BaseBlock;\n}(LocalBaseBlock); //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic block for all PRIMITIVE types\n//**************************************************************************************\n\nvar LocalPrimitiveValueBlock = /*#__PURE__*/function (_ValueBlock) {\n  _inherits(LocalPrimitiveValueBlock, _ValueBlock);\n\n  var _super6 = _createSuper(LocalPrimitiveValueBlock);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalPrimitiveValueBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueBeforeDecode]\n   */\n  function LocalPrimitiveValueBlock() {\n    var _this5;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LocalPrimitiveValueBlock);\n\n    _this5 = _super6.call(this, parameters); //region Variables from \"hexBlock\" class\n\n    if (\"valueHex\" in parameters) _this5.valueHex = parameters.valueHex.slice(0);else _this5.valueHex = new ArrayBuffer(0);\n    _this5.isHexOnly = getParametersValue(parameters, \"isHexOnly\", true); //endregion\n\n    return _this5;\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number}\n   */\n\n\n  _createClass(LocalPrimitiveValueBlock, [{\n    key: \"fromBER\",\n    value: function fromBER(inputBuffer, inputOffset, inputLength) {\n      //region Basic check for parameters\n      //noinspection JSCheckFunctionSignatures\n      if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n      //region Getting Uint8Array from ArrayBuffer\n\n      var intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n      //region Initial checks\n\n      if (intBuffer.length === 0) {\n        this.warnings.push(\"Zero buffer length\");\n        return inputOffset;\n      } //endregion\n      //region Copy input buffer into internal buffer\n\n\n      this.valueHex = new ArrayBuffer(intBuffer.length);\n      var valueHexView = new Uint8Array(this.valueHex);\n\n      for (var i = 0; i < intBuffer.length; i++) {\n        valueHexView[i] = intBuffer[i];\n      } //endregion\n\n\n      this.blockLength = inputLength;\n      return inputOffset + inputLength;\n    } //**********************************************************************************\n    //noinspection JSUnusedLocalSymbols\n\n    /**\n     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n     * @returns {ArrayBuffer}\n     */\n\n  }, {\n    key: \"toBER\",\n    value: function toBER() {\n      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return this.valueHex.slice(0);\n    } //**********************************************************************************\n\n    /**\n     * Aux function, need to get a block name. Need to have it here for inhiritence\n     * @returns {string}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: //**********************************************************************************\n\n    /**\n     * Convertion for the block to JSON object\n     * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n     */\n    function toJSON() {\n      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n      try {\n        object = _get(_getPrototypeOf(LocalPrimitiveValueBlock.prototype), \"toJSON\", this).call(this);\n      } catch (ex) {} //endregion\n\n\n      object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n      object.isHexOnly = this.isHexOnly;\n      return object;\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"PrimitiveValueBlock\";\n    }\n  }]);\n\n  return LocalPrimitiveValueBlock;\n}(ValueBlock); //**************************************************************************************\n\n\nexport var Primitive = /*#__PURE__*/function (_BaseBlock) {\n  _inherits(Primitive, _BaseBlock);\n\n  var _super7 = _createSuper(Primitive);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Primitive\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n  function Primitive() {\n    var _this6;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Primitive);\n\n    _this6 = _super7.call(this, parameters, LocalPrimitiveValueBlock);\n    _this6.idBlock.isConstructed = false;\n    return _this6;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(Primitive, null, [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"PRIMITIVE\";\n    } //**********************************************************************************\n\n  }]);\n\n  return Primitive;\n}(BaseBlock); //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic block for all CONSTRUCTED types\n//**************************************************************************************\n\nvar LocalConstructedValueBlock = /*#__PURE__*/function (_ValueBlock2) {\n  _inherits(LocalConstructedValueBlock, _ValueBlock2);\n\n  var _super8 = _createSuper(LocalConstructedValueBlock);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalConstructedValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n  function LocalConstructedValueBlock() {\n    var _this7;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LocalConstructedValueBlock);\n\n    _this7 = _super8.call(this, parameters);\n    _this7.value = getParametersValue(parameters, \"value\", []);\n    _this7.isIndefiniteForm = getParametersValue(parameters, \"isIndefiniteForm\", false);\n    return _this7;\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number}\n   */\n\n\n  _createClass(LocalConstructedValueBlock, [{\n    key: \"fromBER\",\n    value: function fromBER(inputBuffer, inputOffset, inputLength) {\n      //region Store initial offset and length\n      var initialOffset = inputOffset;\n      var initialLength = inputLength; //endregion\n      //region Basic check for parameters\n      //noinspection JSCheckFunctionSignatures\n\n      if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n      //region Getting Uint8Array from ArrayBuffer\n\n      var intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n      //region Initial checks\n\n      if (intBuffer.length === 0) {\n        this.warnings.push(\"Zero buffer length\");\n        return inputOffset;\n      } //endregion\n      //region Aux function\n\n\n      function checkLen(indefiniteLength, length) {\n        if (indefiniteLength === true) return 1;\n        return length;\n      } //endregion\n\n\n      var currentOffset = inputOffset;\n\n      while (checkLen(this.isIndefiniteForm, inputLength) > 0) {\n        var returnObject = LocalFromBER(inputBuffer, currentOffset, inputLength);\n\n        if (returnObject.offset === -1) {\n          this.error = returnObject.result.error;\n          this.warnings.concat(returnObject.result.warnings);\n          return -1;\n        }\n\n        currentOffset = returnObject.offset;\n        this.blockLength += returnObject.result.blockLength;\n        inputLength -= returnObject.result.blockLength;\n        this.value.push(returnObject.result);\n        if (this.isIndefiniteForm === true && returnObject.result.constructor.blockName() === EndOfContent.blockName()) break;\n      }\n\n      if (this.isIndefiniteForm === true) {\n        if (this.value[this.value.length - 1].constructor.blockName() === EndOfContent.blockName()) this.value.pop();else this.warnings.push(\"No EndOfContent block encoded\");\n      } //region Copy \"inputBuffer\" to \"valueBeforeDecode\"\n\n\n      this.valueBeforeDecode = inputBuffer.slice(initialOffset, initialOffset + initialLength); //endregion\n\n      return currentOffset;\n    } //**********************************************************************************\n\n    /**\n     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n     * @returns {ArrayBuffer}\n     */\n\n  }, {\n    key: \"toBER\",\n    value: function toBER() {\n      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var retBuf = new ArrayBuffer(0);\n\n      for (var i = 0; i < this.value.length; i++) {\n        var valueBuf = this.value[i].toBER(sizeOnly);\n        retBuf = utilConcatBuf(retBuf, valueBuf);\n      }\n\n      return retBuf;\n    } //**********************************************************************************\n\n    /**\n     * Aux function, need to get a block name. Need to have it here for inhiritence\n     * @returns {string}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: //**********************************************************************************\n\n    /**\n     * Convertion for the block to JSON object\n     * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n     */\n    function toJSON() {\n      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n      try {\n        object = _get(_getPrototypeOf(LocalConstructedValueBlock.prototype), \"toJSON\", this).call(this);\n      } catch (ex) {} //endregion\n\n\n      object.isIndefiniteForm = this.isIndefiniteForm;\n      object.value = [];\n\n      for (var i = 0; i < this.value.length; i++) {\n        object.value.push(this.value[i].toJSON());\n      }\n\n      return object;\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"ConstructedValueBlock\";\n    }\n  }]);\n\n  return LocalConstructedValueBlock;\n}(ValueBlock); //**************************************************************************************\n\n\nexport var Constructed = /*#__PURE__*/function (_BaseBlock2) {\n  _inherits(Constructed, _BaseBlock2);\n\n  var _super9 = _createSuper(Constructed);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Constructed\" class\n   * @param {Object} [parameters={}]\n   */\n  function Constructed() {\n    var _this8;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Constructed);\n\n    _this8 = _super9.call(this, parameters, LocalConstructedValueBlock);\n    _this8.idBlock.isConstructed = true;\n    return _this8;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(Constructed, [{\n    key: \"fromBER\",\n    value: //**********************************************************************************\n\n    /**\n     * Base function for converting block from BER encoded array of bytes\n     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n     * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n     * @returns {number}\n     */\n    function fromBER(inputBuffer, inputOffset, inputLength) {\n      this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n      var resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n      if (resultOffset === -1) {\n        this.error = this.valueBlock.error;\n        return resultOffset;\n      }\n\n      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n      if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n      return resultOffset;\n    } //**********************************************************************************\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var values = [];\n\n      var _iterator = _createForOfIteratorHelper(this.valueBlock.value),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var value = _step.value;\n          values.push(value.toString().split(\"\\n\").map(function (o) {\n            return \"  \".concat(o);\n          }).join(\"\\n\"));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var blockName = this.idBlock.tagClass === 3 ? \"[\".concat(this.idBlock.tagNumber, \"]\") : this.constructor.blockName();\n      return values.length ? \"\".concat(blockName, \" :\\n\").concat(values.join(\"\\n\")) // items\n      : \"\".concat(blockName, \" :\"); // empty\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"CONSTRUCTED\";\n    }\n  }]);\n\n  return Constructed;\n}(BaseBlock); //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 EndOfContent type class\n//**************************************************************************************\n\nvar LocalEndOfContentValueBlock = /*#__PURE__*/function (_ValueBlock3) {\n  _inherits(LocalEndOfContentValueBlock, _ValueBlock3);\n\n  var _super10 = _createSuper(LocalEndOfContentValueBlock);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalEndOfContentValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n  function LocalEndOfContentValueBlock() {\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LocalEndOfContentValueBlock);\n\n    return _super10.call(this, parameters);\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number}\n   */\n\n\n  _createClass(LocalEndOfContentValueBlock, [{\n    key: \"fromBER\",\n    value: function fromBER(inputBuffer, inputOffset, inputLength) {\n      //region There is no \"value block\" for EndOfContent type and we need to return the same offset\n      return inputOffset; //endregion\n    } //**********************************************************************************\n    //noinspection JSUnusedLocalSymbols\n\n    /**\n     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n     * @returns {ArrayBuffer}\n     */\n\n  }, {\n    key: \"toBER\",\n    value: function toBER() {\n      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return new ArrayBuffer(0);\n    } //**********************************************************************************\n\n    /**\n     * Aux function, need to get a block name. Need to have it here for inhiritence\n     * @returns {string}\n     */\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"EndOfContentValueBlock\";\n    } //**********************************************************************************\n\n  }]);\n\n  return LocalEndOfContentValueBlock;\n}(ValueBlock); //**************************************************************************************\n\n\nexport var EndOfContent = /*#__PURE__*/function (_BaseBlock3) {\n  _inherits(EndOfContent, _BaseBlock3);\n\n  var _super11 = _createSuper(EndOfContent);\n\n  //**********************************************************************************\n  function EndOfContent() {\n    var _this9;\n\n    var paramaters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, EndOfContent);\n\n    _this9 = _super11.call(this, paramaters, LocalEndOfContentValueBlock);\n    _this9.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this9.idBlock.tagNumber = 0; // EndOfContent\n\n    return _this9;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(EndOfContent, null, [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"EndOfContent\";\n    } //**********************************************************************************\n\n  }]);\n\n  return EndOfContent;\n}(BaseBlock); //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Boolean type class\n//**************************************************************************************\n\nvar LocalBooleanValueBlock = /*#__PURE__*/function (_ValueBlock4) {\n  _inherits(LocalBooleanValueBlock, _ValueBlock4);\n\n  var _super12 = _createSuper(LocalBooleanValueBlock);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalBooleanValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n  function LocalBooleanValueBlock() {\n    var _this10;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LocalBooleanValueBlock);\n\n    _this10 = _super12.call(this, parameters);\n    _this10.value = getParametersValue(parameters, \"value\", false);\n    _this10.isHexOnly = getParametersValue(parameters, \"isHexOnly\", false);\n    if (\"valueHex\" in parameters) _this10.valueHex = parameters.valueHex.slice(0);else {\n      _this10.valueHex = new ArrayBuffer(1);\n\n      if (_this10.value === true) {\n        var view = new Uint8Array(_this10.valueHex);\n        view[0] = 0xFF;\n      }\n    }\n    return _this10;\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  _createClass(LocalBooleanValueBlock, [{\n    key: \"fromBER\",\n    value: function fromBER(inputBuffer, inputOffset, inputLength) {\n      //region Basic check for parameters\n      //noinspection JSCheckFunctionSignatures\n      if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n      //region Getting Uint8Array from ArrayBuffer\n\n      var intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n\n      if (inputLength > 1) this.warnings.push(\"Boolean value encoded in more then 1 octet\");\n      this.isHexOnly = true; //region Copy input buffer to internal array\n\n      this.valueHex = new ArrayBuffer(intBuffer.length);\n      var view = new Uint8Array(this.valueHex);\n\n      for (var i = 0; i < intBuffer.length; i++) {\n        view[i] = intBuffer[i];\n      } //endregion\n\n\n      if (utilDecodeTC.call(this) !== 0) this.value = true;else this.value = false;\n      this.blockLength = inputLength;\n      return inputOffset + inputLength;\n    } //**********************************************************************************\n    //noinspection JSUnusedLocalSymbols\n\n    /**\n     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n     * @returns {ArrayBuffer}\n     */\n\n  }, {\n    key: \"toBER\",\n    value: function toBER() {\n      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return this.valueHex;\n    } //**********************************************************************************\n\n    /**\n     * Aux function, need to get a block name. Need to have it here for inhiritence\n     * @returns {string}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: //**********************************************************************************\n\n    /**\n     * Convertion for the block to JSON object\n     * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n     */\n    function toJSON() {\n      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n      try {\n        object = _get(_getPrototypeOf(LocalBooleanValueBlock.prototype), \"toJSON\", this).call(this);\n      } catch (ex) {} //endregion\n\n\n      object.value = this.value;\n      object.isHexOnly = this.isHexOnly;\n      object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n      return object;\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"BooleanValueBlock\";\n    }\n  }]);\n\n  return LocalBooleanValueBlock;\n}(ValueBlock); //**************************************************************************************\n\n\nexport var Boolean = /*#__PURE__*/function (_BaseBlock4) {\n  _inherits(Boolean, _BaseBlock4);\n\n  var _super13 = _createSuper(Boolean);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Boolean\" class\n   * @param {Object} [parameters={}]\n   */\n  function Boolean() {\n    var _this11;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Boolean);\n\n    _this11 = _super13.call(this, parameters, LocalBooleanValueBlock);\n    _this11.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this11.idBlock.tagNumber = 1; // Boolean\n\n    return _this11;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(Boolean, [{\n    key: \"toString\",\n    value: //**********************************************************************************\n    function toString() {\n      return \"\".concat(this.constructor.blockName(), \" : \").concat(this.valueBlock.value);\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"BOOLEAN\";\n    }\n  }]);\n\n  return Boolean;\n}(BaseBlock); //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Sequence and Set type classes\n//**************************************************************************************\n\nexport var Sequence = /*#__PURE__*/function (_Constructed) {\n  _inherits(Sequence, _Constructed);\n\n  var _super14 = _createSuper(Sequence);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Sequence\" class\n   * @param {Object} [parameters={}]\n   */\n  function Sequence() {\n    var _this12;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Sequence);\n\n    _this12 = _super14.call(this, parameters);\n    _this12.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this12.idBlock.tagNumber = 16; // Sequence\n\n    return _this12;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(Sequence, null, [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"SEQUENCE\";\n    } //**********************************************************************************\n\n  }]);\n\n  return Sequence;\n}(Constructed); //**************************************************************************************\n\nexport var Set = /*#__PURE__*/function (_Constructed2) {\n  _inherits(Set, _Constructed2);\n\n  var _super15 = _createSuper(Set);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Set\" class\n   * @param {Object} [parameters={}]\n   */\n  function Set() {\n    var _this13;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Set);\n\n    _this13 = _super15.call(this, parameters);\n    _this13.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this13.idBlock.tagNumber = 17; // Set\n\n    return _this13;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(Set, null, [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"SET\";\n    } //**********************************************************************************\n\n  }]);\n\n  return Set;\n}(Constructed); //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Null type class\n//**************************************************************************************\n\nexport var Null = /*#__PURE__*/function (_BaseBlock5) {\n  _inherits(Null, _BaseBlock5);\n\n  var _super16 = _createSuper(Null);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Null\" class\n   * @param {Object} [parameters={}]\n   */\n  function Null() {\n    var _this14;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Null);\n\n    _this14 = _super16.call(this, parameters, LocalBaseBlock); // We will not have a call to \"Null value block\" because of specified \"fromBER\" and \"toBER\" functions\n\n    _this14.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this14.idBlock.tagNumber = 5; // Null\n\n    return _this14;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(Null, [{\n    key: \"fromBER\",\n    value: //**********************************************************************************\n    //noinspection JSUnusedLocalSymbols\n\n    /**\n     * Base function for converting block from BER encoded array of bytes\n     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n     * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n     * @returns {number} Offset after least decoded byte\n     */\n    function fromBER(inputBuffer, inputOffset, inputLength) {\n      if (this.lenBlock.length > 0) this.warnings.push(\"Non-zero length of value block for Null type\");\n      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n      this.blockLength += inputLength;\n\n      if (inputOffset + inputLength > inputBuffer.byteLength) {\n        this.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\n        return -1;\n      }\n\n      return inputOffset + inputLength;\n    } //**********************************************************************************\n\n    /**\n     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n     * @returns {ArrayBuffer}\n     */\n\n  }, {\n    key: \"toBER\",\n    value: function toBER() {\n      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var retBuf = new ArrayBuffer(2);\n      if (sizeOnly === true) return retBuf;\n      var retView = new Uint8Array(retBuf);\n      retView[0] = 0x05;\n      retView[1] = 0x00;\n      return retBuf;\n    } //**********************************************************************************\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.constructor.blockName());\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"NULL\";\n    }\n  }]);\n\n  return Null;\n}(BaseBlock); //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 OctetString type class\n//**************************************************************************************\n\nvar LocalOctetStringValueBlock = /*#__PURE__*/function (_HexBlock2) {\n  _inherits(LocalOctetStringValueBlock, _HexBlock2);\n\n  var _super17 = _createSuper(LocalOctetStringValueBlock);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalOctetStringValueBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n  function LocalOctetStringValueBlock() {\n    var _this15;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LocalOctetStringValueBlock);\n\n    _this15 = _super17.call(this, parameters);\n    _this15.isConstructed = getParametersValue(parameters, \"isConstructed\", false);\n    return _this15;\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  _createClass(LocalOctetStringValueBlock, [{\n    key: \"fromBER\",\n    value: function fromBER(inputBuffer, inputOffset, inputLength) {\n      var resultOffset = 0;\n\n      if (this.isConstructed === true) {\n        this.isHexOnly = false;\n        resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n        if (resultOffset === -1) return resultOffset;\n\n        for (var i = 0; i < this.value.length; i++) {\n          var currentBlockName = this.value[i].constructor.blockName();\n\n          if (currentBlockName === EndOfContent.blockName()) {\n            if (this.isIndefiniteForm === true) break;else {\n              this.error = \"EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only\";\n              return -1;\n            }\n          }\n\n          if (currentBlockName !== OctetString.blockName()) {\n            this.error = \"OCTET STRING may consists of OCTET STRINGs only\";\n            return -1;\n          }\n        }\n      } else {\n        this.isHexOnly = true;\n        resultOffset = _get(_getPrototypeOf(LocalOctetStringValueBlock.prototype), \"fromBER\", this).call(this, inputBuffer, inputOffset, inputLength);\n        this.blockLength = inputLength;\n      }\n\n      return resultOffset;\n    } //**********************************************************************************\n\n    /**\n     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n     * @returns {ArrayBuffer}\n     */\n\n  }, {\n    key: \"toBER\",\n    value: function toBER() {\n      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (this.isConstructed === true) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);\n      var retBuf = new ArrayBuffer(this.valueHex.byteLength);\n      if (sizeOnly === true) return retBuf;\n      if (this.valueHex.byteLength === 0) return retBuf;\n      retBuf = this.valueHex.slice(0);\n      return retBuf;\n    } //**********************************************************************************\n\n    /**\n     * Aux function, need to get a block name. Need to have it here for inhiritence\n     * @returns {string}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: //**********************************************************************************\n    function toJSON() {\n      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n      try {\n        object = _get(_getPrototypeOf(LocalOctetStringValueBlock.prototype), \"toJSON\", this).call(this);\n      } catch (ex) {} //endregion\n\n\n      object.isConstructed = this.isConstructed;\n      object.isHexOnly = this.isHexOnly;\n      object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n      return object;\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"OctetStringValueBlock\";\n    }\n  }]);\n\n  return LocalOctetStringValueBlock;\n}(HexBlock(LocalConstructedValueBlock)); //**************************************************************************************\n\n\nexport var OctetString = /*#__PURE__*/function (_BaseBlock6) {\n  _inherits(OctetString, _BaseBlock6);\n\n  var _super18 = _createSuper(OctetString);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"OctetString\" class\n   * @param {Object} [parameters={}]\n   */\n  function OctetString() {\n    var _this16;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, OctetString);\n\n    _this16 = _super18.call(this, parameters, LocalOctetStringValueBlock);\n    _this16.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this16.idBlock.tagNumber = 4; // OctetString\n\n    return _this16;\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  _createClass(OctetString, [{\n    key: \"fromBER\",\n    value: function fromBER(inputBuffer, inputOffset, inputLength) {\n      this.valueBlock.isConstructed = this.idBlock.isConstructed;\n      this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm; //region Ability to encode empty OCTET STRING\n\n      if (inputLength === 0) {\n        if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n        if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n        return inputOffset;\n      } //endregion\n\n\n      if (!this.valueBlock.isConstructed) {\n        var buf = inputBuffer.slice(inputOffset, inputOffset + inputLength);\n\n        try {\n          var asn = _fromBER(buf);\n\n          if (asn.offset !== -1 && asn.offset === inputLength) {\n            this.valueBlock.value = [asn.result];\n          }\n        } catch (e) {// nothing\n        }\n      }\n\n      return _get(_getPrototypeOf(OctetString.prototype), \"fromBER\", this).call(this, inputBuffer, inputOffset, inputLength);\n    } //**********************************************************************************\n\n    /**\n     * Aux function, need to get a block name. Need to have it here for inhiritence\n     * @returns {string}\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: //**********************************************************************************\n    //noinspection JSUnusedGlobalSymbols\n\n    /**\n     * Checking that two OCTETSTRINGs are equal\n     * @param {OctetString} octetString\n     */\n    function isEqual(octetString) {\n      //region Check input type\n      if (octetString instanceof OctetString === false) return false; //endregion\n      //region Compare two JSON strings\n\n      if (JSON.stringify(this) !== JSON.stringify(octetString)) return false; //endregion\n\n      return true;\n    } //**********************************************************************************\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {\n        return Constructed.prototype.toString.call(this);\n      } else {\n        return \"\".concat(this.constructor.blockName(), \" : \").concat(bufferToHexCodes(this.valueBlock.valueHex));\n      }\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"OCTET STRING\";\n    }\n  }]);\n\n  return OctetString;\n}(BaseBlock); //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 BitString type class\n//**************************************************************************************\n\nvar LocalBitStringValueBlock = /*#__PURE__*/function (_HexBlock3) {\n  _inherits(LocalBitStringValueBlock, _HexBlock3);\n\n  var _super19 = _createSuper(LocalBitStringValueBlock);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalBitStringValueBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n  function LocalBitStringValueBlock() {\n    var _this17;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LocalBitStringValueBlock);\n\n    _this17 = _super19.call(this, parameters);\n    _this17.unusedBits = getParametersValue(parameters, \"unusedBits\", 0);\n    _this17.isConstructed = getParametersValue(parameters, \"isConstructed\", false);\n    _this17.blockLength = _this17.valueHex.byteLength;\n    return _this17;\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  _createClass(LocalBitStringValueBlock, [{\n    key: \"fromBER\",\n    value: function fromBER(inputBuffer, inputOffset, inputLength) {\n      //region Ability to decode zero-length BitString value\n      if (inputLength === 0) return inputOffset; //endregion\n\n      var resultOffset = -1; //region If the BISTRING supposed to be a constructed value\n\n      if (this.isConstructed === true) {\n        resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n        if (resultOffset === -1) return resultOffset;\n\n        for (var i = 0; i < this.value.length; i++) {\n          var currentBlockName = this.value[i].constructor.blockName();\n\n          if (currentBlockName === EndOfContent.blockName()) {\n            if (this.isIndefiniteForm === true) break;else {\n              this.error = \"EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only\";\n              return -1;\n            }\n          }\n\n          if (currentBlockName !== BitString.blockName()) {\n            this.error = \"BIT STRING may consists of BIT STRINGs only\";\n            return -1;\n          }\n\n          if (this.unusedBits > 0 && this.value[i].valueBlock.unusedBits > 0) {\n            this.error = \"Using of \\\"unused bits\\\" inside constructive BIT STRING allowed for least one only\";\n            return -1;\n          }\n\n          this.unusedBits = this.value[i].valueBlock.unusedBits;\n\n          if (this.unusedBits > 7) {\n            this.error = \"Unused bits for BitString must be in range 0-7\";\n            return -1;\n          }\n        }\n\n        return resultOffset;\n      } //endregion\n      //region If the BitString supposed to be a primitive value\n      //region Basic check for parameters\n      //noinspection JSCheckFunctionSignatures\n\n\n      if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n\n      var intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n      this.unusedBits = intBuffer[0];\n\n      if (this.unusedBits > 7) {\n        this.error = \"Unused bits for BitString must be in range 0-7\";\n        return -1;\n      }\n\n      if (!this.unusedBits) {\n        var buf = inputBuffer.slice(inputOffset + 1, inputOffset + inputLength);\n\n        try {\n          var asn = _fromBER(buf);\n\n          if (asn.offset !== -1 && asn.offset === inputLength - 1) {\n            this.value = [asn.result];\n          }\n        } catch (e) {// nothing\n        }\n      } //region Copy input buffer to internal buffer\n\n\n      this.valueHex = new ArrayBuffer(intBuffer.length - 1);\n      var view = new Uint8Array(this.valueHex);\n\n      for (var _i3 = 0; _i3 < inputLength - 1; _i3++) {\n        view[_i3] = intBuffer[_i3 + 1];\n      } //endregion\n\n\n      this.blockLength = intBuffer.length;\n      return inputOffset + inputLength; //endregion\n    } //**********************************************************************************\n\n    /**\n     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n     * @returns {ArrayBuffer}\n     */\n\n  }, {\n    key: \"toBER\",\n    value: function toBER() {\n      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (this.isConstructed === true) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);\n      if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength + 1);\n      if (this.valueHex.byteLength === 0) return new ArrayBuffer(0);\n      var curView = new Uint8Array(this.valueHex);\n      var retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);\n      var retView = new Uint8Array(retBuf);\n      retView[0] = this.unusedBits;\n\n      for (var i = 0; i < this.valueHex.byteLength; i++) {\n        retView[i + 1] = curView[i];\n      }\n\n      return retBuf;\n    } //**********************************************************************************\n\n    /**\n     * Aux function, need to get a block name. Need to have it here for inhiritence\n     * @returns {string}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: //**********************************************************************************\n\n    /**\n     * Convertion for the block to JSON object\n     * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n     */\n    function toJSON() {\n      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n      try {\n        object = _get(_getPrototypeOf(LocalBitStringValueBlock.prototype), \"toJSON\", this).call(this);\n      } catch (ex) {} //endregion\n\n\n      object.unusedBits = this.unusedBits;\n      object.isConstructed = this.isConstructed;\n      object.isHexOnly = this.isHexOnly;\n      object.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n      return object;\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"BitStringValueBlock\";\n    }\n  }]);\n\n  return LocalBitStringValueBlock;\n}(HexBlock(LocalConstructedValueBlock)); //**************************************************************************************\n\n\nexport var BitString = /*#__PURE__*/function (_BaseBlock7) {\n  _inherits(BitString, _BaseBlock7);\n\n  var _super20 = _createSuper(BitString);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"BitString\" class\n   * @param {Object} [parameters={}]\n   */\n  function BitString() {\n    var _this18;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, BitString);\n\n    _this18 = _super20.call(this, parameters, LocalBitStringValueBlock);\n    _this18.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this18.idBlock.tagNumber = 3; // BitString\n\n    return _this18;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(BitString, [{\n    key: \"fromBER\",\n    value: //**********************************************************************************\n\n    /**\n     * Base function for converting block from BER encoded array of bytes\n     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n     * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n     * @returns {number} Offset after least decoded byte\n     */\n    function fromBER(inputBuffer, inputOffset, inputLength) {\n      //region Ability to encode empty BitString\n      if (inputLength === 0) return inputOffset; //endregion\n\n      this.valueBlock.isConstructed = this.idBlock.isConstructed;\n      this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n      return _get(_getPrototypeOf(BitString.prototype), \"fromBER\", this).call(this, inputBuffer, inputOffset, inputLength);\n    } //**********************************************************************************\n\n    /**\n     * Checking that two BITSTRINGs are equal\n     * @param {BitString} bitString\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(bitString) {\n      //region Check input type\n      if (bitString instanceof BitString === false) return false; //endregion\n      //region Compare two JSON strings\n\n      if (JSON.stringify(this) !== JSON.stringify(bitString)) return false; //endregion\n\n      return true;\n    } //**********************************************************************************\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {\n        return Constructed.prototype.toString.call(this);\n      } else {\n        // convert bytes to bits\n        var bits = [];\n        var valueHex = new Uint8Array(this.valueBlock.valueHex);\n\n        var _iterator2 = _createForOfIteratorHelper(valueHex),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var byte = _step2.value;\n            bits.push(byte.toString(2).padStart(8, \"0\"));\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        return \"\".concat(this.constructor.blockName(), \" : \").concat(bits.join(\"\"));\n      }\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"BIT STRING\";\n    }\n  }]);\n\n  return BitString;\n}(BaseBlock); //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Integer type class\n//**************************************************************************************\n\n/**\n * @extends ValueBlock\n */\n\nvar LocalIntegerValueBlock = /*#__PURE__*/function (_HexBlock4) {\n  _inherits(LocalIntegerValueBlock, _HexBlock4);\n\n  var _super21 = _createSuper(LocalIntegerValueBlock);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalIntegerValueBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n  function LocalIntegerValueBlock() {\n    var _this19;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LocalIntegerValueBlock);\n\n    _this19 = _super21.call(this, parameters);\n    if (\"value\" in parameters) _this19.valueDec = parameters.value;\n    return _this19;\n  } //**********************************************************************************\n\n  /**\n   * Setter for \"valueHex\"\n   * @param {ArrayBuffer} _value\n   */\n\n\n  _createClass(LocalIntegerValueBlock, [{\n    key: \"valueHex\",\n    get: //**********************************************************************************\n\n    /**\n     * Getter for \"valueHex\"\n     * @returns {ArrayBuffer}\n     */\n    function get() {\n      return this._valueHex;\n    } //**********************************************************************************\n\n    /**\n     * Getter for \"valueDec\"\n     * @param {number} _value\n     */\n    ,\n    set: function set(_value) {\n      this._valueHex = _value.slice(0);\n\n      if (_value.byteLength >= 4) {\n        this.warnings.push(\"Too big Integer for decoding, hex only\");\n        this.isHexOnly = true;\n        this._valueDec = 0;\n      } else {\n        this.isHexOnly = false;\n        if (_value.byteLength > 0) this._valueDec = utilDecodeTC.call(this);\n      }\n    }\n  }, {\n    key: \"valueDec\",\n    get: //**********************************************************************************\n\n    /**\n     * Getter for \"valueDec\"\n     * @returns {number}\n     */\n    function get() {\n      return this._valueDec;\n    } //**********************************************************************************\n\n    /**\n     * Base function for converting block from DER encoded array of bytes\n     * @param {!ArrayBuffer} inputBuffer ASN.1 DER encoded array\n     * @param {!number} inputOffset Offset in ASN.1 DER encoded array where decoding should be started\n     * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n     * @param {number} [expectedLength=0] Expected length of converted \"valueHex\" buffer\n     * @returns {number} Offset after least decoded byte\n     */\n    ,\n    set: function set(_value) {\n      this._valueDec = _value;\n      this.isHexOnly = false;\n      this._valueHex = utilEncodeTC(_value);\n    }\n  }, {\n    key: \"fromDER\",\n    value: function fromDER(inputBuffer, inputOffset, inputLength) {\n      var expectedLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var offset = this.fromBER(inputBuffer, inputOffset, inputLength);\n      if (offset === -1) return offset;\n      var view = new Uint8Array(this._valueHex);\n\n      if (view[0] === 0x00 && (view[1] & 0x80) !== 0) {\n        var updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);\n        var updatedView = new Uint8Array(updatedValueHex);\n        updatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));\n        this._valueHex = updatedValueHex.slice(0);\n      } else {\n        if (expectedLength !== 0) {\n          if (this._valueHex.byteLength < expectedLength) {\n            if (expectedLength - this._valueHex.byteLength > 1) expectedLength = this._valueHex.byteLength + 1;\n\n            var _updatedValueHex = new ArrayBuffer(expectedLength);\n\n            var _updatedView = new Uint8Array(_updatedValueHex);\n\n            _updatedView.set(view, expectedLength - this._valueHex.byteLength);\n\n            this._valueHex = _updatedValueHex.slice(0);\n          }\n        }\n      }\n\n      return offset;\n    } //**********************************************************************************\n\n    /**\n     * Encoding of current ASN.1 block into ASN.1 encoded array (DER rules)\n     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n     * @returns {ArrayBuffer}\n     */\n\n  }, {\n    key: \"toDER\",\n    value: function toDER() {\n      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var view = new Uint8Array(this._valueHex);\n\n      switch (true) {\n        case (view[0] & 0x80) !== 0:\n          {\n            var updatedValueHex = new ArrayBuffer(this._valueHex.byteLength + 1);\n            var updatedView = new Uint8Array(updatedValueHex);\n            updatedView[0] = 0x00;\n            updatedView.set(view, 1);\n            this._valueHex = updatedValueHex.slice(0);\n          }\n          break;\n\n        case view[0] === 0x00 && (view[1] & 0x80) === 0:\n          {\n            var _updatedValueHex2 = new ArrayBuffer(this._valueHex.byteLength - 1);\n\n            var _updatedView2 = new Uint8Array(_updatedValueHex2);\n\n            _updatedView2.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));\n\n            this._valueHex = _updatedValueHex2.slice(0);\n          }\n          break;\n\n        default:\n      }\n\n      return this.toBER(sizeOnly);\n    } //**********************************************************************************\n\n    /**\n     * Base function for converting block from BER encoded array of bytes\n     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n     * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n     * @returns {number} Offset after least decoded byte\n     */\n\n  }, {\n    key: \"fromBER\",\n    value: function fromBER(inputBuffer, inputOffset, inputLength) {\n      var resultOffset = _get(_getPrototypeOf(LocalIntegerValueBlock.prototype), \"fromBER\", this).call(this, inputBuffer, inputOffset, inputLength);\n\n      if (resultOffset === -1) return resultOffset;\n      this.blockLength = inputLength;\n      return inputOffset + inputLength;\n    } //**********************************************************************************\n\n    /**\n     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n     * @returns {ArrayBuffer}\n     */\n\n  }, {\n    key: \"toBER\",\n    value: function toBER() {\n      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      //noinspection JSCheckFunctionSignatures\n      return this.valueHex.slice(0);\n    } //**********************************************************************************\n\n    /**\n     * Aux function, need to get a block name. Need to have it here for inhiritence\n     * @returns {string}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: //**********************************************************************************\n    //noinspection JSUnusedGlobalSymbols\n\n    /**\n     * Convertion for the block to JSON object\n     * @returns {Object}\n     */\n    function toJSON() {\n      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n      try {\n        object = _get(_getPrototypeOf(LocalIntegerValueBlock.prototype), \"toJSON\", this).call(this);\n      } catch (ex) {} //endregion\n\n\n      object.valueDec = this.valueDec;\n      return object;\n    } //**********************************************************************************\n\n    /**\n     * Convert current value to decimal string representation\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      //region Aux functions\n      function viewAdd(first, second) {\n        //region Initial variables\n        var c = new Uint8Array([0]);\n        var firstView = new Uint8Array(first);\n        var secondView = new Uint8Array(second);\n        var firstViewCopy = firstView.slice(0);\n        var firstViewCopyLength = firstViewCopy.length - 1;\n        var secondViewCopy = secondView.slice(0);\n        var secondViewCopyLength = secondViewCopy.length - 1;\n        var value = 0;\n        var max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;\n        var counter = 0; //endregion\n\n        for (var i = max; i >= 0; i--, counter++) {\n          switch (true) {\n            case counter < secondViewCopy.length:\n              value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];\n              break;\n\n            default:\n              value = firstViewCopy[firstViewCopyLength - counter] + c[0];\n          }\n\n          c[0] = value / 10;\n\n          switch (true) {\n            case counter >= firstViewCopy.length:\n              firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);\n              break;\n\n            default:\n              firstViewCopy[firstViewCopyLength - counter] = value % 10;\n          }\n        }\n\n        if (c[0] > 0) firstViewCopy = utilConcatView(c, firstViewCopy);\n        return firstViewCopy.slice(0);\n      }\n\n      function power2(n) {\n        if (n >= powers2.length) {\n          for (var p = powers2.length; p <= n; p++) {\n            var c = new Uint8Array([0]);\n\n            var _digits = powers2[p - 1].slice(0);\n\n            for (var i = _digits.length - 1; i >= 0; i--) {\n              var newValue = new Uint8Array([(_digits[i] << 1) + c[0]]);\n              c[0] = newValue[0] / 10;\n              _digits[i] = newValue[0] % 10;\n            }\n\n            if (c[0] > 0) _digits = utilConcatView(c, _digits);\n            powers2.push(_digits);\n          }\n        }\n\n        return powers2[n];\n      }\n\n      function viewSub(first, second) {\n        //region Initial variables\n        var b = 0;\n        var firstView = new Uint8Array(first);\n        var secondView = new Uint8Array(second);\n        var firstViewCopy = firstView.slice(0);\n        var firstViewCopyLength = firstViewCopy.length - 1;\n        var secondViewCopy = secondView.slice(0);\n        var secondViewCopyLength = secondViewCopy.length - 1;\n        var value;\n        var counter = 0; //endregion\n\n        for (var i = secondViewCopyLength; i >= 0; i--, counter++) {\n          value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;\n\n          switch (true) {\n            case value < 0:\n              b = 1;\n              firstViewCopy[firstViewCopyLength - counter] = value + 10;\n              break;\n\n            default:\n              b = 0;\n              firstViewCopy[firstViewCopyLength - counter] = value;\n          }\n        }\n\n        if (b > 0) {\n          for (var _i4 = firstViewCopyLength - secondViewCopyLength + 1; _i4 >= 0; _i4--, counter++) {\n            value = firstViewCopy[firstViewCopyLength - counter] - b;\n\n            if (value < 0) {\n              b = 1;\n              firstViewCopy[firstViewCopyLength - counter] = value + 10;\n            } else {\n              b = 0;\n              firstViewCopy[firstViewCopyLength - counter] = value;\n              break;\n            }\n          }\n        }\n\n        return firstViewCopy.slice();\n      } //endregion\n      //region Initial variables\n\n\n      var firstBit = this._valueHex.byteLength * 8 - 1;\n      var digits = new Uint8Array(this._valueHex.byteLength * 8 / 3);\n      var bitNumber = 0;\n      var currentByte;\n      var asn1View = new Uint8Array(this._valueHex);\n      var result = \"\";\n      var flag = false; //endregion\n      //region Calculate number\n\n      for (var byteNumber = this._valueHex.byteLength - 1; byteNumber >= 0; byteNumber--) {\n        currentByte = asn1View[byteNumber];\n\n        for (var i = 0; i < 8; i++) {\n          if ((currentByte & 1) === 1) {\n            switch (bitNumber) {\n              case firstBit:\n                digits = viewSub(power2(bitNumber), digits);\n                result = \"-\";\n                break;\n\n              default:\n                digits = viewAdd(digits, power2(bitNumber));\n            }\n          }\n\n          bitNumber++;\n          currentByte >>= 1;\n        }\n      } //endregion\n      //region Print number\n\n\n      for (var _i5 = 0; _i5 < digits.length; _i5++) {\n        if (digits[_i5]) flag = true;\n        if (flag) result += digitsString.charAt(digits[_i5]);\n      }\n\n      if (flag === false) result += digitsString.charAt(0); //endregion\n\n      return result;\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"IntegerValueBlock\";\n    }\n  }]);\n\n  return LocalIntegerValueBlock;\n}(HexBlock(ValueBlock)); //**************************************************************************************\n\n\nexport var Integer = /*#__PURE__*/function (_BaseBlock8) {\n  _inherits(Integer, _BaseBlock8);\n\n  var _super22 = _createSuper(Integer);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Integer\" class\n   * @param {Object} [parameters={}]\n   */\n  function Integer() {\n    var _this20;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Integer);\n\n    _this20 = _super22.call(this, parameters, LocalIntegerValueBlock);\n    _this20.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this20.idBlock.tagNumber = 2; // Integer\n\n    return _this20;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(Integer, [{\n    key: \"isEqual\",\n    value: //**********************************************************************************\n    //noinspection JSUnusedGlobalSymbols\n\n    /**\n     * Compare two Integer object, or Integer and ArrayBuffer objects\n     * @param {!Integer|ArrayBuffer} otherValue\n     * @returns {boolean}\n     */\n    function isEqual(otherValue) {\n      if (otherValue instanceof Integer) {\n        if (this.valueBlock.isHexOnly && otherValue.valueBlock.isHexOnly) // Compare two ArrayBuffers\n          return isEqualBuffer(this.valueBlock.valueHex, otherValue.valueBlock.valueHex);\n        if (this.valueBlock.isHexOnly === otherValue.valueBlock.isHexOnly) return this.valueBlock.valueDec === otherValue.valueBlock.valueDec;\n        return false;\n      }\n\n      if (otherValue instanceof ArrayBuffer) return isEqualBuffer(this.valueBlock.valueHex, otherValue);\n      return false;\n    } //**********************************************************************************\n\n    /**\n     * Convert current Integer value from BER into DER format\n     * @returns {Integer}\n     */\n\n  }, {\n    key: \"convertToDER\",\n    value: function convertToDER() {\n      var integer = new Integer({\n        valueHex: this.valueBlock.valueHex\n      });\n      integer.valueBlock.toDER();\n      return integer;\n    } //**********************************************************************************\n\n    /**\n     * Convert current Integer value from DER to BER format\n     * @returns {Integer}\n     */\n\n  }, {\n    key: \"convertFromDER\",\n    value: function convertFromDER() {\n      var expectedLength = this.valueBlock.valueHex.byteLength % 2 ? this.valueBlock.valueHex.byteLength + 1 : this.valueBlock.valueHex.byteLength;\n      var integer = new Integer({\n        valueHex: this.valueBlock.valueHex\n      });\n      integer.valueBlock.fromDER(integer.valueBlock.valueHex, 0, integer.valueBlock.valueHex.byteLength, expectedLength);\n      return integer;\n    } //**********************************************************************************\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      assertBigInt();\n      var hex = bufferToHexCodes(this.valueBlock.valueHex);\n      var bigInt = BigInt(\"0x\".concat(hex));\n      return \"\".concat(this.constructor.blockName(), \" : \").concat(bigInt.toString());\n    }\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"INTEGER\";\n    }\n  }]);\n\n  return Integer;\n}(BaseBlock); //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Enumerated type class\n//**************************************************************************************\n\nexport var Enumerated = /*#__PURE__*/function (_Integer) {\n  _inherits(Enumerated, _Integer);\n\n  var _super23 = _createSuper(Enumerated);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Enumerated\" class\n   * @param {Object} [parameters={}]\n   */\n  function Enumerated() {\n    var _this21;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Enumerated);\n\n    _this21 = _super23.call(this, parameters);\n    _this21.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this21.idBlock.tagNumber = 10; // Enumerated\n\n    return _this21;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(Enumerated, null, [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"ENUMERATED\";\n    } //**********************************************************************************\n\n  }]);\n\n  return Enumerated;\n}(Integer); //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 ObjectIdentifier type class\n//**************************************************************************************\n\nvar LocalSidValueBlock = /*#__PURE__*/function (_HexBlock5) {\n  _inherits(LocalSidValueBlock, _HexBlock5);\n\n  var _super24 = _createSuper(LocalSidValueBlock);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalSidValueBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {number} [valueDec]\n   * @property {boolean} [isFirstSid]\n   */\n  function LocalSidValueBlock() {\n    var _this22;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LocalSidValueBlock);\n\n    _this22 = _super24.call(this, parameters);\n    _this22.valueDec = getParametersValue(parameters, \"valueDec\", -1);\n    _this22.isFirstSid = getParametersValue(parameters, \"isFirstSid\", false);\n    return _this22;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(LocalSidValueBlock, [{\n    key: \"fromBER\",\n    value: //**********************************************************************************\n\n    /**\n     * Base function for converting block from BER encoded array of bytes\n     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n     * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n     * @returns {number} Offset after least decoded byte\n     */\n    function fromBER(inputBuffer, inputOffset, inputLength) {\n      if (inputLength === 0) return inputOffset; //region Basic check for parameters\n      //noinspection JSCheckFunctionSignatures\n\n      if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n\n      var intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n      this.valueHex = new ArrayBuffer(inputLength);\n      var view = new Uint8Array(this.valueHex);\n\n      for (var i = 0; i < inputLength; i++) {\n        view[i] = intBuffer[i] & 0x7F;\n        this.blockLength++;\n        if ((intBuffer[i] & 0x80) === 0x00) break;\n      } //region Ajust size of valueHex buffer\n\n\n      var tempValueHex = new ArrayBuffer(this.blockLength);\n      var tempView = new Uint8Array(tempValueHex);\n\n      for (var _i6 = 0; _i6 < this.blockLength; _i6++) {\n        tempView[_i6] = view[_i6];\n      } //noinspection JSCheckFunctionSignatures\n\n\n      this.valueHex = tempValueHex.slice(0);\n      view = new Uint8Array(this.valueHex); //endregion\n\n      if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\n        this.error = \"End of input reached before message was fully decoded\";\n        return -1;\n      }\n\n      if (view[0] === 0x00) this.warnings.push(\"Needlessly long format of SID encoding\");\n      if (this.blockLength <= 8) this.valueDec = utilFromBase(view, 7);else {\n        this.isHexOnly = true;\n        this.warnings.push(\"Too big SID for decoding, hex only\");\n      }\n      return inputOffset + this.blockLength;\n    } //**********************************************************************************\n\n    /**\n     * Save a BigInt value immediately as an array of octects.\n     */\n\n  }, {\n    key: \"valueBigInt\",\n    set: function set(value) {\n      assertBigInt();\n      var bits = BigInt(value).toString(2);\n\n      while (bits.length % 7) {\n        bits = '0' + bits;\n      }\n\n      var bytes = new Uint8Array(bits.length / 7);\n\n      for (var i = 0; i < bytes.length; i++) {\n        bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 0x80 : 0);\n      }\n\n      this.fromBER(bytes.buffer, 0, bytes.length);\n    } //**********************************************************************************\n\n    /**\n     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n     * @returns {ArrayBuffer}\n     */\n\n  }, {\n    key: \"toBER\",\n    value: function toBER() {\n      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      //region Initial variables\n      var retBuf;\n      var retView; //endregion\n\n      if (this.isHexOnly) {\n        if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength);\n        var curView = new Uint8Array(this.valueHex);\n        retBuf = new ArrayBuffer(this.blockLength);\n        retView = new Uint8Array(retBuf);\n\n        for (var i = 0; i < this.blockLength - 1; i++) {\n          retView[i] = curView[i] | 0x80;\n        }\n\n        retView[this.blockLength - 1] = curView[this.blockLength - 1];\n        return retBuf;\n      }\n\n      var encodedBuf = utilToBase(this.valueDec, 7);\n\n      if (encodedBuf.byteLength === 0) {\n        this.error = \"Error during encoding SID value\";\n        return new ArrayBuffer(0);\n      }\n\n      retBuf = new ArrayBuffer(encodedBuf.byteLength);\n\n      if (sizeOnly === false) {\n        var encodedView = new Uint8Array(encodedBuf);\n        retView = new Uint8Array(retBuf);\n\n        for (var _i7 = 0; _i7 < encodedBuf.byteLength - 1; _i7++) {\n          retView[_i7] = encodedView[_i7] | 0x80;\n        }\n\n        retView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];\n      }\n\n      return retBuf;\n    } //**********************************************************************************\n\n    /**\n     * Create string representation of current SID block\n     * @returns {string}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var result = \"\";\n      if (this.isHexOnly === true) result = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);else {\n        if (this.isFirstSid) {\n          var sidValue = this.valueDec;\n          if (this.valueDec <= 39) result = \"0.\";else {\n            if (this.valueDec <= 79) {\n              result = \"1.\";\n              sidValue -= 40;\n            } else {\n              result = \"2.\";\n              sidValue -= 80;\n            }\n          }\n          result += sidValue.toString();\n        } else result = this.valueDec.toString();\n      }\n      return result;\n    } //**********************************************************************************\n    //noinspection JSUnusedGlobalSymbols\n\n    /**\n     * Convertion for the block to JSON object\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n      try {\n        object = _get(_getPrototypeOf(LocalSidValueBlock.prototype), \"toJSON\", this).call(this);\n      } catch (ex) {} //endregion\n\n\n      object.valueDec = this.valueDec;\n      object.isFirstSid = this.isFirstSid;\n      return object;\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"sidBlock\";\n    }\n  }]);\n\n  return LocalSidValueBlock;\n}(HexBlock(LocalBaseBlock)); //**************************************************************************************\n\n\nvar LocalObjectIdentifierValueBlock = /*#__PURE__*/function (_ValueBlock5) {\n  _inherits(LocalObjectIdentifierValueBlock, _ValueBlock5);\n\n  var _super25 = _createSuper(LocalObjectIdentifierValueBlock);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalObjectIdentifierValueBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n  function LocalObjectIdentifierValueBlock() {\n    var _this23;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LocalObjectIdentifierValueBlock);\n\n    _this23 = _super25.call(this, parameters);\n\n    _this23.fromString(getParametersValue(parameters, \"value\", \"\"));\n\n    return _this23;\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  _createClass(LocalObjectIdentifierValueBlock, [{\n    key: \"fromBER\",\n    value: function fromBER(inputBuffer, inputOffset, inputLength) {\n      var resultOffset = inputOffset;\n\n      while (inputLength > 0) {\n        var sidBlock = new LocalSidValueBlock();\n        resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n\n        if (resultOffset === -1) {\n          this.blockLength = 0;\n          this.error = sidBlock.error;\n          return resultOffset;\n        }\n\n        if (this.value.length === 0) sidBlock.isFirstSid = true;\n        this.blockLength += sidBlock.blockLength;\n        inputLength -= sidBlock.blockLength;\n        this.value.push(sidBlock);\n      }\n\n      return resultOffset;\n    } //**********************************************************************************\n\n    /**\n     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n     * @returns {ArrayBuffer}\n     */\n\n  }, {\n    key: \"toBER\",\n    value: function toBER() {\n      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var retBuf = new ArrayBuffer(0);\n\n      for (var i = 0; i < this.value.length; i++) {\n        var valueBuf = this.value[i].toBER(sizeOnly);\n\n        if (valueBuf.byteLength === 0) {\n          this.error = this.value[i].error;\n          return new ArrayBuffer(0);\n        }\n\n        retBuf = utilConcatBuf(retBuf, valueBuf);\n      }\n\n      return retBuf;\n    } //**********************************************************************************\n\n    /**\n     * Create \"LocalObjectIdentifierValueBlock\" class from string\n     * @param {string} string Input string to convert from\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"fromString\",\n    value: function fromString(string) {\n      this.value = []; // Clear existing SID values\n\n      var pos1 = 0;\n      var pos2 = 0;\n      var sid = \"\";\n      var flag = false;\n\n      do {\n        pos2 = string.indexOf(\".\", pos1);\n        if (pos2 === -1) sid = string.substr(pos1);else sid = string.substr(pos1, pos2 - pos1);\n        pos1 = pos2 + 1;\n\n        if (flag) {\n          var sidBlock = this.value[0];\n          var plus = 0;\n\n          switch (sidBlock.valueDec) {\n            case 0:\n              break;\n\n            case 1:\n              plus = 40;\n              break;\n\n            case 2:\n              plus = 80;\n              break;\n\n            default:\n              this.value = []; // clear SID array\n\n              return false;\n            // ???\n          }\n\n          var parsedSID = parseInt(sid, 10);\n          if (isNaN(parsedSID)) return true;\n          sidBlock.valueDec = parsedSID + plus;\n          flag = false;\n        } else {\n          var _sidBlock = new LocalSidValueBlock();\n\n          if (sid > Number.MAX_SAFE_INTEGER) {\n            assertBigInt();\n            var sidValue = BigInt(sid);\n            _sidBlock.valueBigInt = sidValue;\n          } else {\n            _sidBlock.valueDec = parseInt(sid, 10);\n            if (isNaN(_sidBlock.valueDec)) return true;\n          }\n\n          if (this.value.length === 0) {\n            _sidBlock.isFirstSid = true;\n            flag = true;\n          }\n\n          this.value.push(_sidBlock);\n        }\n      } while (pos2 !== -1);\n\n      return true;\n    } //**********************************************************************************\n\n    /**\n     * Converts \"LocalObjectIdentifierValueBlock\" class to string\n     * @returns {string}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var result = \"\";\n      var isHexOnly = false;\n\n      for (var i = 0; i < this.value.length; i++) {\n        isHexOnly = this.value[i].isHexOnly;\n        var sidStr = this.value[i].toString();\n        if (i !== 0) result = \"\".concat(result, \".\");\n\n        if (isHexOnly) {\n          sidStr = \"{\".concat(sidStr, \"}\");\n          if (this.value[i].isFirstSid) result = \"2.{\".concat(sidStr, \" - 80}\");else result += sidStr;\n        } else result += sidStr;\n      }\n\n      return result;\n    } //**********************************************************************************\n\n    /**\n     * Aux function, need to get a block name. Need to have it here for inhiritence\n     * @returns {string}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: //**********************************************************************************\n\n    /**\n     * Convertion for the block to JSON object\n     * @returns {Object}\n     */\n    function toJSON() {\n      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n      try {\n        object = _get(_getPrototypeOf(LocalObjectIdentifierValueBlock.prototype), \"toJSON\", this).call(this);\n      } catch (ex) {} //endregion\n\n\n      object.value = this.toString();\n      object.sidArray = [];\n\n      for (var i = 0; i < this.value.length; i++) {\n        object.sidArray.push(this.value[i].toJSON());\n      }\n\n      return object;\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"ObjectIdentifierValueBlock\";\n    }\n  }]);\n\n  return LocalObjectIdentifierValueBlock;\n}(ValueBlock); //**************************************************************************************\n\n/**\n * @extends BaseBlock\n */\n\n\nexport var ObjectIdentifier = /*#__PURE__*/function (_BaseBlock9) {\n  _inherits(ObjectIdentifier, _BaseBlock9);\n\n  var _super26 = _createSuper(ObjectIdentifier);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"ObjectIdentifier\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n  function ObjectIdentifier() {\n    var _this24;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, ObjectIdentifier);\n\n    _this24 = _super26.call(this, parameters, LocalObjectIdentifierValueBlock);\n    _this24.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this24.idBlock.tagNumber = 6; // OBJECT IDENTIFIER\n\n    return _this24;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(ObjectIdentifier, [{\n    key: \"toString\",\n    value: //**********************************************************************************\n    function toString() {\n      return \"\".concat(this.constructor.blockName(), \" : \").concat(this.valueBlock.toString());\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"OBJECT IDENTIFIER\";\n    }\n  }]);\n\n  return ObjectIdentifier;\n}(BaseBlock); //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of all string's classes\n//**************************************************************************************\n\nvar LocalUtf8StringValueBlock = /*#__PURE__*/function (_HexBlock6) {\n  _inherits(LocalUtf8StringValueBlock, _HexBlock6);\n\n  var _super27 = _createSuper(LocalUtf8StringValueBlock);\n\n  //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\n   * Constructor for \"LocalUtf8StringValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n  function LocalUtf8StringValueBlock() {\n    var _this25;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LocalUtf8StringValueBlock);\n\n    _this25 = _super27.call(this, parameters);\n    _this25.isHexOnly = true;\n    _this25.value = \"\"; // String representation of decoded ArrayBuffer\n\n    return _this25;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(LocalUtf8StringValueBlock, [{\n    key: \"toJSON\",\n    value: //**********************************************************************************\n    //noinspection JSUnusedGlobalSymbols\n\n    /**\n     * Convertion for the block to JSON object\n     * @returns {Object}\n     */\n    function toJSON() {\n      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n      try {\n        object = _get(_getPrototypeOf(LocalUtf8StringValueBlock.prototype), \"toJSON\", this).call(this);\n      } catch (ex) {} //endregion\n\n\n      object.value = this.value;\n      return object;\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"Utf8StringValueBlock\";\n    }\n  }]);\n\n  return LocalUtf8StringValueBlock;\n}(HexBlock(LocalBaseBlock)); //**************************************************************************************\n\n/**\n * @extends BaseBlock\n */\n\n\nexport var Utf8String = /*#__PURE__*/function (_BaseBlock10) {\n  _inherits(Utf8String, _BaseBlock10);\n\n  var _super28 = _createSuper(Utf8String);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Utf8String\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n  function Utf8String() {\n    var _this26;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Utf8String);\n\n    _this26 = _super28.call(this, parameters, LocalUtf8StringValueBlock);\n    if (\"value\" in parameters) _this26.fromString(parameters.value);\n    _this26.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this26.idBlock.tagNumber = 12; // Utf8String\n\n    return _this26;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(Utf8String, [{\n    key: \"fromBER\",\n    value: //**********************************************************************************\n\n    /**\n     * Base function for converting block from BER encoded array of bytes\n     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n     * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n     * @returns {number} Offset after least decoded byte\n     */\n    function fromBER(inputBuffer, inputOffset, inputLength) {\n      var resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n      if (resultOffset === -1) {\n        this.error = this.valueBlock.error;\n        return resultOffset;\n      }\n\n      this.fromBuffer(this.valueBlock.valueHex);\n      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n      if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n      return resultOffset;\n    } //**********************************************************************************\n\n    /**\n     * Function converting ArrayBuffer into ASN.1 internal string\n     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n     */\n\n  }, {\n    key: \"fromBuffer\",\n    value: function fromBuffer(inputBuffer) {\n      this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));\n\n      try {\n        //noinspection JSDeprecatedSymbols\n        this.valueBlock.value = decodeURIComponent(escape(this.valueBlock.value));\n      } catch (ex) {\n        this.warnings.push(\"Error during \\\"decodeURIComponent\\\": \".concat(ex, \", using raw string\"));\n      }\n    } //**********************************************************************************\n\n    /**\n     * Function converting JavaScript string into ASN.1 internal class\n     * @param {!string} inputString ASN.1 BER encoded array\n     */\n\n  }, {\n    key: \"fromString\",\n    value: function fromString(inputString) {\n      //noinspection JSDeprecatedSymbols\n      var str = unescape(encodeURIComponent(inputString));\n      var strLen = str.length;\n      this.valueBlock.valueHex = new ArrayBuffer(strLen);\n      var view = new Uint8Array(this.valueBlock.valueHex);\n\n      for (var i = 0; i < strLen; i++) {\n        view[i] = str.charCodeAt(i);\n      }\n\n      this.valueBlock.value = inputString;\n    } //**********************************************************************************\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.constructor.blockName(), \" : \").concat(this.valueBlock.value);\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"UTF8String\";\n    }\n  }]);\n\n  return Utf8String;\n}(BaseBlock); //**************************************************************************************\n//region Declaration of ASN.1 RelativeObjectIdentifier type class\n//**************************************************************************************\n\nvar LocalRelativeSidValueBlock = /*#__PURE__*/function (_HexBlock7) {\n  _inherits(LocalRelativeSidValueBlock, _HexBlock7);\n\n  var _super29 = _createSuper(LocalRelativeSidValueBlock);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalRelativeSidValueBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {number} [valueDec]\n   */\n  function LocalRelativeSidValueBlock() {\n    var _this27;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LocalRelativeSidValueBlock);\n\n    _this27 = _super29.call(this, parameters);\n    _this27.valueDec = getParametersValue(parameters, \"valueDec\", -1);\n    return _this27;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(LocalRelativeSidValueBlock, [{\n    key: \"fromBER\",\n    value: //**********************************************************************************\n\n    /**\n     * Base function for converting block from BER encoded array of bytes\n     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n     * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n     * @returns {number} Offset after least decoded byte\n     */\n    function fromBER(inputBuffer, inputOffset, inputLength) {\n      if (inputLength === 0) return inputOffset; //region Basic check for parameters\n      //noinspection JSCheckFunctionSignatures\n\n      if (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n\n      var intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n      this.valueHex = new ArrayBuffer(inputLength);\n      var view = new Uint8Array(this.valueHex);\n\n      for (var i = 0; i < inputLength; i++) {\n        view[i] = intBuffer[i] & 0x7F;\n        this.blockLength++;\n        if ((intBuffer[i] & 0x80) === 0x00) break;\n      } //region Ajust size of valueHex buffer\n\n\n      var tempValueHex = new ArrayBuffer(this.blockLength);\n      var tempView = new Uint8Array(tempValueHex);\n\n      for (var _i8 = 0; _i8 < this.blockLength; _i8++) {\n        tempView[_i8] = view[_i8];\n      } //noinspection JSCheckFunctionSignatures\n\n\n      this.valueHex = tempValueHex.slice(0);\n      view = new Uint8Array(this.valueHex); //endregion\n\n      if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\n        this.error = \"End of input reached before message was fully decoded\";\n        return -1;\n      }\n\n      if (view[0] === 0x00) this.warnings.push(\"Needlessly long format of SID encoding\");\n      if (this.blockLength <= 8) this.valueDec = utilFromBase(view, 7);else {\n        this.isHexOnly = true;\n        this.warnings.push(\"Too big SID for decoding, hex only\");\n      }\n      return inputOffset + this.blockLength;\n    } //**********************************************************************************\n\n    /**\n     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n     * @returns {ArrayBuffer}\n     */\n\n  }, {\n    key: \"toBER\",\n    value: function toBER() {\n      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      //region Initial variables\n      var retBuf;\n      var retView; //endregion\n\n      if (this.isHexOnly) {\n        if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength);\n        var curView = new Uint8Array(this.valueHex);\n        retBuf = new ArrayBuffer(this.blockLength);\n        retView = new Uint8Array(retBuf);\n\n        for (var i = 0; i < this.blockLength - 1; i++) {\n          retView[i] = curView[i] | 0x80;\n        }\n\n        retView[this.blockLength - 1] = curView[this.blockLength - 1];\n        return retBuf;\n      }\n\n      var encodedBuf = utilToBase(this.valueDec, 7);\n\n      if (encodedBuf.byteLength === 0) {\n        this.error = \"Error during encoding SID value\";\n        return new ArrayBuffer(0);\n      }\n\n      retBuf = new ArrayBuffer(encodedBuf.byteLength);\n\n      if (sizeOnly === false) {\n        var encodedView = new Uint8Array(encodedBuf);\n        retView = new Uint8Array(retBuf);\n\n        for (var _i9 = 0; _i9 < encodedBuf.byteLength - 1; _i9++) {\n          retView[_i9] = encodedView[_i9] | 0x80;\n        }\n\n        retView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];\n      }\n\n      return retBuf;\n    } //**********************************************************************************\n\n    /**\n     * Create string representation of current SID block\n     * @returns {string}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var result = \"\";\n      if (this.isHexOnly === true) result = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);else {\n        result = this.valueDec.toString();\n      }\n      return result;\n    } //**********************************************************************************\n    //noinspection JSUnusedGlobalSymbols\n\n    /**\n     * Convertion for the block to JSON object\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n      try {\n        object = _get(_getPrototypeOf(LocalRelativeSidValueBlock.prototype), \"toJSON\", this).call(this);\n      } catch (ex) {} //endregion\n\n\n      object.valueDec = this.valueDec;\n      return object;\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"relativeSidBlock\";\n    }\n  }]);\n\n  return LocalRelativeSidValueBlock;\n}(HexBlock(LocalBaseBlock)); //**************************************************************************************\n\n\nvar LocalRelativeObjectIdentifierValueBlock = /*#__PURE__*/function (_ValueBlock6) {\n  _inherits(LocalRelativeObjectIdentifierValueBlock, _ValueBlock6);\n\n  var _super30 = _createSuper(LocalRelativeObjectIdentifierValueBlock);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalRelativeObjectIdentifierValueBlock\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n  function LocalRelativeObjectIdentifierValueBlock() {\n    var _this28;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LocalRelativeObjectIdentifierValueBlock);\n\n    _this28 = _super30.call(this, parameters);\n\n    _this28.fromString(getParametersValue(parameters, \"value\", \"\"));\n\n    return _this28;\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  _createClass(LocalRelativeObjectIdentifierValueBlock, [{\n    key: \"fromBER\",\n    value: function fromBER(inputBuffer, inputOffset, inputLength) {\n      var resultOffset = inputOffset;\n\n      while (inputLength > 0) {\n        var sidBlock = new LocalRelativeSidValueBlock();\n        resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n\n        if (resultOffset === -1) {\n          this.blockLength = 0;\n          this.error = sidBlock.error;\n          return resultOffset;\n        }\n\n        this.blockLength += sidBlock.blockLength;\n        inputLength -= sidBlock.blockLength;\n        this.value.push(sidBlock);\n      }\n\n      return resultOffset;\n    } //**********************************************************************************\n\n    /**\n     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n     * @returns {ArrayBuffer}\n     */\n\n  }, {\n    key: \"toBER\",\n    value: function toBER() {\n      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var retBuf = new ArrayBuffer(0);\n\n      for (var i = 0; i < this.value.length; i++) {\n        var valueBuf = this.value[i].toBER(sizeOnly);\n\n        if (valueBuf.byteLength === 0) {\n          this.error = this.value[i].error;\n          return new ArrayBuffer(0);\n        }\n\n        retBuf = utilConcatBuf(retBuf, valueBuf);\n      }\n\n      return retBuf;\n    } //**********************************************************************************\n\n    /**\n     * Create \"LocalRelativeObjectIdentifierValueBlock\" class from string\n     * @param {string} string Input string to convert from\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"fromString\",\n    value: function fromString(string) {\n      this.value = []; // Clear existing SID values\n\n      var pos1 = 0;\n      var pos2 = 0;\n      var sid = \"\";\n\n      do {\n        pos2 = string.indexOf(\".\", pos1);\n        if (pos2 === -1) sid = string.substr(pos1);else sid = string.substr(pos1, pos2 - pos1);\n        pos1 = pos2 + 1;\n        var sidBlock = new LocalRelativeSidValueBlock();\n        sidBlock.valueDec = parseInt(sid, 10);\n        if (isNaN(sidBlock.valueDec)) return true;\n        this.value.push(sidBlock);\n      } while (pos2 !== -1);\n\n      return true;\n    } //**********************************************************************************\n\n    /**\n     * Converts \"LocalRelativeObjectIdentifierValueBlock\" class to string\n     * @returns {string}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var result = \"\";\n      var isHexOnly = false;\n\n      for (var i = 0; i < this.value.length; i++) {\n        isHexOnly = this.value[i].isHexOnly;\n        var sidStr = this.value[i].toString();\n        if (i !== 0) result = \"\".concat(result, \".\");\n\n        if (isHexOnly) {\n          sidStr = \"{\".concat(sidStr, \"}\");\n          result += sidStr;\n        } else result += sidStr;\n      }\n\n      return result;\n    } //**********************************************************************************\n\n    /**\n     * Aux function, need to get a block name. Need to have it here for inhiritence\n     * @returns {string}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: //**********************************************************************************\n\n    /**\n     * Convertion for the block to JSON object\n     * @returns {Object}\n     */\n    function toJSON() {\n      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n      try {\n        object = _get(_getPrototypeOf(LocalRelativeObjectIdentifierValueBlock.prototype), \"toJSON\", this).call(this);\n      } catch (ex) {} //endregion\n\n\n      object.value = this.toString();\n      object.sidArray = [];\n\n      for (var i = 0; i < this.value.length; i++) {\n        object.sidArray.push(this.value[i].toJSON());\n      }\n\n      return object;\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"RelativeObjectIdentifierValueBlock\";\n    }\n  }]);\n\n  return LocalRelativeObjectIdentifierValueBlock;\n}(ValueBlock); //**************************************************************************************\n\n/**\n * @extends BaseBlock\n */\n\n\nexport var RelativeObjectIdentifier = /*#__PURE__*/function (_BaseBlock11) {\n  _inherits(RelativeObjectIdentifier, _BaseBlock11);\n\n  var _super31 = _createSuper(RelativeObjectIdentifier);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"RelativeObjectIdentifier\" class\n   * @param {Object} [parameters={}]\n   * @property {ArrayBuffer} [valueHex]\n   */\n  function RelativeObjectIdentifier() {\n    var _this29;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, RelativeObjectIdentifier);\n\n    _this29 = _super31.call(this, parameters, LocalRelativeObjectIdentifierValueBlock);\n    _this29.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this29.idBlock.tagNumber = 13; // RELATIVE OBJECT IDENTIFIER\n\n    return _this29;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(RelativeObjectIdentifier, null, [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"RelativeObjectIdentifier\";\n    } //**********************************************************************************\n\n  }]);\n\n  return RelativeObjectIdentifier;\n}(BaseBlock); //**************************************************************************************\n//endregion\n//**************************************************************************************\n\n/**\n * @extends LocalBaseBlock\n * @extends HexBlock\n */\n\nvar LocalBmpStringValueBlock = /*#__PURE__*/function (_HexBlock8) {\n  _inherits(LocalBmpStringValueBlock, _HexBlock8);\n\n  var _super32 = _createSuper(LocalBmpStringValueBlock);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalBmpStringValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n  function LocalBmpStringValueBlock() {\n    var _this30;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LocalBmpStringValueBlock);\n\n    _this30 = _super32.call(this, parameters);\n    _this30.isHexOnly = true;\n    _this30.value = \"\";\n    return _this30;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(LocalBmpStringValueBlock, [{\n    key: \"toJSON\",\n    value: //**********************************************************************************\n    //noinspection JSUnusedGlobalSymbols\n\n    /**\n     * Convertion for the block to JSON object\n     * @returns {Object}\n     */\n    function toJSON() {\n      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n      try {\n        object = _get(_getPrototypeOf(LocalBmpStringValueBlock.prototype), \"toJSON\", this).call(this);\n      } catch (ex) {} //endregion\n\n\n      object.value = this.value;\n      return object;\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"BmpStringValueBlock\";\n    }\n  }]);\n\n  return LocalBmpStringValueBlock;\n}(HexBlock(LocalBaseBlock)); //**************************************************************************************\n\n/**\n * @extends BaseBlock\n */\n\n\nexport var BmpString = /*#__PURE__*/function (_BaseBlock12) {\n  _inherits(BmpString, _BaseBlock12);\n\n  var _super33 = _createSuper(BmpString);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"BmpString\" class\n   * @param {Object} [parameters={}]\n   */\n  function BmpString() {\n    var _this31;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, BmpString);\n\n    _this31 = _super33.call(this, parameters, LocalBmpStringValueBlock);\n    if (\"value\" in parameters) _this31.fromString(parameters.value);\n    _this31.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this31.idBlock.tagNumber = 30; // BmpString\n\n    return _this31;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(BmpString, [{\n    key: \"fromBER\",\n    value: //**********************************************************************************\n\n    /**\n     * Base function for converting block from BER encoded array of bytes\n     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n     * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n     * @returns {number} Offset after least decoded byte\n     */\n    function fromBER(inputBuffer, inputOffset, inputLength) {\n      var resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n      if (resultOffset === -1) {\n        this.error = this.valueBlock.error;\n        return resultOffset;\n      }\n\n      this.fromBuffer(this.valueBlock.valueHex);\n      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n      if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n      return resultOffset;\n    } //**********************************************************************************\n\n    /**\n     * Function converting ArrayBuffer into ASN.1 internal string\n     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n     */\n\n  }, {\n    key: \"fromBuffer\",\n    value: function fromBuffer(inputBuffer) {\n      //noinspection JSCheckFunctionSignatures\n      var copyBuffer = inputBuffer.slice(0);\n      var valueView = new Uint8Array(copyBuffer);\n\n      for (var i = 0; i < valueView.length; i += 2) {\n        var temp = valueView[i];\n        valueView[i] = valueView[i + 1];\n        valueView[i + 1] = temp;\n      }\n\n      this.valueBlock.value = String.fromCharCode.apply(null, new Uint16Array(copyBuffer));\n    } //**********************************************************************************\n\n    /**\n     * Function converting JavaScript string into ASN.1 internal class\n     * @param {!string} inputString ASN.1 BER encoded array\n     */\n\n  }, {\n    key: \"fromString\",\n    value: function fromString(inputString) {\n      var strLength = inputString.length;\n      this.valueBlock.valueHex = new ArrayBuffer(strLength * 2);\n      var valueHexView = new Uint8Array(this.valueBlock.valueHex);\n\n      for (var i = 0; i < strLength; i++) {\n        var codeBuf = utilToBase(inputString.charCodeAt(i), 8);\n        var codeView = new Uint8Array(codeBuf);\n        if (codeView.length > 2) continue;\n        var dif = 2 - codeView.length;\n\n        for (var j = codeView.length - 1; j >= 0; j--) {\n          valueHexView[i * 2 + j + dif] = codeView[j];\n        }\n      }\n\n      this.valueBlock.value = inputString;\n    } //**********************************************************************************\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.constructor.blockName(), \" : \").concat(this.valueBlock.value);\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"BMPString\";\n    }\n  }]);\n\n  return BmpString;\n}(BaseBlock); //**************************************************************************************\n\nvar LocalUniversalStringValueBlock = /*#__PURE__*/function (_HexBlock9) {\n  _inherits(LocalUniversalStringValueBlock, _HexBlock9);\n\n  var _super34 = _createSuper(LocalUniversalStringValueBlock);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalUniversalStringValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n  function LocalUniversalStringValueBlock() {\n    var _this32;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LocalUniversalStringValueBlock);\n\n    _this32 = _super34.call(this, parameters);\n    _this32.isHexOnly = true;\n    _this32.value = \"\";\n    return _this32;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(LocalUniversalStringValueBlock, [{\n    key: \"toJSON\",\n    value: //**********************************************************************************\n    //noinspection JSUnusedGlobalSymbols\n\n    /**\n     * Convertion for the block to JSON object\n     * @returns {Object}\n     */\n    function toJSON() {\n      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n      try {\n        object = _get(_getPrototypeOf(LocalUniversalStringValueBlock.prototype), \"toJSON\", this).call(this);\n      } catch (ex) {} //endregion\n\n\n      object.value = this.value;\n      return object;\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"UniversalStringValueBlock\";\n    }\n  }]);\n\n  return LocalUniversalStringValueBlock;\n}(HexBlock(LocalBaseBlock)); //**************************************************************************************\n\n/**\n * @extends BaseBlock\n */\n\n\nexport var UniversalString = /*#__PURE__*/function (_BaseBlock13) {\n  _inherits(UniversalString, _BaseBlock13);\n\n  var _super35 = _createSuper(UniversalString);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"UniversalString\" class\n   * @param {Object} [parameters={}]\n   */\n  function UniversalString() {\n    var _this33;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, UniversalString);\n\n    _this33 = _super35.call(this, parameters, LocalUniversalStringValueBlock);\n    if (\"value\" in parameters) _this33.fromString(parameters.value);\n    _this33.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this33.idBlock.tagNumber = 28; // UniversalString\n\n    return _this33;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(UniversalString, [{\n    key: \"fromBER\",\n    value: //**********************************************************************************\n\n    /**\n     * Base function for converting block from BER encoded array of bytes\n     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n     * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n     * @returns {number} Offset after least decoded byte\n     */\n    function fromBER(inputBuffer, inputOffset, inputLength) {\n      var resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n      if (resultOffset === -1) {\n        this.error = this.valueBlock.error;\n        return resultOffset;\n      }\n\n      this.fromBuffer(this.valueBlock.valueHex);\n      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n      if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n      return resultOffset;\n    } //**********************************************************************************\n\n    /**\n     * Function converting ArrayBuffer into ASN.1 internal string\n     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n     */\n\n  }, {\n    key: \"fromBuffer\",\n    value: function fromBuffer(inputBuffer) {\n      //noinspection JSCheckFunctionSignatures\n      var copyBuffer = inputBuffer.slice(0);\n      var valueView = new Uint8Array(copyBuffer);\n\n      for (var i = 0; i < valueView.length; i += 4) {\n        valueView[i] = valueView[i + 3];\n        valueView[i + 1] = valueView[i + 2];\n        valueView[i + 2] = 0x00;\n        valueView[i + 3] = 0x00;\n      }\n\n      this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));\n    } //**********************************************************************************\n\n    /**\n     * Function converting JavaScript string into ASN.1 internal class\n     * @param {!string} inputString ASN.1 BER encoded array\n     */\n\n  }, {\n    key: \"fromString\",\n    value: function fromString(inputString) {\n      var strLength = inputString.length;\n      this.valueBlock.valueHex = new ArrayBuffer(strLength * 4);\n      var valueHexView = new Uint8Array(this.valueBlock.valueHex);\n\n      for (var i = 0; i < strLength; i++) {\n        var codeBuf = utilToBase(inputString.charCodeAt(i), 8);\n        var codeView = new Uint8Array(codeBuf);\n        if (codeView.length > 4) continue;\n        var dif = 4 - codeView.length;\n\n        for (var j = codeView.length - 1; j >= 0; j--) {\n          valueHexView[i * 4 + j + dif] = codeView[j];\n        }\n      }\n\n      this.valueBlock.value = inputString;\n    } //**********************************************************************************\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.constructor.blockName(), \" : \").concat(this.valueBlock.value);\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"UniversalString\";\n    }\n  }]);\n\n  return UniversalString;\n}(BaseBlock); //**************************************************************************************\n\nvar LocalSimpleStringValueBlock = /*#__PURE__*/function (_HexBlock10) {\n  _inherits(LocalSimpleStringValueBlock, _HexBlock10);\n\n  var _super36 = _createSuper(LocalSimpleStringValueBlock);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalSimpleStringValueBlock\" class\n   * @param {Object} [parameters={}]\n   */\n  function LocalSimpleStringValueBlock() {\n    var _this34;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LocalSimpleStringValueBlock);\n\n    _this34 = _super36.call(this, parameters);\n    _this34.value = \"\";\n    _this34.isHexOnly = true;\n    return _this34;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(LocalSimpleStringValueBlock, [{\n    key: \"toJSON\",\n    value: //**********************************************************************************\n    //noinspection JSUnusedGlobalSymbols\n\n    /**\n     * Convertion for the block to JSON object\n     * @returns {Object}\n     */\n    function toJSON() {\n      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n      try {\n        object = _get(_getPrototypeOf(LocalSimpleStringValueBlock.prototype), \"toJSON\", this).call(this);\n      } catch (ex) {} //endregion\n\n\n      object.value = this.value;\n      return object;\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"SimpleStringValueBlock\";\n    }\n  }]);\n\n  return LocalSimpleStringValueBlock;\n}(HexBlock(LocalBaseBlock)); //**************************************************************************************\n\n/**\n * @extends BaseBlock\n */\n\n\nvar LocalSimpleStringBlock = /*#__PURE__*/function (_BaseBlock14) {\n  _inherits(LocalSimpleStringBlock, _BaseBlock14);\n\n  var _super37 = _createSuper(LocalSimpleStringBlock);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"LocalSimpleStringBlock\" class\n   * @param {Object} [parameters={}]\n   */\n  function LocalSimpleStringBlock() {\n    var _this35;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LocalSimpleStringBlock);\n\n    _this35 = _super37.call(this, parameters, LocalSimpleStringValueBlock);\n    if (\"value\" in parameters) _this35.fromString(parameters.value);\n    return _this35;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(LocalSimpleStringBlock, [{\n    key: \"fromBER\",\n    value: //**********************************************************************************\n\n    /**\n     * Base function for converting block from BER encoded array of bytes\n     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n     * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n     * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n     * @returns {number} Offset after least decoded byte\n     */\n    function fromBER(inputBuffer, inputOffset, inputLength) {\n      var resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n      if (resultOffset === -1) {\n        this.error = this.valueBlock.error;\n        return resultOffset;\n      }\n\n      this.fromBuffer(this.valueBlock.valueHex);\n      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n      if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n      return resultOffset;\n    } //**********************************************************************************\n\n    /**\n     * Function converting ArrayBuffer into ASN.1 internal string\n     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n     */\n\n  }, {\n    key: \"fromBuffer\",\n    value: function fromBuffer(inputBuffer) {\n      this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));\n    } //**********************************************************************************\n\n    /**\n     * Function converting JavaScript string into ASN.1 internal class\n     * @param {!string} inputString ASN.1 BER encoded array\n     */\n\n  }, {\n    key: \"fromString\",\n    value: function fromString(inputString) {\n      var strLen = inputString.length;\n      this.valueBlock.valueHex = new ArrayBuffer(strLen);\n      var view = new Uint8Array(this.valueBlock.valueHex);\n\n      for (var i = 0; i < strLen; i++) {\n        view[i] = inputString.charCodeAt(i);\n      }\n\n      this.valueBlock.value = inputString;\n    } //**********************************************************************************\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.constructor.blockName(), \" : \").concat(this.valueBlock.value);\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"SIMPLESTRING\";\n    }\n  }]);\n\n  return LocalSimpleStringBlock;\n}(BaseBlock); //**************************************************************************************\n\n/**\n * @extends LocalSimpleStringBlock\n */\n\n\nexport var NumericString = /*#__PURE__*/function (_LocalSimpleStringBlo) {\n  _inherits(NumericString, _LocalSimpleStringBlo);\n\n  var _super38 = _createSuper(NumericString);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"NumericString\" class\n   * @param {Object} [parameters={}]\n   */\n  function NumericString() {\n    var _this36;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, NumericString);\n\n    _this36 = _super38.call(this, parameters);\n    _this36.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this36.idBlock.tagNumber = 18; // NumericString\n\n    return _this36;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(NumericString, null, [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"NumericString\";\n    } //**********************************************************************************\n\n  }]);\n\n  return NumericString;\n}(LocalSimpleStringBlock); //**************************************************************************************\n\n/**\n * @extends LocalSimpleStringBlock\n */\n\nexport var PrintableString = /*#__PURE__*/function (_LocalSimpleStringBlo2) {\n  _inherits(PrintableString, _LocalSimpleStringBlo2);\n\n  var _super39 = _createSuper(PrintableString);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"PrintableString\" class\n   * @param {Object} [parameters={}]\n   */\n  function PrintableString() {\n    var _this37;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, PrintableString);\n\n    _this37 = _super39.call(this, parameters);\n    _this37.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this37.idBlock.tagNumber = 19; // PrintableString\n\n    return _this37;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(PrintableString, null, [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"PrintableString\";\n    } //**********************************************************************************\n\n  }]);\n\n  return PrintableString;\n}(LocalSimpleStringBlock); //**************************************************************************************\n\n/**\n * @extends LocalSimpleStringBlock\n */\n\nexport var TeletexString = /*#__PURE__*/function (_LocalSimpleStringBlo3) {\n  _inherits(TeletexString, _LocalSimpleStringBlo3);\n\n  var _super40 = _createSuper(TeletexString);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"TeletexString\" class\n   * @param {Object} [parameters={}]\n   */\n  function TeletexString() {\n    var _this38;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, TeletexString);\n\n    _this38 = _super40.call(this, parameters);\n    _this38.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this38.idBlock.tagNumber = 20; // TeletexString\n\n    return _this38;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(TeletexString, null, [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"TeletexString\";\n    } //**********************************************************************************\n\n  }]);\n\n  return TeletexString;\n}(LocalSimpleStringBlock); //**************************************************************************************\n\n/**\n * @extends LocalSimpleStringBlock\n */\n\nexport var VideotexString = /*#__PURE__*/function (_LocalSimpleStringBlo4) {\n  _inherits(VideotexString, _LocalSimpleStringBlo4);\n\n  var _super41 = _createSuper(VideotexString);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"VideotexString\" class\n   * @param {Object} [parameters={}]\n   */\n  function VideotexString() {\n    var _this39;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, VideotexString);\n\n    _this39 = _super41.call(this, parameters);\n    _this39.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this39.idBlock.tagNumber = 21; // VideotexString\n\n    return _this39;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(VideotexString, null, [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"VideotexString\";\n    } //**********************************************************************************\n\n  }]);\n\n  return VideotexString;\n}(LocalSimpleStringBlock); //**************************************************************************************\n\n/**\n * @extends LocalSimpleStringBlock\n */\n\nexport var IA5String = /*#__PURE__*/function (_LocalSimpleStringBlo5) {\n  _inherits(IA5String, _LocalSimpleStringBlo5);\n\n  var _super42 = _createSuper(IA5String);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"IA5String\" class\n   * @param {Object} [parameters={}]\n   */\n  function IA5String() {\n    var _this40;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, IA5String);\n\n    _this40 = _super42.call(this, parameters);\n    _this40.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this40.idBlock.tagNumber = 22; // IA5String\n\n    return _this40;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(IA5String, null, [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"IA5String\";\n    } //**********************************************************************************\n\n  }]);\n\n  return IA5String;\n}(LocalSimpleStringBlock); //**************************************************************************************\n\n/**\n * @extends LocalSimpleStringBlock\n */\n\nexport var GraphicString = /*#__PURE__*/function (_LocalSimpleStringBlo6) {\n  _inherits(GraphicString, _LocalSimpleStringBlo6);\n\n  var _super43 = _createSuper(GraphicString);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"GraphicString\" class\n   * @param {Object} [parameters={}]\n   */\n  function GraphicString() {\n    var _this41;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, GraphicString);\n\n    _this41 = _super43.call(this, parameters);\n    _this41.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this41.idBlock.tagNumber = 25; // GraphicString\n\n    return _this41;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(GraphicString, null, [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"GraphicString\";\n    } //**********************************************************************************\n\n  }]);\n\n  return GraphicString;\n}(LocalSimpleStringBlock); //**************************************************************************************\n\n/**\n * @extends LocalSimpleStringBlock\n */\n\nexport var VisibleString = /*#__PURE__*/function (_LocalSimpleStringBlo7) {\n  _inherits(VisibleString, _LocalSimpleStringBlo7);\n\n  var _super44 = _createSuper(VisibleString);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"VisibleString\" class\n   * @param {Object} [parameters={}]\n   */\n  function VisibleString() {\n    var _this42;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, VisibleString);\n\n    _this42 = _super44.call(this, parameters);\n    _this42.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this42.idBlock.tagNumber = 26; // VisibleString\n\n    return _this42;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(VisibleString, null, [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"VisibleString\";\n    } //**********************************************************************************\n\n  }]);\n\n  return VisibleString;\n}(LocalSimpleStringBlock); //**************************************************************************************\n\n/**\n * @extends LocalSimpleStringBlock\n */\n\nexport var GeneralString = /*#__PURE__*/function (_LocalSimpleStringBlo8) {\n  _inherits(GeneralString, _LocalSimpleStringBlo8);\n\n  var _super45 = _createSuper(GeneralString);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"GeneralString\" class\n   * @param {Object} [parameters={}]\n   */\n  function GeneralString() {\n    var _this43;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, GeneralString);\n\n    _this43 = _super45.call(this, parameters);\n    _this43.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this43.idBlock.tagNumber = 27; // GeneralString\n\n    return _this43;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(GeneralString, null, [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"GeneralString\";\n    } //**********************************************************************************\n\n  }]);\n\n  return GeneralString;\n}(LocalSimpleStringBlock); //**************************************************************************************\n\n/**\n * @extends LocalSimpleStringBlock\n */\n\nexport var CharacterString = /*#__PURE__*/function (_LocalSimpleStringBlo9) {\n  _inherits(CharacterString, _LocalSimpleStringBlo9);\n\n  var _super46 = _createSuper(CharacterString);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"CharacterString\" class\n   * @param {Object} [parameters={}]\n   */\n  function CharacterString() {\n    var _this44;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, CharacterString);\n\n    _this44 = _super46.call(this, parameters);\n    _this44.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this44.idBlock.tagNumber = 29; // CharacterString\n\n    return _this44;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(CharacterString, null, [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"CharacterString\";\n    } //**********************************************************************************\n\n  }]);\n\n  return CharacterString;\n}(LocalSimpleStringBlock); //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of all date and time classes\n//**************************************************************************************\n\n/**\n * @extends VisibleString\n */\n\nexport var UTCTime = /*#__PURE__*/function (_VisibleString) {\n  _inherits(UTCTime, _VisibleString);\n\n  var _super47 = _createSuper(UTCTime);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"UTCTime\" class\n   * @param {Object} [parameters={}]\n   * @property {string} [value] String representatio of the date\n   * @property {Date} [valueDate] JavaScript \"Date\" object\n   */\n  function UTCTime() {\n    var _this45;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, UTCTime);\n\n    _this45 = _super47.call(this, parameters);\n    _this45.year = 0;\n    _this45.month = 0;\n    _this45.day = 0;\n    _this45.hour = 0;\n    _this45.minute = 0;\n    _this45.second = 0; //region Create UTCTime from ASN.1 UTC string value\n\n    if (\"value\" in parameters) {\n      _this45.fromString(parameters.value);\n\n      _this45.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);\n      var view = new Uint8Array(_this45.valueBlock.valueHex);\n\n      for (var i = 0; i < parameters.value.length; i++) {\n        view[i] = parameters.value.charCodeAt(i);\n      }\n    } //endregion\n    //region Create GeneralizedTime from JavaScript Date type\n\n\n    if (\"valueDate\" in parameters) {\n      _this45.fromDate(parameters.valueDate);\n\n      _this45.valueBlock.valueHex = _this45.toBuffer();\n    } //endregion\n\n\n    _this45.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this45.idBlock.tagNumber = 23; // UTCTime\n\n    return _this45;\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  _createClass(UTCTime, [{\n    key: \"fromBER\",\n    value: function fromBER(inputBuffer, inputOffset, inputLength) {\n      var resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n      if (resultOffset === -1) {\n        this.error = this.valueBlock.error;\n        return resultOffset;\n      }\n\n      this.fromBuffer(this.valueBlock.valueHex);\n      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n      if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n      return resultOffset;\n    } //**********************************************************************************\n\n    /**\n     * Function converting ArrayBuffer into ASN.1 internal string\n     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n     */\n\n  }, {\n    key: \"fromBuffer\",\n    value: function fromBuffer(inputBuffer) {\n      this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));\n    } //**********************************************************************************\n\n    /**\n     * Function converting ASN.1 internal string into ArrayBuffer\n     * @returns {ArrayBuffer}\n     */\n\n  }, {\n    key: \"toBuffer\",\n    value: function toBuffer() {\n      var str = this.toString();\n      var buffer = new ArrayBuffer(str.length);\n      var view = new Uint8Array(buffer);\n\n      for (var i = 0; i < str.length; i++) {\n        view[i] = str.charCodeAt(i);\n      }\n\n      return buffer;\n    } //**********************************************************************************\n\n    /**\n     * Function converting \"Date\" object into ASN.1 internal string\n     * @param {!Date} inputDate JavaScript \"Date\" object\n     */\n\n  }, {\n    key: \"fromDate\",\n    value: function fromDate(inputDate) {\n      this.year = inputDate.getUTCFullYear();\n      this.month = inputDate.getUTCMonth() + 1;\n      this.day = inputDate.getUTCDate();\n      this.hour = inputDate.getUTCHours();\n      this.minute = inputDate.getUTCMinutes();\n      this.second = inputDate.getUTCSeconds();\n    } //**********************************************************************************\n    //noinspection JSUnusedGlobalSymbols\n\n    /**\n     * Function converting ASN.1 internal string into \"Date\" object\n     * @returns {Date}\n     */\n\n  }, {\n    key: \"toDate\",\n    value: function toDate() {\n      return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));\n    } //**********************************************************************************\n\n    /**\n     * Function converting JavaScript string into ASN.1 internal class\n     * @param {!string} inputString ASN.1 BER encoded array\n     */\n\n  }, {\n    key: \"fromString\",\n    value: function fromString(inputString) {\n      //region Parse input string\n      var parser = /(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z/ig;\n      var parserArray = parser.exec(inputString);\n\n      if (parserArray === null) {\n        this.error = \"Wrong input string for convertion\";\n        return;\n      } //endregion\n      //region Store parsed values\n\n\n      var year = parseInt(parserArray[1], 10);\n      if (year >= 50) this.year = 1900 + year;else this.year = 2000 + year;\n      this.month = parseInt(parserArray[2], 10);\n      this.day = parseInt(parserArray[3], 10);\n      this.hour = parseInt(parserArray[4], 10);\n      this.minute = parseInt(parserArray[5], 10);\n      this.second = parseInt(parserArray[6], 10); //endregion\n    } //**********************************************************************************\n\n    /**\n     * Function converting ASN.1 internal class into JavaScript string\n     * @returns {string}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var outputArray = new Array(7);\n      outputArray[0] = padNumber(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);\n      outputArray[1] = padNumber(this.month, 2);\n      outputArray[2] = padNumber(this.day, 2);\n      outputArray[3] = padNumber(this.hour, 2);\n      outputArray[4] = padNumber(this.minute, 2);\n      outputArray[5] = padNumber(this.second, 2);\n      outputArray[6] = \"Z\";\n      return outputArray.join(\"\");\n    } //**********************************************************************************\n\n    /**\n     * Aux function, need to get a block name. Need to have it here for inhiritence\n     * @returns {string}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: //**********************************************************************************\n\n    /**\n     * Convertion for the block to JSON object\n     * @returns {Object}\n     */\n    function toJSON() {\n      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n      try {\n        object = _get(_getPrototypeOf(UTCTime.prototype), \"toJSON\", this).call(this);\n      } catch (ex) {} //endregion\n\n\n      object.year = this.year;\n      object.month = this.month;\n      object.day = this.day;\n      object.hour = this.hour;\n      object.minute = this.minute;\n      object.second = this.second;\n      return object;\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"UTCTime\";\n    }\n  }]);\n\n  return UTCTime;\n}(VisibleString); //**************************************************************************************\n\n/**\n * @extends VisibleString\n */\n\nexport var GeneralizedTime = /*#__PURE__*/function (_VisibleString2) {\n  _inherits(GeneralizedTime, _VisibleString2);\n\n  var _super48 = _createSuper(GeneralizedTime);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"GeneralizedTime\" class\n   * @param {Object} [parameters={}]\n   * @property {string} [value] String representatio of the date\n   * @property {Date} [valueDate] JavaScript \"Date\" object\n   */\n  function GeneralizedTime() {\n    var _this46;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, GeneralizedTime);\n\n    _this46 = _super48.call(this, parameters);\n    _this46.year = 0;\n    _this46.month = 0;\n    _this46.day = 0;\n    _this46.hour = 0;\n    _this46.minute = 0;\n    _this46.second = 0;\n    _this46.millisecond = 0; //region Create UTCTime from ASN.1 UTC string value\n\n    if (\"value\" in parameters) {\n      _this46.fromString(parameters.value);\n\n      _this46.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);\n      var view = new Uint8Array(_this46.valueBlock.valueHex);\n\n      for (var i = 0; i < parameters.value.length; i++) {\n        view[i] = parameters.value.charCodeAt(i);\n      }\n    } //endregion\n    //region Create GeneralizedTime from JavaScript Date type\n\n\n    if (\"valueDate\" in parameters) {\n      _this46.fromDate(parameters.valueDate);\n\n      _this46.valueBlock.valueHex = _this46.toBuffer();\n    } //endregion\n\n\n    _this46.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this46.idBlock.tagNumber = 24; // GeneralizedTime\n\n    return _this46;\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  _createClass(GeneralizedTime, [{\n    key: \"fromBER\",\n    value: function fromBER(inputBuffer, inputOffset, inputLength) {\n      var resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n      if (resultOffset === -1) {\n        this.error = this.valueBlock.error;\n        return resultOffset;\n      }\n\n      this.fromBuffer(this.valueBlock.valueHex);\n      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n      if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n      return resultOffset;\n    } //**********************************************************************************\n\n    /**\n     * Function converting ArrayBuffer into ASN.1 internal string\n     * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n     */\n\n  }, {\n    key: \"fromBuffer\",\n    value: function fromBuffer(inputBuffer) {\n      this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));\n    } //**********************************************************************************\n\n    /**\n     * Function converting ASN.1 internal string into ArrayBuffer\n     * @returns {ArrayBuffer}\n     */\n\n  }, {\n    key: \"toBuffer\",\n    value: function toBuffer() {\n      var str = this.toString();\n      var buffer = new ArrayBuffer(str.length);\n      var view = new Uint8Array(buffer);\n\n      for (var i = 0; i < str.length; i++) {\n        view[i] = str.charCodeAt(i);\n      }\n\n      return buffer;\n    } //**********************************************************************************\n\n    /**\n     * Function converting \"Date\" object into ASN.1 internal string\n     * @param {!Date} inputDate JavaScript \"Date\" object\n     */\n\n  }, {\n    key: \"fromDate\",\n    value: function fromDate(inputDate) {\n      this.year = inputDate.getUTCFullYear();\n      this.month = inputDate.getUTCMonth() + 1;\n      this.day = inputDate.getUTCDate();\n      this.hour = inputDate.getUTCHours();\n      this.minute = inputDate.getUTCMinutes();\n      this.second = inputDate.getUTCSeconds();\n      this.millisecond = inputDate.getUTCMilliseconds();\n    } //**********************************************************************************\n    //noinspection JSUnusedGlobalSymbols\n\n    /**\n     * Function converting ASN.1 internal string into \"Date\" object\n     * @returns {Date}\n     */\n\n  }, {\n    key: \"toDate\",\n    value: function toDate() {\n      return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));\n    } //**********************************************************************************\n\n    /**\n     * Function converting JavaScript string into ASN.1 internal class\n     * @param {!string} inputString ASN.1 BER encoded array\n     */\n\n  }, {\n    key: \"fromString\",\n    value: function fromString(inputString) {\n      //region Initial variables\n      var isUTC = false;\n      var timeString = \"\";\n      var dateTimeString = \"\";\n      var fractionPart = 0;\n      var parser;\n      var hourDifference = 0;\n      var minuteDifference = 0; //endregion\n      //region Convert as UTC time\n\n      if (inputString[inputString.length - 1] === \"Z\") {\n        timeString = inputString.substr(0, inputString.length - 1);\n        isUTC = true;\n      } //endregion\n      //region Convert as local time\n      else {\n        //noinspection JSPrimitiveTypeWrapperUsage\n        var number = new Number(inputString[inputString.length - 1]);\n        if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for convertion\");\n        timeString = inputString;\n      } //endregion\n      //region Check that we do not have a \"+\" and \"-\" symbols inside UTC time\n\n\n      if (isUTC) {\n        if (timeString.indexOf(\"+\") !== -1) throw new Error(\"Wrong input string for convertion\");\n        if (timeString.indexOf(\"-\") !== -1) throw new Error(\"Wrong input string for convertion\");\n      } //endregion\n      //region Get \"UTC time difference\" in case of local time\n      else {\n        var multiplier = 1;\n        var differencePosition = timeString.indexOf(\"+\");\n        var differenceString = \"\";\n\n        if (differencePosition === -1) {\n          differencePosition = timeString.indexOf(\"-\");\n          multiplier = -1;\n        }\n\n        if (differencePosition !== -1) {\n          differenceString = timeString.substr(differencePosition + 1);\n          timeString = timeString.substr(0, differencePosition);\n          if (differenceString.length !== 2 && differenceString.length !== 4) throw new Error(\"Wrong input string for convertion\"); //noinspection JSPrimitiveTypeWrapperUsage\n\n          var _number = new Number(differenceString.substr(0, 2));\n\n          if (isNaN(_number.valueOf())) throw new Error(\"Wrong input string for convertion\");\n          hourDifference = multiplier * _number;\n\n          if (differenceString.length === 4) {\n            //noinspection JSPrimitiveTypeWrapperUsage\n            _number = new Number(differenceString.substr(2, 2));\n            if (isNaN(_number.valueOf())) throw new Error(\"Wrong input string for convertion\");\n            minuteDifference = multiplier * _number;\n          }\n        }\n      } //endregion\n      //region Get position of fraction point\n\n\n      var fractionPointPosition = timeString.indexOf(\".\"); // Check for \"full stop\" symbol\n\n      if (fractionPointPosition === -1) fractionPointPosition = timeString.indexOf(\",\"); // Check for \"comma\" symbol\n      //endregion\n      //region Get fraction part\n\n      if (fractionPointPosition !== -1) {\n        //noinspection JSPrimitiveTypeWrapperUsage\n        var fractionPartCheck = new Number(\"0\".concat(timeString.substr(fractionPointPosition)));\n        if (isNaN(fractionPartCheck.valueOf())) throw new Error(\"Wrong input string for convertion\");\n        fractionPart = fractionPartCheck.valueOf();\n        dateTimeString = timeString.substr(0, fractionPointPosition);\n      } else dateTimeString = timeString; //endregion\n      //region Parse internal date\n\n\n      switch (true) {\n        case dateTimeString.length === 8:\n          // \"YYYYMMDD\"\n          parser = /(\\d{4})(\\d{2})(\\d{2})/ig;\n          if (fractionPointPosition !== -1) throw new Error(\"Wrong input string for convertion\"); // Here we should not have a \"fraction point\"\n\n          break;\n\n        case dateTimeString.length === 10:\n          // \"YYYYMMDDHH\"\n          parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n          if (fractionPointPosition !== -1) {\n            var fractionResult = 60 * fractionPart;\n            this.minute = Math.floor(fractionResult);\n            fractionResult = 60 * (fractionResult - this.minute);\n            this.second = Math.floor(fractionResult);\n            fractionResult = 1000 * (fractionResult - this.second);\n            this.millisecond = Math.floor(fractionResult);\n          }\n\n          break;\n\n        case dateTimeString.length === 12:\n          // \"YYYYMMDDHHMM\"\n          parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n          if (fractionPointPosition !== -1) {\n            var _fractionResult = 60 * fractionPart;\n\n            this.second = Math.floor(_fractionResult);\n            _fractionResult = 1000 * (_fractionResult - this.second);\n            this.millisecond = Math.floor(_fractionResult);\n          }\n\n          break;\n\n        case dateTimeString.length === 14:\n          // \"YYYYMMDDHHMMSS\"\n          parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n          if (fractionPointPosition !== -1) {\n            var _fractionResult2 = 1000 * fractionPart;\n\n            this.millisecond = Math.floor(_fractionResult2);\n          }\n\n          break;\n\n        default:\n          throw new Error(\"Wrong input string for convertion\");\n      } //endregion\n      //region Put parsed values at right places\n\n\n      var parserArray = parser.exec(dateTimeString);\n      if (parserArray === null) throw new Error(\"Wrong input string for convertion\");\n\n      for (var j = 1; j < parserArray.length; j++) {\n        switch (j) {\n          case 1:\n            this.year = parseInt(parserArray[j], 10);\n            break;\n\n          case 2:\n            this.month = parseInt(parserArray[j], 10);\n            break;\n\n          case 3:\n            this.day = parseInt(parserArray[j], 10);\n            break;\n\n          case 4:\n            this.hour = parseInt(parserArray[j], 10) + hourDifference;\n            break;\n\n          case 5:\n            this.minute = parseInt(parserArray[j], 10) + minuteDifference;\n            break;\n\n          case 6:\n            this.second = parseInt(parserArray[j], 10);\n            break;\n\n          default:\n            throw new Error(\"Wrong input string for convertion\");\n        }\n      } //endregion\n      //region Get final date\n\n\n      if (isUTC === false) {\n        var tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\n        this.year = tempDate.getUTCFullYear();\n        this.month = tempDate.getUTCMonth();\n        this.day = tempDate.getUTCDay();\n        this.hour = tempDate.getUTCHours();\n        this.minute = tempDate.getUTCMinutes();\n        this.second = tempDate.getUTCSeconds();\n        this.millisecond = tempDate.getUTCMilliseconds();\n      } //endregion\n\n    } //**********************************************************************************\n\n    /**\n     * Function converting ASN.1 internal class into JavaScript string\n     * @returns {string}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var outputArray = [];\n      outputArray.push(padNumber(this.year, 4));\n      outputArray.push(padNumber(this.month, 2));\n      outputArray.push(padNumber(this.day, 2));\n      outputArray.push(padNumber(this.hour, 2));\n      outputArray.push(padNumber(this.minute, 2));\n      outputArray.push(padNumber(this.second, 2));\n\n      if (this.millisecond !== 0) {\n        outputArray.push(\".\");\n        outputArray.push(padNumber(this.millisecond, 3));\n      }\n\n      outputArray.push(\"Z\");\n      return outputArray.join(\"\");\n    } //**********************************************************************************\n\n    /**\n     * Aux function, need to get a block name. Need to have it here for inhiritence\n     * @returns {string}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: //**********************************************************************************\n\n    /**\n     * Convertion for the block to JSON object\n     * @returns {Object}\n     */\n    function toJSON() {\n      var object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n      try {\n        object = _get(_getPrototypeOf(GeneralizedTime.prototype), \"toJSON\", this).call(this);\n      } catch (ex) {} //endregion\n\n\n      object.year = this.year;\n      object.month = this.month;\n      object.day = this.day;\n      object.hour = this.hour;\n      object.minute = this.minute;\n      object.second = this.second;\n      object.millisecond = this.millisecond;\n      return object;\n    } //**********************************************************************************\n\n  }], [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"GeneralizedTime\";\n    }\n  }]);\n\n  return GeneralizedTime;\n}(VisibleString); //**************************************************************************************\n\n/**\n * @extends Utf8String\n */\n\nexport var DATE = /*#__PURE__*/function (_Utf8String) {\n  _inherits(DATE, _Utf8String);\n\n  var _super49 = _createSuper(DATE);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"DATE\" class\n   * @param {Object} [parameters={}]\n   */\n  function DATE() {\n    var _this47;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, DATE);\n\n    _this47 = _super49.call(this, parameters);\n    _this47.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this47.idBlock.tagNumber = 31; // DATE\n\n    return _this47;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(DATE, null, [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"DATE\";\n    } //**********************************************************************************\n\n  }]);\n\n  return DATE;\n}(Utf8String); //**************************************************************************************\n\n/**\n * @extends Utf8String\n */\n\nexport var TimeOfDay = /*#__PURE__*/function (_Utf8String2) {\n  _inherits(TimeOfDay, _Utf8String2);\n\n  var _super50 = _createSuper(TimeOfDay);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"TimeOfDay\" class\n   * @param {Object} [parameters={}]\n   */\n  function TimeOfDay() {\n    var _this48;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, TimeOfDay);\n\n    _this48 = _super50.call(this, parameters);\n    _this48.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this48.idBlock.tagNumber = 32; // TimeOfDay\n\n    return _this48;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(TimeOfDay, null, [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"TimeOfDay\";\n    } //**********************************************************************************\n\n  }]);\n\n  return TimeOfDay;\n}(Utf8String); //**************************************************************************************\n\n/**\n * @extends Utf8String\n */\n\nexport var DateTime = /*#__PURE__*/function (_Utf8String3) {\n  _inherits(DateTime, _Utf8String3);\n\n  var _super51 = _createSuper(DateTime);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"DateTime\" class\n   * @param {Object} [parameters={}]\n   */\n  function DateTime() {\n    var _this49;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, DateTime);\n\n    _this49 = _super51.call(this, parameters);\n    _this49.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this49.idBlock.tagNumber = 33; // DateTime\n\n    return _this49;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(DateTime, null, [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"DateTime\";\n    } //**********************************************************************************\n\n  }]);\n\n  return DateTime;\n}(Utf8String); //**************************************************************************************\n\n/**\n * @extends Utf8String\n */\n\nexport var Duration = /*#__PURE__*/function (_Utf8String4) {\n  _inherits(Duration, _Utf8String4);\n\n  var _super52 = _createSuper(Duration);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Duration\" class\n   * @param {Object} [parameters={}]\n   */\n  function Duration() {\n    var _this50;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Duration);\n\n    _this50 = _super52.call(this, parameters);\n    _this50.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this50.idBlock.tagNumber = 34; // Duration\n\n    return _this50;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(Duration, null, [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"Duration\";\n    } //**********************************************************************************\n\n  }]);\n\n  return Duration;\n}(Utf8String); //**************************************************************************************\n\n/**\n * @extends Utf8String\n */\n\nexport var TIME = /*#__PURE__*/function (_Utf8String5) {\n  _inherits(TIME, _Utf8String5);\n\n  var _super53 = _createSuper(TIME);\n\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Time\" class\n   * @param {Object} [parameters={}]\n   */\n  function TIME() {\n    var _this51;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, TIME);\n\n    _this51 = _super53.call(this, parameters);\n    _this51.idBlock.tagClass = 1; // UNIVERSAL\n\n    _this51.idBlock.tagNumber = 14; // Time\n\n    return _this51;\n  } //**********************************************************************************\n\n  /**\n   * Aux function, need to get a block name. Need to have it here for inhiritence\n   * @returns {string}\n   */\n\n\n  _createClass(TIME, null, [{\n    key: \"blockName\",\n    value: function blockName() {\n      return \"TIME\";\n    } //**********************************************************************************\n\n  }]);\n\n  return TIME;\n}(Utf8String); //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Choice\n//**************************************************************************************\n\nexport var Choice = /*#__PURE__*/_createClass( //**********************************************************************************\n\n/**\n * Constructor for \"Choice\" class\n * @param {Object} [parameters={}]\n * @property {Array} [value] Array of ASN.1 types for make a choice from\n * @property {boolean} [optional]\n */\nfunction Choice() {\n  var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  _classCallCheck(this, Choice);\n\n  this.value = getParametersValue(parameters, \"value\", []);\n  this.optional = getParametersValue(parameters, \"optional\", false);\n} //**********************************************************************************\n); //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Any\n//**************************************************************************************\n\nexport var Any = /*#__PURE__*/_createClass( //**********************************************************************************\n\n/**\n * Constructor for \"Any\" class\n * @param {Object} [parameters={}]\n * @property {string} [name]\n * @property {boolean} [optional]\n */\nfunction Any() {\n  var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  _classCallCheck(this, Any);\n\n  this.name = getParametersValue(parameters, \"name\", \"\");\n  this.optional = getParametersValue(parameters, \"optional\", false);\n} //**********************************************************************************\n); //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Repeated\n//**************************************************************************************\n\nexport var Repeated = /*#__PURE__*/_createClass( //**********************************************************************************\n\n/**\n * Constructor for \"Repeated\" class\n * @param {Object} [parameters={}]\n * @property {string} [name]\n * @property {boolean} [optional]\n */\nfunction Repeated() {\n  var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  _classCallCheck(this, Repeated);\n\n  this.name = getParametersValue(parameters, \"name\", \"\");\n  this.optional = getParametersValue(parameters, \"optional\", false);\n  this.value = getParametersValue(parameters, \"value\", new Any());\n  this.local = getParametersValue(parameters, \"local\", false); // Could local or global array to store elements\n} //**********************************************************************************\n); //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type RawData\n//**************************************************************************************\n\n/**\n * @description Special class providing ability to have \"toBER/fromBER\" for raw ArrayBuffer\n */\n\nexport var RawData = /*#__PURE__*/function () {\n  //**********************************************************************************\n\n  /**\n   * Constructor for \"Repeated\" class\n   * @param {Object} [parameters={}]\n   * @property {string} [name]\n   * @property {boolean} [optional]\n   */\n  function RawData() {\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, RawData);\n\n    this.data = getParametersValue(parameters, \"data\", new ArrayBuffer(0));\n  } //**********************************************************************************\n\n  /**\n   * Base function for converting block from BER encoded array of bytes\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n   * @returns {number} Offset after least decoded byte\n   */\n\n\n  _createClass(RawData, [{\n    key: \"fromBER\",\n    value: function fromBER(inputBuffer, inputOffset, inputLength) {\n      this.data = inputBuffer.slice(inputOffset, inputLength);\n      return inputOffset + inputLength;\n    } //**********************************************************************************\n\n    /**\n     * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n     * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n     * @returns {ArrayBuffer}\n     */\n\n  }, {\n    key: \"toBER\",\n    value: function toBER() {\n      var sizeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return this.data;\n    } //**********************************************************************************\n\n  }]);\n\n  return RawData;\n}(); //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major ASN.1 BER decoding function\n//**************************************************************************************\n\n/**\n * Internal library function for decoding ASN.1 BER\n * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n * @returns {{offset: number, result: Object}}\n */\n\nfunction LocalFromBER(inputBuffer, inputOffset, inputLength) {\n  var incomingOffset = inputOffset; // Need to store initial offset since \"inputOffset\" is changing in the function\n  //region Local function changing a type for ASN.1 classes\n\n  function localChangeType(inputObject, newType) {\n    if (inputObject instanceof newType) return inputObject;\n    var newObject = new newType();\n    newObject.idBlock = inputObject.idBlock;\n    newObject.lenBlock = inputObject.lenBlock;\n    newObject.warnings = inputObject.warnings; //noinspection JSCheckFunctionSignatures\n\n    newObject.valueBeforeDecode = inputObject.valueBeforeDecode.slice(0);\n    return newObject;\n  } //endregion\n  //region Create a basic ASN.1 type since we need to return errors and warnings from the function\n\n\n  var returnObject = new BaseBlock({}, Object); //endregion\n  //region Basic check for parameters\n\n  var baseBlock = new LocalBaseBlock();\n\n  if (checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) === false) {\n    returnObject.error = baseBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  } //endregion\n  //region Getting Uint8Array from ArrayBuffer\n\n\n  var intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n  //region Initial checks\n\n  if (intBuffer.length === 0) {\n    returnObject.error = \"Zero buffer length\";\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  } //endregion\n  //region Decode indentifcation block of ASN.1 BER structure\n\n\n  var resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);\n  returnObject.warnings.concat(returnObject.idBlock.warnings);\n\n  if (resultOffset === -1) {\n    returnObject.error = returnObject.idBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n\n  inputOffset = resultOffset;\n  inputLength -= returnObject.idBlock.blockLength; //endregion\n  //region Decode length block of ASN.1 BER structure\n\n  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);\n  returnObject.warnings.concat(returnObject.lenBlock.warnings);\n\n  if (resultOffset === -1) {\n    returnObject.error = returnObject.lenBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n\n  inputOffset = resultOffset;\n  inputLength -= returnObject.lenBlock.blockLength; //endregion\n  //region Check for usign indefinite length form in encoding for primitive types\n\n  if (returnObject.idBlock.isConstructed === false && returnObject.lenBlock.isIndefiniteForm === true) {\n    returnObject.error = \"Indefinite length form used for primitive encoding form\";\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  } //endregion\n  //region Switch ASN.1 block type\n\n\n  var newASN1Type = BaseBlock;\n\n  switch (returnObject.idBlock.tagClass) {\n    //region UNIVERSAL\n    case 1:\n      //region Check for reserved tag numbers\n      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {\n        returnObject.error = \"UNIVERSAL 37 and upper tags are reserved by ASN.1 standard\";\n        return {\n          offset: -1,\n          result: returnObject\n        };\n      } //endregion\n\n\n      switch (returnObject.idBlock.tagNumber) {\n        //region EndOfContent type\n        case 0:\n          //region Check for EndOfContent type\n          if (returnObject.idBlock.isConstructed === true && returnObject.lenBlock.length > 0) {\n            returnObject.error = \"Type [UNIVERSAL 0] is reserved\";\n            return {\n              offset: -1,\n              result: returnObject\n            };\n          } //endregion\n\n\n          newASN1Type = EndOfContent;\n          break;\n        //endregion\n        //region Boolean type\n\n        case 1:\n          newASN1Type = Boolean;\n          break;\n        //endregion\n        //region Integer type\n\n        case 2:\n          newASN1Type = Integer;\n          break;\n        //endregion\n        //region BitString type\n\n        case 3:\n          newASN1Type = BitString;\n          break;\n        //endregion\n        //region OctetString type\n\n        case 4:\n          newASN1Type = OctetString;\n          break;\n        //endregion\n        //region Null type\n\n        case 5:\n          newASN1Type = Null;\n          break;\n        //endregion\n        //region OBJECT IDENTIFIER type\n\n        case 6:\n          newASN1Type = ObjectIdentifier;\n          break;\n        //endregion\n        //region Enumerated type\n\n        case 10:\n          newASN1Type = Enumerated;\n          break;\n        //endregion\n        //region Utf8String type\n\n        case 12:\n          newASN1Type = Utf8String;\n          break;\n        //endregion\n        //region Time type\n        //region RELATIVE OBJECT IDENTIFIER type\n\n        case 13:\n          newASN1Type = RelativeObjectIdentifier;\n          break;\n        //endregion\n\n        case 14:\n          newASN1Type = TIME;\n          break;\n        //endregion\n        //region ASN.1 reserved type\n\n        case 15:\n          returnObject.error = \"[UNIVERSAL 15] is reserved by ASN.1 standard\";\n          return {\n            offset: -1,\n            result: returnObject\n          };\n        //endregion\n        //region Sequence type\n\n        case 16:\n          newASN1Type = Sequence;\n          break;\n        //endregion\n        //region Set type\n\n        case 17:\n          newASN1Type = Set;\n          break;\n        //endregion\n        //region NumericString type\n\n        case 18:\n          newASN1Type = NumericString;\n          break;\n        //endregion\n        //region PrintableString type\n\n        case 19:\n          newASN1Type = PrintableString;\n          break;\n        //endregion\n        //region TeletexString type\n\n        case 20:\n          newASN1Type = TeletexString;\n          break;\n        //endregion\n        //region VideotexString type\n\n        case 21:\n          newASN1Type = VideotexString;\n          break;\n        //endregion\n        //region IA5String type\n\n        case 22:\n          newASN1Type = IA5String;\n          break;\n        //endregion\n        //region UTCTime type\n\n        case 23:\n          newASN1Type = UTCTime;\n          break;\n        //endregion\n        //region GeneralizedTime type\n\n        case 24:\n          newASN1Type = GeneralizedTime;\n          break;\n        //endregion\n        //region GraphicString type\n\n        case 25:\n          newASN1Type = GraphicString;\n          break;\n        //endregion\n        //region VisibleString type\n\n        case 26:\n          newASN1Type = VisibleString;\n          break;\n        //endregion\n        //region GeneralString type\n\n        case 27:\n          newASN1Type = GeneralString;\n          break;\n        //endregion\n        //region UniversalString type\n\n        case 28:\n          newASN1Type = UniversalString;\n          break;\n        //endregion\n        //region CharacterString type\n\n        case 29:\n          newASN1Type = CharacterString;\n          break;\n        //endregion\n        //region BmpString type\n\n        case 30:\n          newASN1Type = BmpString;\n          break;\n        //endregion\n        //region DATE type\n\n        case 31:\n          newASN1Type = DATE;\n          break;\n        //endregion\n        //region TimeOfDay type\n\n        case 32:\n          newASN1Type = TimeOfDay;\n          break;\n        //endregion\n        //region Date-Time type\n\n        case 33:\n          newASN1Type = DateTime;\n          break;\n        //endregion\n        //region Duration type\n\n        case 34:\n          newASN1Type = Duration;\n          break;\n        //endregion\n        //region default\n\n        default:\n          {\n            var newObject;\n            if (returnObject.idBlock.isConstructed === true) newObject = new Constructed();else newObject = new Primitive();\n            newObject.idBlock = returnObject.idBlock;\n            newObject.lenBlock = returnObject.lenBlock;\n            newObject.warnings = returnObject.warnings;\n            returnObject = newObject;\n          }\n        //endregion\n      }\n\n      break;\n    //endregion\n    //region All other tag classes\n\n    case 2: // APPLICATION\n\n    case 3: // CONTEXT-SPECIFIC\n\n    case 4: // PRIVATE\n\n    default:\n      {\n        if (returnObject.idBlock.isConstructed === true) newASN1Type = Constructed;else newASN1Type = Primitive;\n      }\n    //endregion\n  } //endregion\n  //region Change type and perform BER decoding\n\n\n  returnObject = localChangeType(returnObject, newASN1Type);\n  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm === true ? inputLength : returnObject.lenBlock.length); //endregion\n  //region Coping incoming buffer for entire ASN.1 block\n\n  returnObject.valueBeforeDecode = inputBuffer.slice(incomingOffset, incomingOffset + returnObject.blockLength); //endregion\n\n  return {\n    offset: resultOffset,\n    result: returnObject\n  };\n} //**************************************************************************************\n\n/**\n * Major function for decoding ASN.1 BER array into internal library structuries\n * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array of bytes\n */\n\n\nfunction _fromBER(inputBuffer) {\n  if (inputBuffer.byteLength === 0) {\n    var result = new BaseBlock({}, Object);\n    result.error = \"Input buffer has zero length\";\n    return {\n      offset: -1,\n      result: result\n    };\n  }\n\n  return LocalFromBER(inputBuffer, 0, inputBuffer.byteLength);\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major scheme verification function\n//**************************************************************************************\n\n/**\n * Compare of two ASN.1 object trees\n * @param {!Object} root Root of input ASN.1 object tree\n * @param {!Object} inputData Input ASN.1 object tree\n * @param {!Object} inputSchema Input ASN.1 schema to compare with\n * @return {{verified: boolean}|{verified:boolean, result: Object}}\n */\n\n\nexport { _fromBER as fromBER };\nexport function compareSchema(root, inputData, inputSchema) {\n  //region Special case for Choice schema element type\n  if (inputSchema instanceof Choice) {\n    var choiceResult = false;\n\n    for (var j = 0; j < inputSchema.value.length; j++) {\n      var result = compareSchema(root, inputData, inputSchema.value[j]);\n\n      if (result.verified === true) {\n        return {\n          verified: true,\n          result: root\n        };\n      }\n    }\n\n    if (choiceResult === false) {\n      var _result = {\n        verified: false,\n        result: {\n          error: \"Wrong values for Choice type\"\n        }\n      };\n      if (inputSchema.hasOwnProperty(\"name\")) _result.name = inputSchema.name;\n      return _result;\n    }\n  } //endregion\n  //region Special case for Any schema element type\n\n\n  if (inputSchema instanceof Any) {\n    //region Add named component of ASN.1 schema\n    if (inputSchema.hasOwnProperty(\"name\")) root[inputSchema.name] = inputData; //endregion\n\n    return {\n      verified: true,\n      result: root\n    };\n  } //endregion\n  //region Initial check\n\n\n  if (root instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong root object\"\n      }\n    };\n  }\n\n  if (inputData instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 data\"\n      }\n    };\n  }\n\n  if (inputSchema instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (\"idBlock\" in inputSchema === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  } //endregion\n  //region Comparing idBlock properties in ASN.1 data and ASN.1 schema\n  //region Encode and decode ASN.1 schema idBlock\n  /// <remarks>This encoding/decoding is neccessary because could be an errors in schema definition</remarks>\n\n\n  if (\"fromBER\" in inputSchema.idBlock === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (\"toBER\" in inputSchema.idBlock === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  var encodedId = inputSchema.idBlock.toBER(false);\n\n  if (encodedId.byteLength === 0) {\n    return {\n      verified: false,\n      result: {\n        error: \"Error encoding idBlock for ASN.1 schema\"\n      }\n    };\n  }\n\n  var decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);\n\n  if (decodedOffset === -1) {\n    return {\n      verified: false,\n      result: {\n        error: \"Error decoding idBlock for ASN.1 schema\"\n      }\n    };\n  } //endregion\n  //region tagClass\n\n\n  if (inputSchema.idBlock.hasOwnProperty(\"tagClass\") === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {\n    return {\n      verified: false,\n      result: root\n    };\n  } //endregion\n  //region tagNumber\n\n\n  if (inputSchema.idBlock.hasOwnProperty(\"tagNumber\") === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {\n    return {\n      verified: false,\n      result: root\n    };\n  } //endregion\n  //region isConstructed\n\n\n  if (inputSchema.idBlock.hasOwnProperty(\"isConstructed\") === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {\n    return {\n      verified: false,\n      result: root\n    };\n  } //endregion\n  //region isHexOnly\n\n\n  if (\"isHexOnly\" in inputSchema.idBlock === false) // Since 'isHexOnly' is an inhirited property\n    {\n      return {\n        verified: false,\n        result: {\n          error: \"Wrong ASN.1 schema\"\n        }\n      };\n    }\n\n  if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {\n    return {\n      verified: false,\n      result: root\n    };\n  } //endregion\n  //region valueHex\n\n\n  if (inputSchema.idBlock.isHexOnly === true) {\n    if (\"valueHex\" in inputSchema.idBlock === false) // Since 'valueHex' is an inhirited property\n      {\n        return {\n          verified: false,\n          result: {\n            error: \"Wrong ASN.1 schema\"\n          }\n        };\n      }\n\n    var schemaView = new Uint8Array(inputSchema.idBlock.valueHex);\n    var asn1View = new Uint8Array(inputData.idBlock.valueHex);\n\n    if (schemaView.length !== asn1View.length) {\n      return {\n        verified: false,\n        result: root\n      };\n    }\n\n    for (var i = 0; i < schemaView.length; i++) {\n      if (schemaView[i] !== asn1View[1]) {\n        return {\n          verified: false,\n          result: root\n        };\n      }\n    }\n  } //endregion\n  //endregion\n  //region Add named component of ASN.1 schema\n\n\n  if (inputSchema.hasOwnProperty(\"name\")) {\n    inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n    if (inputSchema.name !== \"\") root[inputSchema.name] = inputData;\n  } //endregion\n  //region Getting next ASN.1 block for comparition\n\n\n  if (inputSchema.idBlock.isConstructed === true) {\n    var admission = 0;\n    var _result2 = {\n      verified: false\n    };\n    var maxLength = inputSchema.valueBlock.value.length;\n\n    if (maxLength > 0) {\n      if (inputSchema.valueBlock.value[0] instanceof Repeated) maxLength = inputData.valueBlock.value.length;\n    } //region Special case when constructive value has no elements\n\n\n    if (maxLength === 0) {\n      return {\n        verified: true,\n        result: root\n      };\n    } //endregion\n    //region Special case when \"inputData\" has no values and \"inputSchema\" has all optional values\n\n\n    if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {\n      var _optional = true;\n\n      for (var _i10 = 0; _i10 < inputSchema.valueBlock.value.length; _i10++) {\n        _optional = _optional && (inputSchema.valueBlock.value[_i10].optional || false);\n      }\n\n      if (_optional === true) {\n        return {\n          verified: true,\n          result: root\n        };\n      } //region Delete early added name of block\n\n\n      if (inputSchema.hasOwnProperty(\"name\")) {\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n        if (inputSchema.name !== \"\") delete root[inputSchema.name];\n      } //endregion\n\n\n      root.error = \"Inconsistent object length\";\n      return {\n        verified: false,\n        result: root\n      };\n    } //endregion\n\n\n    for (var _i11 = 0; _i11 < maxLength; _i11++) {\n      //region Special case when there is an \"optional\" element of ASN.1 schema at the end\n      if (_i11 - admission >= inputData.valueBlock.value.length) {\n        if (inputSchema.valueBlock.value[_i11].optional === false) {\n          var _result3 = {\n            verified: false,\n            result: root\n          };\n          root.error = \"Inconsistent length between ASN.1 data and schema\"; //region Delete early added name of block\n\n          if (inputSchema.hasOwnProperty(\"name\")) {\n            inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\n            if (inputSchema.name !== \"\") {\n              delete root[inputSchema.name];\n              _result3.name = inputSchema.name;\n            }\n          } //endregion\n\n\n          return _result3;\n        }\n      } //endregion\n      else {\n        //region Special case for Repeated type of ASN.1 schema element\n        if (inputSchema.valueBlock.value[0] instanceof Repeated) {\n          _result2 = compareSchema(root, inputData.valueBlock.value[_i11], inputSchema.valueBlock.value[0].value);\n\n          if (_result2.verified === false) {\n            if (inputSchema.valueBlock.value[0].optional === true) admission++;else {\n              //region Delete early added name of block\n              if (inputSchema.hasOwnProperty(\"name\")) {\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n                if (inputSchema.name !== \"\") delete root[inputSchema.name];\n              } //endregion\n\n\n              return _result2;\n            }\n          }\n\n          if (\"name\" in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {\n            var arrayRoot = {};\n            if (\"local\" in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local === true) arrayRoot = inputData;else arrayRoot = root;\n            if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === \"undefined\") arrayRoot[inputSchema.valueBlock.value[0].name] = [];\n            arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[_i11]);\n          }\n        } //endregion\n        else {\n          _result2 = compareSchema(root, inputData.valueBlock.value[_i11 - admission], inputSchema.valueBlock.value[_i11]);\n\n          if (_result2.verified === false) {\n            if (inputSchema.valueBlock.value[_i11].optional === true) admission++;else {\n              //region Delete early added name of block\n              if (inputSchema.hasOwnProperty(\"name\")) {\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n                if (inputSchema.name !== \"\") delete root[inputSchema.name];\n              } //endregion\n\n\n              return _result2;\n            }\n          }\n        }\n      }\n    }\n\n    if (_result2.verified === false) // The situation may take place if last element is \"optional\" and verification failed\n      {\n        var _result4 = {\n          verified: false,\n          result: root\n        }; //region Delete early added name of block\n\n        if (inputSchema.hasOwnProperty(\"name\")) {\n          inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\n          if (inputSchema.name !== \"\") {\n            delete root[inputSchema.name];\n            _result4.name = inputSchema.name;\n          }\n        } //endregion\n\n\n        return _result4;\n      }\n\n    return {\n      verified: true,\n      result: root\n    };\n  } //endregion\n  //region Ability to parse internal value for primitive-encoded value (value of OctetString, for example)\n\n\n  if (\"primitiveSchema\" in inputSchema && \"valueHex\" in inputData.valueBlock) {\n    //region Decoding of raw ASN.1 data\n    var asn1 = _fromBER(inputData.valueBlock.valueHex);\n\n    if (asn1.offset === -1) {\n      var _result5 = {\n        verified: false,\n        result: asn1.result\n      }; //region Delete early added name of block\n\n      if (inputSchema.hasOwnProperty(\"name\")) {\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\n        if (inputSchema.name !== \"\") {\n          delete root[inputSchema.name];\n          _result5.name = inputSchema.name;\n        }\n      } //endregion\n\n\n      return _result5;\n    } //endregion\n\n\n    return compareSchema(root, asn1.result, inputSchema.primitiveSchema);\n  }\n\n  return {\n    verified: true,\n    result: root\n  }; //endregion\n} //**************************************************************************************\n//noinspection JSUnusedGlobalSymbols\n\n/**\n * ASN.1 schema verification for ArrayBuffer data\n * @param {!ArrayBuffer} inputBuffer Input BER-encoded ASN.1 data\n * @param {!Object} inputSchema Input ASN.1 schema to verify against to\n * @return {{verified: boolean}|{verified:boolean, result: Object}}\n */\n\nexport function verifySchema(inputBuffer, inputSchema) {\n  //region Initial check\n  if (inputSchema instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema type\"\n      }\n    };\n  } //endregion\n  //region Decoding of raw ASN.1 data\n\n\n  var asn1 = _fromBER(inputBuffer);\n\n  if (asn1.offset === -1) {\n    return {\n      verified: false,\n      result: asn1.result\n    };\n  } //endregion\n  //region Compare ASN.1 struct with input schema\n\n\n  return compareSchema(asn1.result, asn1.result, inputSchema); //endregion\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major function converting JSON to ASN.1 objects\n//**************************************************************************************\n//noinspection JSUnusedGlobalSymbols\n\n/**\n * Converting from JSON to ASN.1 objects\n * @param {string|Object} json JSON string or object to convert to ASN.1 objects\n */\n\nexport function fromJSON(json) {// TODO Implement\n} //**************************************************************************************\n//endregion\n//**************************************************************************************","map":{"version":3,"sources":["C:/Users/rkanthet/Documents/test_window_object/node_modules/asn1js/src/asn1.js"],"names":["getParametersValue","padNumber","isEqualBuffer","bufferToHexCodes","checkBufferParams","utilToBase","utilFromBase","utilEncodeTC","utilDecodeTC","utilConcatBuf","utilConcatView","assertBigInt","BigInt","Error","powers2","Uint8Array","digitsString","LocalBaseBlock","parameters","blockLength","error","warnings","valueBeforeDecode","slice","ArrayBuffer","blockName","constructor","byteLength","HexBlock","BaseClass","isHexOnly","valueHex","inputBuffer","inputOffset","inputLength","intBuffer","length","push","sizeOnly","object","ex","LocalIdentificationBlock","idBlock","tagClass","tagNumber","isConstructed","firstOctet","retBuf","retView","number","encodedBuf","encodedView","size","i","curView","tagClassMask","tagNumberMask","count","tagNumberBufferMaxLength","intTagNumberBuffer","tempBuffer","tempBufferView","set","LocalLengthBlock","isIndefiniteForm","lenBlock","longFormUsed","lengthBufferView","ValueBlock","TypeError","BaseBlock","valueBlockType","name","optional","primitiveSchema","valueBlock","resultOffset","fromBER","idBlockBuf","toBER","valueBlockSizeBuf","lenBlockBuf","valueBlockBuf","indefBuf","indefView","toJSON","LocalPrimitiveValueBlock","valueHexView","Primitive","LocalConstructedValueBlock","value","initialOffset","initialLength","checkLen","indefiniteLength","currentOffset","returnObject","LocalFromBER","offset","result","concat","EndOfContent","pop","valueBuf","Constructed","values","toString","split","map","o","join","LocalEndOfContentValueBlock","paramaters","LocalBooleanValueBlock","view","call","Boolean","Sequence","Set","Null","LocalOctetStringValueBlock","prototype","currentBlockName","OctetString","buf","asn","e","octetString","JSON","stringify","LocalBitStringValueBlock","unusedBits","BitString","bitString","bits","byte","padStart","LocalIntegerValueBlock","valueDec","_valueHex","_value","_valueDec","expectedLength","updatedValueHex","updatedView","viewAdd","first","second","c","firstView","secondView","firstViewCopy","firstViewCopyLength","secondViewCopy","secondViewCopyLength","max","counter","power2","n","p","digits","newValue","viewSub","b","firstBit","bitNumber","currentByte","asn1View","flag","byteNumber","charAt","Integer","otherValue","integer","toDER","fromDER","hex","bigInt","Enumerated","LocalSidValueBlock","isFirstSid","tempValueHex","tempView","bytes","parseInt","buffer","sidValue","LocalObjectIdentifierValueBlock","fromString","sidBlock","string","pos1","pos2","sid","indexOf","substr","plus","parsedSID","isNaN","Number","MAX_SAFE_INTEGER","valueBigInt","sidStr","sidArray","ObjectIdentifier","LocalUtf8StringValueBlock","Utf8String","fromBuffer","String","fromCharCode","apply","decodeURIComponent","escape","inputString","str","unescape","encodeURIComponent","strLen","charCodeAt","LocalRelativeSidValueBlock","LocalRelativeObjectIdentifierValueBlock","RelativeObjectIdentifier","LocalBmpStringValueBlock","BmpString","copyBuffer","valueView","temp","Uint16Array","strLength","codeBuf","codeView","dif","j","LocalUniversalStringValueBlock","UniversalString","Uint32Array","LocalSimpleStringValueBlock","LocalSimpleStringBlock","NumericString","PrintableString","TeletexString","VideotexString","IA5String","GraphicString","VisibleString","GeneralString","CharacterString","UTCTime","year","month","day","hour","minute","fromDate","valueDate","toBuffer","inputDate","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","Date","UTC","parser","parserArray","exec","outputArray","Array","GeneralizedTime","millisecond","getUTCMilliseconds","isUTC","timeString","dateTimeString","fractionPart","hourDifference","minuteDifference","valueOf","multiplier","differencePosition","differenceString","fractionPointPosition","fractionPartCheck","fractionResult","Math","floor","tempDate","getUTCDay","DATE","TimeOfDay","DateTime","Duration","TIME","Choice","Any","Repeated","local","RawData","data","incomingOffset","localChangeType","inputObject","newType","newObject","Object","baseBlock","newASN1Type","compareSchema","root","inputData","inputSchema","choiceResult","verified","_result","hasOwnProperty","encodedId","decodedOffset","schemaView","replace","admission","maxLength","_optional","arrayRoot","asn1","verifySchema","fromJSON","json"],"mappings":"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","sourcesContent":["/* eslint-disable indent */\n/*\n * Copyright (c) 2016-2018, Peculiar Ventures\n * All rights reserved.\n *\n * Author 2016-2018, Yury Strozhevsky <www.strozhevsky.com>.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its contributors\n *    may be used to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\n * OF SUCH DAMAGE.\n *\n */\n//**************************************************************************************\nimport { getParametersValue, padNumber, isEqualBuffer, bufferToHexCodes, checkBufferParams, utilToBase, utilFromBase, utilEncodeTC, utilDecodeTC, utilConcatBuf, utilConcatView } from \"pvutils\";\n//**************************************************************************************\n//region Other utility functions\n//**************************************************************************************\nfunction assertBigInt() {\n  if (typeof BigInt === \"undefined\") {\n    throw new Error(\"BigInt is not defined. Your environment doesn't implement BigInt.\")\n  }\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of global variables\n//**************************************************************************************\nconst powers2 = [new Uint8Array([1])];\nconst digitsString = \"0123456789\";\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration for \"LocalBaseBlock\" class\n//**************************************************************************************\n/**\n * Class used as a base block for all remaining ASN.1 classes\n * @typedef LocalBaseBlock\n * @interface\n * @property {number} blockLength\n * @property {string} error\n * @property {Array.<string>} warnings\n * @property {ArrayBuffer} valueBeforeDecode\n */\nclass LocalBaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalBaseBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueBeforeDecode]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\t/**\n\t\t * @type {number} blockLength\n\t\t */\n\t\tthis.blockLength = getParametersValue(parameters, \"blockLength\", 0);\n\t\t/**\n\t\t * @type {string} error\n\t\t */\n\t\tthis.error = getParametersValue(parameters, \"error\", \"\");\n\t\t/**\n\t\t * @type {Array.<string>} warnings\n\t\t */\n\t\tthis.warnings = getParametersValue(parameters, \"warnings\", []);\n\t\t//noinspection JSCheckFunctionSignatures\n\t\t/**\n\t\t * @type {ArrayBuffer} valueBeforeDecode\n\t\t */\n\t\tif(\"valueBeforeDecode\" in parameters)\n\t\t\tthis.valueBeforeDecode = parameters.valueBeforeDecode.slice(0);\n\t\telse\n\t\t\tthis.valueBeforeDecode = new ArrayBuffer(0);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"baseBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n\t */\n\ttoJSON()\n\t{\n\t\treturn {\n\t\t\tblockName: this.constructor.blockName(),\n\t\t\tblockLength: this.blockLength,\n\t\t\terror: this.error,\n\t\t\twarnings: this.warnings,\n\t\t\tvalueBeforeDecode: bufferToHexCodes(this.valueBeforeDecode, 0, this.valueBeforeDecode.byteLength)\n\t\t};\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Description for \"HexBlock\" class\n//**************************************************************************************\n/**\n * Class used as a base block for all remaining ASN.1 classes\n * @extends LocalBaseBlock\n * @typedef HexBlock\n * @property {number} blockLength\n * @property {string} error\n * @property {Array.<string>} warnings\n * @property {ArrayBuffer} valueBeforeDecode\n * @property {boolean} isHexOnly\n * @property {ArrayBuffer} valueHex\n */\n//noinspection JSUnusedLocalSymbols\nexport const HexBlock = BaseClass => class LocalHexBlockMixin extends BaseClass\n{\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Constructor for \"HexBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueHex]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\t/**\n\t\t * @type {boolean}\n\t\t */\n\t\tthis.isHexOnly = getParametersValue(parameters, \"isHexOnly\", false);\n\t\t/**\n\t\t * @type {ArrayBuffer}\n\t\t */\n\t\tif(\"valueHex\" in parameters)\n\t\t\tthis.valueHex = parameters.valueHex.slice(0);\n\t\telse\n\t\t\tthis.valueHex = new ArrayBuffer(0);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"hexBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\n\t\t\treturn (-1);\n\t\t//endregion\n\n\t\t//region Getting Uint8Array from ArrayBuffer\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t//endregion\n\n\t\t//region Initial checks\n\t\tif(intBuffer.length === 0)\n\t\t{\n\t\t\tthis.warnings.push(\"Zero buffer length\");\n\t\t\treturn inputOffset;\n\t\t}\n\t\t//endregion\n\n\t\t//region Copy input buffer to internal buffer\n\t\tthis.valueHex = inputBuffer.slice(inputOffset, inputOffset + inputLength);\n\t\t//endregion\n\n\t\tthis.blockLength = inputLength;\n\n\t\treturn (inputOffset + inputLength);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\tif(this.isHexOnly !== true)\n\t\t{\n\t\t\tthis.error = \"Flag \\\"isHexOnly\\\" is not set, abort\";\n\t\t\treturn new ArrayBuffer(0);\n\t\t}\n\n\t\tif(sizeOnly === true)\n\t\t\treturn new ArrayBuffer(this.valueHex.byteLength);\n\n\t\t//noinspection JSCheckFunctionSignatures\n\t\treturn this.valueHex.slice(0);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.blockName = this.constructor.blockName();\n\t\tobject.isHexOnly = this.isHexOnly;\n\t\tobject.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n};\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of identification block class\n//**************************************************************************************\nclass LocalIdentificationBlock extends HexBlock(LocalBaseBlock)\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalBaseBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {Object} [idBlock]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper();\n\n\t\tif(\"idBlock\" in parameters)\n\t\t{\n\t\t\t//region Properties from hexBlock class\n\t\t\tthis.isHexOnly = getParametersValue(parameters.idBlock, \"isHexOnly\", false);\n\t\t\tthis.valueHex = getParametersValue(parameters.idBlock, \"valueHex\", new ArrayBuffer(0));\n\t\t\t//endregion\n\n\t\t\tthis.tagClass = getParametersValue(parameters.idBlock, \"tagClass\", (-1));\n\t\t\tthis.tagNumber = getParametersValue(parameters.idBlock, \"tagNumber\", (-1));\n\t\t\tthis.isConstructed = getParametersValue(parameters.idBlock, \"isConstructed\", false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.tagClass = (-1);\n\t\t\tthis.tagNumber = (-1);\n\t\t\tthis.isConstructed = false;\n\t\t}\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"identificationBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\t//region Initial variables\n\t\tlet firstOctet = 0;\n\t\tlet retBuf;\n\t\tlet retView;\n\t\t//endregion\n\n\t\tswitch(this.tagClass)\n\t\t{\n\t\t\tcase 1:\n\t\t\t\tfirstOctet |= 0x00; // UNIVERSAL\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tfirstOctet |= 0x40; // APPLICATION\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfirstOctet |= 0x80; // CONTEXT-SPECIFIC\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tfirstOctet |= 0xC0; // PRIVATE\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.error = \"Unknown tag class\";\n\t\t\t\treturn (new ArrayBuffer(0));\n\t\t}\n\n\t\tif(this.isConstructed)\n\t\t\tfirstOctet |= 0x20;\n\n\t\tif((this.tagNumber < 31) && (!this.isHexOnly))\n\t\t{\n\t\t\tretBuf = new ArrayBuffer(1);\n\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\tif(!sizeOnly)\n\t\t\t{\n\t\t\t\tlet number = this.tagNumber;\n\t\t\t\tnumber &= 0x1F;\n\t\t\t\tfirstOctet |= number;\n\n\t\t\t\tretView[0] = firstOctet;\n\t\t\t}\n\n\t\t\treturn retBuf;\n\t\t}\n\n\t\tif(this.isHexOnly === false)\n\t\t{\n\t\t\tconst encodedBuf = utilToBase(this.tagNumber, 7);\n\t\t\tconst encodedView = new Uint8Array(encodedBuf);\n\t\t\tconst size = encodedBuf.byteLength;\n\n\t\t\tretBuf = new ArrayBuffer(size + 1);\n\t\t\tretView = new Uint8Array(retBuf);\n\t\t\tretView[0] = (firstOctet | 0x1F);\n\n\t\t\tif(!sizeOnly)\n\t\t\t{\n\t\t\t\tfor(let i = 0; i < (size - 1); i++)\n\t\t\t\t\tretView[i + 1] = encodedView[i] | 0x80;\n\n\t\t\t\tretView[size] = encodedView[size - 1];\n\t\t\t}\n\n\t\t\treturn retBuf;\n\t\t}\n\n\t\tretBuf = new ArrayBuffer(this.valueHex.byteLength + 1);\n\t\tretView = new Uint8Array(retBuf);\n\n\t\tretView[0] = (firstOctet | 0x1F);\n\n\t\tif(sizeOnly === false)\n\t\t{\n\t\t\tconst curView = new Uint8Array(this.valueHex);\n\n\t\t\tfor(let i = 0; i < (curView.length - 1); i++)\n\t\t\t\tretView[i + 1] = curView[i] | 0x80;\n\n\t\t\tretView[this.valueHex.byteLength] = curView[curView.length - 1];\n\t\t}\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number}\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\n\t\t\treturn (-1);\n\t\t//endregion\n\n\t\t//region Getting Uint8Array from ArrayBuffer\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t//endregion\n\n\t\t//region Initial checks\n\t\tif(intBuffer.length === 0)\n\t\t{\n\t\t\tthis.error = \"Zero buffer length\";\n\t\t\treturn (-1);\n\t\t}\n\t\t//endregion\n\n\t\t//region Find tag class\n\t\tconst tagClassMask = intBuffer[0] & 0xC0;\n\n\t\tswitch(tagClassMask)\n\t\t{\n\t\t\tcase 0x00:\n\t\t\t\tthis.tagClass = (1); // UNIVERSAL\n\t\t\t\tbreak;\n\t\t\tcase 0x40:\n\t\t\t\tthis.tagClass = (2); // APPLICATION\n\t\t\t\tbreak;\n\t\t\tcase 0x80:\n\t\t\t\tthis.tagClass = (3); // CONTEXT-SPECIFIC\n\t\t\t\tbreak;\n\t\t\tcase 0xC0:\n\t\t\t\tthis.tagClass = (4); // PRIVATE\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.error = \"Unknown tag class\";\n\t\t\t\treturn (-1);\n\t\t}\n\t\t//endregion\n\n\t\t//region Find it's constructed or not\n\t\tthis.isConstructed = (intBuffer[0] & 0x20) === 0x20;\n\t\t//endregion\n\n\t\t//region Find tag number\n\t\tthis.isHexOnly = false;\n\n\t\tconst tagNumberMask = intBuffer[0] & 0x1F;\n\n\t\t//region Simple case (tag number < 31)\n\t\tif(tagNumberMask !== 0x1F)\n\t\t{\n\t\t\tthis.tagNumber = (tagNumberMask);\n\t\t\tthis.blockLength = 1;\n\t\t}\n\t\t//endregion\n\t\t//region Tag number bigger or equal to 31\n\t\telse\n\t\t{\n\t\t\tlet count = 1;\n\n\t\t\tthis.valueHex = new ArrayBuffer(255);\n\t\t\tlet tagNumberBufferMaxLength = 255;\n\t\t\tlet intTagNumberBuffer = new Uint8Array(this.valueHex);\n\n\t\t\t//noinspection JSBitwiseOperatorUsage\n\t\t\twhile(intBuffer[count] & 0x80)\n\t\t\t{\n\t\t\t\tintTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\n\t\t\t\tcount++;\n\n\t\t\t\tif(count >= intBuffer.length)\n\t\t\t\t{\n\t\t\t\t\tthis.error = \"End of input reached before message was fully decoded\";\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\n\t\t\t\t//region In case if tag number length is greater than 255 bytes (rare but possible case)\n\t\t\t\tif(count === tagNumberBufferMaxLength)\n\t\t\t\t{\n\t\t\t\t\ttagNumberBufferMaxLength += 255;\n\n\t\t\t\t\tconst tempBuffer = new ArrayBuffer(tagNumberBufferMaxLength);\n\t\t\t\t\tconst tempBufferView = new Uint8Array(tempBuffer);\n\n\t\t\t\t\tfor(let i = 0; i < intTagNumberBuffer.length; i++)\n\t\t\t\t\t\ttempBufferView[i] = intTagNumberBuffer[i];\n\n\t\t\t\t\tthis.valueHex = new ArrayBuffer(tagNumberBufferMaxLength);\n\t\t\t\t\tintTagNumberBuffer = new Uint8Array(this.valueHex);\n\t\t\t\t}\n\t\t\t\t//endregion\n\t\t\t}\n\n\t\t\tthis.blockLength = (count + 1);\n\t\t\tintTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F; // Write last byte to buffer\n\n\t\t\t//region Cut buffer\n\t\t\tconst tempBuffer = new ArrayBuffer(count);\n\t\t\tconst tempBufferView = new Uint8Array(tempBuffer);\n\n\t\t\tfor(let i = 0; i < count; i++)\n\t\t\t\ttempBufferView[i] = intTagNumberBuffer[i];\n\n\t\t\tthis.valueHex = new ArrayBuffer(count);\n\t\t\tintTagNumberBuffer = new Uint8Array(this.valueHex);\n\t\t\tintTagNumberBuffer.set(tempBufferView);\n\t\t\t//endregion\n\n\t\t\t//region Try to convert long tag number to short form\n\t\t\tif(this.blockLength <= 9)\n\t\t\t\tthis.tagNumber = utilFromBase(intTagNumberBuffer, 7);\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.isHexOnly = true;\n\t\t\t\tthis.warnings.push(\"Tag too long, represented as hex-coded\");\n\t\t\t}\n\t\t\t//endregion\n\t\t}\n\t\t//endregion\n\t\t//endregion\n\n\t\t//region Check if constructed encoding was using for primitive type\n\t\tif(((this.tagClass === 1)) &&\n\t\t\t(this.isConstructed))\n\t\t{\n\t\t\tswitch(this.tagNumber)\n\t\t\t{\n\t\t\t\tcase 1:  // Boolean\n\t\t\t\tcase 2:  // REAL\n\t\t\t\tcase 5:  // Null\n\t\t\t\tcase 6:  // OBJECT IDENTIFIER\n\t\t\t\tcase 9:  // REAL\n\t\t\t\tcase 13: // RELATIVE OBJECT IDENTIFIER\n\t\t\t\tcase 14: // Time\n\t\t\t\tcase 23:\n\t\t\t\tcase 24:\n\t\t\t\tcase 31:\n\t\t\t\tcase 32:\n\t\t\t\tcase 33:\n\t\t\t\tcase 34:\n\t\t\t\t\tthis.error = \"Constructed encoding used for primitive type\";\n\t\t\t\t\treturn (-1);\n\t\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t\t//endregion\n\n\t\treturn (inputOffset + this.blockLength); // Return current offset in input buffer\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {{blockName: string,\n\t *  tagClass: number,\n\t *  tagNumber: number,\n\t *  isConstructed: boolean,\n\t *  isHexOnly: boolean,\n\t *  valueHex: ArrayBuffer,\n\t *  blockLength: number,\n\t *  error: string, warnings: Array.<string>,\n\t *  valueBeforeDecode: string}}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.blockName = this.constructor.blockName();\n\t\tobject.tagClass = this.tagClass;\n\t\tobject.tagNumber = this.tagNumber;\n\t\tobject.isConstructed = this.isConstructed;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of length block class\n//**************************************************************************************\nclass LocalLengthBlock extends LocalBaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalLengthBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {Object} [lenBlock]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper();\n\n\t\tif(\"lenBlock\" in parameters)\n\t\t{\n\t\t\tthis.isIndefiniteForm = getParametersValue(parameters.lenBlock, \"isIndefiniteForm\", false);\n\t\t\tthis.longFormUsed = getParametersValue(parameters.lenBlock, \"longFormUsed\", false);\n\t\t\tthis.length = getParametersValue(parameters.lenBlock, \"length\", 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.isIndefiniteForm = false;\n\t\t\tthis.longFormUsed = false;\n\t\t\tthis.length = 0;\n\t\t}\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"lengthBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number}\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\n\t\t\treturn (-1);\n\t\t//endregion\n\n\t\t//region Getting Uint8Array from ArrayBuffer\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t//endregion\n\n\t\t//region Initial checks\n\t\tif(intBuffer.length === 0)\n\t\t{\n\t\t\tthis.error = \"Zero buffer length\";\n\t\t\treturn (-1);\n\t\t}\n\n\t\tif(intBuffer[0] === 0xFF)\n\t\t{\n\t\t\tthis.error = \"Length block 0xFF is reserved by standard\";\n\t\t\treturn (-1);\n\t\t}\n\t\t//endregion\n\n\t\t//region Check for length form type\n\t\tthis.isIndefiniteForm = intBuffer[0] === 0x80;\n\t\t//endregion\n\n\t\t//region Stop working in case of indefinite length form\n\t\tif(this.isIndefiniteForm === true)\n\t\t{\n\t\t\tthis.blockLength = 1;\n\t\t\treturn (inputOffset + this.blockLength);\n\t\t}\n\t\t//endregion\n\n\t\t//region Check is long form of length encoding using\n\t\tthis.longFormUsed = !!(intBuffer[0] & 0x80);\n\t\t//endregion\n\n\t\t//region Stop working in case of short form of length value\n\t\tif(this.longFormUsed === false)\n\t\t{\n\t\t\tthis.length = (intBuffer[0]);\n\t\t\tthis.blockLength = 1;\n\t\t\treturn (inputOffset + this.blockLength);\n\t\t}\n\t\t//endregion\n\n\t\t//region Calculate length value in case of long form\n\t\tconst count = intBuffer[0] & 0x7F;\n\n\t\tif(count > 8) // Too big length value\n\t\t{\n\t\t\tthis.error = \"Too big integer\";\n\t\t\treturn (-1);\n\t\t}\n\n\t\tif((count + 1) > intBuffer.length)\n\t\t{\n\t\t\tthis.error = \"End of input reached before message was fully decoded\";\n\t\t\treturn (-1);\n\t\t}\n\n\t\tconst lengthBufferView = new Uint8Array(count);\n\n\t\tfor(let i = 0; i < count; i++)\n\t\t\tlengthBufferView[i] = intBuffer[i + 1];\n\n\t\tif(lengthBufferView[count - 1] === 0x00)\n\t\t\tthis.warnings.push(\"Needlessly long encoded length\");\n\n\t\tthis.length = utilFromBase(lengthBufferView, 8);\n\n\t\tif(this.longFormUsed && (this.length <= 127))\n\t\t\tthis.warnings.push(\"Unnecessary usage of long length form\");\n\n\t\tthis.blockLength = count + 1;\n\t\t//endregion\n\n\t\treturn (inputOffset + this.blockLength); // Return current offset in input buffer\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\t//region Initial variables\n\t\tlet retBuf;\n\t\tlet retView;\n\t\t//endregion\n\n\t\tif(this.length > 127)\n\t\t\tthis.longFormUsed = true;\n\n\t\tif(this.isIndefiniteForm)\n\t\t{\n\t\t\tretBuf = new ArrayBuffer(1);\n\n\t\t\tif(sizeOnly === false)\n\t\t\t{\n\t\t\t\tretView = new Uint8Array(retBuf);\n\t\t\t\tretView[0] = 0x80;\n\t\t\t}\n\n\t\t\treturn retBuf;\n\t\t}\n\n\t\tif(this.longFormUsed === true)\n\t\t{\n\t\t\tconst encodedBuf = utilToBase(this.length, 8);\n\n\t\t\tif(encodedBuf.byteLength > 127)\n\t\t\t{\n\t\t\t\tthis.error = \"Too big length\";\n\t\t\t\treturn (new ArrayBuffer(0));\n\t\t\t}\n\n\t\t\tretBuf = new ArrayBuffer(encodedBuf.byteLength + 1);\n\n\t\t\tif(sizeOnly === true)\n\t\t\t\treturn retBuf;\n\n\t\t\tconst encodedView = new Uint8Array(encodedBuf);\n\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\tretView[0] = encodedBuf.byteLength | 0x80;\n\n\t\t\tfor(let i = 0; i < encodedBuf.byteLength; i++)\n\t\t\t\tretView[i + 1] = encodedView[i];\n\n\t\t\treturn retBuf;\n\t\t}\n\n\t\tretBuf = new ArrayBuffer(1);\n\n\t\tif(sizeOnly === false)\n\t\t{\n\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\tretView[0] = this.length;\n\t\t}\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.blockName = this.constructor.blockName();\n\t\tobject.isIndefiniteForm = this.isIndefiniteForm;\n\t\tobject.longFormUsed = this.longFormUsed;\n\t\tobject.length = this.length;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of value block class\n//**************************************************************************************\nexport class ValueBlock extends LocalBaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"ValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"valueBlock\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols,JSUnusedLocalSymbols\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number}\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\t//region Throw an exception for a function which needs to be specified in extended classes\n\t\tthrow TypeError(\"User need to make a specific function in a class which extends \\\"ValueBlock\\\"\");\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedLocalSymbols\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\t//region Throw an exception for a function which needs to be specified in extended classes\n\t\tthrow TypeError(\"User need to make a specific function in a class which extends \\\"ValueBlock\\\"\");\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic ASN.1 block class\n//**************************************************************************************\nexport class BaseBlock extends LocalBaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"BaseBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {Object} [primitiveSchema]\n\t * @property {string} [name]\n\t * @property {boolean} [optional]\n\t * @param valueBlockType Type of value block\n\t */\n\tconstructor(parameters = {}, valueBlockType = ValueBlock)\n\t{\n\t\tsuper(parameters);\n\n\t\tif(\"name\" in parameters)\n\t\t\tthis.name = parameters.name;\n\t\tif(\"optional\" in parameters)\n\t\t\tthis.optional = parameters.optional;\n\t\tif(\"primitiveSchema\" in parameters)\n\t\t\tthis.primitiveSchema = parameters.primitiveSchema;\n\n\t\tthis.idBlock = new LocalIdentificationBlock(parameters);\n\t\tthis.lenBlock = new LocalLengthBlock(parameters);\n\t\tthis.valueBlock = new valueBlockType(parameters);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"BaseBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number}\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\n\t\tif(resultOffset === (-1))\n\t\t{\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tif(this.idBlock.error.length === 0)\n\t\t\tthis.blockLength += this.idBlock.blockLength;\n\n\t\tif(this.lenBlock.error.length === 0)\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\n\n\t\tif(this.valueBlock.error.length === 0)\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\tlet retBuf;\n\n\t\tconst idBlockBuf = this.idBlock.toBER(sizeOnly);\n\t\tconst valueBlockSizeBuf = this.valueBlock.toBER(true);\n\n\t\tthis.lenBlock.length = valueBlockSizeBuf.byteLength;\n\t\tconst lenBlockBuf = this.lenBlock.toBER(sizeOnly);\n\n\t\tretBuf = utilConcatBuf(idBlockBuf, lenBlockBuf);\n\n\t\tlet valueBlockBuf;\n\n\t\tif(sizeOnly === false)\n\t\t\tvalueBlockBuf = this.valueBlock.toBER(sizeOnly);\n\t\telse\n\t\t\tvalueBlockBuf = new ArrayBuffer(this.lenBlock.length);\n\n\t\tretBuf = utilConcatBuf(retBuf, valueBlockBuf);\n\n\t\tif(this.lenBlock.isIndefiniteForm === true)\n\t\t{\n\t\t\tconst indefBuf = new ArrayBuffer(2);\n\n\t\t\tif(sizeOnly === false)\n\t\t\t{\n\t\t\t\tconst indefView = new Uint8Array(indefBuf);\n\n\t\t\t\tindefView[0] = 0x00;\n\t\t\t\tindefView[1] = 0x00;\n\t\t\t}\n\n\t\t\tretBuf = utilConcatBuf(retBuf, indefBuf);\n\t\t}\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.idBlock = this.idBlock.toJSON();\n\t\tobject.lenBlock = this.lenBlock.toJSON();\n\t\tobject.valueBlock = this.valueBlock.toJSON();\n\n\t\tif(\"name\" in this)\n\t\t\tobject.name = this.name;\n\t\tif(\"optional\" in this)\n\t\t\tobject.optional = this.optional;\n\t\tif(\"primitiveSchema\" in this)\n\t\t\tobject.primitiveSchema = this.primitiveSchema.toJSON();\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\treturn `${this.constructor.blockName()} : ${bufferToHexCodes(this.valueBlock.valueHex)}`;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic block for all PRIMITIVE types\n//**************************************************************************************\nclass LocalPrimitiveValueBlock extends ValueBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalPrimitiveValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueBeforeDecode]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\t//region Variables from \"hexBlock\" class\n\t\tif(\"valueHex\" in parameters)\n\t\t\tthis.valueHex = parameters.valueHex.slice(0);\n\t\telse\n\t\t\tthis.valueHex = new ArrayBuffer(0);\n\n\t\tthis.isHexOnly = getParametersValue(parameters, \"isHexOnly\", true);\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number}\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\n\t\t\treturn (-1);\n\t\t//endregion\n\n\t\t//region Getting Uint8Array from ArrayBuffer\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t//endregion\n\n\t\t//region Initial checks\n\t\tif(intBuffer.length === 0)\n\t\t{\n\t\t\tthis.warnings.push(\"Zero buffer length\");\n\t\t\treturn inputOffset;\n\t\t}\n\t\t//endregion\n\n\t\t//region Copy input buffer into internal buffer\n\t\tthis.valueHex = new ArrayBuffer(intBuffer.length);\n\t\tconst valueHexView = new Uint8Array(this.valueHex);\n\n\t\tfor(let i = 0; i < intBuffer.length; i++)\n\t\t\tvalueHexView[i] = intBuffer[i];\n\t\t//endregion\n\n\t\tthis.blockLength = inputLength;\n\n\t\treturn (inputOffset + inputLength);\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedLocalSymbols\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\treturn this.valueHex.slice(0);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"PrimitiveValueBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n\t\tobject.isHexOnly = this.isHexOnly;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nexport class Primitive extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Primitive\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueHex]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalPrimitiveValueBlock);\n\n\t\tthis.idBlock.isConstructed = false;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"PRIMITIVE\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic block for all CONSTRUCTED types\n//**************************************************************************************\nclass LocalConstructedValueBlock extends ValueBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalConstructedValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.value = getParametersValue(parameters, \"value\", []);\n\t\tthis.isIndefiniteForm = getParametersValue(parameters, \"isIndefiniteForm\", false);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number}\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\t//region Store initial offset and length\n\t\tconst initialOffset = inputOffset;\n\t\tconst initialLength = inputLength;\n\t\t//endregion\n\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\n\t\t\treturn (-1);\n\t\t//endregion\n\n\t\t//region Getting Uint8Array from ArrayBuffer\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t//endregion\n\n\t\t//region Initial checks\n\t\tif(intBuffer.length === 0)\n\t\t{\n\t\t\tthis.warnings.push(\"Zero buffer length\");\n\t\t\treturn inputOffset;\n\t\t}\n\t\t//endregion\n\n\t\t//region Aux function\n\t\tfunction checkLen(indefiniteLength, length)\n\t\t{\n\t\t\tif(indefiniteLength === true)\n\t\t\t\treturn 1;\n\n\t\t\treturn length;\n\t\t}\n\t\t//endregion\n\n\t\tlet currentOffset = inputOffset;\n\n\t\twhile(checkLen(this.isIndefiniteForm, inputLength) > 0)\n\t\t{\n\t\t\tconst returnObject = LocalFromBER(inputBuffer, currentOffset, inputLength);\n\t\t\tif(returnObject.offset === (-1))\n\t\t\t{\n\t\t\t\tthis.error = returnObject.result.error;\n\t\t\t\tthis.warnings.concat(returnObject.result.warnings);\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\tcurrentOffset = returnObject.offset;\n\n\t\t\tthis.blockLength += returnObject.result.blockLength;\n\t\t\tinputLength -= returnObject.result.blockLength;\n\n\t\t\tthis.value.push(returnObject.result);\n\n\t\t\tif((this.isIndefiniteForm === true) && (returnObject.result.constructor.blockName() === EndOfContent.blockName()))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif(this.isIndefiniteForm === true)\n\t\t{\n\t\t\tif(this.value[this.value.length - 1].constructor.blockName() === EndOfContent.blockName())\n\t\t\t\tthis.value.pop();\n\t\t\telse\n\t\t\t\tthis.warnings.push(\"No EndOfContent block encoded\");\n\t\t}\n\n\t\t//region Copy \"inputBuffer\" to \"valueBeforeDecode\"\n\t\tthis.valueBeforeDecode = inputBuffer.slice(initialOffset, initialOffset + initialLength);\n\t\t//endregion\n\n\t\treturn currentOffset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\tlet retBuf = new ArrayBuffer(0);\n\n\t\tfor(let i = 0; i < this.value.length; i++)\n\t\t{\n\t\t\tconst valueBuf = this.value[i].toBER(sizeOnly);\n\t\t\tretBuf = utilConcatBuf(retBuf, valueBuf);\n\t\t}\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"ConstructedValueBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.isIndefiniteForm = this.isIndefiniteForm;\n\t\tobject.value = [];\n\t\tfor(let i = 0; i < this.value.length; i++)\n\t\t\tobject.value.push(this.value[i].toJSON());\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nexport class Constructed extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Constructed\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalConstructedValueBlock);\n\n\t\tthis.idBlock.isConstructed = true;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"CONSTRUCTED\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number}\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tthis.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\n\t\tif(resultOffset === (-1))\n\t\t{\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tif(this.idBlock.error.length === 0)\n\t\t\tthis.blockLength += this.idBlock.blockLength;\n\n\t\tif(this.lenBlock.error.length === 0)\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\n\n\t\tif(this.valueBlock.error.length === 0)\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\tconst values = [];\n\t\tfor (const value of this.valueBlock.value) {\n\t\t\tvalues.push(value.toString().split(\"\\n\").map(o => `  ${o}`).join(\"\\n\"));\n\t\t}\n\t\tconst blockName = this.idBlock.tagClass === 3\n\t\t\t? `[${this.idBlock.tagNumber}]`\n\t\t\t: this.constructor.blockName();\n\t\treturn values.length \n\t\t\t? `${blockName} :\\n${values.join(\"\\n\")}` // items\n\t\t\t: `${blockName} :`; // empty\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 EndOfContent type class\n//**************************************************************************************\nclass LocalEndOfContentValueBlock extends ValueBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalEndOfContentValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number}\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\t//region There is no \"value block\" for EndOfContent type and we need to return the same offset\n\t\treturn inputOffset;\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedLocalSymbols\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\treturn new ArrayBuffer(0);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"EndOfContentValueBlock\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nexport class EndOfContent extends BaseBlock\n{\n\t//**********************************************************************************\n\tconstructor(paramaters = {})\n\t{\n\t\tsuper(paramaters, LocalEndOfContentValueBlock);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 0; // EndOfContent\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"EndOfContent\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Boolean type class\n//**************************************************************************************\nclass LocalBooleanValueBlock extends ValueBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalBooleanValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\t\t\n\t\tthis.value = getParametersValue(parameters, \"value\", false);\n\t\tthis.isHexOnly = getParametersValue(parameters, \"isHexOnly\", false);\n\t\t\n\t\tif(\"valueHex\" in parameters)\n\t\t\tthis.valueHex = parameters.valueHex.slice(0);\n\t\telse\n\t\t{\n\t\t\tthis.valueHex = new ArrayBuffer(1);\n\t\t\tif(this.value === true)\n\t\t\t{\n\t\t\t\tconst view = new Uint8Array(this.valueHex);\n\t\t\t\tview[0] = 0xFF;\n\t\t\t}\n\t\t}\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\n\t\t\treturn (-1);\n\t\t//endregion\n\n\t\t//region Getting Uint8Array from ArrayBuffer\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t\t//endregion\n\n\t\tif(inputLength > 1)\n\t\t\tthis.warnings.push(\"Boolean value encoded in more then 1 octet\");\n\n\t\tthis.isHexOnly = true;\n\n\t\t//region Copy input buffer to internal array\n\t\tthis.valueHex = new ArrayBuffer(intBuffer.length);\n\t\tconst view = new Uint8Array(this.valueHex);\n\n\t\tfor(let i = 0; i < intBuffer.length; i++)\n\t\t\tview[i] = intBuffer[i];\n\t\t//endregion\n\t\t\n\t\tif(utilDecodeTC.call(this) !== 0 )\n\t\t\tthis.value = true;\n\t\telse\n\t\t\tthis.value = false;\n\n\t\tthis.blockLength = inputLength;\n\n\t\treturn (inputOffset + inputLength);\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedLocalSymbols\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\treturn this.valueHex;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"BooleanValueBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.value = this.value;\n\t\tobject.isHexOnly = this.isHexOnly;\n\t\tobject.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nexport class Boolean extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Boolean\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalBooleanValueBlock);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 1; // Boolean\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"BOOLEAN\";\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\treturn `${this.constructor.blockName()} : ${this.valueBlock.value}`;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Sequence and Set type classes\n//**************************************************************************************\nexport class Sequence extends Constructed\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Sequence\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 16; // Sequence\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"SEQUENCE\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nexport class Set extends Constructed\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Set\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 17; // Set\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"SET\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Null type class\n//**************************************************************************************\nexport class Null extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Null\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalBaseBlock); // We will not have a call to \"Null value block\" because of specified \"fromBER\" and \"toBER\" functions\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 5; // Null\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"NULL\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedLocalSymbols\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tif(this.lenBlock.length > 0)\n\t\t\tthis.warnings.push(\"Non-zero length of value block for Null type\");\n\n\t\tif(this.idBlock.error.length === 0)\n\t\t\tthis.blockLength += this.idBlock.blockLength;\n\n\t\tif(this.lenBlock.error.length === 0)\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\n\t\t\n\t\tthis.blockLength += inputLength;\n\t\t\n\t\tif((inputOffset + inputLength) > inputBuffer.byteLength)\n\t\t{\n\t\t\tthis.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\n\t\t\treturn (-1);\n\t\t}\n\t\t\n\t\treturn (inputOffset + inputLength);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\tconst retBuf = new ArrayBuffer(2);\n\n\t\tif(sizeOnly === true)\n\t\t\treturn retBuf;\n\n\t\tconst retView = new Uint8Array(retBuf);\n\t\tretView[0] = 0x05;\n\t\tretView[1] = 0x00;\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\treturn `${this.constructor.blockName()}`;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 OctetString type class\n//**************************************************************************************\nclass LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock)\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalOctetStringValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueHex]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.isConstructed = getParametersValue(parameters, \"isConstructed\", false);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tlet resultOffset = 0;\n\n\t\tif(this.isConstructed === true)\n\t\t{\n\t\t\tthis.isHexOnly = false;\n\n\t\t\tresultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n\t\t\tif(resultOffset === (-1))\n\t\t\t\treturn resultOffset;\n\n\t\t\tfor(let i = 0; i < this.value.length; i++)\n\t\t\t{\n\t\t\t\tconst currentBlockName = this.value[i].constructor.blockName();\n\n\t\t\t\tif(currentBlockName === EndOfContent.blockName())\n\t\t\t\t{\n\t\t\t\t\tif(this.isIndefiniteForm === true)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.error = \"EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only\";\n\t\t\t\t\t\treturn (-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(currentBlockName !== OctetString.blockName())\n\t\t\t\t{\n\t\t\t\t\tthis.error = \"OCTET STRING may consists of OCTET STRINGs only\";\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.isHexOnly = true;\n\n\t\t\tresultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n\t\t\tthis.blockLength = inputLength;\n\t\t}\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\tif(this.isConstructed === true)\n\t\t\treturn LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);\n\n\t\tlet retBuf = new ArrayBuffer(this.valueHex.byteLength);\n\n\t\tif(sizeOnly === true)\n\t\t\treturn retBuf;\n\n\t\tif(this.valueHex.byteLength === 0)\n\t\t\treturn retBuf;\n\n\t\tretBuf = this.valueHex.slice(0);\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"OctetStringValueBlock\";\n\t}\n\t//**********************************************************************************\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.isConstructed = this.isConstructed;\n\t\tobject.isHexOnly = this.isHexOnly;\n\t\tobject.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nexport class OctetString extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"OctetString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalOctetStringValueBlock);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 4; // OctetString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tthis.valueBlock.isConstructed = this.idBlock.isConstructed;\n\t\tthis.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n\n\t\t//region Ability to encode empty OCTET STRING\n\t\tif(inputLength === 0)\n\t\t{\n\t\t\tif(this.idBlock.error.length === 0)\n\t\t\t\tthis.blockLength += this.idBlock.blockLength;\n\n\t\t\tif(this.lenBlock.error.length === 0)\n\t\t\t\tthis.blockLength += this.lenBlock.blockLength;\n\n\t\t\treturn inputOffset;\n\t\t}\n\t\t//endregion\n\n\t\tif (!this.valueBlock.isConstructed) {\n\t\t\tconst buf = inputBuffer.slice(inputOffset, inputOffset + inputLength);\n\t\t\ttry {\n\t\t\t\tconst asn = fromBER(buf);\n\t\t\t\tif (asn.offset !== -1 && asn.offset === inputLength) {\n\t\t\t\t\tthis.valueBlock.value = [asn.result];\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// nothing\n\t\t\t}\n\t\t}\n\n\t\treturn super.fromBER(inputBuffer, inputOffset, inputLength);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"OCTET STRING\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Checking that two OCTETSTRINGs are equal\n\t * @param {OctetString} octetString\n\t */\n\tisEqual(octetString)\n\t{\n\t\t//region Check input type\n\t\tif((octetString instanceof OctetString) === false)\n\t\t\treturn false;\n\t\t//endregion\n\n\t\t//region Compare two JSON strings\n\t\tif(JSON.stringify(this) !== JSON.stringify(octetString))\n\t\t\treturn false;\n\t\t//endregion\n\n\t\treturn true;\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\tif (this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length)) {\n\t\t\treturn Constructed.prototype.toString.call(this);\n\t\t} else {\n\t\t\treturn `${this.constructor.blockName()} : ${bufferToHexCodes(this.valueBlock.valueHex)}`;\n\t\t}\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 BitString type class\n//**************************************************************************************\nclass LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock)\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalBitStringValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueHex]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.unusedBits = getParametersValue(parameters, \"unusedBits\", 0);\n\t\tthis.isConstructed = getParametersValue(parameters, \"isConstructed\", false);\n\t\tthis.blockLength = this.valueHex.byteLength;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\t//region Ability to decode zero-length BitString value\n\t\tif(inputLength === 0)\n\t\t\treturn inputOffset;\n\t\t//endregion\n\n\t\tlet resultOffset = (-1);\n\n\t\t//region If the BISTRING supposed to be a constructed value\n\t\tif(this.isConstructed === true)\n\t\t{\n\t\t\tresultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n\t\t\tif(resultOffset === (-1))\n\t\t\t\treturn resultOffset;\n\n\t\t\tfor(let i = 0; i < this.value.length; i++)\n\t\t\t{\n\t\t\t\tconst currentBlockName = this.value[i].constructor.blockName();\n\n\t\t\t\tif(currentBlockName === EndOfContent.blockName())\n\t\t\t\t{\n\t\t\t\t\tif(this.isIndefiniteForm === true)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.error = \"EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only\";\n\t\t\t\t\t\treturn (-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(currentBlockName !== BitString.blockName())\n\t\t\t\t{\n\t\t\t\t\tthis.error = \"BIT STRING may consists of BIT STRINGs only\";\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\n\t\t\t\tif((this.unusedBits > 0) && (this.value[i].valueBlock.unusedBits > 0))\n\t\t\t\t{\n\t\t\t\t\tthis.error = \"Using of \\\"unused bits\\\" inside constructive BIT STRING allowed for least one only\";\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\n\t\t\t\tthis.unusedBits = this.value[i].valueBlock.unusedBits;\n\t\t\t\tif(this.unusedBits > 7)\n\t\t\t\t{\n\t\t\t\t\tthis.error = \"Unused bits for BitString must be in range 0-7\";\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn resultOffset;\n\t\t}\n\t\t//endregion\n\t\t//region If the BitString supposed to be a primitive value\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\n\t\t\treturn (-1);\n\t\t//endregion\n\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\n\t\tthis.unusedBits = intBuffer[0];\n\t\t\n\t\tif(this.unusedBits > 7)\n\t\t{\n\t\t\tthis.error = \"Unused bits for BitString must be in range 0-7\";\n\t\t\treturn (-1);\n\t\t}\n\n\t\tif (!this.unusedBits) {\n\t\t\tconst buf = inputBuffer.slice(inputOffset + 1, inputOffset + inputLength);\n\t\t\ttry {\n\t\t\t\tconst asn = fromBER(buf);\n\t\t\t\tif (asn.offset !== -1 && asn.offset === (inputLength - 1)) {\n\t\t\t\t\tthis.value = [asn.result];\n\t\t\t\t}\n\t\t\t} catch(e) {\n\t\t\t\t// nothing\n\t\t\t}\n\t\t}\n\n\t\t//region Copy input buffer to internal buffer\n\t\tthis.valueHex = new ArrayBuffer(intBuffer.length - 1);\n\t\tconst view = new Uint8Array(this.valueHex);\n\t\tfor(let i = 0; i < (inputLength - 1); i++)\n\t\t\tview[i] = intBuffer[i + 1];\n\t\t//endregion\n\n\t\tthis.blockLength = intBuffer.length;\n\n\t\treturn (inputOffset + inputLength);\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\tif(this.isConstructed === true)\n\t\t\treturn LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);\n\n\t\tif(sizeOnly === true)\n\t\t\treturn (new ArrayBuffer(this.valueHex.byteLength + 1));\n\n\t\tif(this.valueHex.byteLength === 0)\n\t\t\treturn (new ArrayBuffer(0));\n\n\t\tconst curView = new Uint8Array(this.valueHex);\n\n\t\tconst retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);\n\t\tconst retView = new Uint8Array(retBuf);\n\n\t\tretView[0] = this.unusedBits;\n\n\t\tfor(let i = 0; i < this.valueHex.byteLength; i++)\n\t\t\tretView[i + 1] = curView[i];\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"BitStringValueBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.unusedBits = this.unusedBits;\n\t\tobject.isConstructed = this.isConstructed;\n\t\tobject.isHexOnly = this.isHexOnly;\n\t\tobject.valueHex = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nexport class BitString extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"BitString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalBitStringValueBlock);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 3; // BitString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"BIT STRING\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\t//region Ability to encode empty BitString\n\t\tif(inputLength === 0)\n\t\t\treturn inputOffset;\n\t\t//endregion\n\n\t\tthis.valueBlock.isConstructed = this.idBlock.isConstructed;\n\t\tthis.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n\n\t\treturn super.fromBER(inputBuffer, inputOffset, inputLength);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Checking that two BITSTRINGs are equal\n\t * @param {BitString} bitString\n\t */\n\tisEqual(bitString)\n\t{\n\t\t//region Check input type\n\t\tif((bitString instanceof BitString) === false)\n\t\t\treturn false;\n\t\t//endregion\n\n\t\t//region Compare two JSON strings\n\t\tif(JSON.stringify(this) !== JSON.stringify(bitString))\n\t\t\treturn false;\n\t\t//endregion\n\n\t\treturn true;\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\tif (this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length)) {\n\t\t\treturn Constructed.prototype.toString.call(this);\n\t\t} else {\n\t\t\t// convert bytes to bits\n\t\t\tconst bits = [];\n\t\t\tconst valueHex = new Uint8Array(this.valueBlock.valueHex);\n\t\t\tfor (const byte of valueHex) {\n\t\t\t\tbits.push(byte.toString(2).padStart(8, \"0\"));\n\t\t\t}\n\t\t\treturn `${this.constructor.blockName()} : ${bits.join(\"\")}`;\n\t\t}\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Integer type class\n//**************************************************************************************\n/**\n * @extends ValueBlock\n */\nclass LocalIntegerValueBlock extends HexBlock(ValueBlock)\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalIntegerValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueHex]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tif(\"value\" in parameters)\n\t\t\tthis.valueDec = parameters.value;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Setter for \"valueHex\"\n\t * @param {ArrayBuffer} _value\n\t */\n\tset valueHex(_value)\n\t{\n\t\tthis._valueHex = _value.slice(0);\n\n\t\tif(_value.byteLength >= 4)\n\t\t{\n\t\t\tthis.warnings.push(\"Too big Integer for decoding, hex only\");\n\t\t\tthis.isHexOnly = true;\n\t\t\tthis._valueDec = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.isHexOnly = false;\n\n\t\t\tif(_value.byteLength > 0)\n\t\t\t\tthis._valueDec = utilDecodeTC.call(this);\n\t\t}\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Getter for \"valueHex\"\n\t * @returns {ArrayBuffer}\n\t */\n\tget valueHex()\n\t{\n\t\treturn this._valueHex;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Getter for \"valueDec\"\n\t * @param {number} _value\n\t */\n\tset valueDec(_value)\n\t{\n\t\tthis._valueDec = _value;\n\n\t\tthis.isHexOnly = false;\n\t\tthis._valueHex = utilEncodeTC(_value);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Getter for \"valueDec\"\n\t * @returns {number}\n\t */\n\tget valueDec()\n\t{\n\t\treturn this._valueDec;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from DER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 DER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 DER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @param {number} [expectedLength=0] Expected length of converted \"valueHex\" buffer\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0)\n\t{\n\t\tconst offset = this.fromBER(inputBuffer, inputOffset, inputLength);\n\t\tif(offset === (-1))\n\t\t\treturn offset;\n\n\t\tconst view = new Uint8Array(this._valueHex);\n\n\t\tif((view[0] === 0x00) && ((view[1] & 0x80) !== 0))\n\t\t{\n\t\t\tconst updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);\n\t\t\tconst updatedView = new Uint8Array(updatedValueHex);\n\n\t\t\tupdatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));\n\n\t\t\tthis._valueHex = updatedValueHex.slice(0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(expectedLength !== 0)\n\t\t\t{\n\t\t\t\tif(this._valueHex.byteLength < expectedLength)\n\t\t\t\t{\n\t\t\t\t\tif((expectedLength - this._valueHex.byteLength) > 1)\n\t\t\t\t\t\texpectedLength = this._valueHex.byteLength + 1;\n\t\t\t\t\t\n\t\t\t\t\tconst updatedValueHex = new ArrayBuffer(expectedLength);\n\t\t\t\t\tconst updatedView = new Uint8Array(updatedValueHex);\n\n\t\t\t\t\tupdatedView.set(view, expectedLength - this._valueHex.byteLength);\n\n\t\t\t\t\tthis._valueHex = updatedValueHex.slice(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn offset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (DER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoDER(sizeOnly = false)\n\t{\n\t\tconst view = new Uint8Array(this._valueHex);\n\n\t\tswitch(true)\n\t\t{\n\t\t\tcase ((view[0] & 0x80) !== 0):\n\t\t\t\t{\n\t\t\t\t\tconst updatedValueHex = new ArrayBuffer(this._valueHex.byteLength + 1);\n\t\t\t\t\tconst updatedView = new Uint8Array(updatedValueHex);\n\n\t\t\t\t\tupdatedView[0] = 0x00;\n\t\t\t\t\tupdatedView.set(view, 1);\n\n\t\t\t\t\tthis._valueHex = updatedValueHex.slice(0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ((view[0] === 0x00) && ((view[1] & 0x80) === 0)):\n\t\t\t\t{\n\t\t\t\t\tconst updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);\n\t\t\t\t\tconst updatedView = new Uint8Array(updatedValueHex);\n\n\t\t\t\t\tupdatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));\n\n\t\t\t\t\tthis._valueHex = updatedValueHex.slice(0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t}\n\n\t\treturn this.toBER(sizeOnly);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tconst resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n\t\tif(resultOffset === (-1))\n\t\t\treturn resultOffset;\n\n\t\tthis.blockLength = inputLength;\n\n\t\treturn (inputOffset + inputLength);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\t//noinspection JSCheckFunctionSignatures\n\t\treturn this.valueHex.slice(0);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"IntegerValueBlock\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.valueDec = this.valueDec;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convert current value to decimal string representation\n\t */\n\ttoString()\n\t{\n\t\t//region Aux functions\n\t\tfunction viewAdd(first, second)\n\t\t{\n\t\t\t//region Initial variables\n\t\t\tconst c = new Uint8Array([0]);\n\t\t\t\n\t\t\tlet firstView = new Uint8Array(first);\n\t\t\tlet secondView = new Uint8Array(second);\n\t\t\t\n\t\t\tlet firstViewCopy = firstView.slice(0);\n\t\t\tconst firstViewCopyLength = firstViewCopy.length - 1;\n\t\t\tlet secondViewCopy = secondView.slice(0);\n\t\t\tconst secondViewCopyLength = secondViewCopy.length - 1;\n\t\t\t\n\t\t\tlet value = 0;\n\t\t\t\n\t\t\tconst max = (secondViewCopyLength < firstViewCopyLength) ? firstViewCopyLength : secondViewCopyLength;\n\t\t\t\n\t\t\tlet counter = 0;\n\t\t\t//endregion\n\t\t\t\n\t\t\tfor(let i = max; i >= 0; i--, counter++)\n\t\t\t{\n\t\t\t\tswitch(true)\n\t\t\t\t{\n\t\t\t\t\tcase (counter < secondViewCopy.length):\n\t\t\t\t\t\tvalue = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tvalue = firstViewCopy[firstViewCopyLength - counter] + c[0];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tc[0] = value / 10;\n\t\t\t\t\n\t\t\t\tswitch(true)\n\t\t\t\t{\n\t\t\t\t\tcase (counter >= firstViewCopy.length):\n\t\t\t\t\t\tfirstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value % 10;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(c[0] > 0)\n\t\t\t\tfirstViewCopy = utilConcatView(c, firstViewCopy);\n\t\t\t\n\t\t\treturn firstViewCopy.slice(0);\n\t\t}\n\t\t\n\t\tfunction power2(n)\n\t\t{\n\t\t\tif(n >= powers2.length)\n\t\t\t{\n\t\t\t\tfor(let p = powers2.length; p <= n; p++)\n\t\t\t\t{\n\t\t\t\t\tconst c = new Uint8Array([0]);\n\t\t\t\t\tlet digits = (powers2[p - 1]).slice(0);\n\t\t\t\t\t\n\t\t\t\t\tfor(let i = (digits.length - 1); i >=0; i--)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst newValue = new Uint8Array([(digits[i] << 1) + c[0]]);\n\t\t\t\t\t\tc[0] = newValue[0] / 10;\n\t\t\t\t\t\tdigits[i] = newValue[0] % 10;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (c[0] > 0)\n\t\t\t\t\t\tdigits = utilConcatView(c, digits);\n\t\t\t\t\t\n\t\t\t\t\tpowers2.push(digits);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn powers2[n];\n\t\t}\n\t\t\n\t\tfunction viewSub(first, second)\n\t\t{\n\t\t\t//region Initial variables\n\t\t\tlet b = 0;\n\t\t\t\n\t\t\tlet firstView = new Uint8Array(first);\n\t\t\tlet secondView = new Uint8Array(second);\n\t\t\t\n\t\t\tlet firstViewCopy = firstView.slice(0);\n\t\t\tconst firstViewCopyLength = firstViewCopy.length - 1;\n\t\t\tlet secondViewCopy = secondView.slice(0);\n\t\t\tconst secondViewCopyLength = secondViewCopy.length - 1;\n\t\t\t\n\t\t\tlet value;\n\t\t\t\n\t\t\tlet counter = 0;\n\t\t\t//endregion\n\t\t\t\n\t\t\tfor(let i = secondViewCopyLength; i >= 0; i--, counter++)\n\t\t\t{\n\t\t\t\tvalue = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;\n\t\t\t\t\n\t\t\t\tswitch(true)\n\t\t\t\t{\n\t\t\t\t\tcase (value < 0):\n\t\t\t\t\t\tb = 1;\n\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value + 10;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(b > 0)\n\t\t\t{\n\t\t\t\tfor(let i = (firstViewCopyLength - secondViewCopyLength + 1); i >= 0; i--, counter++)\n\t\t\t\t{\n\t\t\t\t\tvalue = firstViewCopy[firstViewCopyLength - counter] - b;\n\t\t\t\t\t\n\t\t\t\t\tif(value < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tb = 1;\n\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value + 10;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t\tfirstViewCopy[firstViewCopyLength - counter] = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn firstViewCopy.slice();\n\t\t}\n\t\t//endregion\n\t\t\n\t\t//region Initial variables\n\t\tconst firstBit = (this._valueHex.byteLength * 8) - 1;\n\t\t\n\t\tlet digits = new Uint8Array((this._valueHex.byteLength * 8) / 3);\n\t\tlet bitNumber = 0;\n\t\tlet currentByte;\n\t\t\n\t\tconst asn1View = new Uint8Array(this._valueHex);\n\t\t\n\t\tlet result = \"\";\n\t\t\n\t\tlet flag = false;\n\t\t//endregion\n\t\t\n\t\t//region Calculate number\n\t\tfor(let byteNumber = (this._valueHex.byteLength - 1); byteNumber >= 0; byteNumber--)\n\t\t{\n\t\t\tcurrentByte = asn1View[byteNumber];\n\t\t\t\n\t\t\tfor(let i = 0; i < 8; i++)\n\t\t\t{\n\t\t\t\tif((currentByte & 1) === 1)\n\t\t\t\t{\n\t\t\t\t\tswitch(bitNumber)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase firstBit:\n\t\t\t\t\t\t\tdigits = viewSub(power2(bitNumber), digits);\n\t\t\t\t\t\t\tresult = \"-\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tdigits = viewAdd(digits, power2(bitNumber));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbitNumber++;\n\t\t\t\tcurrentByte >>= 1;\n\t\t\t}\n\t\t}\n\t\t//endregion\n\t\t\n\t\t//region Print number\n\t\tfor(let i = 0; i < digits.length; i++)\n\t\t{\n\t\t\tif(digits[i])\n\t\t\t\tflag = true;\n\t\t\t\n\t\t\tif(flag)\n\t\t\t\tresult += digitsString.charAt(digits[i]);\n\t\t}\n\t\t\n\t\tif(flag === false)\n\t\t\tresult += digitsString.charAt(0);\n\t\t//endregion\n\t\t\n\t\treturn result;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nexport class Integer extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Integer\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalIntegerValueBlock);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 2; // Integer\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"INTEGER\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Compare two Integer object, or Integer and ArrayBuffer objects\n\t * @param {!Integer|ArrayBuffer} otherValue\n\t * @returns {boolean}\n\t */\n\tisEqual(otherValue)\n\t{\n\t\tif(otherValue instanceof Integer)\n\t\t{\n\t\t\tif(this.valueBlock.isHexOnly && otherValue.valueBlock.isHexOnly) // Compare two ArrayBuffers\n\t\t\t\treturn isEqualBuffer(this.valueBlock.valueHex, otherValue.valueBlock.valueHex);\n\n\t\t\tif(this.valueBlock.isHexOnly === otherValue.valueBlock.isHexOnly)\n\t\t\t\treturn (this.valueBlock.valueDec === otherValue.valueBlock.valueDec);\n\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(otherValue instanceof ArrayBuffer)\n\t\t\treturn isEqualBuffer(this.valueBlock.valueHex, otherValue);\n\n\t\treturn false;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convert current Integer value from BER into DER format\n\t * @returns {Integer}\n\t */\n\tconvertToDER()\n\t{\n\t\tconst integer = new Integer({ valueHex: this.valueBlock.valueHex });\n\t\tinteger.valueBlock.toDER();\n\n\t\treturn integer;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convert current Integer value from DER to BER format\n\t * @returns {Integer}\n\t */\n\tconvertFromDER()\n\t{\n\t\tconst expectedLength = (this.valueBlock.valueHex.byteLength % 2) ? (this.valueBlock.valueHex.byteLength + 1) : this.valueBlock.valueHex.byteLength;\n\t\tconst integer = new Integer({ valueHex: this.valueBlock.valueHex });\n\t\tinteger.valueBlock.fromDER(integer.valueBlock.valueHex, 0, integer.valueBlock.valueHex.byteLength, expectedLength);\n\t\t\n\t\treturn integer;\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\tassertBigInt();\n\t\tconst hex = bufferToHexCodes(this.valueBlock.valueHex);\n\t\tconst bigInt = BigInt(`0x${hex}`);\n\t\treturn `${this.constructor.blockName()} : ${bigInt.toString()}`;\n\t}\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Enumerated type class\n//**************************************************************************************\nexport class Enumerated extends Integer\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Enumerated\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 10; // Enumerated\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"ENUMERATED\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 ObjectIdentifier type class\n//**************************************************************************************\nclass LocalSidValueBlock extends HexBlock(LocalBaseBlock)\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalSidValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {number} [valueDec]\n\t * @property {boolean} [isFirstSid]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.valueDec = getParametersValue(parameters, \"valueDec\", -1);\n\t\tthis.isFirstSid = getParametersValue(parameters, \"isFirstSid\", false);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"sidBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tif(inputLength === 0)\n\t\t\treturn inputOffset;\n\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif(checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\n\t\t\treturn (-1);\n\t\t//endregion\n\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\n\t\tthis.valueHex = new ArrayBuffer(inputLength);\n\t\tlet view = new Uint8Array(this.valueHex);\n\n\t\tfor(let i = 0; i < inputLength; i++)\n\t\t{\n\t\t\tview[i] = intBuffer[i] & 0x7F;\n\n\t\t\tthis.blockLength++;\n\n\t\t\tif((intBuffer[i] & 0x80) === 0x00)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t//region Ajust size of valueHex buffer\n\t\tconst tempValueHex = new ArrayBuffer(this.blockLength);\n\t\tconst tempView = new Uint8Array(tempValueHex);\n\n\t\tfor(let i = 0; i < this.blockLength; i++)\n\t\t\ttempView[i] = view[i];\n\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tthis.valueHex = tempValueHex.slice(0);\n\t\tview = new Uint8Array(this.valueHex);\n\t\t//endregion\n\n\t\tif((intBuffer[this.blockLength - 1] & 0x80) !== 0x00)\n\t\t{\n\t\t\tthis.error = \"End of input reached before message was fully decoded\";\n\t\t\treturn (-1);\n\t\t}\n\n\t\tif(view[0] === 0x00)\n\t\t\tthis.warnings.push(\"Needlessly long format of SID encoding\");\n\n\t\tif(this.blockLength <= 8)\n\t\t\tthis.valueDec = utilFromBase(view, 7);\n\t\telse\n\t\t{\n\t\t\tthis.isHexOnly = true;\n\t\t\tthis.warnings.push(\"Too big SID for decoding, hex only\");\n\t\t}\n\n\t\treturn (inputOffset + this.blockLength);\n\t}\n//**********************************************************************************\n\t/**\n\t * Save a BigInt value immediately as an array of octects.\n\t */\n set valueBigInt(value) {\n\n\tassertBigInt();\n\n\tlet bits = BigInt(value).toString(2);\n\twhile (bits.length % 7) {\n\t\tbits = '0' + bits\n\t}\n\tconst bytes = new Uint8Array(bits.length / 7)\n\tfor (let i = 0; i < bytes.length; i++) {\n\t\tbytes[i] = parseInt(bits.slice(i*7, i*7 + 7), 2) + (i + 1 < bytes.length ? 0x80 : 0)\n\t}\n\tthis.fromBER(bytes.buffer, 0, bytes.length)\n}\n//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\t//region Initial variables\n\t\tlet retBuf;\n\t\tlet retView;\n\t\t//endregion\n\n\t\tif(this.isHexOnly)\n\t\t{\n\t\t\tif(sizeOnly === true)\n\t\t\t\treturn (new ArrayBuffer(this.valueHex.byteLength));\n\n\t\t\tconst curView = new Uint8Array(this.valueHex);\n\n\t\t\tretBuf = new ArrayBuffer(this.blockLength);\n\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\tfor(let i = 0; i < (this.blockLength - 1); i++)\n\t\t\t\tretView[i] = curView[i] | 0x80;\n\n\t\t\tretView[this.blockLength - 1] = curView[this.blockLength - 1];\n\n\t\t\treturn retBuf;\n\t\t}\n\n\t\tconst encodedBuf = utilToBase(this.valueDec, 7);\n\t\tif(encodedBuf.byteLength === 0)\n\t\t{\n\t\t\tthis.error = \"Error during encoding SID value\";\n\t\t\treturn (new ArrayBuffer(0));\n\t\t}\n\n\t\tretBuf = new ArrayBuffer(encodedBuf.byteLength);\n\n\t\tif(sizeOnly === false)\n\t\t{\n\t\t\tconst encodedView = new Uint8Array(encodedBuf);\n\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\tfor(let i = 0; i < (encodedBuf.byteLength - 1); i++)\n\t\t\t\tretView[i] = encodedView[i] | 0x80;\n\n\t\t\tretView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];\n\t\t}\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Create string representation of current SID block\n\t * @returns {string}\n\t */\n\ttoString()\n\t{\n\t\tlet result = \"\";\n\n\t\tif(this.isHexOnly === true)\n\t\t\tresult = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n\t\telse\n\t\t{\n\t\t\tif(this.isFirstSid)\n\t\t\t{\n\t\t\t\tlet sidValue = this.valueDec;\n\n\t\t\t\tif(this.valueDec <= 39)\n\t\t\t\t\tresult = \"0.\";\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(this.valueDec <= 79)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = \"1.\";\n\t\t\t\t\t\tsidValue -= 40;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = \"2.\";\n\t\t\t\t\t\tsidValue -= 80;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresult += sidValue.toString();\n\t\t\t}\n\t\t\telse\n\t\t\t\tresult = this.valueDec.toString();\n\t\t}\n\n\t\treturn result;\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.valueDec = this.valueDec;\n\t\tobject.isFirstSid = this.isFirstSid;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nclass LocalObjectIdentifierValueBlock extends ValueBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalObjectIdentifierValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueHex]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.fromString(getParametersValue(parameters, \"value\", \"\"));\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tlet resultOffset = inputOffset;\n\n\t\twhile(inputLength > 0)\n\t\t{\n\t\t\tconst sidBlock = new LocalSidValueBlock();\n\t\t\tresultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n\t\t\tif(resultOffset === (-1))\n\t\t\t{\n\t\t\t\tthis.blockLength = 0;\n\t\t\t\tthis.error = sidBlock.error;\n\t\t\t\treturn resultOffset;\n\t\t\t}\n\n\t\t\tif(this.value.length === 0)\n\t\t\t\tsidBlock.isFirstSid = true;\n\n\t\t\tthis.blockLength += sidBlock.blockLength;\n\t\t\tinputLength -= sidBlock.blockLength;\n\n\t\t\tthis.value.push(sidBlock);\n\t\t}\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\tlet retBuf = new ArrayBuffer(0);\n\n\t\tfor(let i = 0; i < this.value.length; i++)\n\t\t{\n\t\t\tconst valueBuf = this.value[i].toBER(sizeOnly);\n\t\t\tif(valueBuf.byteLength === 0)\n\t\t\t{\n\t\t\t\tthis.error = this.value[i].error;\n\t\t\t\treturn (new ArrayBuffer(0));\n\t\t\t}\n\n\t\t\tretBuf = utilConcatBuf(retBuf, valueBuf);\n\t\t}\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Create \"LocalObjectIdentifierValueBlock\" class from string\n\t * @param {string} string Input string to convert from\n\t * @returns {boolean}\n\t */\n\tfromString(string)\n\t{\n\t\tthis.value = []; // Clear existing SID values\n\n\t\tlet pos1 = 0;\n\t\tlet pos2 = 0;\n\n\t\tlet sid = \"\";\n\n\t\tlet flag = false;\n\n\t\tdo\n\t\t{\n\t\t\tpos2 = string.indexOf(\".\", pos1);\n\t\t\tif(pos2 === (-1))\n\t\t\t\tsid = string.substr(pos1);\n\t\t\telse\n\t\t\t\tsid = string.substr(pos1, pos2 - pos1);\n\n\t\t\tpos1 = pos2 + 1;\n\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\tconst sidBlock = this.value[0];\n\n\t\t\t\tlet plus = 0;\n\n\t\t\t\tswitch(sidBlock.valueDec)\n\t\t\t\t{\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tplus = 40;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tplus = 80;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthis.value = []; // clear SID array\n\t\t\t\t\t\treturn false; // ???\n\t\t\t\t}\n\n\t\t\t\tconst parsedSID = parseInt(sid, 10);\n\t\t\t\tif(isNaN(parsedSID))\n\t\t\t\t\treturn true;\n\n\t\t\t\tsidBlock.valueDec = parsedSID + plus;\n\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconst sidBlock = new LocalSidValueBlock();\n        if (sid > Number.MAX_SAFE_INTEGER) {\n\t\t\t\t\tassertBigInt();\n\t\t\t\t\tconst sidValue = BigInt(sid);\n          sidBlock.valueBigInt = sidValue\n        } else {\n          sidBlock.valueDec = parseInt(sid, 10);\n          if (isNaN(sidBlock.valueDec)) return true;  \n        }\n\n\t\t\t\tif(this.value.length === 0)\n\t\t\t\t{\n\t\t\t\t\tsidBlock.isFirstSid = true;\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\n\t\t\t\tthis.value.push(sidBlock);\n\t\t\t}\n\t\t} while(pos2 !== (-1));\n\n\t\treturn true;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Converts \"LocalObjectIdentifierValueBlock\" class to string\n\t * @returns {string}\n\t */\n\ttoString()\n\t{\n\t\tlet result = \"\";\n\t\tlet isHexOnly = false;\n\n\t\tfor(let i = 0; i < this.value.length; i++)\n\t\t{\n\t\t\tisHexOnly = this.value[i].isHexOnly;\n\n\t\t\tlet sidStr = this.value[i].toString();\n\n\t\t\tif(i !== 0)\n\t\t\t\tresult = `${result}.`;\n\n\t\t\tif(isHexOnly)\n\t\t\t{\n\t\t\t\tsidStr = `{${sidStr}}`;\n\n\t\t\t\tif(this.value[i].isFirstSid)\n\t\t\t\t\tresult = `2.{${sidStr} - 80}`;\n\t\t\t\telse\n\t\t\t\t\tresult += sidStr;\n\t\t\t}\n\t\t\telse\n\t\t\t\tresult += sidStr;\n\t\t}\n\n\t\treturn result;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"ObjectIdentifierValueBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.value = this.toString();\n\t\tobject.sidArray = [];\n\t\tfor(let i = 0; i < this.value.length; i++)\n\t\t\tobject.sidArray.push(this.value[i].toJSON());\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends BaseBlock\n */\nexport class ObjectIdentifier extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"ObjectIdentifier\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueHex]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalObjectIdentifierValueBlock);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 6; // OBJECT IDENTIFIER\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"OBJECT IDENTIFIER\";\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\treturn `${this.constructor.blockName()} : ${this.valueBlock.toString()}`;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of all string's classes\n//**************************************************************************************\nclass LocalUtf8StringValueBlock extends HexBlock(LocalBaseBlock)\n{\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Constructor for \"LocalUtf8StringValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.isHexOnly = true;\n\t\tthis.value = \"\"; // String representation of decoded ArrayBuffer\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"Utf8StringValueBlock\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.value = this.value;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends BaseBlock\n */\nexport class Utf8String extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Utf8String\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueHex]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalUtf8StringValueBlock);\n\n\t\tif(\"value\" in parameters)\n\t\t\tthis.fromString(parameters.value);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 12; // Utf8String\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"UTF8String\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\n\t\tif(resultOffset === (-1))\n\t\t{\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\tif(this.idBlock.error.length === 0)\n\t\t\tthis.blockLength += this.idBlock.blockLength;\n\n\t\tif(this.lenBlock.error.length === 0)\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\n\n\t\tif(this.valueBlock.error.length === 0)\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting ArrayBuffer into ASN.1 internal string\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t */\n\tfromBuffer(inputBuffer)\n\t{\n\t\tthis.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));\n\n\t\ttry\n\t\t{\n\t\t\t//noinspection JSDeprecatedSymbols\n\t\t\tthis.valueBlock.value = decodeURIComponent(escape(this.valueBlock.value));\n\t\t}\n\t\tcatch(ex)\n\t\t{\n\t\t\tthis.warnings.push(`Error during \"decodeURIComponent\": ${ex}, using raw string`);\n\t\t}\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting JavaScript string into ASN.1 internal class\n\t * @param {!string} inputString ASN.1 BER encoded array\n\t */\n\tfromString(inputString)\n\t{\n\t\t//noinspection JSDeprecatedSymbols\n\t\tconst str = unescape(encodeURIComponent(inputString));\n\t\tconst strLen = str.length;\n\n\t\tthis.valueBlock.valueHex = new ArrayBuffer(strLen);\n\t\tconst view = new Uint8Array(this.valueBlock.valueHex);\n\n\t\tfor(let i = 0; i < strLen; i++)\n\t\t\tview[i] = str.charCodeAt(i);\n\n\t\tthis.valueBlock.value = inputString;\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\treturn `${this.constructor.blockName()} : ${this.valueBlock.value}`;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//region Declaration of ASN.1 RelativeObjectIdentifier type class\n//**************************************************************************************\nclass LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock)\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalRelativeSidValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {number} [valueDec]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.valueDec = getParametersValue(parameters, \"valueDec\", -1);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"relativeSidBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tif (inputLength === 0)\n\t\t\treturn inputOffset;\n\n\t\t//region Basic check for parameters\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tif (checkBufferParams(this, inputBuffer, inputOffset, inputLength) === false)\n\t\t\treturn (-1);\n\t\t//endregion\n\n\t\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\n\t\tthis.valueHex = new ArrayBuffer(inputLength);\n\t\tlet view = new Uint8Array(this.valueHex);\n\n\t\tfor (let i = 0; i < inputLength; i++)\n\t\t{\n\t\t\tview[i] = intBuffer[i] & 0x7F;\n\n\t\t\tthis.blockLength++;\n\n\t\t\tif ((intBuffer[i] & 0x80) === 0x00)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t//region Ajust size of valueHex buffer\n\t\tconst tempValueHex = new ArrayBuffer(this.blockLength);\n\t\tconst tempView = new Uint8Array(tempValueHex);\n\n\t\tfor (let i = 0; i < this.blockLength; i++)\n\t\t\ttempView[i] = view[i];\n\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tthis.valueHex = tempValueHex.slice(0);\n\t\tview = new Uint8Array(this.valueHex);\n\t\t//endregion\n\n\t\tif ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00)\n\t\t{\n\t\t\tthis.error = \"End of input reached before message was fully decoded\";\n\t\t\treturn (-1);\n\t\t}\n\n\t\tif (view[0] === 0x00)\n\t\t\tthis.warnings.push(\"Needlessly long format of SID encoding\");\n\n\t\tif (this.blockLength <= 8)\n\t\t\tthis.valueDec = utilFromBase(view, 7);\n\t\telse\n\t\t{\n\t\t\tthis.isHexOnly = true;\n\t\t\tthis.warnings.push(\"Too big SID for decoding, hex only\");\n\t\t}\n\n\t\treturn (inputOffset + this.blockLength);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\t//region Initial variables\n\t\tlet retBuf;\n\t\tlet retView;\n\t\t//endregion\n\n\t\tif (this.isHexOnly)\n\t\t{\n\t\t\tif (sizeOnly === true)\n\t\t\t\treturn (new ArrayBuffer(this.valueHex.byteLength));\n\n\t\t\tconst curView = new Uint8Array(this.valueHex);\n\n\t\t\tretBuf = new ArrayBuffer(this.blockLength);\n\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\tfor (let i = 0; i < (this.blockLength - 1); i++)\n\t\t\t\tretView[i] = curView[i] | 0x80;\n\n\t\t\tretView[this.blockLength - 1] = curView[this.blockLength - 1];\n\n\t\t\treturn retBuf;\n\t\t}\n\n\t\tconst encodedBuf = utilToBase(this.valueDec, 7);\n\t\tif (encodedBuf.byteLength === 0)\n\t\t{\n\t\t\tthis.error = \"Error during encoding SID value\";\n\t\t\treturn (new ArrayBuffer(0));\n\t\t}\n\n\t\tretBuf = new ArrayBuffer(encodedBuf.byteLength);\n\n\t\tif (sizeOnly === false)\n\t\t{\n\t\t\tconst encodedView = new Uint8Array(encodedBuf);\n\t\t\tretView = new Uint8Array(retBuf);\n\n\t\t\tfor (let i = 0; i < (encodedBuf.byteLength - 1); i++)\n\t\t\t\tretView[i] = encodedView[i] | 0x80;\n\n\t\t\tretView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];\n\t\t}\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Create string representation of current SID block\n\t * @returns {string}\n\t */\n\ttoString()\n\t{\n\t\tlet result = \"\";\n\n\t\tif (this.isHexOnly === true)\n\t\t\tresult = bufferToHexCodes(this.valueHex, 0, this.valueHex.byteLength);\n\t\telse {\n\t\t\tresult = this.valueDec.toString();\n\t\t}\n\n\t\treturn result;\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry {\n\t\t\tobject = super.toJSON();\n\t\t} catch (ex) {}\n\t\t//endregion\n\n\t\tobject.valueDec = this.valueDec;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nclass LocalRelativeObjectIdentifierValueBlock extends ValueBlock {\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalRelativeObjectIdentifierValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueHex]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.fromString(getParametersValue(parameters, \"value\", \"\"));\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tlet resultOffset = inputOffset;\n\n\t\twhile (inputLength > 0)\n\t\t{\n\t\t\tconst sidBlock = new LocalRelativeSidValueBlock();\n\t\t\tresultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n\t\t\tif (resultOffset === (-1))\n\t\t\t{\n\t\t\t\tthis.blockLength = 0;\n\t\t\t\tthis.error = sidBlock.error;\n\t\t\t\treturn resultOffset;\n\t\t\t}\n\n\t\t\tthis.blockLength += sidBlock.blockLength;\n\t\t\tinputLength -= sidBlock.blockLength;\n\n\t\t\tthis.value.push(sidBlock);\n\t\t}\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\tlet retBuf = new ArrayBuffer(0);\n\n\t\tfor (let i = 0; i < this.value.length; i++)\n\t\t{\n\t\t\tconst valueBuf = this.value[i].toBER(sizeOnly);\n\t\t\tif (valueBuf.byteLength === 0)\n\t\t\t{\n\t\t\t\tthis.error = this.value[i].error;\n\t\t\t\treturn (new ArrayBuffer(0));\n\t\t\t}\n\n\t\t\tretBuf = utilConcatBuf(retBuf, valueBuf);\n\t\t}\n\n\t\treturn retBuf;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Create \"LocalRelativeObjectIdentifierValueBlock\" class from string\n\t * @param {string} string Input string to convert from\n\t * @returns {boolean}\n\t */\n\tfromString(string)\n\t{\n\t\tthis.value = []; // Clear existing SID values\n\n\t\tlet pos1 = 0;\n\t\tlet pos2 = 0;\n\n\t\tlet sid = \"\";\n\n\t\tdo\n\t\t{\n\t\t\tpos2 = string.indexOf(\".\", pos1);\n\t\t\tif (pos2 === (-1))\n\t\t\t\tsid = string.substr(pos1);\n\t\t\telse\n\t\t\t\tsid = string.substr(pos1, pos2 - pos1);\n\n\t\t\tpos1 = pos2 + 1;\n\n\t\t\tconst sidBlock = new LocalRelativeSidValueBlock();\n\t\t\tsidBlock.valueDec = parseInt(sid, 10);\n\t\t\tif (isNaN(sidBlock.valueDec))\n\t\t\t\treturn true;\n\n\t\t\tthis.value.push(sidBlock);\n\n\t\t} while (pos2 !== (-1));\n\n\t\treturn true;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Converts \"LocalRelativeObjectIdentifierValueBlock\" class to string\n\t * @returns {string}\n\t */\n\ttoString()\n\t{\n\t\tlet result = \"\";\n\t\tlet isHexOnly = false;\n\n\t\tfor (let i = 0; i < this.value.length; i++)\n\t\t{\n\t\t\tisHexOnly = this.value[i].isHexOnly;\n\n\t\t\tlet sidStr = this.value[i].toString();\n\n\t\t\tif (i !== 0)\n\t\t\t\tresult = `${result}.`;\n\n\t\t\tif (isHexOnly)\n\t\t\t{\n\t\t\t\tsidStr = `{${sidStr}}`;\n\t\t\t\tresult += sidStr;\n\t\t\t} else\n\t\t\t\tresult += sidStr;\n\t\t}\n\n\t\treturn result;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"RelativeObjectIdentifierValueBlock\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t} catch (ex) {}\n\t\t//endregion\n\n\t\tobject.value = this.toString();\n\t\tobject.sidArray = [];\n\t\tfor (let i = 0; i < this.value.length; i++)\n\t\t\tobject.sidArray.push(this.value[i].toJSON());\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends BaseBlock\n */\nexport class RelativeObjectIdentifier extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"RelativeObjectIdentifier\" class\n\t * @param {Object} [parameters={}]\n\t * @property {ArrayBuffer} [valueHex]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalRelativeObjectIdentifierValueBlock);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 13; // RELATIVE OBJECT IDENTIFIER\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"RelativeObjectIdentifier\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n/**\n * @extends LocalBaseBlock\n * @extends HexBlock\n */\nclass LocalBmpStringValueBlock extends HexBlock(LocalBaseBlock)\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalBmpStringValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.isHexOnly = true;\n\t\tthis.value = \"\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"BmpStringValueBlock\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.value = this.value;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends BaseBlock\n */\nexport class BmpString extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"BmpString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalBmpStringValueBlock);\n\n\t\tif(\"value\" in parameters)\n\t\t\tthis.fromString(parameters.value);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 30; // BmpString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"BMPString\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\n\t\tif(resultOffset === (-1))\n\t\t{\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\tif(this.idBlock.error.length === 0)\n\t\t\tthis.blockLength += this.idBlock.blockLength;\n\n\t\tif(this.lenBlock.error.length === 0)\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\n\n\t\tif(this.valueBlock.error.length === 0)\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting ArrayBuffer into ASN.1 internal string\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t */\n\tfromBuffer(inputBuffer)\n\t{\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tconst copyBuffer = inputBuffer.slice(0);\n\t\tconst valueView = new Uint8Array(copyBuffer);\n\n\t\tfor(let i = 0; i < valueView.length; i += 2)\n\t\t{\n\t\t\tconst temp = valueView[i];\n\n\t\t\tvalueView[i] = valueView[i + 1];\n\t\t\tvalueView[i + 1] = temp;\n\t\t}\n\n\t\tthis.valueBlock.value = String.fromCharCode.apply(null, new Uint16Array(copyBuffer));\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting JavaScript string into ASN.1 internal class\n\t * @param {!string} inputString ASN.1 BER encoded array\n\t */\n\tfromString(inputString)\n\t{\n\t\tconst strLength = inputString.length;\n\n\t\tthis.valueBlock.valueHex = new ArrayBuffer(strLength * 2);\n\t\tconst valueHexView = new Uint8Array(this.valueBlock.valueHex);\n\n\t\tfor(let i = 0; i < strLength; i++)\n\t\t{\n\t\t\tconst codeBuf = utilToBase(inputString.charCodeAt(i), 8);\n\t\t\tconst codeView = new Uint8Array(codeBuf);\n\t\t\tif(codeView.length > 2)\n\t\t\t\tcontinue;\n\n\t\t\tconst dif = 2 - codeView.length;\n\n\t\t\tfor(let j = (codeView.length - 1); j >= 0; j--)\n\t\t\t\tvalueHexView[i * 2 + j + dif] = codeView[j];\n\t\t}\n\n\t\tthis.valueBlock.value = inputString;\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\treturn `${this.constructor.blockName()} : ${this.valueBlock.value}`;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nclass LocalUniversalStringValueBlock extends HexBlock(LocalBaseBlock)\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalUniversalStringValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.isHexOnly = true;\n\t\tthis.value = \"\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"UniversalStringValueBlock\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.value = this.value;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends BaseBlock\n */\nexport class UniversalString extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"UniversalString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalUniversalStringValueBlock);\n\n\t\tif(\"value\" in parameters)\n\t\t\tthis.fromString(parameters.value);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 28; // UniversalString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"UniversalString\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\n\t\tif(resultOffset === (-1))\n\t\t{\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\tif(this.idBlock.error.length === 0)\n\t\t\tthis.blockLength += this.idBlock.blockLength;\n\n\t\tif(this.lenBlock.error.length === 0)\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\n\n\t\tif(this.valueBlock.error.length === 0)\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting ArrayBuffer into ASN.1 internal string\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t */\n\tfromBuffer(inputBuffer)\n\t{\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tconst copyBuffer = inputBuffer.slice(0);\n\t\tconst valueView = new Uint8Array(copyBuffer);\n\n\t\tfor(let i = 0; i < valueView.length; i += 4)\n\t\t{\n\t\t\tvalueView[i] = valueView[i + 3];\n\t\t\tvalueView[i + 1] = valueView[i + 2];\n\t\t\tvalueView[i + 2] = 0x00;\n\t\t\tvalueView[i + 3] = 0x00;\n\t\t}\n\n\t\tthis.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting JavaScript string into ASN.1 internal class\n\t * @param {!string} inputString ASN.1 BER encoded array\n\t */\n\tfromString(inputString)\n\t{\n\t\tconst strLength = inputString.length;\n\n\t\tthis.valueBlock.valueHex = new ArrayBuffer(strLength * 4);\n\t\tconst valueHexView = new Uint8Array(this.valueBlock.valueHex);\n\n\t\tfor(let i = 0; i < strLength; i++)\n\t\t{\n\t\t\tconst codeBuf = utilToBase(inputString.charCodeAt(i), 8);\n\t\t\tconst codeView = new Uint8Array(codeBuf);\n\t\t\tif(codeView.length > 4)\n\t\t\t\tcontinue;\n\n\t\t\tconst dif = 4 - codeView.length;\n\n\t\t\tfor(let j = (codeView.length - 1); j >= 0; j--)\n\t\t\t\tvalueHexView[i * 4 + j + dif] = codeView[j];\n\t\t}\n\n\t\tthis.valueBlock.value = inputString;\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\treturn `${this.constructor.blockName()} : ${this.valueBlock.value}`;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\nclass LocalSimpleStringValueBlock extends HexBlock(LocalBaseBlock)\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalSimpleStringValueBlock\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.value = \"\";\n\t\tthis.isHexOnly = true;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"SimpleStringValueBlock\";\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.value = this.value;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends BaseBlock\n */\nclass LocalSimpleStringBlock extends BaseBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"LocalSimpleStringBlock\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters, LocalSimpleStringValueBlock);\n\n\t\tif(\"value\" in parameters)\n\t\t\tthis.fromString(parameters.value);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"SIMPLESTRING\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\n\t\tif(resultOffset === (-1))\n\t\t{\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\tif(this.idBlock.error.length === 0)\n\t\t\tthis.blockLength += this.idBlock.blockLength;\n\n\t\tif(this.lenBlock.error.length === 0)\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\n\n\t\tif(this.valueBlock.error.length === 0)\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting ArrayBuffer into ASN.1 internal string\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t */\n\tfromBuffer(inputBuffer)\n\t{\n\t\tthis.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting JavaScript string into ASN.1 internal class\n\t * @param {!string} inputString ASN.1 BER encoded array\n\t */\n\tfromString(inputString)\n\t{\n\t\tconst strLen = inputString.length;\n\n\t\tthis.valueBlock.valueHex = new ArrayBuffer(strLen);\n\t\tconst view = new Uint8Array(this.valueBlock.valueHex);\n\n\t\tfor(let i = 0; i < strLen; i++)\n\t\t\tview[i] = inputString.charCodeAt(i);\n\n\t\tthis.valueBlock.value = inputString;\n\t}\n\t//**********************************************************************************\n\ttoString() {\n\t\treturn `${this.constructor.blockName()} : ${this.valueBlock.value}`;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends LocalSimpleStringBlock\n */\nexport class NumericString extends LocalSimpleStringBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"NumericString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 18; // NumericString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"NumericString\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends LocalSimpleStringBlock\n */\nexport class PrintableString extends LocalSimpleStringBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"PrintableString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 19; // PrintableString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"PrintableString\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends LocalSimpleStringBlock\n */\nexport class TeletexString extends LocalSimpleStringBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"TeletexString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 20; // TeletexString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"TeletexString\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends LocalSimpleStringBlock\n */\nexport class VideotexString extends LocalSimpleStringBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"VideotexString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 21; // VideotexString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"VideotexString\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends LocalSimpleStringBlock\n */\nexport class IA5String extends LocalSimpleStringBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"IA5String\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 22; // IA5String\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"IA5String\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends LocalSimpleStringBlock\n */\nexport class GraphicString extends LocalSimpleStringBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"GraphicString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 25; // GraphicString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"GraphicString\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends LocalSimpleStringBlock\n */\nexport class VisibleString extends LocalSimpleStringBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"VisibleString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 26; // VisibleString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"VisibleString\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends LocalSimpleStringBlock\n */\nexport class GeneralString extends LocalSimpleStringBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"GeneralString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 27; // GeneralString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"GeneralString\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends LocalSimpleStringBlock\n */\nexport class CharacterString extends LocalSimpleStringBlock\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"CharacterString\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 29; // CharacterString\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"CharacterString\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of all date and time classes\n//**************************************************************************************\n/**\n * @extends VisibleString\n */\nexport class UTCTime extends VisibleString\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"UTCTime\" class\n\t * @param {Object} [parameters={}]\n\t * @property {string} [value] String representatio of the date\n\t * @property {Date} [valueDate] JavaScript \"Date\" object\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.year = 0;\n\t\tthis.month = 0;\n\t\tthis.day = 0;\n\t\tthis.hour = 0;\n\t\tthis.minute = 0;\n\t\tthis.second = 0;\n\n\t\t//region Create UTCTime from ASN.1 UTC string value\n\t\tif(\"value\" in parameters)\n\t\t{\n\t\t\tthis.fromString(parameters.value);\n\n\t\t\tthis.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);\n\t\t\tconst view = new Uint8Array(this.valueBlock.valueHex);\n\n\t\t\tfor(let i = 0; i < parameters.value.length; i++)\n\t\t\t\tview[i] = parameters.value.charCodeAt(i);\n\t\t}\n\t\t//endregion\n\t\t//region Create GeneralizedTime from JavaScript Date type\n\t\tif(\"valueDate\" in parameters)\n\t\t{\n\t\t\tthis.fromDate(parameters.valueDate);\n\t\t\tthis.valueBlock.valueHex = this.toBuffer();\n\t\t}\n\t\t//endregion\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 23; // UTCTime\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\n\t\tif(resultOffset === (-1))\n\t\t{\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\tif(this.idBlock.error.length === 0)\n\t\t\tthis.blockLength += this.idBlock.blockLength;\n\n\t\tif(this.lenBlock.error.length === 0)\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\n\n\t\tif(this.valueBlock.error.length === 0)\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting ArrayBuffer into ASN.1 internal string\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t */\n\tfromBuffer(inputBuffer)\n\t{\n\t\tthis.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting ASN.1 internal string into ArrayBuffer\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBuffer()\n\t{\n\t\tconst str = this.toString();\n\n\t\tconst buffer = new ArrayBuffer(str.length);\n\t\tconst view = new Uint8Array(buffer);\n\n\t\tfor(let i = 0; i < str.length; i++)\n\t\t\tview[i] = str.charCodeAt(i);\n\n\t\treturn buffer;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting \"Date\" object into ASN.1 internal string\n\t * @param {!Date} inputDate JavaScript \"Date\" object\n\t */\n\tfromDate(inputDate)\n\t{\n\t\tthis.year = inputDate.getUTCFullYear();\n\t\tthis.month = inputDate.getUTCMonth() + 1;\n\t\tthis.day = inputDate.getUTCDate();\n\t\tthis.hour = inputDate.getUTCHours();\n\t\tthis.minute = inputDate.getUTCMinutes();\n\t\tthis.second = inputDate.getUTCSeconds();\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Function converting ASN.1 internal string into \"Date\" object\n\t * @returns {Date}\n\t */\n\ttoDate()\n\t{\n\t\treturn (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second)));\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting JavaScript string into ASN.1 internal class\n\t * @param {!string} inputString ASN.1 BER encoded array\n\t */\n\tfromString(inputString)\n\t{\n\t\t//region Parse input string\n\t\tconst parser = /(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z/ig;\n\t\tconst parserArray = parser.exec(inputString);\n\t\tif(parserArray === null)\n\t\t{\n\t\t\tthis.error = \"Wrong input string for convertion\";\n\t\t\treturn;\n\t\t}\n\t\t//endregion\n\n\t\t//region Store parsed values\n\t\tconst year = parseInt(parserArray[1], 10);\n\t\tif(year >= 50)\n\t\t\tthis.year = 1900 + year;\n\t\telse\n\t\t\tthis.year = 2000 + year;\n\n\t\tthis.month = parseInt(parserArray[2], 10);\n\t\tthis.day = parseInt(parserArray[3], 10);\n\t\tthis.hour = parseInt(parserArray[4], 10);\n\t\tthis.minute = parseInt(parserArray[5], 10);\n\t\tthis.second = parseInt(parserArray[6], 10);\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting ASN.1 internal class into JavaScript string\n\t * @returns {string}\n\t */\n\ttoString()\n\t{\n\t\tconst outputArray = new Array(7);\n\n\t\toutputArray[0] = padNumber(((this.year < 2000) ? (this.year - 1900) : (this.year - 2000)), 2);\n\t\toutputArray[1] = padNumber(this.month, 2);\n\t\toutputArray[2] = padNumber(this.day, 2);\n\t\toutputArray[3] = padNumber(this.hour, 2);\n\t\toutputArray[4] = padNumber(this.minute, 2);\n\t\toutputArray[5] = padNumber(this.second, 2);\n\t\toutputArray[6] = \"Z\";\n\n\t\treturn outputArray.join(\"\");\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"UTCTime\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.year = this.year;\n\t\tobject.month = this.month;\n\t\tobject.day = this.day;\n\t\tobject.hour = this.hour;\n\t\tobject.minute = this.minute;\n\t\tobject.second = this.second;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends VisibleString\n */\nexport class GeneralizedTime extends VisibleString\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"GeneralizedTime\" class\n\t * @param {Object} [parameters={}]\n\t * @property {string} [value] String representatio of the date\n\t * @property {Date} [valueDate] JavaScript \"Date\" object\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.year = 0;\n\t\tthis.month = 0;\n\t\tthis.day = 0;\n\t\tthis.hour = 0;\n\t\tthis.minute = 0;\n\t\tthis.second = 0;\n\t\tthis.millisecond = 0;\n\n\t\t//region Create UTCTime from ASN.1 UTC string value\n\t\tif(\"value\" in parameters)\n\t\t{\n\t\t\tthis.fromString(parameters.value);\n\n\t\t\tthis.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);\n\t\t\tconst view = new Uint8Array(this.valueBlock.valueHex);\n\n\t\t\tfor(let i = 0; i < parameters.value.length; i++)\n\t\t\t\tview[i] = parameters.value.charCodeAt(i);\n\t\t}\n\t\t//endregion\n\t\t//region Create GeneralizedTime from JavaScript Date type\n\t\tif(\"valueDate\" in parameters)\n\t\t{\n\t\t\tthis.fromDate(parameters.valueDate);\n\t\t\tthis.valueBlock.valueHex = this.toBuffer();\n\t\t}\n\t\t//endregion\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 24; // GeneralizedTime\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tconst resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm === true) ? inputLength : this.lenBlock.length);\n\t\tif(resultOffset === (-1))\n\t\t{\n\t\t\tthis.error = this.valueBlock.error;\n\t\t\treturn resultOffset;\n\t\t}\n\n\t\tthis.fromBuffer(this.valueBlock.valueHex);\n\n\t\tif(this.idBlock.error.length === 0)\n\t\t\tthis.blockLength += this.idBlock.blockLength;\n\n\t\tif(this.lenBlock.error.length === 0)\n\t\t\tthis.blockLength += this.lenBlock.blockLength;\n\n\t\tif(this.valueBlock.error.length === 0)\n\t\t\tthis.blockLength += this.valueBlock.blockLength;\n\n\t\treturn resultOffset;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting ArrayBuffer into ASN.1 internal string\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t */\n\tfromBuffer(inputBuffer)\n\t{\n\t\tthis.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting ASN.1 internal string into ArrayBuffer\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBuffer()\n\t{\n\t\tconst str = this.toString();\n\n\t\tconst buffer = new ArrayBuffer(str.length);\n\t\tconst view = new Uint8Array(buffer);\n\n\t\tfor(let i = 0; i < str.length; i++)\n\t\t\tview[i] = str.charCodeAt(i);\n\n\t\treturn buffer;\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting \"Date\" object into ASN.1 internal string\n\t * @param {!Date} inputDate JavaScript \"Date\" object\n\t */\n\tfromDate(inputDate)\n\t{\n\t\tthis.year = inputDate.getUTCFullYear();\n\t\tthis.month = inputDate.getUTCMonth() + 1;\n\t\tthis.day = inputDate.getUTCDate();\n\t\tthis.hour = inputDate.getUTCHours();\n\t\tthis.minute = inputDate.getUTCMinutes();\n\t\tthis.second = inputDate.getUTCSeconds();\n\t\tthis.millisecond = inputDate.getUTCMilliseconds();\n\t}\n\t//**********************************************************************************\n\t//noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Function converting ASN.1 internal string into \"Date\" object\n\t * @returns {Date}\n\t */\n\ttoDate()\n\t{\n\t\treturn (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)));\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting JavaScript string into ASN.1 internal class\n\t * @param {!string} inputString ASN.1 BER encoded array\n\t */\n\tfromString(inputString)\n\t{\n\t\t//region Initial variables\n\t\tlet isUTC = false;\n\n\t\tlet timeString = \"\";\n\t\tlet dateTimeString = \"\";\n\t\tlet fractionPart = 0;\n\n\t\tlet parser;\n\n\t\tlet hourDifference = 0;\n\t\tlet minuteDifference = 0;\n\t\t//endregion\n\n\t\t//region Convert as UTC time\n\t\tif(inputString[inputString.length - 1] === \"Z\")\n\t\t{\n\t\t\ttimeString = inputString.substr(0, inputString.length - 1);\n\n\t\t\tisUTC = true;\n\t\t}\n\t\t//endregion\n\t\t//region Convert as local time\n\t\telse\n\t\t{\n\t\t\t//noinspection JSPrimitiveTypeWrapperUsage\n\t\t\tconst number = new Number(inputString[inputString.length - 1]);\n\n\t\t\tif(isNaN(number.valueOf()))\n\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\n\t\t\ttimeString = inputString;\n\t\t}\n\t\t//endregion\n\n\t\t//region Check that we do not have a \"+\" and \"-\" symbols inside UTC time\n\t\tif(isUTC)\n\t\t{\n\t\t\tif(timeString.indexOf(\"+\") !== (-1))\n\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\n\t\t\tif(timeString.indexOf(\"-\") !== (-1))\n\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\t\t}\n\t\t//endregion\n\t\t//region Get \"UTC time difference\" in case of local time\n\t\telse\n\t\t{\n\t\t\tlet multiplier = 1;\n\t\t\tlet differencePosition = timeString.indexOf(\"+\");\n\t\t\tlet differenceString = \"\";\n\n\t\t\tif(differencePosition === (-1))\n\t\t\t{\n\t\t\t\tdifferencePosition = timeString.indexOf(\"-\");\n\t\t\t\tmultiplier = (-1);\n\t\t\t}\n\n\t\t\tif(differencePosition !== (-1))\n\t\t\t{\n\t\t\t\tdifferenceString = timeString.substr(differencePosition + 1);\n\t\t\t\ttimeString = timeString.substr(0, differencePosition);\n\n\t\t\t\tif((differenceString.length !== 2) && (differenceString.length !== 4))\n\t\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\n\t\t\t\t//noinspection JSPrimitiveTypeWrapperUsage\n\t\t\t\tlet number = new Number(differenceString.substr(0, 2));\n\n\t\t\t\tif(isNaN(number.valueOf()))\n\t\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\n\t\t\t\thourDifference = multiplier * number;\n\n\t\t\t\tif(differenceString.length === 4)\n\t\t\t\t{\n\t\t\t\t\t//noinspection JSPrimitiveTypeWrapperUsage\n\t\t\t\t\tnumber = new Number(differenceString.substr(2, 2));\n\n\t\t\t\t\tif(isNaN(number.valueOf()))\n\t\t\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\n\t\t\t\t\tminuteDifference = multiplier * number;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//endregion\n\n\t\t//region Get position of fraction point\n\t\tlet fractionPointPosition = timeString.indexOf(\".\"); // Check for \"full stop\" symbol\n\t\tif(fractionPointPosition === (-1))\n\t\t\tfractionPointPosition = timeString.indexOf(\",\"); // Check for \"comma\" symbol\n\t\t//endregion\n\n\t\t//region Get fraction part\n\t\tif(fractionPointPosition !== (-1))\n\t\t{\n\t\t\t//noinspection JSPrimitiveTypeWrapperUsage\n\t\t\tconst fractionPartCheck = new Number(`0${timeString.substr(fractionPointPosition)}`);\n\n\t\t\tif(isNaN(fractionPartCheck.valueOf()))\n\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\n\t\t\tfractionPart = fractionPartCheck.valueOf();\n\n\t\t\tdateTimeString = timeString.substr(0, fractionPointPosition);\n\t\t}\n\t\telse\n\t\t\tdateTimeString = timeString;\n\t\t//endregion\n\n\t\t//region Parse internal date\n\t\tswitch(true)\n\t\t{\n\t\t\tcase (dateTimeString.length === 8): // \"YYYYMMDD\"\n\t\t\t\tparser = /(\\d{4})(\\d{2})(\\d{2})/ig;\n\t\t\t\tif(fractionPointPosition !== (-1))\n\t\t\t\t\tthrow new Error(\"Wrong input string for convertion\"); // Here we should not have a \"fraction point\"\n\t\t\t\tbreak;\n\t\t\tcase (dateTimeString.length === 10): // \"YYYYMMDDHH\"\n\t\t\t\tparser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n\t\t\t\tif(fractionPointPosition !== (-1))\n\t\t\t\t{\n\t\t\t\t\tlet fractionResult = 60 * fractionPart;\n\t\t\t\t\tthis.minute = Math.floor(fractionResult);\n\n\t\t\t\t\tfractionResult = 60 * (fractionResult - this.minute);\n\t\t\t\t\tthis.second = Math.floor(fractionResult);\n\n\t\t\t\t\tfractionResult = 1000 * (fractionResult - this.second);\n\t\t\t\t\tthis.millisecond = Math.floor(fractionResult);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase (dateTimeString.length === 12): // \"YYYYMMDDHHMM\"\n\t\t\t\tparser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n\t\t\t\tif(fractionPointPosition !== (-1))\n\t\t\t\t{\n\t\t\t\t\tlet fractionResult = 60 * fractionPart;\n\t\t\t\t\tthis.second = Math.floor(fractionResult);\n\n\t\t\t\t\tfractionResult = 1000 * (fractionResult - this.second);\n\t\t\t\t\tthis.millisecond = Math.floor(fractionResult);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase (dateTimeString.length === 14): // \"YYYYMMDDHHMMSS\"\n\t\t\t\tparser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n\t\t\t\tif(fractionPointPosition !== (-1))\n\t\t\t\t{\n\t\t\t\t\tconst fractionResult = 1000 * fractionPart;\n\t\t\t\t\tthis.millisecond = Math.floor(fractionResult);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\t\t}\n\t\t//endregion\n\n\t\t//region Put parsed values at right places\n\t\tconst parserArray = parser.exec(dateTimeString);\n\t\tif(parserArray === null)\n\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\n\t\tfor(let j = 1; j < parserArray.length; j++)\n\t\t{\n\t\t\tswitch(j)\n\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\tthis.year = parseInt(parserArray[j], 10);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tthis.month = parseInt(parserArray[j], 10);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tthis.day = parseInt(parserArray[j], 10);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tthis.hour = parseInt(parserArray[j], 10) + hourDifference;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tthis.minute = parseInt(parserArray[j], 10) + minuteDifference;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tthis.second = parseInt(parserArray[j], 10);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"Wrong input string for convertion\");\n\t\t\t}\n\t\t}\n\t\t//endregion\n\n\t\t//region Get final date\n\t\tif(isUTC === false)\n\t\t{\n\t\t\tconst tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\n\n\t\t\tthis.year = tempDate.getUTCFullYear();\n\t\t\tthis.month = tempDate.getUTCMonth();\n\t\t\tthis.day = tempDate.getUTCDay();\n\t\t\tthis.hour = tempDate.getUTCHours();\n\t\t\tthis.minute = tempDate.getUTCMinutes();\n\t\t\tthis.second = tempDate.getUTCSeconds();\n\t\t\tthis.millisecond = tempDate.getUTCMilliseconds();\n\t\t}\n\t\t//endregion\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Function converting ASN.1 internal class into JavaScript string\n\t * @returns {string}\n\t */\n\ttoString()\n\t{\n\t\tconst outputArray = [];\n\n\t\toutputArray.push(padNumber(this.year, 4));\n\t\toutputArray.push(padNumber(this.month, 2));\n\t\toutputArray.push(padNumber(this.day, 2));\n\t\toutputArray.push(padNumber(this.hour, 2));\n\t\toutputArray.push(padNumber(this.minute, 2));\n\t\toutputArray.push(padNumber(this.second, 2));\n\t\tif(this.millisecond !== 0)\n\t\t{\n\t\t\toutputArray.push(\".\");\n\t\t\toutputArray.push(padNumber(this.millisecond, 3));\n\t\t}\n\t\toutputArray.push(\"Z\");\n\n\t\treturn outputArray.join(\"\");\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"GeneralizedTime\";\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Convertion for the block to JSON object\n\t * @returns {Object}\n\t */\n\ttoJSON()\n\t{\n\t\tlet object = {};\n\t\t\n\t\t//region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\t\ttry\n\t\t{\n\t\t\tobject = super.toJSON();\n\t\t}\n\t\tcatch(ex){}\n\t\t//endregion\n\n\t\tobject.year = this.year;\n\t\tobject.month = this.month;\n\t\tobject.day = this.day;\n\t\tobject.hour = this.hour;\n\t\tobject.minute = this.minute;\n\t\tobject.second = this.second;\n\t\tobject.millisecond = this.millisecond;\n\n\t\treturn object;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends Utf8String\n */\nexport class DATE extends Utf8String\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"DATE\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 31; // DATE\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"DATE\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends Utf8String\n */\nexport class TimeOfDay extends Utf8String\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"TimeOfDay\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 32; // TimeOfDay\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"TimeOfDay\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends Utf8String\n */\nexport class DateTime extends Utf8String\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"DateTime\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 33; // DateTime\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"DateTime\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends Utf8String\n */\nexport class Duration extends Utf8String\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Duration\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 34; // Duration\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"Duration\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n/**\n * @extends Utf8String\n */\nexport class TIME extends Utf8String\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Time\" class\n\t * @param {Object} [parameters={}]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tsuper(parameters);\n\n\t\tthis.idBlock.tagClass = 1; // UNIVERSAL\n\t\tthis.idBlock.tagNumber = 14; // Time\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Aux function, need to get a block name. Need to have it here for inhiritence\n\t * @returns {string}\n\t */\n\tstatic blockName()\n\t{\n\t\treturn \"TIME\";\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Choice\n//**************************************************************************************\nexport class Choice\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Choice\" class\n\t * @param {Object} [parameters={}]\n\t * @property {Array} [value] Array of ASN.1 types for make a choice from\n\t * @property {boolean} [optional]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tthis.value = getParametersValue(parameters, \"value\", []);\n\t\tthis.optional = getParametersValue(parameters, \"optional\", false);\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Any\n//**************************************************************************************\nexport class Any\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Any\" class\n\t * @param {Object} [parameters={}]\n\t * @property {string} [name]\n\t * @property {boolean} [optional]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tthis.name = getParametersValue(parameters, \"name\", \"\");\n\t\tthis.optional = getParametersValue(parameters, \"optional\", false);\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Repeated\n//**************************************************************************************\nexport class Repeated\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Repeated\" class\n\t * @param {Object} [parameters={}]\n\t * @property {string} [name]\n\t * @property {boolean} [optional]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tthis.name = getParametersValue(parameters, \"name\", \"\");\n\t\tthis.optional = getParametersValue(parameters, \"optional\", false);\n\t\tthis.value = getParametersValue(parameters, \"value\", new Any());\n\t\tthis.local = getParametersValue(parameters, \"local\", false); // Could local or global array to store elements\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type RawData\n//**************************************************************************************\n/**\n * @description Special class providing ability to have \"toBER/fromBER\" for raw ArrayBuffer\n */\nexport class RawData\n{\n\t//**********************************************************************************\n\t/**\n\t * Constructor for \"Repeated\" class\n\t * @param {Object} [parameters={}]\n\t * @property {string} [name]\n\t * @property {boolean} [optional]\n\t */\n\tconstructor(parameters = {})\n\t{\n\t\tthis.data = getParametersValue(parameters, \"data\", new ArrayBuffer(0));\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Base function for converting block from BER encoded array of bytes\n\t * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n\t * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n\t * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n\t * @returns {number} Offset after least decoded byte\n\t */\n\tfromBER(inputBuffer, inputOffset, inputLength)\n\t{\n\t\tthis.data = inputBuffer.slice(inputOffset, inputLength);\n\t\treturn (inputOffset + inputLength);\n\t}\n\t//**********************************************************************************\n\t/**\n\t * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\n\t * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\n\t * @returns {ArrayBuffer}\n\t */\n\ttoBER(sizeOnly = false)\n\t{\n\t\treturn this.data;\n\t}\n\t//**********************************************************************************\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major ASN.1 BER decoding function\n//**************************************************************************************\n/**\n * Internal library function for decoding ASN.1 BER\n * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\n * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\n * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\n * @returns {{offset: number, result: Object}}\n */\nfunction LocalFromBER(inputBuffer, inputOffset, inputLength)\n{\n\tconst incomingOffset = inputOffset; // Need to store initial offset since \"inputOffset\" is changing in the function\n\n\t//region Local function changing a type for ASN.1 classes\n\tfunction localChangeType(inputObject, newType)\n\t{\n\t\tif(inputObject instanceof newType)\n\t\t\treturn inputObject;\n\n\t\tconst newObject = new newType();\n\t\tnewObject.idBlock = inputObject.idBlock;\n\t\tnewObject.lenBlock = inputObject.lenBlock;\n\t\tnewObject.warnings = inputObject.warnings;\n\t\t//noinspection JSCheckFunctionSignatures\n\t\tnewObject.valueBeforeDecode = inputObject.valueBeforeDecode.slice(0);\n\n\t\treturn newObject;\n\t}\n\t//endregion\n\n\t//region Create a basic ASN.1 type since we need to return errors and warnings from the function\n\tlet returnObject = new BaseBlock({}, Object);\n\t//endregion\n\n\t//region Basic check for parameters\n\tconst baseBlock = new LocalBaseBlock();\n\tif(checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) === false)\n\t{\n\t\treturnObject.error = baseBlock.error;\n\t\treturn {\n\t\t\toffset: (-1),\n\t\t\tresult: returnObject\n\t\t};\n\t}\n\t//endregion\n\n\t//region Getting Uint8Array from ArrayBuffer\n\tconst intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n\t//endregion\n\n\t//region Initial checks\n\tif(intBuffer.length === 0)\n\t{\n\t\treturnObject.error = \"Zero buffer length\";\n\t\treturn {\n\t\t\toffset: (-1),\n\t\t\tresult: returnObject\n\t\t};\n\t}\n\t//endregion\n\n\t//region Decode indentifcation block of ASN.1 BER structure\n\tlet resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);\n\treturnObject.warnings.concat(returnObject.idBlock.warnings);\n\tif(resultOffset === (-1))\n\t{\n\t\treturnObject.error = returnObject.idBlock.error;\n\t\treturn {\n\t\t\toffset: (-1),\n\t\t\tresult: returnObject\n\t\t};\n\t}\n\n\tinputOffset = resultOffset;\n\tinputLength -= returnObject.idBlock.blockLength;\n\t//endregion\n\n\t//region Decode length block of ASN.1 BER structure\n\tresultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);\n\treturnObject.warnings.concat(returnObject.lenBlock.warnings);\n\tif(resultOffset === (-1))\n\t{\n\t\treturnObject.error = returnObject.lenBlock.error;\n\t\treturn {\n\t\t\toffset: (-1),\n\t\t\tresult: returnObject\n\t\t};\n\t}\n\n\tinputOffset = resultOffset;\n\tinputLength -= returnObject.lenBlock.blockLength;\n\t//endregion\n\n\t//region Check for usign indefinite length form in encoding for primitive types\n\tif((returnObject.idBlock.isConstructed === false) &&\n\t\t(returnObject.lenBlock.isIndefiniteForm === true))\n\t{\n\t\treturnObject.error = \"Indefinite length form used for primitive encoding form\";\n\t\treturn {\n\t\t\toffset: (-1),\n\t\t\tresult: returnObject\n\t\t};\n\t}\n\t//endregion\n\n\t//region Switch ASN.1 block type\n\tlet newASN1Type = BaseBlock;\n\n\tswitch(returnObject.idBlock.tagClass)\n\t{\n\t\t//region UNIVERSAL\n\t\tcase 1:\n\t\t\t//region Check for reserved tag numbers\n\t\t\tif((returnObject.idBlock.tagNumber >= 37) &&\n\t\t\t\t(returnObject.idBlock.isHexOnly === false))\n\t\t\t{\n\t\t\t\treturnObject.error = \"UNIVERSAL 37 and upper tags are reserved by ASN.1 standard\";\n\t\t\t\treturn {\n\t\t\t\t\toffset: (-1),\n\t\t\t\t\tresult: returnObject\n\t\t\t\t};\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\tswitch(returnObject.idBlock.tagNumber)\n\t\t\t{\n\t\t\t\t//region EndOfContent type\n\t\t\t\tcase 0:\n\t\t\t\t\t//region Check for EndOfContent type\n\t\t\t\t\tif((returnObject.idBlock.isConstructed === true) &&\n\t\t\t\t\t\t(returnObject.lenBlock.length > 0))\n\t\t\t\t\t{\n\t\t\t\t\t\treturnObject.error = \"Type [UNIVERSAL 0] is reserved\";\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\toffset: (-1),\n\t\t\t\t\t\t\tresult: returnObject\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\t//endregion\n\n\t\t\t\t\tnewASN1Type = EndOfContent;\n\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Boolean type\n\t\t\t\tcase 1:\n\t\t\t\t\tnewASN1Type = Boolean;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Integer type\n\t\t\t\tcase 2:\n\t\t\t\t\tnewASN1Type = Integer;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region BitString type\n\t\t\t\tcase 3:\n\t\t\t\t\tnewASN1Type = BitString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region OctetString type\n\t\t\t\tcase 4:\n\t\t\t\t\tnewASN1Type = OctetString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Null type\n\t\t\t\tcase 5:\n\t\t\t\t\tnewASN1Type = Null;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region OBJECT IDENTIFIER type\n\t\t\t\tcase 6:\n\t\t\t\t\tnewASN1Type = ObjectIdentifier;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Enumerated type\n\t\t\t\tcase 10:\n\t\t\t\t\tnewASN1Type = Enumerated;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Utf8String type\n\t\t\t\tcase 12:\n\t\t\t\t\tnewASN1Type = Utf8String;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Time type\n\t\t\t\t//region RELATIVE OBJECT IDENTIFIER type\n\t\t\t\tcase 13:\n\t\t\t\t\tnewASN1Type = RelativeObjectIdentifier;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\tcase 14:\n\t\t\t\t\tnewASN1Type = TIME;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region ASN.1 reserved type\n\t\t\t\tcase 15:\n\t\t\t\t\treturnObject.error = \"[UNIVERSAL 15] is reserved by ASN.1 standard\";\n\t\t\t\t\treturn {\n\t\t\t\t\t\toffset: (-1),\n\t\t\t\t\t\tresult: returnObject\n\t\t\t\t\t};\n\t\t\t\t//endregion\n\t\t\t\t//region Sequence type\n\t\t\t\tcase 16:\n\t\t\t\t\tnewASN1Type = Sequence;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Set type\n\t\t\t\tcase 17:\n\t\t\t\t\tnewASN1Type = Set;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region NumericString type\n\t\t\t\tcase 18:\n\t\t\t\t\tnewASN1Type = NumericString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region PrintableString type\n\t\t\t\tcase 19:\n\t\t\t\t\tnewASN1Type = PrintableString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region TeletexString type\n\t\t\t\tcase 20:\n\t\t\t\t\tnewASN1Type = TeletexString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region VideotexString type\n\t\t\t\tcase 21:\n\t\t\t\t\tnewASN1Type = VideotexString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region IA5String type\n\t\t\t\tcase 22:\n\t\t\t\t\tnewASN1Type = IA5String;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region UTCTime type\n\t\t\t\tcase 23:\n\t\t\t\t\tnewASN1Type = UTCTime;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region GeneralizedTime type\n\t\t\t\tcase 24:\n\t\t\t\t\tnewASN1Type = GeneralizedTime;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region GraphicString type\n\t\t\t\tcase 25:\n\t\t\t\t\tnewASN1Type = GraphicString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region VisibleString type\n\t\t\t\tcase 26:\n\t\t\t\t\tnewASN1Type = VisibleString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region GeneralString type\n\t\t\t\tcase 27:\n\t\t\t\t\tnewASN1Type = GeneralString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region UniversalString type\n\t\t\t\tcase 28:\n\t\t\t\t\tnewASN1Type = UniversalString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region CharacterString type\n\t\t\t\tcase 29:\n\t\t\t\t\tnewASN1Type = CharacterString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region BmpString type\n\t\t\t\tcase 30:\n\t\t\t\t\tnewASN1Type = BmpString;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region DATE type\n\t\t\t\tcase 31:\n\t\t\t\t\tnewASN1Type = DATE;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region TimeOfDay type\n\t\t\t\tcase 32:\n\t\t\t\t\tnewASN1Type = TimeOfDay;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Date-Time type\n\t\t\t\tcase 33:\n\t\t\t\t\tnewASN1Type = DateTime;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region Duration type\n\t\t\t\tcase 34:\n\t\t\t\t\tnewASN1Type = Duration;\n\t\t\t\t\tbreak;\n\t\t\t\t//endregion\n\t\t\t\t//region default\n\t\t\t\tdefault:\n\t\t\t\t\t{\n\t\t\t\t\t\tlet newObject;\n\n\t\t\t\t\t\tif(returnObject.idBlock.isConstructed === true)\n\t\t\t\t\t\t\tnewObject = new Constructed();\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnewObject = new Primitive();\n\n\t\t\t\t\t\tnewObject.idBlock = returnObject.idBlock;\n\t\t\t\t\t\tnewObject.lenBlock = returnObject.lenBlock;\n\t\t\t\t\t\tnewObject.warnings = returnObject.warnings;\n\n\t\t\t\t\t\treturnObject = newObject;\n\t\t\t\t\t}\n\t\t\t\t//endregion\n\t\t\t}\n\t\t\tbreak;\n\t\t//endregion\n\t\t//region All other tag classes\n\t\tcase 2: // APPLICATION\n\t\tcase 3: // CONTEXT-SPECIFIC\n\t\tcase 4: // PRIVATE\n\t\tdefault:\n\t\t\t{\n\t\t\t\tif(returnObject.idBlock.isConstructed === true)\n\t\t\t\t\tnewASN1Type = Constructed;\n\t\t\t\telse\n\t\t\t\t\tnewASN1Type = Primitive;\n\t\t\t}\n\t\t//endregion\n\t}\n\t//endregion\n\n\t//region Change type and perform BER decoding\n\treturnObject = localChangeType(returnObject, newASN1Type);\n\tresultOffset = returnObject.fromBER(inputBuffer, inputOffset, (returnObject.lenBlock.isIndefiniteForm === true) ? inputLength : returnObject.lenBlock.length);\n\t//endregion\n\n\t//region Coping incoming buffer for entire ASN.1 block\n\treturnObject.valueBeforeDecode = inputBuffer.slice(incomingOffset, incomingOffset + returnObject.blockLength);\n\t//endregion\n\n\treturn {\n\t\toffset: resultOffset,\n\t\tresult: returnObject\n\t};\n}\n//**************************************************************************************\n/**\n * Major function for decoding ASN.1 BER array into internal library structuries\n * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array of bytes\n */\nexport function fromBER(inputBuffer)\n{\n\tif(inputBuffer.byteLength === 0)\n\t{\n\t\tconst result = new BaseBlock({}, Object);\n\t\tresult.error = \"Input buffer has zero length\";\n\n\t\treturn {\n\t\t\toffset: (-1),\n\t\t\tresult\n\t\t};\n\t}\n\n\treturn LocalFromBER(inputBuffer, 0, inputBuffer.byteLength);\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major scheme verification function\n//**************************************************************************************\n/**\n * Compare of two ASN.1 object trees\n * @param {!Object} root Root of input ASN.1 object tree\n * @param {!Object} inputData Input ASN.1 object tree\n * @param {!Object} inputSchema Input ASN.1 schema to compare with\n * @return {{verified: boolean}|{verified:boolean, result: Object}}\n */\nexport function compareSchema(root, inputData, inputSchema)\n{\n\t//region Special case for Choice schema element type\n\tif(inputSchema instanceof Choice)\n\t{\n\t\tconst choiceResult = false;\n\n\t\tfor(let j = 0; j < inputSchema.value.length; j++)\n\t\t{\n\t\t\tconst result = compareSchema(root, inputData, inputSchema.value[j]);\n\t\t\tif(result.verified === true)\n\t\t\t{\n\t\t\t\treturn {\n\t\t\t\t\tverified: true,\n\t\t\t\t\tresult: root\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif(choiceResult === false)\n\t\t{\n\t\t\tconst _result = {\n\t\t\t\tverified: false,\n\t\t\t\tresult: {\n\t\t\t\t\terror: \"Wrong values for Choice type\"\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif(inputSchema.hasOwnProperty(\"name\"))\n\t\t\t\t_result.name = inputSchema.name;\n\n\t\t\treturn _result;\n\t\t}\n\t}\n\t//endregion\n\n\t//region Special case for Any schema element type\n\tif(inputSchema instanceof Any)\n\t{\n\t\t//region Add named component of ASN.1 schema\n\t\tif(inputSchema.hasOwnProperty(\"name\"))\n\t\t\troot[inputSchema.name] = inputData;\n\t\t//endregion\n\n\t\treturn {\n\t\t\tverified: true,\n\t\t\tresult: root\n\t\t};\n\t}\n\t//endregion\n\n\t//region Initial check\n\tif((root instanceof Object) === false)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong root object\" }\n\t\t};\n\t}\n\n\tif((inputData instanceof Object) === false)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 data\" }\n\t\t};\n\t}\n\n\tif((inputSchema instanceof Object) === false)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t};\n\t}\n\n\tif((\"idBlock\" in inputSchema) === false)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t};\n\t}\n\t//endregion\n\n\t//region Comparing idBlock properties in ASN.1 data and ASN.1 schema\n\t//region Encode and decode ASN.1 schema idBlock\n\t/// <remarks>This encoding/decoding is neccessary because could be an errors in schema definition</remarks>\n\tif((\"fromBER\" in inputSchema.idBlock) === false)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t};\n\t}\n\n\tif((\"toBER\" in inputSchema.idBlock) === false)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t};\n\t}\n\n\tconst encodedId = inputSchema.idBlock.toBER(false);\n\tif(encodedId.byteLength === 0)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Error encoding idBlock for ASN.1 schema\" }\n\t\t};\n\t}\n\n\tconst decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);\n\tif(decodedOffset === (-1))\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Error decoding idBlock for ASN.1 schema\" }\n\t\t};\n\t}\n\t//endregion\n\n\t//region tagClass\n\tif(inputSchema.idBlock.hasOwnProperty(\"tagClass\") === false)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t};\n\t}\n\n\tif(inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: root\n\t\t};\n\t}\n\t//endregion\n\t//region tagNumber\n\tif(inputSchema.idBlock.hasOwnProperty(\"tagNumber\") === false)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t};\n\t}\n\n\tif(inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: root\n\t\t};\n\t}\n\t//endregion\n\t//region isConstructed\n\tif(inputSchema.idBlock.hasOwnProperty(\"isConstructed\") === false)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t};\n\t}\n\n\tif(inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: root\n\t\t};\n\t}\n\t//endregion\n\t//region isHexOnly\n\tif((\"isHexOnly\" in inputSchema.idBlock) === false) // Since 'isHexOnly' is an inhirited property\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t};\n\t}\n\n\tif(inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: root\n\t\t};\n\t}\n\t//endregion\n\t//region valueHex\n\tif(inputSchema.idBlock.isHexOnly === true)\n\t{\n\t\tif((\"valueHex\" in inputSchema.idBlock) === false) // Since 'valueHex' is an inhirited property\n\t\t{\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: { error: \"Wrong ASN.1 schema\" }\n\t\t\t};\n\t\t}\n\n\t\tconst schemaView = new Uint8Array(inputSchema.idBlock.valueHex);\n\t\tconst asn1View = new Uint8Array(inputData.idBlock.valueHex);\n\n\t\tif(schemaView.length !== asn1View.length)\n\t\t{\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: root\n\t\t\t};\n\t\t}\n\n\t\tfor(let i = 0; i < schemaView.length; i++)\n\t\t{\n\t\t\tif(schemaView[i] !== asn1View[1])\n\t\t\t{\n\t\t\t\treturn {\n\t\t\t\t\tverified: false,\n\t\t\t\t\tresult: root\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\t//endregion\n\t//endregion\n\n\t//region Add named component of ASN.1 schema\n\tif(inputSchema.hasOwnProperty(\"name\"))\n\t{\n\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\tif(inputSchema.name !== \"\")\n\t\t\troot[inputSchema.name] = inputData;\n\t}\n\t//endregion\n\n\t//region Getting next ASN.1 block for comparition\n\tif(inputSchema.idBlock.isConstructed === true)\n\t{\n\t\tlet admission = 0;\n\t\tlet result = { verified: false };\n\n\t\tlet maxLength = inputSchema.valueBlock.value.length;\n\n\t\tif(maxLength > 0)\n\t\t{\n\t\t\tif(inputSchema.valueBlock.value[0] instanceof Repeated)\n\t\t\t\tmaxLength = inputData.valueBlock.value.length;\n\t\t}\n\n\t\t//region Special case when constructive value has no elements\n\t\tif(maxLength === 0)\n\t\t{\n\t\t\treturn {\n\t\t\t\tverified: true,\n\t\t\t\tresult: root\n\t\t\t};\n\t\t}\n\t\t//endregion\n\n\t\t//region Special case when \"inputData\" has no values and \"inputSchema\" has all optional values\n\t\tif((inputData.valueBlock.value.length === 0) &&\n\t\t\t(inputSchema.valueBlock.value.length !== 0))\n\t\t{\n\t\t\tlet _optional = true;\n\n\t\t\tfor(let i = 0; i < inputSchema.valueBlock.value.length; i++)\n\t\t\t\t_optional = _optional && (inputSchema.valueBlock.value[i].optional || false);\n\n\t\t\tif(_optional === true)\n\t\t\t{\n\t\t\t\treturn {\n\t\t\t\t\tverified: true,\n\t\t\t\t\tresult: root\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t//region Delete early added name of block\n\t\t\tif(inputSchema.hasOwnProperty(\"name\"))\n\t\t\t{\n\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\tif(inputSchema.name !== \"\")\n\t\t\t\t\tdelete root[inputSchema.name];\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\troot.error = \"Inconsistent object length\";\n\n\t\t\treturn {\n\t\t\t\tverified: false,\n\t\t\t\tresult: root\n\t\t\t};\n\t\t}\n\t\t//endregion\n\n\t\tfor(let i = 0; i < maxLength; i++)\n\t\t{\n\t\t\t//region Special case when there is an \"optional\" element of ASN.1 schema at the end\n\t\t\tif((i - admission) >= inputData.valueBlock.value.length)\n\t\t\t{\n\t\t\t\tif(inputSchema.valueBlock.value[i].optional === false)\n\t\t\t\t{\n\t\t\t\t\tconst _result = {\n\t\t\t\t\t\tverified: false,\n\t\t\t\t\t\tresult: root\n\t\t\t\t\t};\n\n\t\t\t\t\troot.error = \"Inconsistent length between ASN.1 data and schema\";\n\n\t\t\t\t\t//region Delete early added name of block\n\t\t\t\t\tif(inputSchema.hasOwnProperty(\"name\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\t\t\tif(inputSchema.name !== \"\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdelete root[inputSchema.name];\n\t\t\t\t\t\t\t_result.name = inputSchema.name;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//endregion\n\n\t\t\t\t\treturn _result;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\t\t\telse\n\t\t\t{\n\t\t\t\t//region Special case for Repeated type of ASN.1 schema element\n\t\t\t\tif(inputSchema.valueBlock.value[0] instanceof Repeated)\n\t\t\t\t{\n\t\t\t\t\tresult = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);\n\t\t\t\t\tif(result.verified === false)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(inputSchema.valueBlock.value[0].optional === true)\n\t\t\t\t\t\t\tadmission++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//region Delete early added name of block\n\t\t\t\t\t\t\tif(inputSchema.hasOwnProperty(\"name\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\t\t\t\t\tif(inputSchema.name !== \"\")\n\t\t\t\t\t\t\t\t\tdelete root[inputSchema.name];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//endregion\n\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif((\"name\" in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].name.length > 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tlet arrayRoot = {};\n\n\t\t\t\t\t\tif((\"local\" in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].local === true))\n\t\t\t\t\t\t\tarrayRoot = inputData;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tarrayRoot = root;\n\n\t\t\t\t\t\tif(typeof arrayRoot[inputSchema.valueBlock.value[0].name] === \"undefined\")\n\t\t\t\t\t\t\tarrayRoot[inputSchema.valueBlock.value[0].name] = [];\n\n\t\t\t\t\t\tarrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//endregion\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresult = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);\n\t\t\t\t\tif(result.verified === false)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(inputSchema.valueBlock.value[i].optional === true)\n\t\t\t\t\t\t\tadmission++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//region Delete early added name of block\n\t\t\t\t\t\t\tif(inputSchema.hasOwnProperty(\"name\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\t\t\t\t\tif(inputSchema.name !== \"\")\n\t\t\t\t\t\t\t\t\tdelete root[inputSchema.name];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//endregion\n\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(result.verified === false) // The situation may take place if last element is \"optional\" and verification failed\n\t\t{\n\t\t\tconst _result = {\n\t\t\t\tverified: false,\n\t\t\t\tresult: root\n\t\t\t};\n\n\t\t\t//region Delete early added name of block\n\t\t\tif(inputSchema.hasOwnProperty(\"name\"))\n\t\t\t{\n\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\tif(inputSchema.name !== \"\")\n\t\t\t\t{\n\t\t\t\t\tdelete root[inputSchema.name];\n\t\t\t\t\t_result.name = inputSchema.name;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\treturn _result;\n\t\t}\n\n\t\treturn {\n\t\t\tverified: true,\n\t\t\tresult: root\n\t\t};\n\t}\n\t//endregion\n\t//region Ability to parse internal value for primitive-encoded value (value of OctetString, for example)\n\tif((\"primitiveSchema\" in inputSchema) &&\n\t\t(\"valueHex\" in inputData.valueBlock))\n\t{\n\t\t//region Decoding of raw ASN.1 data\n\t\tconst asn1 = fromBER(inputData.valueBlock.valueHex);\n\t\tif(asn1.offset === (-1))\n\t\t{\n\t\t\tconst _result = {\n\t\t\t\tverified: false,\n\t\t\t\tresult: asn1.result\n\t\t\t};\n\n\t\t\t//region Delete early added name of block\n\t\t\tif(inputSchema.hasOwnProperty(\"name\"))\n\t\t\t{\n\t\t\t\tinputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\t\t\t\tif(inputSchema.name !== \"\")\n\t\t\t\t{\n\t\t\t\t\tdelete root[inputSchema.name];\n\t\t\t\t\t_result.name = inputSchema.name;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//endregion\n\n\t\t\treturn _result;\n\t\t}\n\t\t//endregion\n\n\t\treturn compareSchema(root, asn1.result, inputSchema.primitiveSchema);\n\t}\n\n\treturn {\n\t\tverified: true,\n\t\tresult: root\n\t};\n\t//endregion\n}\n//**************************************************************************************\n//noinspection JSUnusedGlobalSymbols\n/**\n * ASN.1 schema verification for ArrayBuffer data\n * @param {!ArrayBuffer} inputBuffer Input BER-encoded ASN.1 data\n * @param {!Object} inputSchema Input ASN.1 schema to verify against to\n * @return {{verified: boolean}|{verified:boolean, result: Object}}\n */\nexport function verifySchema(inputBuffer, inputSchema)\n{\n\t//region Initial check\n\tif((inputSchema instanceof Object) === false)\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: { error: \"Wrong ASN.1 schema type\" }\n\t\t};\n\t}\n\t//endregion\n\n\t//region Decoding of raw ASN.1 data\n\tconst asn1 = fromBER(inputBuffer);\n\tif(asn1.offset === (-1))\n\t{\n\t\treturn {\n\t\t\tverified: false,\n\t\t\tresult: asn1.result\n\t\t};\n\t}\n\t//endregion\n\n\t//region Compare ASN.1 struct with input schema\n\treturn compareSchema(asn1.result, asn1.result, inputSchema);\n\t//endregion\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major function converting JSON to ASN.1 objects\n//**************************************************************************************\n//noinspection JSUnusedGlobalSymbols\n/**\n * Converting from JSON to ASN.1 objects\n * @param {string|Object} json JSON string or object to convert to ASN.1 objects\n */\nexport function fromJSON(json)\n{\n\t// TODO Implement\n}\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n"]},"metadata":{},"sourceType":"module"}