{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\rkanthet\\\\Documents\\\\test_window_object\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\");\n\nvar _asyncToGenerator = require(\"C:/Users/rkanthet/Documents/test_window_object/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/rkanthet/Documents/test_window_object/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/rkanthet/Documents/test_window_object/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"C:/Users/rkanthet/Documents/test_window_object/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/rkanthet/Documents/test_window_object/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReadStreamTokenizer = void 0;\n\nvar AbstractTokenizer_1 = require(\"./AbstractTokenizer\");\n\nvar peek_readable_1 = require(\"peek-readable\");\n\nvar maxBufferSize = 256000;\n\nvar ReadStreamTokenizer = /*#__PURE__*/function (_AbstractTokenizer_1$) {\n  _inherits(ReadStreamTokenizer, _AbstractTokenizer_1$);\n\n  var _super = _createSuper(ReadStreamTokenizer);\n\n  function ReadStreamTokenizer(stream, fileInfo) {\n    var _this;\n\n    _classCallCheck(this, ReadStreamTokenizer);\n\n    _this = _super.call(this, fileInfo);\n    _this.streamReader = new peek_readable_1.StreamReader(stream);\n    return _this;\n  }\n  /**\r\n   * Get file information, an HTTP-client may implement this doing a HEAD request\r\n   * @return Promise with file information\r\n   */\n\n\n  _createClass(ReadStreamTokenizer, [{\n    key: \"getFileInfo\",\n    value: function () {\n      var _getFileInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", this.fileInfo);\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getFileInfo() {\n        return _getFileInfo.apply(this, arguments);\n      }\n\n      return getFileInfo;\n    }()\n    /**\r\n     * Read buffer from tokenizer\r\n     * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream\r\n     * @param options - Read behaviour options\r\n     * @returns Promise with number of bytes read\r\n     */\n\n  }, {\n    key: \"readBuffer\",\n    value: function () {\n      var _readBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(uint8Array, options) {\n        var normOptions, skipBytes, bytesRead;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                normOptions = this.normalizeOptions(uint8Array, options);\n                skipBytes = normOptions.position - this.position;\n\n                if (!(skipBytes > 0)) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                _context2.next = 5;\n                return this.ignore(skipBytes);\n\n              case 5:\n                return _context2.abrupt(\"return\", this.readBuffer(uint8Array, options));\n\n              case 8:\n                if (!(skipBytes < 0)) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                throw new Error('`options.position` must be equal or greater than `tokenizer.position`');\n\n              case 10:\n                if (!(normOptions.length === 0)) {\n                  _context2.next = 12;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", 0);\n\n              case 12:\n                _context2.next = 14;\n                return this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);\n\n              case 14:\n                bytesRead = _context2.sent;\n                this.position += bytesRead;\n\n                if (!((!options || !options.mayBeLess) && bytesRead < normOptions.length)) {\n                  _context2.next = 18;\n                  break;\n                }\n\n                throw new peek_readable_1.EndOfStreamError();\n\n              case 18:\n                return _context2.abrupt(\"return\", bytesRead);\n\n              case 19:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function readBuffer(_x, _x2) {\n        return _readBuffer.apply(this, arguments);\n      }\n\n      return readBuffer;\n    }()\n    /**\r\n     * Peek (read ahead) buffer from tokenizer\r\n     * @param uint8Array - Uint8Array (or Buffer) to write data to\r\n     * @param options - Read behaviour options\r\n     * @returns Promise with number of bytes peeked\r\n     */\n\n  }, {\n    key: \"peekBuffer\",\n    value: function () {\n      var _peekBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(uint8Array, options) {\n        var normOptions, bytesRead, skipBytes, skipBuffer;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                normOptions = this.normalizeOptions(uint8Array, options);\n                bytesRead = 0;\n\n                if (!normOptions.position) {\n                  _context3.next = 15;\n                  break;\n                }\n\n                skipBytes = normOptions.position - this.position;\n\n                if (!(skipBytes > 0)) {\n                  _context3.next = 13;\n                  break;\n                }\n\n                skipBuffer = new Uint8Array(normOptions.length + skipBytes);\n                _context3.next = 8;\n                return this.peekBuffer(skipBuffer, {\n                  mayBeLess: normOptions.mayBeLess\n                });\n\n              case 8:\n                bytesRead = _context3.sent;\n                uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);\n                return _context3.abrupt(\"return\", bytesRead - skipBytes);\n\n              case 13:\n                if (!(skipBytes < 0)) {\n                  _context3.next = 15;\n                  break;\n                }\n\n                throw new Error('Cannot peek from a negative offset in a stream');\n\n              case 15:\n                if (!(normOptions.length > 0)) {\n                  _context3.next = 29;\n                  break;\n                }\n\n                _context3.prev = 16;\n                _context3.next = 19;\n                return this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);\n\n              case 19:\n                bytesRead = _context3.sent;\n                _context3.next = 27;\n                break;\n\n              case 22:\n                _context3.prev = 22;\n                _context3.t0 = _context3[\"catch\"](16);\n\n                if (!(options && options.mayBeLess && _context3.t0 instanceof peek_readable_1.EndOfStreamError)) {\n                  _context3.next = 26;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", 0);\n\n              case 26:\n                throw _context3.t0;\n\n              case 27:\n                if (!(!normOptions.mayBeLess && bytesRead < normOptions.length)) {\n                  _context3.next = 29;\n                  break;\n                }\n\n                throw new peek_readable_1.EndOfStreamError();\n\n              case 29:\n                return _context3.abrupt(\"return\", bytesRead);\n\n              case 30:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[16, 22]]);\n      }));\n\n      function peekBuffer(_x3, _x4) {\n        return _peekBuffer.apply(this, arguments);\n      }\n\n      return peekBuffer;\n    }()\n  }, {\n    key: \"ignore\",\n    value: function () {\n      var _ignore = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(length) {\n        var bufSize, buf, totBytesRead, remaining, bytesRead;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                // debug(`ignore ${this.position}...${this.position + length - 1}`);\n                bufSize = Math.min(maxBufferSize, length);\n                buf = new Uint8Array(bufSize);\n                totBytesRead = 0;\n\n              case 3:\n                if (!(totBytesRead < length)) {\n                  _context4.next = 13;\n                  break;\n                }\n\n                remaining = length - totBytesRead;\n                _context4.next = 7;\n                return this.readBuffer(buf, {\n                  length: Math.min(bufSize, remaining)\n                });\n\n              case 7:\n                bytesRead = _context4.sent;\n\n                if (!(bytesRead < 0)) {\n                  _context4.next = 10;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", bytesRead);\n\n              case 10:\n                totBytesRead += bytesRead;\n                _context4.next = 3;\n                break;\n\n              case 13:\n                return _context4.abrupt(\"return\", totBytesRead);\n\n              case 14:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function ignore(_x5) {\n        return _ignore.apply(this, arguments);\n      }\n\n      return ignore;\n    }()\n  }]);\n\n  return ReadStreamTokenizer;\n}(AbstractTokenizer_1.AbstractTokenizer);\n\nexports.ReadStreamTokenizer = ReadStreamTokenizer;","map":{"version":3,"sources":["C:/Users/rkanthet/Documents/test_window_object/node_modules/strtok3/lib/ReadStreamTokenizer.js"],"names":["Object","defineProperty","exports","value","ReadStreamTokenizer","AbstractTokenizer_1","require","peek_readable_1","maxBufferSize","stream","fileInfo","streamReader","StreamReader","uint8Array","options","normOptions","normalizeOptions","skipBytes","position","ignore","readBuffer","Error","length","read","offset","bytesRead","mayBeLess","EndOfStreamError","skipBuffer","Uint8Array","peekBuffer","set","subarray","peek","bufSize","Math","min","buf","totBytesRead","remaining","AbstractTokenizer"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ReadStreamTokenizer = void 0;\r\nconst AbstractTokenizer_1 = require(\"./AbstractTokenizer\");\r\nconst peek_readable_1 = require(\"peek-readable\");\r\nconst maxBufferSize = 256000;\r\nclass ReadStreamTokenizer extends AbstractTokenizer_1.AbstractTokenizer {\r\n    constructor(stream, fileInfo) {\r\n        super(fileInfo);\r\n        this.streamReader = new peek_readable_1.StreamReader(stream);\r\n    }\r\n    /**\r\n     * Get file information, an HTTP-client may implement this doing a HEAD request\r\n     * @return Promise with file information\r\n     */\r\n    async getFileInfo() {\r\n        return this.fileInfo;\r\n    }\r\n    /**\r\n     * Read buffer from tokenizer\r\n     * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream\r\n     * @param options - Read behaviour options\r\n     * @returns Promise with number of bytes read\r\n     */\r\n    async readBuffer(uint8Array, options) {\r\n        const normOptions = this.normalizeOptions(uint8Array, options);\r\n        const skipBytes = normOptions.position - this.position;\r\n        if (skipBytes > 0) {\r\n            await this.ignore(skipBytes);\r\n            return this.readBuffer(uint8Array, options);\r\n        }\r\n        else if (skipBytes < 0) {\r\n            throw new Error('`options.position` must be equal or greater than `tokenizer.position`');\r\n        }\r\n        if (normOptions.length === 0) {\r\n            return 0;\r\n        }\r\n        const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);\r\n        this.position += bytesRead;\r\n        if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {\r\n            throw new peek_readable_1.EndOfStreamError();\r\n        }\r\n        return bytesRead;\r\n    }\r\n    /**\r\n     * Peek (read ahead) buffer from tokenizer\r\n     * @param uint8Array - Uint8Array (or Buffer) to write data to\r\n     * @param options - Read behaviour options\r\n     * @returns Promise with number of bytes peeked\r\n     */\r\n    async peekBuffer(uint8Array, options) {\r\n        const normOptions = this.normalizeOptions(uint8Array, options);\r\n        let bytesRead = 0;\r\n        if (normOptions.position) {\r\n            const skipBytes = normOptions.position - this.position;\r\n            if (skipBytes > 0) {\r\n                const skipBuffer = new Uint8Array(normOptions.length + skipBytes);\r\n                bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });\r\n                uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);\r\n                return bytesRead - skipBytes;\r\n            }\r\n            else if (skipBytes < 0) {\r\n                throw new Error('Cannot peek from a negative offset in a stream');\r\n            }\r\n        }\r\n        if (normOptions.length > 0) {\r\n            try {\r\n                bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);\r\n            }\r\n            catch (err) {\r\n                if (options && options.mayBeLess && err instanceof peek_readable_1.EndOfStreamError) {\r\n                    return 0;\r\n                }\r\n                throw err;\r\n            }\r\n            if ((!normOptions.mayBeLess) && bytesRead < normOptions.length) {\r\n                throw new peek_readable_1.EndOfStreamError();\r\n            }\r\n        }\r\n        return bytesRead;\r\n    }\r\n    async ignore(length) {\r\n        // debug(`ignore ${this.position}...${this.position + length - 1}`);\r\n        const bufSize = Math.min(maxBufferSize, length);\r\n        const buf = new Uint8Array(bufSize);\r\n        let totBytesRead = 0;\r\n        while (totBytesRead < length) {\r\n            const remaining = length - totBytesRead;\r\n            const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });\r\n            if (bytesRead < 0) {\r\n                return bytesRead;\r\n            }\r\n            totBytesRead += bytesRead;\r\n        }\r\n        return totBytesRead;\r\n    }\r\n}\r\nexports.ReadStreamTokenizer = ReadStreamTokenizer;\r\n"]},"metadata":{},"sourceType":"script"}