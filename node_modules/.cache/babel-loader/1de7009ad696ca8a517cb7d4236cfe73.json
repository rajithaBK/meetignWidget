{"ast":null,"code":"\"use strict\";\n\nvar _Reflect$construct = require(\"@babel/runtime-corejs2/core-js/reflect/construct\");\n\nvar _Object$keys2 = require(\"@babel/runtime-corejs2/core-js/object/keys\");\n\nvar _Object$getOwnPropertySymbols = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\");\n\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\");\n\nvar _Object$getOwnPropertyDescriptors = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\");\n\nvar _Object$defineProperties = require(\"@babel/runtime-corejs2/core-js/object/define-properties\");\n\nvar _Object$defineProperty2 = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty2(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = exports.MEDIA_UPDATE_TYPE = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime-corejs2/regenerator\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/define-property\"));\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/keys\"));\n\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/json/stringify\"));\n\nvar _assign = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/assign\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/typeof\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/slicedToArray\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/createClass\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/getPrototypeOf\"));\n\nvar _defineProperty3 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/defineProperty\"));\n\nvar _pick2 = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _isEqual2 = _interopRequireDefault(require(\"lodash/isEqual\"));\n\nvar _cloneDeep2 = _interopRequireDefault(require(\"lodash/cloneDeep\"));\n\nvar _uuid = _interopRequireDefault(require(\"uuid\"));\n\nvar _webexCore = require(\"@webex/webex-core\");\n\nvar _webexErrors = require(\"../common/errors/webex-errors\");\n\nvar _statsAnalyzer = _interopRequireDefault(require(\"../statsAnalyzer\"));\n\nvar _networkQualityMonitor = _interopRequireDefault(require(\"../networkQualityMonitor\"));\n\nvar _loggerProxy = _interopRequireDefault(require(\"../common/logs/logger-proxy\"));\n\nvar _triggerProxy = _interopRequireDefault(require(\"../common/events/trigger-proxy\"));\n\nvar _index = _interopRequireDefault(require(\"../roap/index\"));\n\nvar _media = _interopRequireDefault(require(\"../media\"));\n\nvar _properties = _interopRequireDefault(require(\"../media/properties\"));\n\nvar _state = _interopRequireDefault(require(\"../meeting/state\"));\n\nvar _muteState = _interopRequireDefault(require(\"../meeting/muteState\"));\n\nvar _locusInfo = _interopRequireDefault(require(\"../locus-info\"));\n\nvar _peerConnectionManager = _interopRequireDefault(require(\"../peer-connection-manager\"));\n\nvar _metrics = _interopRequireDefault(require(\"../metrics\"));\n\nvar _config = require(\"../metrics/config\");\n\nvar _reconnectionManager = _interopRequireDefault(require(\"../reconnection-manager\"));\n\nvar _request = _interopRequireDefault(require(\"../meeting/request\"));\n\nvar _index2 = _interopRequireDefault(require(\"../members/index\"));\n\nvar _util = _interopRequireDefault(require(\"../meeting/util\"));\n\nvar _util2 = _interopRequireDefault(require(\"../media/util\"));\n\nvar _index3 = _interopRequireDefault(require(\"../stats/index\"));\n\nvar _metrics2 = _interopRequireDefault(require(\"../stats/metrics\"));\n\nvar _util3 = _interopRequireDefault(require(\"../stats/util\"));\n\nvar _transcription = _interopRequireDefault(require(\"../transcription\"));\n\nvar _passwordError = _interopRequireDefault(require(\"../common/errors/password-error\"));\n\nvar _captchaError = _interopRequireDefault(require(\"../common/errors/captcha-error\"));\n\nvar _reconnection = _interopRequireDefault(require(\"../common/errors/reconnection\"));\n\nvar _reconnectionInProgress = _interopRequireDefault(require(\"../common/errors/reconnection-in-progress\"));\n\nvar _constants = require(\"../constants\");\n\nvar _parameter = _interopRequireDefault(require(\"../common/errors/parameter\"));\n\nvar _media2 = _interopRequireDefault(require(\"../common/errors/media\"));\n\nvar _meetingInfoV = require(\"../meeting-info/meeting-info-v2\");\n\nvar _mqaProcessor = _interopRequireDefault(require(\"../metrics/mqa-processor\"));\n\nvar _browserDetection = _interopRequireDefault(require(\"../common/browser-detection\"));\n\nvar _collection = _interopRequireDefault(require(\"../roap/collection\"));\n\nvar _inMeetingActions = _interopRequireDefault(require(\"./in-meeting-actions\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = _Object$keys2(object);\n\n  if (_Object$getOwnPropertySymbols) {\n    var symbols = _Object$getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return _Object$getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty3.default)(target, key, source[key]);\n      });\n    } else if (_Object$getOwnPropertyDescriptors) {\n      _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        _Object$defineProperty2(target, key, _Object$getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2.default)(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;\n      result = _Reflect$construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0, _possibleConstructorReturn2.default)(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false;\n  if (_Reflect$construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar _BrowserDetection = (0, _browserDetection.default)(),\n    isBrowser = _BrowserDetection.isBrowser;\n\nvar logRequest = function logRequest(request, _ref) {\n  var _ref$header = _ref.header,\n      header = _ref$header === void 0 ? '' : _ref$header,\n      _ref$success = _ref.success,\n      success = _ref$success === void 0 ? '' : _ref$success,\n      _ref$failure = _ref.failure,\n      failure = _ref$failure === void 0 ? '' : _ref$failure;\n\n  _loggerProxy.default.logger.info(header);\n\n  return request.then(function (arg) {\n    _loggerProxy.default.logger.info(success);\n\n    return arg;\n  }).catch(function (error) {\n    _loggerProxy.default.logger.error(failure, error);\n\n    throw error;\n  });\n};\n\nvar MEDIA_UPDATE_TYPE = {\n  ALL: 'ALL',\n  AUDIO: 'AUDIO',\n  VIDEO: 'VIDEO',\n  SHARE: 'SHARE'\n};\n/**\n * MediaDirection\n * @typedef {Object} MediaDirection\n * @property {boolean} sendAudio\n * @property {boolean} receiveAudio\n * @property {boolean} sendVideo\n * @property {boolean} receiveVideo\n * @property {boolean} sendShare\n * @property {boolean} receiveShare\n * @property {boolean} isSharing\n */\n\n/**\n  * AudioVideo\n  * @typedef {Object} AudioVideo\n  * @property {Object} audio\n  * @property {String} audio.deviceId\n  * @property {Object} video\n  * @property {String} video.deviceId\n  */\n\n/**\n   * SharePreferences\n   * @typedef {Object} SharePreferences\n   * @property {Object} [shareConstraints]\n   * @property {Boolean} [highFrameRate]\n   */\n\n/**\n * JoinOptions\n * @typedef {Object} JoinOptions\n * @property {String} [resourceId]\n * @property {String} [pin]\n * @property {Boolean} [moderator]\n * @property {String|Object} [meetingQuality]\n * @property {String} [meetingQuality.local]\n * @property {String} [meetingQuality.remote]\n * @property {Boolean} [rejoin]\n */\n\n/**\n * SendOptions\n * @typedef {Object} SendOptions\n * @property {Boolean} sendAudio\n * @property {Boolean} sendVideo\n * @property {Boolean} sendShare\n */\n\n/**\n * Recording\n * @typedef {Object} Recording\n * @property {Object} state\n * @property {String} modifiedBy\n */\n\n/**\n  * Meeting State Change Event\n  * Emitted when ever there is a meeting state change\n  * @event meeting:stateChange\n  * @instance\n  * @type {Object}\n  * @property {String} currentState current state of the meeting\n  * @property {String} previousState previous state of the meeting\n  * @memberof Meeting\n  */\n\n/**\n  * Media Ready Event\n  * Emitted when a stream is ready to be rendered\n  * @event media:ready\n  * @instance\n  * @type {Object}\n  * @property {MediaStream} stream the media stream\n  * @property {String} type what type of stream, remote, local\n  * @memberof Meeting\n  */\n\n/**\n  * Media Stopped Event\n  * Emitted when a stream has stopped sending\n  * @event media:stopped\n  * @instance\n  * @type {Object}\n  * @property {String} type what type of stream, remote, local\n  * @memberof Meeting\n  */\n\n/**\n * Meeting Ringing Event\n * Emitted when this client should play a ringing sound, because this member is getting an incoming meeting\n * or sending out an incoming meeting\n * @event meeting:ringing\n * @instance\n * @type {Object}\n * @property {String} type // INCOMING or JOIN\n * @property {String} id\n * @memberof Meeting\n */\n\n/**\n * Meeting Ringing Stop Event\n * Emitted when this client should stop playing a ringing sound\n * @event meeting:ringingStop\n * @instance\n * @type {Object}\n * @property {Object} type\n * @property {Boolean} type.remoteAnswered\n * @property {Boolean} type.remoteDeclined\n * @property {String} id\n * @memberof Meeting\n */\n\n/**\n * Meeting Started Sharing Local Event\n * Emitted when this member starts sharing\n * @event meeting:startedSharingLocal\n * @instance\n * @type {Object}\n * @memberof Meeting\n */\n\n/**\n * Meeting Stopped Sharing Local Event\n * Emitted when this member stops sharing\n * @event meeting:stoppedSharingLocal\n * @instance\n * @type {Object}\n * @memberof Meeting\n */\n\n/**\n * Meeting Started Sharing Remote Event\n * Emitted when remote sharing starts\n * @event meeting:startedSharingRemote\n * @instance\n * @type {Object}\n * @property {Boolean} memberId id of the meeting member that started screen share\n * @memberof Meeting\n */\n\n/**\n * Meeting Stopped Sharing Remote Event\n * Emitted when remote screen sharing ends\n * @event meeting:stoppedSharingRemote\n * @instance\n * @type {Object}\n * @memberof Meeting\n */\n\n/**\n * Meeting Locked Event\n * Emitted when a meeting is locked\n * @event meeting:locked\n * @instance\n * @type {Object}\n * @property {Object} info\n * @memberof Meeting\n */\n\n/**\n * Meeting Unlocked Event\n * Emitted when a meeting is unlocked\n * @event meeting:unlocked\n * @instance\n * @type {Object}\n * @property {Object} info\n * @memberof Meeting\n */\n\n/**\n * Meeting Actions Update Event\n * Emitted when a user can take actions on a meeting such as lock, unlock, assign host\n * @event meeting:actionsUpdate\n * @instance\n * @type {Object}\n * @property {Boolean} canLock\n * @property {Boolean} canUnlock\n * @property {Boolean} canAssignHost\n * @memberof Meeting\n */\n\n/**\n * Meeting Unmuted By Others Event\n * Emitted when a member is unmuted by another member\n * @event meeting:self:unmutedByOthers\n * @instance\n * @type {Object}\n * @property {Object} payload\n * @memberof Meeting\n */\n\n/**\n * Meeting Muted By Others Event\n * Emitted when a member is muted by another member\n * @event meeting:self:mutedByOthers\n * @instance\n * @type {Object}\n * @property {Object} payload\n * @property {Boolean} payload.unmuteAllowed - whether the user is allowed to unmute self\n * @memberof Meeting\n */\n\n/**\n * Meeting Muted By Others Event\n * Emitted when the host(moderator)/co-host requests a user to unmute\n * @event meeting:self:requestedToUnmute\n * @instance\n * @type {Object}\n * @property {Object} payload\n * @memberof Meeting\n */\n\n/**\n * Meeting Self Guest Admitted Event\n * Emitted when a joined user get admitted to the meeting by another member or host\n * @event meeting:self:guestAdmitted\n * @instance\n * @type {Object}\n * @property {Object} payload\n * @memberof Meeting\n */\n\n/**\n * Meeting Self Lobby Waiting Event\n * Emitted when joined user enters the lobby and is waiting for the webex meeting to begin\n * @event meeting:self:lobbyWaiting\n * @instance\n * @type {Object}\n * @property {Object} reason Reason why user left the meeting\n * @memberof Meeting\n */\n\n/**\n * Meeting Self Left State\n * Emitted when user is inactive for more then 40 seconds, User can rejoin the meeting again\n * @event meeting:self:left\n * @instance\n * @type {Object}\n * @property {Object} payload\n * @memberof Meeting\n */\n\n/**\n  * Reconnection Starting Event\n  * Emitted when reconnection of media to the active meeting was successful\n  * @event meeting:reconnectionStarting\n  * @instance\n  * @memberof Meeting\n  */\n\n/**\n  * Reconnection Success Event\n  * Emitted when reconnection of media to the active meeting was successful\n  * @event meeting:reconnectionSuccess\n  * @instance\n  * @type {Object}\n  * @property {Object} reconnect\n  * @memberof Meeting\n  */\n\n/**\n  * Reconnection Failure Event\n  * Emitted when reconnection of media to the active meeting was successful\n  * @event meeting:reconnectionFailure\n  * @instance\n  * @type {Object}\n  * @property {Error} error\n  * @memberof Meeting\n  */\n\n/**\n  * Meeting network quality event\n  * Emitted on each interval of retrieving stats Analyzer data\n  * @event network:quality\n  * @type {Object}\n  * @property {string} mediaType {video|audio}\n  * @property {number} networkQualityScore - {1|0} 1 indicates acceptable uplink 0 indicates unacceptable uplink based on threshold\n  * @memberof Meeting\n  */\n\n/**\n * @description Meeting is the crux of the plugin\n * @export\n * @class Meeting\n */\n\nexports.MEDIA_UPDATE_TYPE = MEDIA_UPDATE_TYPE;\n\nvar Meeting = /*#__PURE__*/function (_StatelessWebexPlugin) {\n  (0, _inherits2.default)(Meeting, _StatelessWebexPlugin);\n\n  var _super = _createSuper(Meeting);\n  /**\n   * @param {Object} attrs\n   * @param {Object} options\n   * @constructor\n   * @memberof Meeting\n  */\n\n\n  function Meeting(attrs, _options) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, Meeting);\n    _this = _super.call(this, {}, _options);\n    /**\n     * @instance\n     * @type {Object}\n     * @readonly\n     * @private\n     * @memberof Meeting\n     */\n\n    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), \"namespace\", _constants.MEETINGS);\n    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), \"getMediaStreams\", function (mediaDirection) {\n      var audioVideo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _constants.VIDEO_RESOLUTIONS[_this.mediaProperties.localQualityLevel];\n      var sharePreferences = arguments.length > 2 ? arguments[2] : undefined;\n\n      if (mediaDirection && (mediaDirection.sendAudio || mediaDirection.sendVideo || mediaDirection.sendShare)) {\n        if (mediaDirection && mediaDirection.sendAudio && mediaDirection.sendVideo && mediaDirection.sendShare && isBrowser('safari')) {\n          _loggerProxy.default.logger.warn('Meeting:index#getMediaStreams --> Setting `sendShare` to FALSE, due to complications with Safari');\n\n          mediaDirection.sendShare = false;\n\n          _loggerProxy.default.logger.warn('Meeting:index#getMediaStreams --> Enabling `sendShare` along with `sendAudio` & `sendVideo`, on Safari, causes a failure while setting up a screen share at the same time as the camera+mic stream');\n\n          _loggerProxy.default.logger.warn('Meeting:index#getMediaStreams --> Please use `meeting.shareScreen()` to manually start the screen share after successfully joining the meeting');\n        } // extract deviceId if exists otherwise default to null.\n\n\n        var _ref2 = audioVideo && audioVideo.video || {\n          deviceId: null\n        },\n            preferredVideoDevice = _ref2.deviceId;\n\n        var lastVideoDeviceId = _this.mediaProperties.getVideoDeviceId();\n\n        if (preferredVideoDevice) {\n          // Store new preferred video input device\n          _this.mediaProperties.setVideoDeviceId(preferredVideoDevice);\n        } else if (lastVideoDeviceId) {\n          // no new video preference specified so use last stored value,\n          // works with empty object {} or media constraint.\n          // eslint-disable-next-line no-param-reassign\n          audioVideo = _objectSpread(_objectSpread({}, audioVideo), {}, {\n            video: _objectSpread(_objectSpread({}, audioVideo.video), {}, {\n              deviceId: lastVideoDeviceId\n            })\n          });\n        }\n\n        return _media.default.getSupportedDevice({\n          sendAudio: mediaDirection.sendAudio,\n          sendVideo: mediaDirection.sendVideo\n        }).catch(function (error) {\n          return _promise.default.reject(new _media2.default('Given constraints do not match permission set for either camera or microphone', error));\n        }).then(function (devicePermissions) {\n          return _media.default.getUserMedia(_objectSpread(_objectSpread({}, mediaDirection), {}, {\n            sendAudio: devicePermissions.sendAudio,\n            sendVideo: devicePermissions.sendVideo,\n            isSharing: _this.shareStatus === _constants.SHARE_STATUS.LOCAL_SHARE_ACTIVE\n          }), audioVideo, sharePreferences, _this.config).catch(function (error) {\n            var _this$locusUrl; // Whenever there is a failure when trying to access a user's device\n            // report it as an Behavioral metric\n            // This gives visibility into common errors and can help\n            // with further troubleshooting\n\n\n            var metricName = _constants.BEHAVIORAL_METRICS.GET_USER_MEDIA_FAILURE;\n            var data = {\n              correlation_id: _this.correlationId,\n              locus_id: (_this$locusUrl = _this.locusUrl) === null || _this$locusUrl === void 0 ? void 0 : _this$locusUrl.split('/').pop(),\n              reason: error.message,\n              stack: error.stack\n            };\n            var metadata = {\n              type: error.name\n            };\n\n            _metrics.default.sendBehavioralMetric(metricName, data, metadata);\n\n            throw new _media2.default('Unable to retrieve media streams', error);\n          });\n        });\n      }\n\n      return _promise.default.reject(new _media2.default('At least one of the mediaDirection value should be true'));\n    });\n    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), \"getSupportedDevices\", function (_ref3) {\n      var _ref3$sendAudio = _ref3.sendAudio,\n          sendAudio = _ref3$sendAudio === void 0 ? true : _ref3$sendAudio,\n          _ref3$sendVideo = _ref3.sendVideo,\n          sendVideo = _ref3$sendVideo === void 0 ? true : _ref3$sendVideo;\n      return _media.default.getSupportedDevice({\n        sendAudio: sendAudio,\n        sendVideo: sendVideo\n      });\n    });\n    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), \"getDevices\", function () {\n      return _media.default.getDevices();\n    });\n    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), \"mediaNegotiatedEvent\", function () {\n      if (_this.config.experimental.enableMediaNegotiatedEvent) {\n        _loggerProxy.default.logger.info('Meeting:mediaNegotiatedEvent --> Media server negotiated');\n\n        _triggerProxy.default.trigger((0, _assertThisInitialized2.default)(_this), {\n          file: 'meeting/index',\n          function: 'mediaNegotiatedEvent'\n        }, _constants.EVENT_TRIGGERS.MEDIA_NEGOTIATED);\n      }\n    });\n    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), \"processNextQueuedMediaUpdate\", function () {\n      if (_this.canUpdateMedia() && _this.queuedMediaUpdates.length > 0) {\n        var _this$queuedMediaUpda = _this.queuedMediaUpdates.shift(),\n            pendingPromiseResolve = _this$queuedMediaUpda.pendingPromiseResolve,\n            pendingPromiseReject = _this$queuedMediaUpda.pendingPromiseReject,\n            mediaUpdateType = _this$queuedMediaUpda.mediaUpdateType,\n            options = _this$queuedMediaUpda.options;\n\n        _loggerProxy.default.logger.log(\"Meeting:index#processNextQueuedMediaUpdate --> performing delayed media update type=\".concat(mediaUpdateType));\n\n        switch (mediaUpdateType) {\n          case MEDIA_UPDATE_TYPE.ALL:\n            _this.updateMedia(options).then(pendingPromiseResolve, pendingPromiseReject);\n\n            break;\n\n          case MEDIA_UPDATE_TYPE.AUDIO:\n            _this.updateAudio(options).then(pendingPromiseResolve, pendingPromiseReject);\n\n            break;\n\n          case MEDIA_UPDATE_TYPE.VIDEO:\n            _this.updateVideo(options).then(pendingPromiseResolve, pendingPromiseReject);\n\n            break;\n\n          case MEDIA_UPDATE_TYPE.SHARE:\n            _this.updateShare(options).then(pendingPromiseResolve, pendingPromiseReject);\n\n            break;\n\n          default:\n            _loggerProxy.default.logger.error(\"Peer-connection-manager:index#processNextQueuedMediaUpdate --> unsupported media update type \".concat(mediaUpdateType, \" found in the queue\"));\n\n            break;\n        }\n      }\n    });\n    _this.attrs = attrs;\n    /**\n     * @instance\n     * @type {Object}\n     * @readonly\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.options = _options;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.id = _uuid.default.v4();\n    /**\n     * Correlation ID used for network tracking of meeting join\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.correlationId = _this.id;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.userId = attrs.userId;\n    /**\n     * Organization ID\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.orgId = attrs.orgId;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.resource = attrs.resource;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.deviceUrl = attrs.deviceUrl;\n    /**\n     * @description set you -1 as default values is 0 (used to idenfify if 1st roap request was sent)\n     * @instance\n     * @type {Number}\n     * @readonly\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.roapSeq = _constants.ROAP_SEQ_PRE;\n    /**\n     * @instance\n     * @type {Object}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n    // TODO: needs to be defined as a class\n\n    _this.meetingInfo = {};\n    /**\n     * @instance\n     * @type {Members}\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.members = new _index2.default({\n      locusUrl: attrs.locus && attrs.locus.url\n    }, {\n      parent: _this.webex\n    });\n    /**\n     * @instance\n     * @type {Roap}\n     * @readonly\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.roap = new _index.default({}, {\n      parent: _this.webex\n    });\n    /**\n     * created later\n     * @instance\n     * @type {ReconnectionManager}\n     * @readonly\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.reconnectionManager = new _reconnectionManager.default((0, _assertThisInitialized2.default)(_this));\n    /**\n     * created later\n     * @instance\n     * @type {MuteState}\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.audio = null;\n    /**\n     * created later\n     * @instance\n     * @type {MuteState}\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.video = null;\n    /**\n     * @instance\n     * @type {MeetingStateMachine}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.meetingFiniteStateMachine = _state.default.create((0, _assertThisInitialized2.default)(_this));\n    /**\n     * @instance\n     * @type {WebRTCStats}\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.stats = null;\n    /**\n     * @instance\n     * @type {WebRTCStats}\n     * @readonly\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.internalStats = null;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.conversationUrl = null;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.locusUrl = attrs.locus && attrs.locus.url || null;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.sipUri = null;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.partner = null;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.type = null;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.owner = null;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.hostId = null;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.policy = null;\n    /**\n     * @instance\n     * @type {MeetingRequest}\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.meetingRequest = new _request.default({}, _options);\n    /**\n     * @instance\n     * @type {Array}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.mediaConnections = null;\n    /**\n     * Update the MediaConnections property with new information\n     * @param {array} mediaConnections\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.updateMediaConnections = function (mediaConnections) {\n      if (!(0, _isEqual2.default)(_this.mediaConnections, mediaConnections)) {\n        // grab last/latest item in the new mediaConnections information\n        _this.mediaConnections = mediaConnections.slice(-1);\n      }\n    };\n    /**\n     * Passing only info as we send basic info for meeting added event\n     * @instance\n     * @type {MediaProperties}\n     * @public\n     * @memberof Meeting\n     */\n\n\n    _this.mediaProperties = new _properties.default();\n    /**\n     * @instance\n     * @type {InMeetingActions}\n     * @public\n     * @memberof Meeting\n    */\n\n    _this.inMeetingActions = new _inMeetingActions.default();\n    /**\n     * This is deprecated, please use shareStatus instead.\n     * @instance\n     * @type {Boolean}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     * @deprecated after v1.118.13\n     */\n\n    _this.isSharing = false;\n    /**\n     * @instance\n     * @type {Boolean}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.shareStatus = _constants.SHARE_STATUS.NO_SHARE;\n    /**\n     * @instance\n     * @type {Boolean}\n     * @readonly\n     * @private\n     * @memberof Meeting\n     */\n\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), 'isLocalShareLive', {\n      get: function get() {\n        var _shareTransceiver$sen, _shareTransceiver$sen2;\n\n        var shareTransceiver = _this.mediaProperties.peerConnection.shareTransceiver;\n        var shareDirection = shareTransceiver === null || shareTransceiver === void 0 ? void 0 : shareTransceiver.direction;\n        var trackReadyState = shareTransceiver === null || shareTransceiver === void 0 ? void 0 : (_shareTransceiver$sen = shareTransceiver.sender) === null || _shareTransceiver$sen === void 0 ? void 0 : (_shareTransceiver$sen2 = _shareTransceiver$sen.track) === null || _shareTransceiver$sen2 === void 0 ? void 0 : _shareTransceiver$sen2.readyState;\n        var activeShare = trackReadyState === _constants.LIVE;\n        var offersToSendData = shareDirection === _constants.SENDRECV;\n\n        if (activeShare && offersToSendData) {\n          return true;\n        }\n\n        return false;\n      },\n      configurable: true\n    });\n    /**\n     * @instance\n     * @type {Array}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.callEvents = [];\n    /**\n     * There is a pending floor requested by the user\n     * @instance\n     * @type {floorGrantPending}\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.floorGrantPending = false;\n    /**\n     * The latest status of the dial in device (can be \"JOINED\", \"CONNECTED\", \"LEFT\",\n     * \"TRANSFERRING\", \"SUCCESS\" or \"\")\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.dialInDeviceStatus = _constants.PSTN_STATUS.UNKNOWN;\n    /**\n     * the url for provisioned device used to dial in\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.dialInUrl = '';\n    /**\n     * The latest status of the dial out device (can be \"JOINED\", \"CONNECTED\", \"LEFT\",\n     * \"TRANSFERRING\", \"SUCCESS\" or \"\")\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.dialOutDeviceStatus = _constants.PSTN_STATUS.UNKNOWN;\n    /**\n     * the url for provisioned device used to dial out\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.dialOutUrl = '';\n    /**\n     * @instance\n     * @type {MediaMetrics}\n     * @readonly\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.mediaQualityMetrics = null;\n    /**\n     * @instance\n     * @type {StatsAnalyzer}\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.statsAnalyzer = null;\n    /**\n     * @instance\n     * @type {NetworkQualityMonitor}\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.networkQualityMonitor = null;\n    /**\n     * @instance\n     * @type {MQAProcessor}\n     * @readonly\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.mqaProcessor = null;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.networkStatus = null;\n    /**\n     * Passing only info as we send basic info for meeting added event\n     * @instance\n     * @type {MeetingRequest}\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.locusInfo = new _locusInfo.default(_this.updateMeetingObject.bind((0, _assertThisInitialized2.default)(_this)), _this.webex, _this.id); // We had to add listeners first before setting up the locus instance\n\n    /**\n     * @instance\n     * @type {Recording}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.recording = null;\n    /**\n     * Promise that exists if joining, and resolves upon method completion.\n     * @instance\n     * @type {Promise}\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.deferJoin = undefined;\n    /**\n     * Staus of websocket connection/mercury connection.\n     * @instance\n     * @type {Boolean}\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.hasWebsocketConnected = _this.webex.internal.mercury.connected;\n    /**\n     * Last sent render information\n     * @instance\n     * @type {Object}\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.lastVideoLayoutInfo = {\n      layoutType: undefined,\n      main: undefined,\n      content: undefined\n    };\n    /**\n     * Queue of pending media updates requested by the app\n     * @instance\n     * @type {Array}\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.queuedMediaUpdates = [];\n    /**\n     * Meeting transcription object\n     * @instance\n     * @type {Transcription}\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.transcription = undefined;\n    /**\n     * Password status. If it's PASSWORD_STATUS.REQUIRED then verifyPassword() needs to be called\n     * with the correct password before calling join()\n     * @instance\n     * @type {PASSWORD_STATUS}\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.passwordStatus = _constants.PASSWORD_STATUS.UNKNOWN;\n    /**\n     * Information about required captcha. If null, then no captcha is required. status. If it's PASSWORD_STATUS.REQUIRED then verifyPassword() needs to be called\n     * with the correct password before calling join()\n     * @instance\n     * @type {Object}\n     * @property {string} captchaId captcha id\n     * @property {string} verificationImageURL Url of the captcha image\n     * @property {string} verificationAudioURL Url of the captcha audio file\n     * @property {string} refreshURL Url used for refreshing the captcha (don't use it directly, call refreshCaptcha() instead)\n     * @public\n     * @memberof Meeting\n     */\n\n    _this.requiredCaptcha = null;\n    /**\n     * Indicates the reason for last failure to obtain meeting.meetingInfo. MEETING_INFO_FAILURE_REASON.NONE if meeting info was\n     * retrieved successfully\n     * @instance\n     * @type {MEETING_INFO_FAILURE_REASON}\n     * @private\n     * @memberof Meeting\n     */\n\n    _this.meetingInfoFailureReason = undefined;\n\n    _this.setUpLocusInfoListeners();\n\n    _this.locusInfo.init(attrs.locus ? attrs.locus : {});\n\n    _this.hasJoinedOnce = false;\n    return _this;\n  }\n  /**\n   * Fetches meeting information.\n   * @param {Object} options\n   * @param {String} options.destination\n   * @param {String} options.type\n   * @private\n   * @memberof Meeting\n   * @returns {Promise}\n   */\n\n\n  (0, _createClass2.default)(Meeting, [{\n    key: \"fetchMeetingInfo\",\n    value: function () {\n      var _fetchMeetingInfo = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(_ref4) {\n        var destination, type, _ref4$password, password, _ref4$captchaCode, captchaCode, captchaInfo, info, _err$body, _err$body2;\n\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                destination = _ref4.destination, type = _ref4.type, _ref4$password = _ref4.password, password = _ref4$password === void 0 ? null : _ref4$password, _ref4$captchaCode = _ref4.captchaCode, captchaCode = _ref4$captchaCode === void 0 ? null : _ref4$captchaCode;\n\n                if (!(captchaCode && !this.requiredCaptcha)) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", _promise.default.reject(new Error('fetchMeetingInfo() called with captchaCode when captcha was not required')));\n\n              case 3:\n                if (!(password && this.passwordStatus !== _constants.PASSWORD_STATUS.REQUIRED && this.passwordStatus !== _constants.PASSWORD_STATUS.UNKNOWN)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", _promise.default.reject(new Error('fetchMeetingInfo() called with password when password was not required')));\n\n              case 5:\n                _context.prev = 5;\n                captchaInfo = captchaCode ? {\n                  code: captchaCode,\n                  id: this.requiredCaptcha.captchaId\n                } : null;\n                _context.next = 9;\n                return this.attrs.meetingInfoProvider.fetchMeetingInfo(destination, type, password, captchaInfo);\n\n              case 9:\n                info = _context.sent;\n                this.parseMeetingInfo(info);\n                this.meetingInfo = info ? info.body : null;\n                this.meetingInfoFailureReason = _constants.MEETING_INFO_FAILURE_REASON.NONE;\n                this.requiredCaptcha = null;\n\n                if (this.passwordStatus === _constants.PASSWORD_STATUS.REQUIRED || this.passwordStatus === _constants.PASSWORD_STATUS.VERIFIED) {\n                  this.passwordStatus = _constants.PASSWORD_STATUS.VERIFIED;\n                } else {\n                  this.passwordStatus = _constants.PASSWORD_STATUS.NOT_REQUIRED;\n                }\n\n                return _context.abrupt(\"return\", _promise.default.resolve());\n\n              case 18:\n                _context.prev = 18;\n                _context.t0 = _context[\"catch\"](5);\n\n                if (!(_context.t0 instanceof _meetingInfoV.MeetingInfoV2PasswordError)) {\n                  _context.next = 31;\n                  break;\n                }\n\n                _loggerProxy.default.logger.info(\"Meeting:index#fetchMeetingInfo --> Info Unable to fetch meeting info for \".concat(destination, \" - password required (code=\").concat(_context.t0 === null || _context.t0 === void 0 ? void 0 : (_err$body = _context.t0.body) === null || _err$body === void 0 ? void 0 : _err$body.code, \").\")); // when wbxappapi requires password it still populates partial meeting info in the response\n\n\n                if (_context.t0.meetingInfo) {\n                  this.meetingInfo = _context.t0.meetingInfo;\n                  this.meetingNumber = _context.t0.meetingInfo.meetingNumber;\n                }\n\n                this.passwordStatus = _constants.PASSWORD_STATUS.REQUIRED;\n                this.meetingInfoFailureReason = _constants.MEETING_INFO_FAILURE_REASON.WRONG_PASSWORD;\n\n                if (!this.requiredCaptcha) {\n                  _context.next = 28;\n                  break;\n                }\n\n                _context.next = 28;\n                return this.refreshCaptcha();\n\n              case 28:\n                throw new _passwordError.default();\n\n              case 31:\n                if (!(_context.t0 instanceof _meetingInfoV.MeetingInfoV2CaptchaError)) {\n                  _context.next = 39;\n                  break;\n                }\n\n                _loggerProxy.default.logger.info(\"Meeting:index#fetchMeetingInfo --> Info Unable to fetch meeting info for \".concat(destination, \" - captcha required (code=\").concat(_context.t0 === null || _context.t0 === void 0 ? void 0 : (_err$body2 = _context.t0.body) === null || _err$body2 === void 0 ? void 0 : _err$body2.code, \").\"));\n\n                this.meetingInfoFailureReason = this.requiredCaptcha ? _constants.MEETING_INFO_FAILURE_REASON.WRONG_CAPTCHA : _constants.MEETING_INFO_FAILURE_REASON.WRONG_PASSWORD;\n\n                if (_context.t0.isPasswordRequired) {\n                  this.passwordStatus = _constants.PASSWORD_STATUS.REQUIRED;\n                }\n\n                this.requiredCaptcha = _context.t0.captchaInfo;\n                throw new _captchaError.default();\n\n              case 39:\n                this.meetingInfoFailureReason = _constants.MEETING_INFO_FAILURE_REASON.OTHER;\n                throw _context.t0;\n\n              case 41:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[5, 18]]);\n      }));\n\n      function fetchMeetingInfo(_x) {\n        return _fetchMeetingInfo.apply(this, arguments);\n      }\n\n      return fetchMeetingInfo;\n    }()\n    /**\n     * Checks if the supplied password/host key is correct. It returns a promise with information whether the\n     * password and captcha code were correct or not.\n     * @param {String} password - this can be either a password or a host key, can be undefined if only captcha was required\n     * @param {String} captchaCode - can be undefined if captcha was not required by the server\n     * @public\n     * @memberof Meeting\n     * @returns {Promise<{isPasswordValid: boolean, requiredCaptcha: boolean, failureReason: MEETING_INFO_FAILURE_REASON}>}\n     */\n\n  }, {\n    key: \"verifyPassword\",\n    value: function verifyPassword(password, captchaCode) {\n      var _this2 = this;\n\n      return this.fetchMeetingInfo({\n        destination: this.sipUri,\n        type: _constants._SIP_URI_,\n        password: password,\n        captchaCode: captchaCode\n      }).then(function () {\n        return {\n          isPasswordValid: true,\n          requiredCaptcha: null,\n          failureReason: _constants.MEETING_INFO_FAILURE_REASON.NONE\n        };\n      }).catch(function (error) {\n        if (error instanceof _passwordError.default || error instanceof _captchaError.default) {\n          return {\n            isPasswordValid: _this2.passwordStatus === _constants.PASSWORD_STATUS.VERIFIED,\n            requiredCaptcha: _this2.requiredCaptcha,\n            failureReason: _this2.meetingInfoFailureReason\n          };\n        }\n\n        throw error;\n      });\n    }\n    /**\n     * Refreshes the captcha. As a result the meeting will have new captcha id, image and audio.\n     * If the refresh operation fails, meeting remains with the old captcha properties.\n     * @public\n     * @memberof Meeting\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"refreshCaptcha\",\n    value: function refreshCaptcha() {\n      var _this3 = this;\n\n      if (!this.requiredCaptcha) {\n        return _promise.default.reject(new Error('There is no captcha to refresh'));\n      } // in order to get fully populated uris for captcha audio and image in response to refresh captcha request\n      // we have to pass the wbxappapi hostname as the siteFullName parameter\n\n\n      var _URL = new URL(this.requiredCaptcha.refreshURL),\n          hostname = _URL.hostname;\n\n      return this.meetingRequest.refreshCaptcha({\n        captchaRefreshUrl: \"\".concat(this.requiredCaptcha.refreshURL, \"&siteFullName=\").concat(hostname),\n        captchaId: this.requiredCaptcha.captchaId\n      }).then(function (response) {\n        _this3.requiredCaptcha.captchaId = response.body.captchaID;\n        _this3.requiredCaptcha.verificationImageURL = response.body.verificationImageURL;\n        _this3.requiredCaptcha.verificationAudioURL = response.body.verificationAudioURL;\n      });\n    }\n    /**\n     * Proxy function for all the listener set ups\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"setUpLocusInfoListeners\",\n    value: function setUpLocusInfoListeners() {\n      // meeting update listeners\n      this.setUpLocusInfoSelfListener();\n      this.setUpLocusInfoMeetingListener(); // members update listeners\n\n      this.setUpLocusFullStateListener();\n      this.setUpLocusUrlListener();\n      this.setUpLocusHostListener();\n      this.setUpLocusSelfListener();\n      this.setUpLocusParticipantsListener();\n      this.setupLocusControlsListener();\n      this.setUpLocusMediaSharesListener();\n      this.setUpLocusInfoMeetingInfoListener();\n      this.setUpLocusInfoAssignHostListener();\n      this.setUpLocusInfoMediaInactiveListener();\n    }\n    /**\n     * Set up the locus info listener for meetings disconnected due to inactivity\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"setUpLocusInfoMediaInactiveListener\",\n    value: function setUpLocusInfoMediaInactiveListener() {\n      var _this4 = this; // User gets kicked off the meeting due to inactivity or user did a refresh\n\n\n      this.locusInfo.on(_constants.EVENTS.DISCONNECT_DUE_TO_INACTIVITY, function (res) {\n        // https:// jira-eng-gpk2.cisco.com/jira/browse/SPARK-240520\n        // TODO: send custom parameter explaining why the inactivity happened\n        // refresh , no media or network got dsconnected or something else\n        _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.DISCONNECT_DUE_TO_INACTIVITY, {\n          correlation_id: _this4.correlationId,\n          locus_id: _this4.locusId\n        }); // Upload logs on media inactivity\n        // Normally media should not be inactive\n\n\n        _triggerProxy.default.trigger(_this4, {\n          file: 'meeting/index',\n          function: 'setUpLocusInfoMediaInactiveListener'\n        }, _constants.EVENTS.REQUEST_UPLOAD_LOGS, _this4);\n\n        _loggerProxy.default.logger.error(\"Meeting:index#setUpLocusInfoMediaInactiveListener --> Meeting disconnected due to inactivity: \".concat(res.reason));\n\n        if (_this4.config.reconnection.autoRejoin) {\n          _this4.reconnect();\n        } else {\n          _triggerProxy.default.trigger(_this4, {\n            file: 'meeting/index',\n            function: 'setUpLocusInfoMediaInactiveListener'\n          }, _constants.EVENT_TRIGGERS.MEETING_SELF_LEFT, res.reason);\n        }\n      });\n    }\n    /**\n     * Set up the locus info listener for assign host permissions on a meeting\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"setUpLocusInfoAssignHostListener\",\n    value: function setUpLocusInfoAssignHostListener() {\n      var _this5 = this;\n\n      this.locusInfo.on(_constants.EVENTS.LOCUS_INFO_CAN_ASSIGN_HOST, function (payload) {\n        _triggerProxy.default.trigger(_this5, {\n          file: 'meeting/index',\n          function: 'setUpLocusInfoAssignHostListener'\n        }, _constants.EVENT_TRIGGERS.MEETING_ACTIONS_UPDATE, {\n          canAssignHost: payload.canAssignHost,\n          canLock: _this5.inMeetingActions.getCanLock(),\n          canUnlock: _this5.inMeetingActions.getCanUnlock()\n        });\n\n        _this5.inMeetingActions.setCanAssignHost(payload.canAssignHost);\n      });\n    }\n    /**\n     * Set up the internal locus info full state object listener\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"setUpLocusFullStateListener\",\n    value: function setUpLocusFullStateListener() {\n      var _this6 = this;\n\n      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.FULL_STATE_MEETING_STATE_CHANGE, function (payload) {\n        _triggerProxy.default.trigger(_this6, {\n          file: 'meeting/index',\n          function: 'setUpLocusFullStateListener'\n        }, _constants.EVENT_TRIGGERS.MEETING_STATE_CHANGE, {\n          payload: payload\n        });\n      });\n      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.FULL_STATE_TYPE_UPDATE, function (payload) {\n        _this6.members.locusFullStateTypeUpdate(payload);\n      });\n    }\n    /**\n     * get the metrics payload pre\n     * @param {Object} options\n     * @param {String} options.event\n     * @param {String} options.trackingId\n     * @param {Object} options.locus\n     * @param {Array} options.mediaConnections\n     * @returns {Object}\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"getAnalyzerMetricsPrePayload\",\n    value: function getAnalyzerMetricsPrePayload(options) {\n      if (options) {\n        var event = options.event,\n            trackingId = options.trackingId,\n            mediaConnections = options.mediaConnections;\n\n        if (!event) {\n          _loggerProxy.default.logger.error('Meeting:index#getAnalyzerMetricsPrePayload --> Error [Call Analyzer Event', event || '', \"]: invalid identifers or event type! \".concat(this.correlationId));\n\n          return null;\n        }\n\n        var identifiers = {\n          correlationId: this.correlationId,\n          userId: this.userId,\n          deviceId: this.deviceUrl,\n          orgId: this.orgId,\n          locusUrl: this.webex.internal.services.get('locus')\n        };\n\n        if (this.locusUrl && this.locusInfo.fullState) {\n          identifiers.locusUrl = this.locusUrl;\n          identifiers.locusId = this.locusUrl && this.locusUrl.split('/').pop();\n          identifiers.locusStartTime = this.locusInfo.fullState && this.locusInfo.fullState.lastActive;\n        } // Check if mediaConnections has been passed in or else use this.mediaConnections\n\n\n        if (mediaConnections) {\n          identifiers.mediaAgentAlias = mediaConnections === null || mediaConnections === void 0 ? void 0 : mediaConnections[0].mediaAgentAlias;\n          identifiers.mediaAgentGroupId = mediaConnections === null || mediaConnections === void 0 ? void 0 : mediaConnections[0].mediaAgentGroupId;\n          identifiers.mediaAgentCluster = mediaConnections === null || mediaConnections === void 0 ? void 0 : mediaConnections[0].mediaAgentCluster;\n        } else if (this.mediaConnections) {\n          var _this$mediaConnection, _this$mediaConnection2, _this$mediaConnection3;\n\n          identifiers.mediaAgentAlias = (_this$mediaConnection = this.mediaConnections) === null || _this$mediaConnection === void 0 ? void 0 : _this$mediaConnection[0].mediaAgentAlias;\n          identifiers.mediaAgentGroupId = (_this$mediaConnection2 = this.mediaConnections) === null || _this$mediaConnection2 === void 0 ? void 0 : _this$mediaConnection2[0].mediaAgentGroupId;\n          identifiers.mediaAgentCluster = (_this$mediaConnection3 = this.mediaConnections) === null || _this$mediaConnection3 === void 0 ? void 0 : _this$mediaConnection3[0].mediaAgentCluster;\n        }\n\n        if (options.trackingId) {\n          identifiers.trackingId = trackingId;\n        }\n\n        var payload = {};\n        var joinRespRxStartAudio = this.getSetupDelayDuration('audio');\n\n        if (joinRespRxStartAudio) {\n          options.audioSetupDelay = {\n            joinRespRxStart: joinRespRxStartAudio\n          };\n        }\n\n        var joinRespRxStartVideo = this.getSetupDelayDuration('video');\n\n        if (joinRespRxStartAudio) {\n          options.videoSetupDelay = {\n            joinRespRxStart: joinRespRxStartVideo\n          };\n        }\n\n        var joinRespTxStartAudio = this.getSendingMediaDelayDuration('audio');\n\n        if (joinRespTxStartAudio) {\n          options.audioSetupDelay = _objectSpread(_objectSpread({}, options.audioSetupDelay), {}, {\n            joinRespTxStart: joinRespTxStartAudio\n          });\n        }\n\n        var joinRespTxStartVideo = this.getSendingMediaDelayDuration('video');\n\n        if (joinRespTxStartVideo) {\n          options.videoSetupDelay = _objectSpread(_objectSpread({}, options.videoSetupDelay), {}, {\n            joinRespTxStart: joinRespTxStartVideo\n          });\n        }\n\n        var localSDPGenRemoteSDPRecv = this.getLocalSDPGenRemoteSDPRecvDelay();\n\n        if (localSDPGenRemoteSDPRecv) {\n          options.joinTimes = _objectSpread(_objectSpread({}, options.joinTimes), {}, {\n            localSDPGenRemoteSDPRecv: localSDPGenRemoteSDPRecv\n          });\n        }\n\n        var callInitiateJoinReq = this.getCallInitiateJoinReq();\n\n        if (callInitiateJoinReq) {\n          options.joinTimes = _objectSpread(_objectSpread({}, options.joinTimes), {}, {\n            callInitiateJoinReq: callInitiateJoinReq\n          });\n        }\n\n        var joinReqResp = this.getJoinReqResp();\n\n        if (joinReqResp) {\n          options.joinTimes = _objectSpread(_objectSpread({}, options.joinTimes), {}, {\n            joinReqResp: joinReqResp\n          });\n        }\n\n        var getTotalJmt = this.getTotalJmt();\n\n        if (getTotalJmt) {\n          options.joinTimes = _objectSpread(_objectSpread({}, options.joinTimes), {}, {\n            getTotalJmt: getTotalJmt\n          });\n        }\n\n        if (options.type === _constants.MQA_STATS.CA_TYPE) {\n          payload = _metrics.default.initMediaPayload(options.event, identifiers, options);\n        } else {\n          payload = _metrics.default.initPayload(options.event, identifiers, options);\n        }\n\n        return payload;\n      }\n\n      return null;\n    }\n    /**\n     * Send the metrics to call-analyzer dashboard\n     * @param {Object} options\n     * @param {String} options.event\n     * @param {String} options.trackingId\n     * @param {Object} options.locus\n     * @returns {Promise}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"sendCallAnalyzerMetrics\",\n    value: function sendCallAnalyzerMetrics(options) {\n      var payload = this.getAnalyzerMetricsPrePayload(_objectSpread(_objectSpread({}, (0, _pick2.default)(this.config.metrics, ['clientType', 'subClientType'])), options));\n      return this.webex.internal.metrics.submitCallDiagnosticEvents(payload);\n    }\n    /**\n     * Send the metrics to Media Quality Analyzer dashboard\n     * @param {Object} options\n     * @param {String} options.event\n     * @param {String} options.trackingId\n     * @param {Object} options.locus\n     * @returns {Promise}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"sendMediaQualityAnalyzerMetrics\",\n    value: function sendMediaQualityAnalyzerMetrics(options) {\n      var payload = this.getAnalyzerMetricsPrePayload(_objectSpread(_objectSpread({\n        type: _constants.MQA_STATS.CA_TYPE\n      }, (0, _pick2.default)(this.config.metrics, ['clientType', 'subClientType'])), options));\n      return this.webex.internal.metrics.submitCallDiagnosticEvents(payload);\n    }\n    /**\n     * sets the network status on meeting object\n     * @param {String} networkStatus\n     * @private\n     * @returns {undefined}\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"setNetworkStatus\",\n    value: function setNetworkStatus(networkStatus) {\n      if (networkStatus === _constants.NETWORK_STATUS.DISCONNECTED) {\n        _triggerProxy.default.trigger(this, {\n          file: 'meeting/index',\n          function: 'setNetworkStatus'\n        }, _constants.EVENT_TRIGGERS.MEETINGS_NETWORK_DISCONNECTED);\n      } else if (networkStatus === _constants.NETWORK_STATUS.CONNECTED && this.networkStatus === _constants.NETWORK_STATUS.DISCONNECTED) {\n        _triggerProxy.default.trigger(this, {\n          file: 'meeting/index',\n          function: 'setNetworkStatus'\n        }, _constants.EVENT_TRIGGERS.MEETINGS_NETWORK_CONNECTED);\n      }\n\n      this.networkStatus = networkStatus;\n    }\n    /**\n     * Set up the locus info self listener\n     * update self value for members and updates the member\n     * notifies consumer with members:self:update {activeSelfId endedSelfId}\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"setUpLocusSelfListener\",\n    value: function setUpLocusSelfListener() {\n      var _this7 = this;\n\n      this.locusInfo.on(_constants.EVENTS.LOCUS_INFO_UPDATE_SELF, function (payload) {\n        _this7.members.locusSelfUpdate(payload);\n\n        _this7.pstnUpdate(payload); // If user moved to a JOINED state and there is a pending floor grant trigger it\n\n\n        if (_this7.floorGrantPending && payload.newSelf.state === _constants.MEETING_STATE.STATES.JOINED) {\n          _this7.share().then(function () {\n            _this7.floorGrantPending = false;\n          });\n        }\n      });\n    }\n    /**\n     * Notify any changes on the pstn devices\n     * @param {Object} payload\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"pstnUpdate\",\n    value: function pstnUpdate(payload) {\n      var _this8 = this;\n\n      if (this.locusInfo.self) {\n        var _payload$newSelf, _payload$newSelf2;\n\n        var dialInPstnDevice = (_payload$newSelf = payload.newSelf) === null || _payload$newSelf === void 0 ? void 0 : _payload$newSelf.pstnDevices.find(function (device) {\n          return device.url === _this8.dialInUrl;\n        });\n        var dialOutPstnDevice = (_payload$newSelf2 = payload.newSelf) === null || _payload$newSelf2 === void 0 ? void 0 : _payload$newSelf2.pstnDevices.find(function (device) {\n          return device.url === _this8.dialOutUrl;\n        });\n        var changed = false;\n\n        if (dialInPstnDevice) {\n          var _dialInPstnDevice$dia;\n\n          var newStatus = (_dialInPstnDevice$dia = dialInPstnDevice.dialingStatus) !== null && _dialInPstnDevice$dia !== void 0 ? _dialInPstnDevice$dia : dialInPstnDevice.state;\n\n          if (newStatus !== this.dialInDeviceStatus) {\n            this.dialInDeviceStatus = newStatus;\n            changed = true;\n          }\n        }\n\n        if (dialOutPstnDevice) {\n          var _dialOutPstnDevice$di;\n\n          var _newStatus = (_dialOutPstnDevice$di = dialOutPstnDevice.dialingStatus) !== null && _dialOutPstnDevice$di !== void 0 ? _dialOutPstnDevice$di : dialOutPstnDevice.state;\n\n          if (_newStatus !== this.dialOutDeviceStatus) {\n            this.dialOutDeviceStatus = _newStatus;\n            changed = true;\n          }\n        }\n\n        if (changed) {\n          _triggerProxy.default.trigger(this, {\n            file: 'meeting/index',\n            function: 'setUpLocusSelfListener'\n          }, _constants.EVENT_TRIGGERS.MEETING_SELF_PHONE_AUDIO_UPDATE, {\n            dialIn: {\n              status: this.dialInDeviceStatus,\n              attendeeId: dialInPstnDevice === null || dialInPstnDevice === void 0 ? void 0 : dialInPstnDevice.attendeeId\n            },\n            dialOut: {\n              status: this.dialOutDeviceStatus,\n              attendeeId: dialOutPstnDevice === null || dialOutPstnDevice === void 0 ? void 0 : dialOutPstnDevice.attendeeId\n            }\n          });\n        }\n      }\n    }\n    /**\n     * Set up the locus info host listener\n     * update host value for members and updates the member\n     * notifies consumer with members:host:update: {activeHostId, endedHostId}\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"setUpLocusHostListener\",\n    value: function setUpLocusHostListener() {\n      var _this9 = this;\n\n      this.locusInfo.on(_constants.EVENTS.LOCUS_INFO_UPDATE_HOST, function (payload) {\n        _this9.members.locusHostUpdate(payload);\n      });\n    }\n    /**\n     * Set up the locus info participants update listener\n     * update members collection value for members\n     * notifies consumer with members:update\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"setUpLocusParticipantsListener\",\n    value: function setUpLocusParticipantsListener() {\n      var _this10 = this;\n\n      this.locusInfo.on(_constants.EVENTS.LOCUS_INFO_UPDATE_PARTICIPANTS, function (payload) {\n        _this10.members.locusParticipantsUpdate(payload);\n      });\n    }\n    /**\n     * Set up the locus info recording update listener\n     * update recording value for the meeting\n     * notifies consumer with:\n     *  meeting:recording:started\n     *  meeting:recording:stopped\n     *  meeting:recording:paused\n     *  meeting:recording:resumed\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"setupLocusControlsListener\",\n    value: function setupLocusControlsListener() {\n      var _this11 = this;\n\n      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.CONTROLS_RECORDING_UPDATED, function (_ref5) {\n        var state = _ref5.state,\n            modifiedBy = _ref5.modifiedBy,\n            lastModified = _ref5.lastModified;\n        var event;\n\n        switch (state) {\n          case _constants.RECORDING_STATE.RECORDING:\n            event = _constants.EVENT_TRIGGERS.MEETING_STARTED_RECORDING;\n            break;\n\n          case _constants.RECORDING_STATE.IDLE:\n            event = _constants.EVENT_TRIGGERS.MEETING_STOPPED_RECORDING;\n            break;\n\n          case _constants.RECORDING_STATE.PAUSED:\n            event = _constants.EVENT_TRIGGERS.MEETING_PAUSED_RECORDING;\n            break;\n\n          case _constants.RECORDING_STATE.RESUMED:\n            event = _constants.EVENT_TRIGGERS.MEETING_RESUMED_RECORDING;\n            break;\n\n          default:\n            event = null;\n            break;\n        } // `RESUMED` state should be converted to `RECORDING` after triggering the event\n\n\n        _this11.recording = {\n          state: state === _constants.RECORDING_STATE.RESUMED ? _constants.RECORDING_STATE.RECORDING : state,\n          modifiedBy: modifiedBy,\n          lastModified: lastModified\n        };\n\n        _triggerProxy.default.trigger(_this11, {\n          file: 'meeting/index',\n          function: 'setupLocusControlsListener'\n        }, event, _this11.recording);\n      });\n    }\n    /**\n     * Set up the locus info media shares listener\n     * update content and whiteboard sharing id value for members, and updates the member\n     * notifies consumer with members:content:update {activeContentSharingId, endedContentSharingId}\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"setUpLocusMediaSharesListener\",\n    value: function setUpLocusMediaSharesListener() {\n      var _this12 = this; // Will get triggered on local and remote share\n\n\n      this.locusInfo.on(_constants.EVENTS.LOCUS_INFO_UPDATE_MEDIA_SHARES, function (payload) {\n        var _payload$previous, _payload$previous2;\n\n        var _payload$current = payload.current,\n            contentShare = _payload$current.content,\n            whiteboardShare = _payload$current.whiteboard;\n        var previousContentShare = (_payload$previous = payload.previous) === null || _payload$previous === void 0 ? void 0 : _payload$previous.content;\n        var previousWhiteboardShare = (_payload$previous2 = payload.previous) === null || _payload$previous2 === void 0 ? void 0 : _payload$previous2.whiteboard;\n\n        if (contentShare.beneficiaryId === (previousContentShare === null || previousContentShare === void 0 ? void 0 : previousContentShare.beneficiaryId) && contentShare.disposition === (previousContentShare === null || previousContentShare === void 0 ? void 0 : previousContentShare.disposition) && whiteboardShare.beneficiaryId === (previousWhiteboardShare === null || previousWhiteboardShare === void 0 ? void 0 : previousWhiteboardShare.beneficiaryId) && whiteboardShare.disposition === (previousWhiteboardShare === null || previousWhiteboardShare === void 0 ? void 0 : previousWhiteboardShare.disposition) && whiteboardShare.resourceUrl === (previousWhiteboardShare === null || previousWhiteboardShare === void 0 ? void 0 : previousWhiteboardShare.resourceUrl)) {\n          // nothing changed, so ignore\n          // (this happens when we steal presentation from remote)\n          return;\n        }\n\n        var newShareStatus = _this12.shareStatus; // REMOTE - check if remote started sharing\n\n        if (_this12.selfId !== contentShare.beneficiaryId && contentShare.disposition === _constants.FLOOR_ACTION.GRANTED) {\n          // CONTENT - sharing content remote\n          newShareStatus = _constants.SHARE_STATUS.REMOTE_SHARE_ACTIVE;\n        } // LOCAL - check if we started sharing content\n        else if (_this12.selfId === contentShare.beneficiaryId && contentShare.disposition === _constants.FLOOR_ACTION.GRANTED) {\n          var _this12$mediaProperti;\n\n          if (((_this12$mediaProperti = _this12.mediaProperties.shareTrack) === null || _this12$mediaProperti === void 0 ? void 0 : _this12$mediaProperti.readyState) === 'ended') {\n            _this12.stopShare({\n              skipSignalingCheck: true\n            }).catch(function (error) {\n              _loggerProxy.default.logger.log('Meeting:index#setUpLocusMediaSharesListener --> Error stopping share: ', error);\n            });\n          } else {\n            // CONTENT - sharing content local\n            newShareStatus = _constants.SHARE_STATUS.LOCAL_SHARE_ACTIVE;\n          }\n        } // If we did not hit the cases above, no one is sharng content, so we check if we are sharing whiteboard\n        // There is no concept of local/remote share for whiteboard\n        // It does not matter who requested to share the whiteboard, everyone gets the same view\n        else if (whiteboardShare.disposition === _constants.FLOOR_ACTION.GRANTED) {\n          // WHITEBOARD - sharing whiteboard\n          newShareStatus = _constants.SHARE_STATUS.WHITEBOARD_SHARE_ACTIVE;\n        } // or if content share is either released or null and whiteboard share is either released or null, no one is sharing\n        else if ((previousContentShare && contentShare.disposition === _constants.FLOOR_ACTION.RELEASED || contentShare.disposition === null) && (previousWhiteboardShare && whiteboardShare.disposition === _constants.FLOOR_ACTION.RELEASED || whiteboardShare.disposition === null)) {\n          newShareStatus = _constants.SHARE_STATUS.NO_SHARE;\n        }\n\n        if (newShareStatus !== _this12.shareStatus) {\n          var oldShareStatus = _this12.shareStatus; // update our state before we send out any notifications\n\n          _this12.shareStatus = newShareStatus; // send out \"stop\" notifications for the old state\n\n          switch (oldShareStatus) {\n            case _constants.SHARE_STATUS.REMOTE_SHARE_ACTIVE:\n              _triggerProxy.default.trigger(_this12, {\n                file: 'meetings/index',\n                function: 'remoteShare'\n              }, _constants.EVENT_TRIGGERS.MEETING_STOPPED_SHARING_REMOTE);\n\n              break;\n\n            case _constants.SHARE_STATUS.LOCAL_SHARE_ACTIVE:\n              _triggerProxy.default.trigger(_this12, {\n                file: 'meeting/index',\n                function: 'stopFloorRequest'\n              }, _constants.EVENT_TRIGGERS.MEETING_STOPPED_SHARING_LOCAL, {\n                reason: _constants.SHARE_STOPPED_REASON.SELF_STOPPED\n              });\n\n              break;\n\n            case _constants.SHARE_STATUS.WHITEBOARD_SHARE_ACTIVE:\n              _triggerProxy.default.trigger(_this12, {\n                file: 'meeting/index',\n                function: 'stopWhiteboardShare'\n              }, _constants.EVENT_TRIGGERS.MEETING_STOPPED_SHARING_WHITEBOARD);\n\n              break;\n\n            case _constants.SHARE_STATUS.NO_SHARE:\n              // nothing to do\n              break;\n\n            default:\n              break;\n          } // send \"start\" notifications for the new state\n\n\n          switch (newShareStatus) {\n            case _constants.SHARE_STATUS.REMOTE_SHARE_ACTIVE:\n              {\n                var _this12$mediaProperti2;\n\n                var sendStartedSharingRemote = function sendStartedSharingRemote() {\n                  _triggerProxy.default.trigger(_this12, {\n                    file: 'meetings/index',\n                    function: 'remoteShare'\n                  }, _constants.EVENT_TRIGGERS.MEETING_STARTED_SHARING_REMOTE, {\n                    memberId: contentShare.beneficiaryId\n                  });\n                }; // if a remote participant is stealing the presentation from us\n\n\n                if (!((_this12$mediaProperti2 = _this12.mediaProperties.mediaDirection) !== null && _this12$mediaProperti2 !== void 0 && _this12$mediaProperti2.sendShare) || oldShareStatus === _constants.SHARE_STATUS.WHITEBOARD_SHARE_ACTIVE) {\n                  sendStartedSharingRemote();\n                } else {\n                  _this12.updateShare({\n                    sendShare: false,\n                    receiveShare: _this12.mediaProperties.mediaDirection.receiveShare\n                  }).finally(function () {\n                    sendStartedSharingRemote();\n                  });\n                }\n\n                break;\n              }\n\n            case _constants.SHARE_STATUS.LOCAL_SHARE_ACTIVE:\n              _triggerProxy.default.trigger(_this12, {\n                file: 'meeting/index',\n                function: 'share'\n              }, _constants.EVENT_TRIGGERS.MEETING_STARTED_SHARING_LOCAL);\n\n              _metrics.default.postEvent({\n                event: _config.eventType.LOCAL_SHARE_FLOOR_GRANTED,\n                meeting: _this12\n              });\n\n              break;\n\n            case _constants.SHARE_STATUS.WHITEBOARD_SHARE_ACTIVE:\n              _triggerProxy.default.trigger(_this12, {\n                file: 'meeting/index',\n                function: 'startWhiteboardShare'\n              }, _constants.EVENT_TRIGGERS.MEETING_STARTED_SHARING_WHITEBOARD, {\n                resourceUrl: whiteboardShare.resourceUrl,\n                memberId: whiteboardShare.beneficiaryId\n              });\n\n              _metrics.default.postEvent({\n                event: _config.eventType.WHITEBOARD_SHARE_FLOOR_GRANTED,\n                meeting: _this12\n              });\n\n              break;\n\n            case _constants.SHARE_STATUS.NO_SHARE:\n              // nothing to do\n              break;\n\n            default:\n              break;\n          }\n\n          _this12.members.locusMediaSharesUpdate(payload);\n        } else if (newShareStatus === _constants.SHARE_STATUS.REMOTE_SHARE_ACTIVE) {\n          // if we got here, then some remote participant has stolen\n          // the presentation from another remote participant\n          _triggerProxy.default.trigger(_this12, {\n            file: 'meetings/index',\n            function: 'remoteShare'\n          }, _constants.EVENT_TRIGGERS.MEETING_STARTED_SHARING_REMOTE, {\n            memberId: contentShare.beneficiaryId\n          });\n\n          _this12.members.locusMediaSharesUpdate(payload);\n        } else if (newShareStatus === _constants.SHARE_STATUS.WHITEBOARD_SHARE_ACTIVE) {\n          // if we got here, then some remote participant has stolen\n          // the presentation from another remote participant\n          _triggerProxy.default.trigger(_this12, {\n            file: 'meeting/index',\n            function: 'startWhiteboardShare'\n          }, _constants.EVENT_TRIGGERS.MEETING_STARTED_SHARING_WHITEBOARD, {\n            resourceUrl: whiteboardShare.resourceUrl,\n            memberId: whiteboardShare.beneficiaryId\n          });\n\n          _metrics.default.postEvent({\n            event: _config.eventType.WHITEBOARD_SHARE_FLOOR_GRANTED,\n            meeting: _this12\n          });\n\n          _this12.members.locusMediaSharesUpdate(payload);\n        }\n      });\n    }\n    /**\n     * Set up the locus info url listener\n     * update locus_url value for members\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"setUpLocusUrlListener\",\n    value: function setUpLocusUrlListener() {\n      var _this13 = this;\n\n      this.locusInfo.on(_constants.EVENTS.LOCUS_INFO_UPDATE_URL, function (payload) {\n        var _this13$locusUrl;\n\n        _this13.members.locusUrlUpdate(payload);\n\n        _this13.locusUrl = payload;\n        _this13.locusId = (_this13$locusUrl = _this13.locusUrl) === null || _this13$locusUrl === void 0 ? void 0 : _this13$locusUrl.split('/').pop();\n      });\n    }\n    /**\n     * Set up the locus info meeting info listener\n     * @returns {undefined}\n     * @private\n     * @memberof meeting\n     */\n\n  }, {\n    key: \"setUpLocusInfoMeetingInfoListener\",\n    value: function setUpLocusInfoMeetingInfoListener() {\n      var _this14 = this;\n\n      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.MEETING_LOCKED, function (payload) {\n        if (payload) {\n          _triggerProxy.default.trigger(_this14, {\n            file: 'meeting/index',\n            function: 'setUpLocusInfoMeetingInfoListener'\n          }, _constants.EVENT_TRIGGERS.MEETING_LOCKED, {\n            payload: payload\n          });\n        }\n      });\n      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.MEETING_UNLOCKED, function (payload) {\n        if (payload) {\n          _triggerProxy.default.trigger(_this14, {\n            file: 'meeting/index',\n            function: 'setUpLocusInfoMeetingInfoListener'\n          }, _constants.EVENT_TRIGGERS.MEETING_UNLOCKED, {\n            payload: payload\n          });\n        }\n      });\n      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.MEETING_INFO_UPDATED, function (payload) {\n        if (payload && payload.info) {\n          var newCanLock;\n          var newCanUnlock;\n\n          if (payload.self && !payload.self.moderator) {\n            newCanLock = false;\n            newCanUnlock = false;\n          } else {\n            newCanLock = _util.default.canUserLock(payload.info.moderator, payload.info.policy);\n            newCanUnlock = _util.default.canUserUnlock(payload.info.moderator, payload.info.policy);\n          }\n\n          if (newCanLock && !_this14.inMeetingActions.canLock) {\n            _triggerProxy.default.trigger(_this14, {\n              file: 'meeting/index',\n              function: 'setUpLocusInfoMeetingInfoListener'\n            }, _constants.EVENT_TRIGGERS.MEETING_ACTIONS_UPDATE, {\n              canLock: true,\n              canUnlock: false,\n              canAssignHost: _this14.inMeetingActions.getCanAssignHost()\n            });\n          }\n\n          if (newCanUnlock && !_this14.inMeetingActions.canUnlock || !newCanLock) {\n            _triggerProxy.default.trigger(_this14, {\n              file: 'meeting/index',\n              function: 'setUpLocusInfoMeetingInfoListener'\n            }, _constants.EVENT_TRIGGERS.MEETING_ACTIONS_UPDATE, {\n              canLock: false,\n              canUnlock: true,\n              canAssignHost: _this14.inMeetingActions.getCanAssignHost()\n            });\n          }\n\n          _this14.inMeetingActions.setCanLock(newCanLock || false);\n\n          _this14.inMeetingActions.setCanUnlock(newCanUnlock || false);\n        }\n      });\n    }\n    /**\n     * Internal function to listen to the self object changes\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"setUpLocusInfoSelfListener\",\n    value: function setUpLocusInfoSelfListener() {\n      var _this15 = this;\n\n      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.LOCAL_UNMUTE_REQUIRED, function (payload) {\n        if (_this15.audio) {\n          _this15.audio.handleServerLocalUnmuteRequired(_this15);\n\n          _triggerProxy.default.trigger(_this15, {\n            file: 'meeting/index',\n            function: 'setUpLocusInfoSelfListener'\n          }, _constants.EVENT_TRIGGERS.MEETING_SELF_UNMUTED_BY_OTHERS, {\n            payload: payload\n          });\n        }\n      });\n      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.SELF_REMOTE_MUTE_STATUS_UPDATED, function (payload) {\n        if (payload) {\n          var _this15$audio;\n\n          if (_this15.audio) {\n            _this15.audio.handleServerRemoteMuteUpdate(payload.muted, payload.unmuteAllowed);\n          } // with \"mute on entry\" server will send us remote mute even if we don't have media configured,\n          // so if being muted by others, always send the notification,\n          // but if being unmuted, only send it if we are also locally unmuted\n\n\n          if (payload.muted || !((_this15$audio = _this15.audio) !== null && _this15$audio !== void 0 && _this15$audio.isMuted())) {\n            _triggerProxy.default.trigger(_this15, {\n              file: 'meeting/index',\n              function: 'setUpLocusInfoSelfListener'\n            }, payload.muted ? _constants.EVENT_TRIGGERS.MEETING_SELF_MUTED_BY_OTHERS : _constants.EVENT_TRIGGERS.MEETING_SELF_UNMUTED_BY_OTHERS, {\n              payload: payload\n            });\n          }\n        }\n      });\n      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.LOCAL_UNMUTE_REQUESTED, function (payload) {\n        _triggerProxy.default.trigger(_this15, {\n          file: 'meeting/index',\n          function: 'setUpLocusInfoSelfListener'\n        }, _constants.EVENT_TRIGGERS.MEETING_SELF_REQUESTED_TO_UNMUTE, {\n          payload: payload\n        });\n      });\n      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.SELF_UNADMITTED_GUEST, function (payload) {\n        if (payload) {\n          _triggerProxy.default.trigger(_this15, {\n            file: 'meeting/index',\n            function: 'setUpLocusInfoSelfListener'\n          }, _constants.EVENT_TRIGGERS.MEETING_SELF_LOBBY_WAITING, {\n            payload: payload\n          });\n\n          _metrics.default.postEvent({\n            event: _config.eventType.LOBBY_ENTERED,\n            meeting: _this15\n          });\n        }\n      });\n      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.SELF_ADMITTED_GUEST, function (payload) {\n        if (payload) {\n          _triggerProxy.default.trigger(_this15, {\n            file: 'meeting/index',\n            function: 'setUpLocusInfoSelfListener'\n          }, _constants.EVENT_TRIGGERS.MEETING_SELF_GUEST_ADMITTED, {\n            payload: payload\n          });\n\n          _metrics.default.postEvent({\n            event: _config.eventType.LOBBY_EXITED,\n            meeting: _this15\n          });\n        }\n      });\n      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.MEDIA_INACTIVITY, function () {\n        _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.MEETING_MEDIA_INACTIVE, {\n          correlation_id: _this15.correlationId,\n          locus_id: _this15.locusId\n        });\n\n        _this15.reconnect();\n      }); // There is two stats for mute one is the actual media being sent or received\n      // The second on is if the audio is muted, we need to tell the statsAnalyzer when\n      // the audio is muted or the user is not willing to send media\n\n      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.MEDIA_STATUS_CHANGE, function (status) {\n        if (_this15.statsAnalyzer) {\n          var _this15$mediaProperti, _this15$audio2, _this15$mediaProperti2, _this15$video, _this15$mediaProperti3, _this15$mediaProperti4, _this15$mediaProperti5, _this15$mediaProperti6;\n\n          _this15.statsAnalyzer.updateMediaStatus({\n            actual: status,\n            expected: {\n              // We need to check what should be the actual direction of media\n              sendAudio: ((_this15$mediaProperti = _this15.mediaProperties.mediaDirection) === null || _this15$mediaProperti === void 0 ? void 0 : _this15$mediaProperti.sendAudio) && !((_this15$audio2 = _this15.audio) !== null && _this15$audio2 !== void 0 && _this15$audio2.isMuted()),\n              sendVideo: ((_this15$mediaProperti2 = _this15.mediaProperties.mediaDirection) === null || _this15$mediaProperti2 === void 0 ? void 0 : _this15$mediaProperti2.sendVideo) && !((_this15$video = _this15.video) !== null && _this15$video !== void 0 && _this15$video.isMuted()),\n              sendShare: (_this15$mediaProperti3 = _this15.mediaProperties.mediaDirection) === null || _this15$mediaProperti3 === void 0 ? void 0 : _this15$mediaProperti3.sendShare,\n              receiveAudio: (_this15$mediaProperti4 = _this15.mediaProperties.mediaDirection) === null || _this15$mediaProperti4 === void 0 ? void 0 : _this15$mediaProperti4.receiveAudio,\n              receiveVideo: (_this15$mediaProperti5 = _this15.mediaProperties.mediaDirection) === null || _this15$mediaProperti5 === void 0 ? void 0 : _this15$mediaProperti5.receiveVideo,\n              receiveShare: (_this15$mediaProperti6 = _this15.mediaProperties.mediaDirection) === null || _this15$mediaProperti6 === void 0 ? void 0 : _this15$mediaProperti6.receiveShare\n            }\n          });\n        }\n      });\n    }\n    /**\n     * Add LocusInfo nested object listeners (from child to parent)\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"setUpLocusInfoMeetingListener\",\n    value: function setUpLocusInfoMeetingListener() {\n      var _this16 = this;\n\n      this.locusInfo.on(_constants.EVENTS.REMOTE_RESPONSE, function (payload) {\n        _this16.meetingFiniteStateMachine.remote(payload);\n\n        if (payload.remoteDeclined) {\n          _this16.leave({\n            reason: payload.reason\n          }).then(function () {\n            _loggerProxy.default.logger.info('Meeting:index#setUpLocusInfoMeetingListener --> REMOTE_RESPONSE. Attempting to leave meeting.');\n          }).catch(function (error) {\n            _loggerProxy.default.logger.error(\"Meeting:index#setUpLocusInfoMeetingListener --> REMOTE_RESPONSE. Issue with leave for meeting, meeting still in collection: \".concat(_this16.meeting, \", error: \").concat(error));\n          });\n        }\n      });\n      this.locusInfo.on(_constants.EVENTS.DESTROY_MEETING, function (payload) {\n        // if self state is NOT left\n        // TODO: Handle sharing and wireless sharing when meeting end\n        if (_this16.wirelessShare) {\n          if (_this16.mediaProperties.shareTrack) {\n            _this16.mediaProperties.shareTrack.onended = null;\n\n            _this16.mediaProperties.shareTrack.stop();\n          }\n        } // when multiple WEB deviceType join with same user\n        // and some of the devices are joined and some are left\n        // when your own device is still connected you want to leave and destroy\n        // else you want to just destroy\n        // this looks odd because when it leaves it should destroy, but we get a\n        // leave response and we should destroy it on the next event loop\n        // the leave response gets parsed and we decide if we want to destroy the meeting\n        // the first time we just leave it, the second time it comes it destroys it from the collection\n\n\n        if (payload.shouldLeave) {\n          // TODO:  We should do cleaning of meeting object if the shouldLeave: false because there might be meeting object which we are not cleaning\n          _this16.leave({\n            reason: payload.reason\n          }).then(function () {\n            _loggerProxy.default.logger.warn('Meeting:index#setUpLocusInfoMeetingListener --> DESTROY_MEETING. The meeting has been left, but has not been destroyed, you should see a later event for leave.');\n          }).catch(function (error) {\n            _loggerProxy.default.logger.error(\"Meeting:index#setUpLocusInfoMeetingListener --> DESTROY_MEETING. Issue with leave for meeting, meeting still in collection: \".concat(_this16.meeting, \", error: \").concat(error));\n          });\n        } else {\n          _loggerProxy.default.logger.info('Meeting:index#setUpLocusInfoMeetingListener --> MEETING_REMOVED_REASON', payload.reason);\n\n          _util.default.cleanUp(_this16);\n\n          _triggerProxy.default.trigger(_this16, {\n            file: 'meeting/index',\n            function: 'setUpLocusInfoMeetingListener'\n          }, _constants.EVENTS.DESTROY_MEETING, {\n            reason: payload.reason,\n            meetingId: _this16.id\n          });\n        }\n      });\n    }\n    /**\n     * Set meeting values rather than events\n     * @param {Object} object\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     * // TODO: is this function necessary?\n     */\n\n  }, {\n    key: \"updateMeetingObject\",\n    value: function updateMeetingObject(object) {\n      var _this17 = this; // Validate if these are valid meeting object property\n      // TODO: add a check to make sure the value passed in the constructor\n      // is not changed by any delta event\n\n\n      if (object && (0, _keys.default)(object).length) {\n        (0, _keys.default)(object).forEach(function (key) {\n          _this17[key] = object[key];\n        });\n      }\n    }\n    /**\n     * Invite a guest to the call that isn't normally part of this call\n     * @param {Object} invitee\n     * @param {String} invitee.emailAddress\n     * @param {String} invitee.email\n     * @param {String} invitee.phoneNumber\n     * @param {Boolean} [alertIfActive]\n     * @returns {Promise} see #members.addMember\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"invite\",\n    value: function invite(invitee) {\n      var alertIfActive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return this.members.addMember(invitee, alertIfActive);\n    }\n    /**\n     * Cancel an outgoing phone call invitation made during a meeting\n     * @param {Object} invitee\n     * @param {String} invitee.phoneNumber\n     * @returns {Promise} see #members.cancelPhoneInvite\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"cancelPhoneInvite\",\n    value: function cancelPhoneInvite(invitee) {\n      return this.members.cancelPhoneInvite(invitee);\n    }\n    /**\n     * Admit the guest(s) to the call once they are waiting\n     * @param {Array} memberIds\n     * @returns {Promise} see #members.admitMembers\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"admit\",\n    value: function admit(memberIds) {\n      return this.members.admitMembers(memberIds);\n    }\n    /**\n     * Remove the member from the meeting, boot them\n     * @param {String} memberId\n     * @returns {Promise} see #members.removeMember\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(memberId) {\n      return this.members.removeMember(memberId);\n    }\n    /**\n     * Mute another member from the meeting\n     * @param {String} memberId\n     * @param {Boolean} mute\n     * @returns {Promise} see #members.muteMember\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"mute\",\n    value: function mute(memberId) {\n      var _mute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      return this.members.muteMember(memberId, _mute);\n    }\n    /**\n     * Transfer the moderator role to another eligible member\n     * @param {String} memberId\n     * @param {Boolean} moderator\n     * @returns {Promise} see #members.transferHostToMember\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"transfer\",\n    value: function transfer(memberId) {\n      var moderator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return this.members.transferHostToMember(memberId, moderator);\n    }\n    /**\n     * Reference to the Members object\n     * @returns {Members}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"getMembers\",\n    value: function getMembers() {\n      return this.members;\n    }\n    /**\n     * If this gets turned off mid meeting after attaching media, it will shut down the MQA metrics and they will\n     * not restart unless the start function is called again\n     * @returns {undefined}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"cleanMQAInterval\",\n    value: function cleanMQAInterval() {\n      if (this.mqaInterval) {\n        clearInterval(this.mqaInterval);\n      }\n    }\n    /**\n     * Automatically publishes media metrics data and on a config interval\n     * uses the existing getStats data filter, so no new streams are created\n     * but it is separate than history, so history will not be available\n     * @returns {MediaMetrics}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"startMediaQualityMetrics\",\n    value: function startMediaQualityMetrics() {\n      var _this18 = this;\n\n      var automaticMetrics = new _metrics2.default({\n        config: this.config\n      });\n      var stats = this.getStats(automaticMetrics.initialize(), true);\n      this.mediaQualityMetrics = automaticMetrics;\n      this.mediaQualityMetrics.setStats(stats);\n      this.mqaInterval = setInterval(function () {\n        return _this18.processMQAData();\n      }, this.config.metrics.mqaMetricsInterval);\n      return automaticMetrics;\n    }\n    /**\n     * @private\n     * @returns {undefined}\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"processMQAData\",\n    value: function processMQAData() {\n      var _this19 = this;\n\n      if (!this.mqaProcessor) {\n        this.mqaProcessor = new _mqaProcessor.default();\n      }\n\n      _constants.MQA_STATS.DATA_PLACEMENTS.forEach(function (key) {\n        if (_this19.mediaQualityMetrics && _this19.mediaQualityMetrics.stats) {\n          var sendRecvData;\n\n          if (key.toLowerCase().endsWith(_constants.STATS.SENDER)) {\n            sendRecvData = _this19.mediaQualityMetrics.stats.getSender(key);\n          } else if (key.toLowerCase().endsWith(_constants.STATS.RECEIVER)) {\n            sendRecvData = _this19.mediaQualityMetrics.stats.getReceiver(key);\n          }\n\n          var mqa;\n\n          if (sendRecvData) {\n            mqa = sendRecvData.getMQA();\n          }\n\n          if (mqa) {\n            var interval = mqa.getSlice(_this19.config.metrics.mqaMetricsInterval / 1000); // milliseconds -> second based intervals\n\n            _this19.mqaProcessor.process(key, interval);\n          }\n        }\n      });\n    }\n    /**\n     * Reference to the stats builder object\n     * @param {Object} options - see #createStats\n     * @param {Boolean} override - override the previous getStats\n     * @returns {WebRTCStats}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"getStats\",\n    value: function getStats(options, override) {\n      if (!this.stats) {\n        return this.createStats(options);\n      }\n\n      if (override) {\n        if (this.stats) {\n          _loggerProxy.default.logger.log('Meeting:index#getStats --> Overriding the previous stats object without destroying first can result in memory leaks.');\n        }\n\n        return this.createStats(options);\n      }\n\n      return this.stats;\n    }\n    /**\n     * write the stats builder object and assign to meeting property\n     * @param {Object} options\n     * @returns {WebRTCStats}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"createStats\",\n    value: function createStats() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _util3.default.generateOptions(options, _constants.STATS.CONFIG, this);\n\n      options.config = _constants.STATS.CONFIG;\n      this.stats = new _index3.default(this.attrs, this.options, options);\n      return this.stats;\n    }\n    /**\n     * if you have started a stats instance, here's how you can stop it\n     * @returns {undefined}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"stopStats\",\n    value: function stopStats() {\n      if (this.stats) {\n        this.stats.destroySenders();\n        this.stats.destroyReceivers();\n        this.stats = null;\n      }\n    }\n    /**\n     * Truthy when a meeting has an audio connection established\n     * @returns {Boolean}  true if meeting audio is connected otherwise false\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"isAudioConnected\",\n    value: function isAudioConnected() {\n      return !!this.audio;\n    }\n    /**\n     * Convenience function to tell whether a meeting is muted\n     * @returns {Boolean} if meeting audio muted or not\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"isAudioMuted\",\n    value: function isAudioMuted() {\n      return this.audio && this.audio.isMuted();\n    }\n    /**\n     * Convenience function to tell if the end user last changed the audio state\n     * @returns {Boolean} if audio was manipulated by the end user\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"isAudioSelf\",\n    value: function isAudioSelf() {\n      return this.audio && this.audio.isSelf();\n    }\n    /**\n     * Truthy when a meeting has a video connection established\n     * @returns {Boolean} true if meeting video connected otherwise false\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"isVideoConnected\",\n    value: function isVideoConnected() {\n      return !!this.video;\n    }\n    /**\n     * Convenience function to tell whether video is muted\n     * @returns {Boolean} if meeting video is muted or not\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"isVideoMuted\",\n    value: function isVideoMuted() {\n      return this.video && this.video.isMuted();\n    }\n    /**\n     * Convenience function to tell whether the end user changed the video state\n     * @returns {Boolean} if meeting video is muted or not\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"isVideoSelf\",\n    value: function isVideoSelf() {\n      return this.video && this.video.isSelf();\n    }\n    /**\n     * Sets the meeting info on the class instance\n     * @param {Object} meetingInfo\n     * @param {Object} meetingInfo.body\n     * @param {String} meetingInfo.body.conversationUrl\n     * @param {String} meetingInfo.body.locusUrl\n     * @param {String} meetingInfo.body.sipUri\n     * @param {Object} meetingInfo.body.owner\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"parseMeetingInfo\",\n    value: function parseMeetingInfo(meetingInfo) {\n      var webexMeetingInfo = meetingInfo === null || meetingInfo === void 0 ? void 0 : meetingInfo.body; // MeetingInfo will be undefined for 1:1 calls\n\n      if (webexMeetingInfo && !(meetingInfo.errors && meetingInfo.errors.length > 0)) {\n        this.conversationUrl = webexMeetingInfo.conversationUrl || this.conversationUrl;\n        this.locusUrl = webexMeetingInfo.locusUrl || this.locusUrl;\n        this.setSipUri(this.config.experimental.enableUnifiedMeetings ? webexMeetingInfo.sipUrl : webexMeetingInfo.sipMeetingUri || this.sipUri);\n\n        if (this.config.experimental.enableUnifiedMeetings) {\n          this.meetingNumber = webexMeetingInfo.meetingNumber;\n          this.meetingJoinUrl = webexMeetingInfo.meetingJoinUrl;\n        }\n\n        this.owner = webexMeetingInfo.owner || webexMeetingInfo.hostId || this.owner;\n        this.permissionToken = webexMeetingInfo.permissionToken;\n      }\n    }\n    /**\n     * Sets the first locus info on the class instance\n     * @param {Object} locus\n     * @param {String} locus.url\n     * @param {Array} locus.participants\n     * @param {Object} locus.self\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"parseLocus\",\n    value: function parseLocus(locus) {\n      if (locus) {\n        this.locusUrl = locus.url; // TODO: move this to parse participants module\n\n        this.setLocus(locus); // check if we can extract this info from partner\n        // Parsing of locus object must be finished at this state\n\n        if (locus.participants && locus.self) {\n          this.partner = _util.default.getLocusPartner(locus.participants, locus.self);\n        } // For webex meeting the sipUrl gets updated in info parser\n\n\n        if (!this.sipUri && this.partner && this.type === _constants._CALL_) {\n          this.setSipUri(this.partner.person.sipUrl || this.partner.person.id);\n        }\n      }\n    }\n    /**\n     * Sets the sip uri on the class instance\n     * uses meeting info as precedence\n     * @param {String} sipUri\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"setSipUri\",\n    value: function setSipUri(sipUri) {\n      // This can be tel no, device id or a sip uri, user Id\n      this.sipUri = sipUri;\n    }\n    /**\n     * Set the roap seq on the class instance\n     * @param {Number} seq\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"setRoapSeq\",\n    value: function setRoapSeq(seq) {\n      if (seq >= 0) {\n        this.roapSeq = seq;\n      }\n    }\n    /**\n     * Set the locus info the class instance\n     * @param {Object} locus\n     * @param {Array} locus.mediaConnections\n     * @param {String} locus.locusUrl\n     * @param {String} locus.locusId\n     * @param {String} locus.mediaId\n     * @param {Object} locus.host\n     * @todo change name to genertic parser\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"setLocus\",\n    value: function setLocus(locus) {\n      var mtgLocus = locus.locus || locus; // LocusInfo object saves the locus object\n      // this.locus = mtgLocus;\n\n      this.mediaConnections = locus.mediaConnections;\n      this.locusUrl = locus.locusUrl || locus.url;\n      this.locusId = locus.locusId;\n      this.selfId = locus.selfId;\n      this.mediaId = locus.mediaId;\n      this.hostId = mtgLocus.host ? mtgLocus.host.id : this.hostId;\n      this.locusInfo.initialSetup(mtgLocus);\n    }\n    /**\n     * Sets the remote stream on the class instance and emits and\n     * event to developers\n     * @param {Object} pc The remote stream peer connection\n     * @returns {undefined}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"setRemoteStream\",\n    value: function setRemoteStream(pc) {\n      var _this20 = this;\n\n      if (!pc) {\n        return;\n      } // eslint-disable-next-line no-param-reassign\n\n\n      pc.ontrack = function (event) {\n        // eslint-disable-next-line no-warning-comments\n        // TODO: It's possible for media to not be present\n        // so we might need to either\n        // A) wait until we have media flowing\n        // B) trigger a second event when video is flowing\n        _loggerProxy.default.logger.log(\"Meeting:index#setRemoteStream --> ontrack event received for peerConnection: \".concat(event));\n\n        var MEDIA_ID = {\n          AUDIO_TRACK: '0',\n          VIDEO_TRACK: '1',\n          SHARE_TRACK: '2'\n        };\n        var eventType = null;\n        var mediaTrack = event.track;\n        var trackMediaID = null; // In case of safari some time the transceiver is not present for specific os version\n        // sdk tries to determine the transceive using the track id present\n\n        if (event.transceiver && event.transceiver.mid) {\n          trackMediaID = event.transceiver.mid;\n        } else {\n          var _event$target = event.target,\n              audioTransceiver = _event$target.audioTransceiver,\n              videoTransceiver = _event$target.videoTransceiver,\n              shareTransceiver = _event$target.shareTransceiver; // audio kind indicates its a audio stream\n\n          if (mediaTrack.id === audioTransceiver.receiver.track.id) {\n            trackMediaID = '0';\n          } else if (mediaTrack.id === videoTransceiver.receiver.track.id) {\n            trackMediaID = '1';\n          } else if (mediaTrack.id === shareTransceiver.receiver.track.id) {\n            trackMediaID = '2';\n          } else {\n            trackMediaID = null;\n\n            _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.MUTE_AUDIO_FAILURE, {\n              correlation_id: _this20.correlationId,\n              locus_id: _this20.locusUrl.split('/').pop()\n            });\n          }\n        }\n\n        switch (trackMediaID) {\n          case MEDIA_ID.AUDIO_TRACK:\n            eventType = _constants.EVENT_TYPES.REMOTE_AUDIO;\n\n            _this20.mediaProperties.setRemoteAudioTrack(mediaTrack);\n\n            break;\n\n          case MEDIA_ID.VIDEO_TRACK:\n            eventType = _constants.EVENT_TYPES.REMOTE_VIDEO;\n\n            _this20.mediaProperties.setRemoteVideoTrack(mediaTrack);\n\n            break;\n\n          case MEDIA_ID.SHARE_TRACK:\n            if (event.track) {\n              eventType = _constants.EVENT_TYPES.REMOTE_SHARE;\n\n              _this20.mediaProperties.setRemoteShare(mediaTrack);\n            }\n\n            break;\n\n          default:\n            {\n              _loggerProxy.default.logger.log('Meeting:index#setRemoteStream --> no matching media track id');\n            }\n        } // start stats here the stats are coming null if you dont receive streams\n\n\n        _this20.statsAnalyzer.startAnalyzer(_this20.mediaProperties.peerConnection);\n\n        if (eventType && mediaTrack) {\n          _triggerProxy.default.trigger(_this20, {\n            file: 'meeting/index',\n            function: 'setRemoteStream:pc.ontrack'\n          }, _constants.EVENT_TRIGGERS.MEDIA_READY, {\n            type: eventType,\n            stream: _util2.default.createMediaStream([mediaTrack])\n          });\n        }\n      };\n    }\n    /**\n     * Upload logs for the current meeting\n     * @param {object} options file name and function name\n     * @returns {undefined}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"uploadLogs\",\n    value: function uploadLogs() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        file: 'meeting/index',\n        function: 'uploadLogs'\n      };\n\n      _triggerProxy.default.trigger(this, options, _constants.EVENTS.REQUEST_UPLOAD_LOGS, this);\n    }\n    /**\n     * Removes remote audio and video stream on the class instance and triggers an event\n     * to developers\n     * @returns {undefined}\n     * @public\n     * @memberof Meeting\n     * @deprecated after v1.89.3\n     */\n\n  }, {\n    key: \"unsetRemoteStream\",\n    value: function unsetRemoteStream() {\n      _loggerProxy.default.logger.warn('Meeting:index#unsetRemoteStream --> [DEPRECATION WARNING]: unsetRemoteStream has been deprecated after v1.89.3');\n\n      this.mediaProperties.unsetRemoteMedia();\n    }\n    /**\n     * Removes remote audio, video and share tracks from class instance's mediaProperties\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"unsetRemoteTracks\",\n    value: function unsetRemoteTracks() {\n      this.mediaProperties.unsetRemoteTracks();\n    }\n    /**\n     * Removes the remote stream on the class instance and triggers an event\n     * to developers\n     * @returns {undefined}\n     * @public\n     * @memberof Meeting\n     * @deprecated after v1.89.3\n     */\n\n  }, {\n    key: \"closeRemoteStream\",\n    value: function closeRemoteStream() {\n      _loggerProxy.default.logger.warn('Meeting:index#closeRemoteStream --> [DEPRECATION WARNING]: closeRemoteStream has been deprecated after v1.89.3');\n\n      this.closeRemoteTracks();\n    }\n    /**\n     * Removes the remote tracks on the class instance and triggers an event\n     * to developers\n     * @returns {undefined}\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"closeRemoteTracks\",\n    value: function closeRemoteTracks() {\n      var _this21 = this;\n\n      var _this$mediaProperties = this.mediaProperties,\n          remoteAudioTrack = _this$mediaProperties.remoteAudioTrack,\n          remoteVideoTrack = _this$mediaProperties.remoteVideoTrack,\n          remoteShare = _this$mediaProperties.remoteShare;\n      /**\n       * Triggers an event to the developer\n       * @param {string} mediaType Type of media that was stopped\n       * @returns {void}\n       * @inner\n       */\n\n      var triggerMediaStoppedEvent = function triggerMediaStoppedEvent(mediaType) {\n        _triggerProxy.default.trigger(_this21, {\n          file: 'meeting/index',\n          function: 'closeRemoteTracks'\n        }, _constants.EVENT_TRIGGERS.MEDIA_STOPPED, {\n          type: mediaType\n        });\n      };\n      /**\n       * Stops a media track and emits an event\n       * @param {MediaStreamTrack} track Media track to stop\n       * @param {string} type Media track type\n       * @returns {Promise}\n       * @inner\n       */\n      // eslint-disable-next-line arrow-body-style\n\n\n      var stopTrack = function stopTrack(track, type) {\n        return _media.default.stopTracks(track).then(function () {\n          var isTrackStopped = track && track.readyState === _constants.ENDED;\n          var isWrongReadyState = track && !isTrackStopped;\n\n          if (isTrackStopped) {\n            triggerMediaStoppedEvent(type);\n          } else if (isWrongReadyState) {\n            _loggerProxy.default.logger.warn(\"Meeting:index#closeRemoteTracks --> Error: MediaStreamTrack.readyState is \".concat(track.readyState, \" for \").concat(type));\n          }\n        });\n      };\n\n      return _promise.default.all([stopTrack(remoteAudioTrack, _constants.EVENT_TYPES.REMOTE_AUDIO), stopTrack(remoteVideoTrack, _constants.EVENT_TYPES.REMOTE_VIDEO), stopTrack(remoteShare, _constants.EVENT_TYPES.REMOTE_SHARE)]);\n    }\n    /**\n     * Emits the 'media:ready' event with a local stream that consists of 1 local audio and 1 local video track\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"sendLocalMediaReadyEvent\",\n    value: function sendLocalMediaReadyEvent() {\n      _triggerProxy.default.trigger(this, {\n        file: 'meeting/index',\n        function: 'setLocalTracks'\n      }, _constants.EVENT_TRIGGERS.MEDIA_READY, {\n        type: _constants.EVENT_TYPES.LOCAL,\n        stream: _util2.default.createMediaStream([this.mediaProperties.audioTrack, this.mediaProperties.videoTrack])\n      });\n    }\n    /**\n     * Sets the local audio track on the class and emits an event to the developer\n     * @param {MediaStreamTrack} audioTrack\n     * @param {Boolean} emitEvent if true, a media ready event is emitted to the developer\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"setLocalAudioTrack\",\n    value: function setLocalAudioTrack(audioTrack) {\n      var emitEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (audioTrack) {\n        var settings = audioTrack.getSettings();\n        this.mediaProperties.setMediaSettings('audio', {\n          echoCancellation: settings.echoCancellation,\n          noiseSuppression: settings.noiseSuppression\n        });\n\n        _loggerProxy.default.logger.log('Meeting:index#setLocalAudioTrack --> Audio settings.', (0, _stringify.default)(this.mediaProperties.mediaSettings.audio));\n\n        this.mediaProperties.setLocalAudioTrack(audioTrack);\n        if (this.audio) this.audio.applyClientStateLocally(this);\n      }\n\n      if (emitEvent) {\n        this.sendLocalMediaReadyEvent();\n      }\n    }\n    /**\n     * Sets the local video track on the class and emits an event to the developer\n     * @param {MediaStreamTrack} videoTrack\n     * @param {Boolean} emitEvent if true, a media ready event is emitted to the developer\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"setLocalVideoTrack\",\n    value: function setLocalVideoTrack(videoTrack) {\n      var emitEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (videoTrack) {\n        var _videoTrack$getSettin = videoTrack.getSettings(),\n            aspectRatio = _videoTrack$getSettin.aspectRatio,\n            frameRate = _videoTrack$getSettin.frameRate,\n            height = _videoTrack$getSettin.height,\n            width = _videoTrack$getSettin.width,\n            deviceId = _videoTrack$getSettin.deviceId;\n\n        this.mediaProperties.setLocalVideoTrack(videoTrack);\n        if (this.video) this.video.applyClientStateLocally(this);\n        this.mediaProperties.setMediaSettings('video', {\n          aspectRatio: aspectRatio,\n          frameRate: frameRate,\n          height: height,\n          width: width\n        }); // store and save the selected video input device\n\n        if (deviceId) {\n          this.mediaProperties.setVideoDeviceId(deviceId);\n        }\n\n        _loggerProxy.default.logger.log('Meeting:index#setLocalVideoTrack --> Video settings.', (0, _stringify.default)(this.mediaProperties.mediaSettings.video));\n      }\n\n      if (emitEvent) {\n        this.sendLocalMediaReadyEvent();\n      }\n    }\n    /**\n     * Sets the local media stream on the class and emits an event to the developer\n     * @param {Stream} localStream the local media stream\n     * @returns {undefined}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"setLocalTracks\",\n    value: function setLocalTracks(localStream) {\n      if (localStream) {\n        var _MeetingUtil$getTrack = _util.default.getTrack(localStream),\n            audioTrack = _MeetingUtil$getTrack.audioTrack,\n            videoTrack = _MeetingUtil$getTrack.videoTrack;\n\n        this.setLocalAudioTrack(audioTrack, false);\n        this.setLocalVideoTrack(videoTrack, false);\n        this.sendLocalMediaReadyEvent();\n      }\n    }\n    /**\n     * Sets the local media stream on the class and emits an event to the developer\n     * @param {Stream} localShare the local media stream\n     * @returns {undefined}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"setLocalShareTrack\",\n    value: function setLocalShareTrack(localShare) {\n      var _this22 = this;\n\n      var settings = null;\n\n      if (localShare) {\n        this.mediaProperties.setLocalShareTrack(_util.default.getTrack(localShare).videoTrack);\n        var contentTracks = this.mediaProperties.shareTrack;\n\n        if (contentTracks) {\n          settings = contentTracks.getSettings();\n          this.mediaProperties.setMediaSettings('screen', {\n            aspectRatio: settings.aspectRatio,\n            frameRate: settings.frameRate,\n            height: settings.height,\n            width: settings.width,\n            displaySurface: settings.displaySurface,\n            cursor: settings.cursor\n          });\n\n          _loggerProxy.default.logger.log('Meeting:index#setLocalShareTrack --> Screen settings.', (0, _stringify.default)(this.mediaProperties.mediaSettings.screen));\n        }\n\n        contentTracks.onended = function () {\n          return _this22.handleShareTrackEnded(localShare);\n        };\n\n        _triggerProxy.default.trigger(this, {\n          file: 'meeting/index',\n          function: 'setLocalShareTrack'\n        }, _constants.EVENT_TRIGGERS.MEDIA_READY, {\n          type: _constants.EVENT_TYPES.LOCAL_SHARE,\n          stream: localShare\n        });\n      }\n    }\n    /**\n     * Closes the local stream from the class and emits an event to the developer\n     * @returns {undefined}\n     * @event media:stopped\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"closeLocalStream\",\n    value: function closeLocalStream() {\n      var _this23 = this;\n\n      var _this$mediaProperties2 = this.mediaProperties,\n          audioTrack = _this$mediaProperties2.audioTrack,\n          videoTrack = _this$mediaProperties2.videoTrack;\n      return _media.default.stopTracks(audioTrack).then(function () {\n        return _media.default.stopTracks(videoTrack);\n      }).then(function () {\n        var audioStopped = audioTrack && audioTrack.readyState === _constants.ENDED;\n        var videoStopped = videoTrack && videoTrack.readyState === _constants.ENDED;\n\n        if (audioStopped && videoStopped) {\n          _triggerProxy.default.trigger(_this23, {\n            file: 'meeting/index',\n            function: 'closeLocalStream'\n          }, _constants.EVENT_TRIGGERS.MEDIA_STOPPED, {\n            type: _constants.EVENT_TYPES.LOCAL\n          });\n        } else if (audioTrack || videoTrack) {\n          _loggerProxy.default.logger.warn('Meeting:index#closeLocalStream --> Error: MediaStreamTrack.readyState is incorrect.');\n        }\n      });\n    }\n    /**\n     * Closes the local stream from the class and emits an event to the developer\n     * @returns {undefined}\n     * @event media:stopped\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"closeLocalShare\",\n    value: function closeLocalShare() {\n      var _this24 = this;\n\n      var track = this.mediaProperties.shareTrack;\n      return _media.default.stopTracks(track).then(function () {\n        if (track && track.readyState === _constants.ENDED) {\n          _triggerProxy.default.trigger(_this24, {\n            file: 'meeting/index',\n            function: 'closeLocalShare'\n          }, _constants.EVENT_TRIGGERS.MEDIA_STOPPED, {\n            type: _constants.EVENT_TYPES.LOCAL_SHARE\n          });\n        } else if (track) {\n          // Track exists but with wrong readyState\n          _loggerProxy.default.logger.warn(\"Meeting:index#closeLocalShare --> Error: MediaStreamTrack.readyState is \".concat(track.readyState, \" for localShare\"));\n        }\n      });\n    }\n    /**\n     * Removes the local stream from the class and emits an event to the developer\n     * @returns {undefined}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"unsetLocalVideoTrack\",\n    value: function unsetLocalVideoTrack() {\n      this.mediaProperties.unsetLocalVideoTrack();\n    }\n    /**\n     * Removes the local share from the class and emits an event to the developer\n     * @returns {undefined}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"unsetLocalShareTrack\",\n    value: function unsetLocalShareTrack() {\n      this.mediaProperties.unsetLocalShareTrack();\n    }\n    /**\n     * sets up listner for mercury event\n     * @returns {undefined}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"setMercuryListener\",\n    value: function setMercuryListener() {\n      var _this25 = this; // Client will have a socket manager and handle reconnecting to mercury, when we reconnect to mercury\n      // if the meeting has active peer connections, it should try to reconnect.\n\n\n      this.webex.internal.mercury.on(_constants.ONLINE, function () {\n        _loggerProxy.default.logger.info('Meeting:index#setMercuryListener --> Web socket online'); // Only send restore event when it was disconnected before and for connected later\n\n\n        if (!_this25.hasWebsocketConnected) {\n          _metrics.default.postEvent({\n            event: _config.eventType.MERCURY_CONNECTION_RESTORED,\n            meeting: _this25\n          });\n\n          _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.MERCURY_CONNECTION_RESTORED, {\n            correlation_id: _this25.correlationId\n          });\n        }\n\n        _this25.hasWebsocketConnected = true;\n      });\n      this.webex.internal.mercury.on(_constants.OFFLINE, function () {\n        _loggerProxy.default.logger.error('Meeting:index#setMercuryListener --> Web socket offline');\n\n        _metrics.default.postEvent({\n          event: _config.eventType.MERCURY_CONNECTION_LOST,\n          meeting: _this25\n        });\n\n        _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.MERCURY_CONNECTION_FAILURE, {\n          correlation_id: _this25.correlationId\n        });\n      });\n    }\n    /**\n     * Close the peer connections and remove them from the class. Triggers an event\n     * when each is closed.\n     * @returns {Promise} returns a resolved promise with an array of closed peer connections\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"closePeerConnections\",\n    value: function closePeerConnections() {\n      return _peerConnectionManager.default.close(this.mediaProperties.peerConnection);\n    }\n    /**\n     * Unsets the peer connections on the class\n     * warning DO NOT CALL WITHOUT CLOSING PEER CONNECTIONS FIRST\n     * @param {PeerConnection} peerConnection\n     * @returns {undefined}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"unsetPeerConnections\",\n    value: function unsetPeerConnections() {\n      this.mediaProperties.unsetPeerConnection();\n\n      if (this.config.reconnection.detection) {\n        this.webex.internal.mercury.off(_constants.ONLINE);\n      }\n    }\n    /**\n     * Convenience method to set the correlation id for the Meeting\n     * @param {String} id correlation id to set on the class\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"setCorrelationId\",\n    value: function setCorrelationId(id) {\n      this.correlationId = id;\n    }\n    /**\n     * Mute the audio for a meeting\n     * @returns {Promise} resolves the data from muting audio {mute, self} or rejects if there is no audio set\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"muteAudio\",\n    value: function muteAudio() {\n      var _this26 = this;\n\n      if (!_util.default.isUserInJoinedState(this.locusInfo)) {\n        return _promise.default.reject(new _webexErrors.UserNotJoinedError());\n      }\n\n      if (!this.mediaId) {\n        // Happens when addMedia and mute are triggered in succession\n        return _promise.default.reject(new _webexErrors.NoMediaEstablishedYetError());\n      }\n\n      if (!this.audio) {\n        return _promise.default.reject(new _parameter.default('no audio control associated to the meeting'));\n      }\n\n      var LOG_HEADER = 'Meeting:index#muteAudio -->'; // First, stop sending the local audio media\n\n      return logRequest(this.audio.handleClientRequest(this, true).then(function () {\n        _util.default.handleAudioLogging(_this26.mediaProperties.audioTrack);\n\n        _metrics.default.postEvent({\n          event: _config.eventType.MUTED,\n          meeting: _this26,\n          data: {\n            trigger: _config.trigger.USER_INTERACTION,\n            mediaType: _config.mediaType.AUDIO\n          }\n        });\n      }).catch(function (error) {\n        _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.MUTE_AUDIO_FAILURE, {\n          correlation_id: _this26.correlationId,\n          locus_id: _this26.locusUrl.split('/').pop(),\n          reason: error.message,\n          stack: error.stack\n        });\n\n        throw error;\n      }), {\n        header: \"\".concat(LOG_HEADER, \" muting audio\"),\n        success: \"\".concat(LOG_HEADER, \" muted audio successfully\"),\n        failure: \"\".concat(LOG_HEADER, \" muting audio failed, \")\n      });\n    }\n    /**\n     * Unmute meeting audio\n     * @returns {Promise} resolves data from muting audio {mute, self} or rejects if there is no audio set\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"unmuteAudio\",\n    value: function unmuteAudio() {\n      var _this27 = this;\n\n      if (!_util.default.isUserInJoinedState(this.locusInfo)) {\n        return _promise.default.reject(new _webexErrors.UserNotJoinedError());\n      }\n\n      if (!this.mediaId) {\n        // Happens when addMedia and mute are triggered in succession\n        return _promise.default.reject(new _webexErrors.NoMediaEstablishedYetError());\n      }\n\n      if (!this.audio) {\n        return _promise.default.reject(new _parameter.default('no audio control associated to the meeting'));\n      }\n\n      var LOG_HEADER = 'Meeting:index#unmuteAudio -->'; // First, send the control to unmute the participant on the server\n\n      return logRequest(this.audio.handleClientRequest(this, false).then(function () {\n        _util.default.handleAudioLogging(_this27.mediaProperties.audioTrack);\n\n        _metrics.default.postEvent({\n          event: _config.eventType.UNMUTED,\n          meeting: _this27,\n          data: {\n            trigger: _config.trigger.USER_INTERACTION,\n            mediaType: _config.mediaType.AUDIO\n          }\n        });\n      }).catch(function (error) {\n        _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.UNMUTE_AUDIO_FAILURE, {\n          correlation_id: _this27.correlationId,\n          locus_id: _this27.locusUrl.split('/').pop(),\n          reason: error.message,\n          stack: error.stack\n        });\n\n        throw error;\n      }), {\n        header: \"\".concat(LOG_HEADER, \" unmuting audio\"),\n        success: \"\".concat(LOG_HEADER, \" unmuted audio successfully\"),\n        failure: \"\".concat(LOG_HEADER, \" unmuting audio failed, \")\n      });\n    }\n    /**\n     * Mute the video for a meeting\n     * @returns {Promise} resolves data from muting video {mute, self} or rejects if there is no video set\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"muteVideo\",\n    value: function muteVideo() {\n      var _this28 = this;\n\n      if (!_util.default.isUserInJoinedState(this.locusInfo)) {\n        return _promise.default.reject(new _webexErrors.UserNotJoinedError());\n      }\n\n      if (!this.mediaId) {\n        // Happens when addMedia and mute are triggered in succession\n        return _promise.default.reject(new _webexErrors.NoMediaEstablishedYetError());\n      }\n\n      if (!this.video) {\n        return _promise.default.reject(new _parameter.default('no video control associated to the meeting'));\n      }\n\n      var LOG_HEADER = 'Meeting:index#muteVideo -->';\n      return logRequest(this.video.handleClientRequest(this, true).then(function () {\n        _util.default.handleVideoLogging(_this28.mediaProperties.videoTrack);\n\n        _metrics.default.postEvent({\n          event: _config.eventType.MUTED,\n          meeting: _this28,\n          data: {\n            trigger: _config.trigger.USER_INTERACTION,\n            mediaType: _config.mediaType.VIDEO\n          }\n        });\n      }).catch(function (error) {\n        _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.MUTE_VIDEO_FAILURE, {\n          correlation_id: _this28.correlationId,\n          locus_id: _this28.locusUrl.split('/').pop(),\n          reason: error.message,\n          stack: error.stack\n        });\n\n        throw error;\n      }), {\n        header: \"\".concat(LOG_HEADER, \" muting video\"),\n        success: \"\".concat(LOG_HEADER, \" muted video successfully\"),\n        failure: \"\".concat(LOG_HEADER, \" muting video failed, \")\n      });\n    }\n    /**\n     * Unmute meeting video\n     * @returns {Promise} resolves data from muting video {mute, self} or rejects if there is no video set\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"unmuteVideo\",\n    value: function unmuteVideo() {\n      var _this29 = this;\n\n      if (!_util.default.isUserInJoinedState(this.locusInfo)) {\n        return _promise.default.reject(new _webexErrors.UserNotJoinedError());\n      }\n\n      if (!this.mediaId) {\n        // Happens when addMedia and mute are triggered in succession\n        return _promise.default.reject(new _webexErrors.NoMediaEstablishedYetError());\n      }\n\n      if (!this.video) {\n        return _promise.default.reject(new _parameter.default('no audio control associated to the meeting'));\n      }\n\n      var LOG_HEADER = 'Meeting:index#unmuteVideo -->';\n      return logRequest(this.video.handleClientRequest(this, false).then(function () {\n        _util.default.handleVideoLogging(_this29.mediaProperties.videoTrack);\n\n        _metrics.default.postEvent({\n          event: _config.eventType.UNMUTED,\n          meeting: _this29,\n          data: {\n            trigger: _config.trigger.USER_INTERACTION,\n            mediaType: _config.mediaType.VIDEO\n          }\n        });\n      }).catch(function (error) {\n        _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.UNMUTE_VIDEO_FAILURE, {\n          correlation_id: _this29.correlationId,\n          locus_id: _this29.locusUrl.split('/').pop(),\n          reason: error.message,\n          stack: error.stack\n        });\n\n        throw error;\n      }), {\n        header: \"\".concat(LOG_HEADER, \" unmuting video\"),\n        success: \"\".concat(LOG_HEADER, \" unmuted video successfully\"),\n        failure: \"\".concat(LOG_HEADER, \" unmuting video failed, \")\n      });\n    }\n    /**\n     * Shorthand function to join AND set up media\n     * @param {Object} options - options to join with media\n     * @param {JoinOptions} [options.joinOptions] - see #join()\n     * @param {MediaDirection} options.mediaSettings - see #addMedia()\n     * @param {AudioVideo} [options.audioVideoOptions] - see #getMediaStreams()\n     * @returns {Promise} -- {join: see join(), media: see addMedia(), local: see getMediaStreams()}\n     * @public\n     * @memberof Meeting\n     * @example\n     * joinWithMedia({\n     *  joinOptions: {resourceId: 'resourceId' },\n     *  mediaSettings: {\n     *   sendAudio: true,\n     *   sendVideo: true,\n     *   sendShare: false,\n     *   receiveVideo:true,\n     *   receiveAudio: true,\n     *   receiveShare: true\n     * }\n     * audioVideoOptions: {\n     *   audio: 'audioDeviceId',\n     *   video: 'videoDeviceId'\n     * }})\n     */\n\n  }, {\n    key: \"joinWithMedia\",\n    value: function joinWithMedia() {\n      var _this30 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // TODO: add validations for parameters\n\n      var mediaSettings = options.mediaSettings,\n          joinOptions = options.joinOptions,\n          audioVideoOptions = options.audioVideoOptions;\n      return this.join(joinOptions).then(function (joinResponse) {\n        return _this30.getMediaStreams(mediaSettings, audioVideoOptions).then(function (_ref6) {\n          var _ref7 = (0, _slicedToArray2.default)(_ref6, 2),\n              localStream = _ref7[0],\n              localShare = _ref7[1];\n\n          return _this30.addMedia({\n            mediaSettings: mediaSettings,\n            localShare: localShare,\n            localStream: localStream\n          }).then(function (mediaResponse) {\n            return {\n              join: joinResponse,\n              media: mediaResponse,\n              local: [localStream, localShare]\n            };\n          });\n        });\n      }).catch(function (error) {\n        _loggerProxy.default.logger.error('Meeting:index#joinWithMedia --> ', error);\n\n        _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.JOIN_WITH_MEDIA_FAILURE, {\n          correlation_id: _this30.correlationId,\n          locus_id: _this30.locusUrl.split('/').pop(),\n          reason: error.message,\n          stack: error.stack\n        }, {\n          type: error.name\n        });\n\n        return _promise.default.reject(error);\n      });\n    }\n    /**\n     * Initiates the reconnection of the media in the meeting\n     *\n     * @param {object} options\n     * @returns {Promise} resolves with {reconnect} or errors with {error}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"reconnect\",\n    value: function reconnect(options) {\n      var _this31 = this;\n\n      _loggerProxy.default.logger.log(\"Meeting:index#reconnect --> attempting to reconnect meeting \".concat(this.id));\n\n      if (!this.reconnectionManager || !this.reconnectionManager.reconnect) {\n        return _promise.default.reject(new _parameter.default('Cannot reconnect, ReconnectionManager must first be defined.'));\n      }\n\n      if (!_util.default.isMediaEstablished(this.currentMediaStatus)) {\n        return _promise.default.reject(new _parameter.default('Cannot reconnect, Media has not established to reconnect'));\n      }\n\n      try {\n        _loggerProxy.default.logger.info('Meeting:index#reconnect --> Validating reconnect ability.');\n\n        this.reconnectionManager.validate();\n      } catch (error) {\n        // Unable to reconnect this call\n        if (error instanceof _reconnectionInProgress.default) {\n          _loggerProxy.default.logger.info('Meeting:index#reconnect --> Unable to reconnect, reconnection in progress.');\n        } else {\n          _loggerProxy.default.logger.log('Meeting:index#reconnect --> Unable to reconnect.', error);\n        }\n\n        return _promise.default.resolve();\n      }\n\n      _triggerProxy.default.trigger(this, {\n        file: 'meeting/index',\n        function: 'reconnect'\n      }, _constants.EVENT_TRIGGERS.MEETING_RECONNECTION_STARTING);\n\n      return this.reconnectionManager.reconnect(options).then(function () {\n        _triggerProxy.default.trigger(_this31, {\n          file: 'meeting/index',\n          function: 'reconnect'\n        }, _constants.EVENT_TRIGGERS.MEETING_RECONNECTION_SUCCESS);\n\n        _loggerProxy.default.logger.log('Meeting:index#reconnect --> Meeting reconnect success');\n      }).catch(function (error) {\n        _triggerProxy.default.trigger(_this31, {\n          file: 'meeting/index',\n          function: 'reconnect'\n        }, _constants.EVENT_TRIGGERS.MEETING_RECONNECTION_FAILURE, {\n          error: new _reconnection.default('Reconnection failure event', error)\n        });\n\n        _loggerProxy.default.logger.error('Meeting:index#reconnect --> Meeting reconnect failed', error);\n\n        _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.MEETING_RECONNECT_FAILURE, {\n          correlation_id: _this31.correlationId,\n          locus_id: _this31.locusUrl.split('/').pop(),\n          reason: error.message,\n          stack: error.stack\n        });\n\n        _this31.uploadLogs({\n          file: 'meeting/index',\n          function: 'reconnect'\n        });\n\n        return _promise.default.reject(new _reconnection.default('Reconnection failure event', error));\n      }).finally(function () {\n        _this31.reconnectionManager.reset();\n      });\n    }\n    /**\n     * Check if the meeting supports the Webex Assistant feature\n     * @returns {boolean}\n     * @throws TranscriptionNotSupportedError\n     */\n\n  }, {\n    key: \"isTranscriptionSupported\",\n    value: function isTranscriptionSupported() {\n      var _this$policy;\n\n      if ((_this$policy = this.policy) !== null && _this$policy !== void 0 && _this$policy.WEBEX_ASSISTANT_STATUS_ACTIVE) {\n        return true;\n      }\n\n      _loggerProxy.default.logger.error('Meeting:index#isTranscriptionSupported --> Webex Assistant is not supported');\n\n      return false;\n    }\n    /**\n     * Monitor the Low-Latency Mercury (LLM) web socket connection on `onError` and `onClose` states\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: \"monitorTranscriptionSocketConnection\",\n    value: function monitorTranscriptionSocketConnection() {\n      var _this32 = this;\n\n      this.transcription.onCloseSocket(function (event) {\n        _loggerProxy.default.logger.info(\"Meeting:index#onCloseSocket -->\\n        unable to continue receiving transcription;\\n        low-latency mercury web socket connection is closed now.\\n        \".concat(event));\n\n        _this32.triggerStopReceivingTranscriptionEvent();\n      });\n      this.transcription.onErrorSocket(function (event) {\n        _loggerProxy.default.logger.error(\"Meeting:index#onErrorSocket -->\\n         unable to continue receiving transcription;\\n         low-latency mercury web socket connection error had occured.\\n        \".concat(event));\n\n        _this32.triggerStopReceivingTranscriptionEvent();\n\n        _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.RECEIVE_TRANSCRIPTION_FAILURE, {\n          correlation_id: _this32.correlationId,\n          reason: 'unexpected error: transcription LLM web socket connection error had occured.',\n          event: event\n        });\n      });\n    }\n    /**\n     * Request for a WebSocket Url, open and monitor the WebSocket connection\n     * @private\n     * @returns {Promise<void>} a promise to open the WebSocket connection\n     */\n\n  }, {\n    key: \"receiveTranscription\",\n    value: function () {\n      var _receiveTranscription = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {\n        var _this33 = this;\n\n        var datachannelUrl, _yield$this$request, webSocketUrl;\n\n        return _regenerator.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _loggerProxy.default.logger.info(\"Meeting:index#receiveTranscription -->\\n      Attempting to generate a web socket url.\");\n\n                _context2.prev = 1;\n                datachannelUrl = this.locusInfo.info.datachannelUrl;\n                _context2.next = 5;\n                return this.request({\n                  method: _constants.HTTP_VERBS.POST,\n                  uri: datachannelUrl,\n                  body: {\n                    deviceUrl: this.deviceUrl\n                  }\n                });\n\n              case 5:\n                _yield$this$request = _context2.sent;\n                webSocketUrl = _yield$this$request.body.webSocketUrl;\n\n                _loggerProxy.default.logger.info(\"Meeting:index#receiveTranscription -->\\n        Generated web socket url succesfully.\");\n\n                this.transcription = new _transcription.default(webSocketUrl, this.webex.sessionId, this.members);\n\n                _loggerProxy.default.logger.info(\"Meeting:index#receiveTranscription -->\\n        opened LLM web socket connection successfully.\"); // retrieve and pass the payload\n\n\n                this.transcription.subscribe(function (payload) {\n                  _triggerProxy.default.trigger(_this33, {\n                    file: 'meeting/index',\n                    function: 'join'\n                  }, _constants.EVENT_TRIGGERS.MEETING_STARTED_RECEIVING_TRANSCRIPTION, payload);\n                });\n                this.monitorTranscriptionSocketConnection();\n                this.transcription.connect(this.webex.credentials.supertoken.access_token);\n                _context2.next = 19;\n                break;\n\n              case 15:\n                _context2.prev = 15;\n                _context2.t0 = _context2[\"catch\"](1);\n\n                _loggerProxy.default.logger.error(\"Meeting:index#receiveTranscription --> \".concat(_context2.t0));\n\n                _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.RECEIVE_TRANSCRIPTION_FAILURE, {\n                  correlation_id: this.correlationId,\n                  reason: _context2.t0.message,\n                  stack: _context2.t0.stack\n                });\n\n              case 19:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[1, 15]]);\n      }));\n\n      function receiveTranscription() {\n        return _receiveTranscription.apply(this, arguments);\n      }\n\n      return receiveTranscription;\n    }()\n    /**\n     * stop recieving Transcription by closing\n     * the web socket connection properly\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stopReceivingTranscription\",\n    value: function stopReceivingTranscription() {\n      if (this.transcription) {\n        this.transcription.closeSocket();\n      }\n    }\n    /**\n     * triggers an event to notify that the user\n     * will not receive any more transcription\n     * @private\n     * @returns{void}\n     */\n\n  }, {\n    key: \"triggerStopReceivingTranscriptionEvent\",\n    value: function triggerStopReceivingTranscriptionEvent() {\n      _loggerProxy.default.logger.info(\"\\n      Meeting:index#stopReceivingTranscription -->\\n      closed transcription LLM web socket connection successfully.\");\n\n      _triggerProxy.default.trigger(this, {\n        file: 'meeting',\n        function: 'triggerStopReceivingTranscriptionEvent'\n      }, _constants.EVENT_TRIGGERS.MEETING_STOPPED_RECEIVING_TRANSCRIPTION);\n    }\n    /**\n     * Specify joining via audio (option: pstn), video, screenshare\n     * @param {JoinOptions} options A configurable options object for joining a meeting\n     * @returns {Promise} the join response\n     * @public\n     * @memberof Meeting\n     * Scenario A: Joining own claimed personal meeting room\n     * Scenario B: Joining other's claimed personal meeting room, do pass pin (if desired to join as host, or nullify), do pass moderator\n     * Scenario C: Joining an unclaimed personal meeting room, -do not- pass pin or moderator on first try, -do- pass pin and moderator\n     *             if joining as host on second loop, pass pin and pass moderator if joining as guest on second loop\n     * Scenario D: Joining any other way (sip, pstn, conversationUrl, link just need to specify resourceId)\n     */\n\n  }, {\n    key: \"join\",\n    value: function join() {\n      var _this34 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // If a join request is being processed, refer to the deferred promise.\n\n      if (this.deferJoin) {\n        return this.deferJoin;\n      } // Scope-up the resolve/reject methods for handling within join().\n\n\n      var joinFailed;\n      var joinSuccess; // Create a deferred promise for a consistent resolve value from utils.\n      // This also prevents redundant API calls.\n\n      this.deferJoin = new _promise.default(function (resolve, reject) {\n        joinFailed = reject;\n        joinSuccess = resolve;\n      });\n\n      if (!this.hasJoinedOnce) {\n        this.hasJoinedOnce = true;\n      } else {\n        _loggerProxy.default.logger.log(\"Meeting:index#join --> Generating a new correlation id for meeting \".concat(this.id));\n\n        _loggerProxy.default.logger.log(\"Meeting:index#join --> Previous correlation id \".concat(this.correlationId));\n\n        this.setCorrelationId(_uuid.default.v4());\n\n        _loggerProxy.default.logger.log(\"Meeting:index#join --> New correlation id \".concat(this.correlationId));\n      }\n\n      if (options.rejoin) {\n        this.meetingFiniteStateMachine.reset();\n      }\n\n      _metrics.default.postEvent({\n        event: _config.eventType.CALL_INITIATED,\n        meeting: this,\n        data: {\n          trigger: _config.trigger.USER_INTERACTION\n        }\n      });\n\n      _loggerProxy.default.logger.log('Meeting:index#join --> Joining a meeting');\n\n      if (this.meetingFiniteStateMachine.state === _constants.MEETING_STATE_MACHINE.STATES.ENDED) {\n        this.meetingFiniteStateMachine.reset();\n      }\n\n      if (this.meetingFiniteStateMachine.state !== _constants.MEETING_STATE_MACHINE.STATES.RINGING) {\n        this.meetingFiniteStateMachine.ring(_constants._JOIN_);\n      } // TODO: does this really need to be here?\n\n\n      if (options.resourceId && this.destination && options.resourceId === this.destination) {\n        this.wirelessShare = true;\n      }\n\n      if (options.meetingQuality) {\n        if (typeof options.meetingQuality === 'string') {\n          if (!_constants.QUALITY_LEVELS[options.meetingQuality]) {\n            var errorMessage = \"Meeting:index#join --> \".concat(options.meetingQuality, \" not defined\");\n            var error = new Error(errorMessage);\n\n            _loggerProxy.default.logger.error(errorMessage);\n\n            joinFailed(error);\n            this.deferJoin = undefined;\n            return _promise.default.reject(error);\n          }\n\n          this.mediaProperties.setLocalQualityLevel(options.meetingQuality);\n          this.mediaProperties.setRemoteQualityLevel(options.meetingQuality);\n        }\n\n        if ((0, _typeof2.default)(options.meetingQuality) === 'object') {\n          if (!_constants.QUALITY_LEVELS[options.meetingQuality.local] && !_constants.QUALITY_LEVELS[options.meetingQuality.remote]) {\n            var _errorMessage = \"Meeting:index#join --> \".concat(options.meetingQuality.local || options.meetingQuality.remote, \" not defined\");\n\n            _loggerProxy.default.logger.error(_errorMessage);\n\n            var _error = new Error(_errorMessage);\n\n            joinFailed(_error);\n            this.deferJoin = undefined;\n            return _promise.default.reject(new Error(_errorMessage));\n          }\n\n          if (options.meetingQuality.local) {\n            this.mediaProperties.setLocalQualityLevel(options.meetingQuality.local);\n          }\n\n          if (options.meetingQuality.remote) {\n            this.mediaProperties.setRemoteQualityLevel(options.meetingQuality.remote);\n          }\n        }\n      }\n\n      return _util.default.joinMeetingOptions(this, options).then(function (join) {\n        _this34.meetingFiniteStateMachine.join();\n\n        _loggerProxy.default.logger.log('Meeting:index#join --> Success');\n\n        return join;\n      }).then(function (join) {\n        joinSuccess(join);\n        _this34.deferJoin = undefined;\n\n        _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.JOIN_SUCCESS, {\n          correlation_id: _this34.correlationId\n        });\n\n        return join;\n      }).then( /*#__PURE__*/function () {\n        var _ref8 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(join) {\n          return _regenerator.default.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  if (!isBrowser) {\n                    _context3.next = 8;\n                    break;\n                  }\n\n                  if (!(_this34.config.receiveTranscription || options.receiveTranscription)) {\n                    _context3.next = 6;\n                    break;\n                  }\n\n                  if (!_this34.isTranscriptionSupported()) {\n                    _context3.next = 6;\n                    break;\n                  }\n\n                  _context3.next = 5;\n                  return _this34.receiveTranscription();\n\n                case 5:\n                  _loggerProxy.default.logger.info('Meeting:index#join --> enabled to recieve transcription!');\n\n                case 6:\n                  _context3.next = 9;\n                  break;\n\n                case 8:\n                  _loggerProxy.default.logger.error('Meeting:index#join --> Receving transcription is not supported on this platform');\n\n                case 9:\n                  return _context3.abrupt(\"return\", join);\n\n                case 10:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3);\n        }));\n\n        return function (_x2) {\n          return _ref8.apply(this, arguments);\n        };\n      }()).catch(function (error) {\n        var _error$error;\n\n        _this34.meetingFiniteStateMachine.fail(error);\n\n        _loggerProxy.default.logger.error('Meeting:index#join --> Failed', error); // TODO:  change this to error codes and pre defined dictionary\n\n\n        _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.JOIN_FAILURE, {\n          correlation_id: _this34.correlationId,\n          reason: (_error$error = error.error) === null || _error$error === void 0 ? void 0 : _error$error.message,\n          stack: error.stack\n        }); // Upload logs on join Failure\n\n\n        _triggerProxy.default.trigger(_this34, {\n          file: 'meeting/index',\n          function: 'join'\n        }, _constants.EVENTS.REQUEST_UPLOAD_LOGS, _this34);\n\n        joinFailed(error);\n        _this34.deferJoin = undefined;\n        return _promise.default.reject(error);\n      });\n    }\n    /**\n     * Use phone for meeting audio\n     * @param {String} phoneNumber If provided, it will dial-out using this number. If not provided, dial-in will be used\n     * @returns {Promise} Resolves once the dial-in or dial-out request has completed, or rejects if it failed\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"usePhoneAudio\",\n    value: function usePhoneAudio(phoneNumber) {\n      if (!phoneNumber) {\n        return this.dialInPstn();\n      }\n\n      return this.dialOutPstn(phoneNumber);\n    }\n    /**\n     * Determines if the given pstnStatus is in a state which implies the phone is provisioned\n     * @param {String} pstnStatus\n     * @returns {Boolean}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"isPhoneProvisioned\",\n    value: function isPhoneProvisioned(pstnStatus) {\n      return [_constants.PSTN_STATUS.JOINED, _constants.PSTN_STATUS.CONNECTED, _constants.PSTN_STATUS.SUCCESS].includes(pstnStatus);\n    }\n    /**\n     * Enable dial-in for audio\n     * @returns {Promise} Resolves once the dial-in request has completed, or rejects if it failed\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"dialInPstn\",\n    value: function dialInPstn() {\n      var _this35 = this;\n\n      if (this.isPhoneProvisioned(this.dialInDeviceStatus)) return _promise.default.resolve(); // prevent multiple dial in devices from being provisioned\n\n      var correlationId = this.correlationId,\n          locusUrl = this.locusUrl;\n      if (!this.dialInUrl) this.dialInUrl = \"dialin:///\".concat(_uuid.default.v4());\n      return this.meetingRequest.dialIn({\n        correlationId: correlationId,\n        dialInUrl: this.dialInUrl,\n        locusUrl: locusUrl,\n        clientUrl: this.deviceUrl\n      }).then(function (res) {\n        _this35.locusInfo.onFullLocus(res.body.locus);\n      }).catch(function (error) {\n        var _error$error2;\n\n        _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.ADD_DIAL_IN_FAILURE, {\n          correlation_id: _this35.correlationId,\n          dial_in_url: _this35.dialInUrl,\n          locus_id: locusUrl.split('/').pop(),\n          client_url: _this35.deviceUrl,\n          reason: (_error$error2 = error.error) === null || _error$error2 === void 0 ? void 0 : _error$error2.message,\n          stack: error.stack\n        });\n\n        return _promise.default.reject(error);\n      });\n    }\n    /**\n     * Enable dial-out for audio\n     * @param {String} phoneNumber Phone number to dial out to\n     * @returns {Promise} Resolves once the dial-out request has completed (it doesn't wait for the user to answer the phone), or rejects if it failed\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"dialOutPstn\",\n    value: function dialOutPstn(phoneNumber) {\n      var _this36 = this;\n\n      if (this.isPhoneProvisioned(this.dialOutDeviceStatus)) return _promise.default.resolve(); // prevent multiple dial out devices from being provisioned\n\n      var correlationId = this.correlationId,\n          locusUrl = this.locusUrl;\n      if (!this.dialOutUrl) this.dialOutUrl = \"dialout:///\".concat(_uuid.default.v4());\n      return this.meetingRequest.dialOut({\n        correlationId: correlationId,\n        dialOutUrl: this.dialOutUrl,\n        phoneNumber: phoneNumber,\n        locusUrl: locusUrl,\n        clientUrl: this.deviceUrl\n      }).then(function (res) {\n        _this36.locusInfo.onFullLocus(res.body.locus);\n      }).catch(function (error) {\n        var _error$error3;\n\n        _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.ADD_DIAL_OUT_FAILURE, {\n          correlation_id: _this36.correlationId,\n          dial_out_url: _this36.dialOutUrl,\n          locus_id: locusUrl.split('/').pop(),\n          client_url: _this36.deviceUrl,\n          reason: (_error$error3 = error.error) === null || _error$error3 === void 0 ? void 0 : _error$error3.message,\n          stack: error.stack\n        });\n\n        return _promise.default.reject(error);\n      });\n    }\n    /**\n     * Disconnect meeting audio via phone.\n     * @returns {Promise} Resolves once the phone audio disconnection has completed\n     * @public\n     * @memberof Meeting\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"disconnectPhoneAudio\",\n    value: function disconnectPhoneAudio() {\n      return _promise.default.all([this.isPhoneProvisioned(this.dialInDeviceStatus) ? _util.default.disconnectPhoneAudio(this, this.dialInUrl) : _promise.default.resolve(), this.isPhoneProvisioned(this.dialOutDeviceStatus) ? _util.default.disconnectPhoneAudio(this, this.dialOutUrl) : _promise.default.resolve()]);\n    }\n    /**\n     * Moves the call to the specified resourceId\n     * @param {String} resourceId\n     * @returns {Promise} once the move has been completed\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(resourceId) {\n      var _this37 = this;\n\n      if (!resourceId) {\n        throw new _parameter.default('Cannot move call without a resourceId.');\n      }\n\n      _metrics.default.postEvent({\n        event: _config.eventType.MEDIA_CAPABILITIES,\n        meeting: this,\n        data: {\n          mediaCapabilities: {\n            rx: {\n              audio: false,\n              share: false,\n              share_audio: false,\n              video: false,\n              whiteboard: false\n            },\n            tx: {\n              audio: false,\n              share: false,\n              share_audio: false,\n              video: false,\n              whiteboard: false\n            }\n          }\n        }\n      });\n\n      _metrics.default.postEvent({\n        event: _config.eventType.MOVE_MEDIA,\n        meeting: this\n      });\n\n      return _util.default.joinMeetingOptions(this, {\n        resourceId: resourceId,\n        moveToResource: true\n      }).then(function () {\n        _this37.meetingFiniteStateMachine.join();\n\n        return _this37.updateMedia({\n          mediaSettings: {\n            sendVideo: false,\n            receiveVideo: false,\n            sendAudio: false,\n            receiveAudio: false,\n            sendShare: false,\n            receiveShare: false\n          }\n        }).then(function () {\n          return _promise.default.resolve(_this37);\n        });\n      }).catch(function (error) {\n        _this37.meetingFiniteStateMachine.fail(error);\n\n        return _promise.default.reject(error);\n      });\n    }\n    /**\n     * Moves the call from the specified resourceId, back to computer\n     * @param {String} resourceId\n     * @returns {Promise} once the move has been completed\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"moveFrom\",\n    value: function moveFrom(resourceId) {\n      var _this38 = this;\n\n      if (!resourceId) {\n        throw new _parameter.default('Cannot move call without a resourceId.');\n      }\n\n      var oldCorrelationId = this.correlationId;\n      this.id = _uuid.default.v4();\n      this.webex.meetings.meetingCollection.set(this);\n\n      _metrics.default.postEvent({\n        event: _config.eventType.MEDIA_CAPABILITIES,\n        meeting: this,\n        data: {\n          mediaCapabilities: {\n            rx: {\n              audio: true,\n              share: true,\n              share_audio: true,\n              video: true,\n              whiteboard: true\n            },\n            tx: {\n              audio: true,\n              share: true,\n              share_audio: true,\n              video: true,\n              whiteboard: true\n            }\n          }\n        }\n      });\n\n      _metrics.default.postEvent({\n        event: _config.eventType.MOVE_MEDIA,\n        meeting: this\n      });\n\n      return _util.default.joinMeetingOptions(this).then(function (join) {\n        return _this38.getMediaStreams({\n          sendAudio: true,\n          sendVideo: true,\n          sendShare: false\n        }).then(function (_ref9) {\n          var _ref10 = (0, _slicedToArray2.default)(_ref9, 2),\n              localStream = _ref10[0],\n              localShare = _ref10[1];\n\n          return _this38.updateMedia({\n            mediaSettings: {\n              sendAudio: true,\n              receiveAudio: true,\n              sendVideo: true,\n              receiveVideo: true,\n              sendShare: false,\n              receiveShare: false\n            },\n            localStream: localStream,\n            localShare: localShare\n          }).then(function () {\n            return _promise.default.resolve(join);\n          });\n        }).then(function () {\n          return _util.default.leaveMeeting(_this38, {\n            resourceId: resourceId,\n            correlationId: oldCorrelationId,\n            moveMeeting: true\n          });\n        });\n      }).then(function () {\n        _this38.webex.meetings.meetingCollection.delete(_this38.id);\n\n        return _promise.default.resolve();\n      });\n    }\n    /**\n     * Get local media streams based on options passed\n     * @param {MediaDirection} mediaDirection A configurable options object for joining a meeting\n     * @param {AudioVideo} [audioVideo] audio/video object to set audioinput and videoinput devices, see #Media.getUserMedia\n     * @param {SharePreferences} [sharePreferences] audio/video object to set audioinput and videoinput devices, see #Media.getUserMedia\n     * @returns {Promise} see #Media.getUserMedia\n     * @public\n     * @todo should be static, or moved so can be called outside of a meeting\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"addMedia\",\n    value:\n    /**\n     * Specify joining via audio (option: pstn), video, screenshare\n     * @param {Object} options A configurable options object for joining a meeting\n     * @param {Object} options.resourceId pass the deviceId\n     * @param {MediaDirection} options.mediaSettings pass media options\n     * @param {MediaStream} options.localStream\n     * @param {MediaStream} options.localShare\n     * @returns {Promise}\n     * @public\n     * @memberof Meeting\n     */\n    function addMedia() {\n      var _this39 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var LOG_HEADER = 'Meeting:index#addMedia -->';\n\n      if (this.meetingState !== _constants.FULL_STATE.ACTIVE) {\n        return _promise.default.reject(new _webexErrors.MeetingNotActiveError());\n      }\n\n      if (_util.default.isUserInLeftState(this.locusInfo)) {\n        return _promise.default.reject(new _webexErrors.UserNotJoinedError());\n      } // If the user is unjoined or guest waiting in lobby dont allow the user to addMedia\n\n\n      if (this.guest && _util.default.isUserInIdleState(this.locusInfo) && !this.wirelessShare) {\n        return _promise.default.reject(new _webexErrors.UserInLobbyError());\n      }\n\n      var localStream = options.localStream,\n          localShare = options.localShare,\n          mediaSettings = options.mediaSettings;\n\n      _loggerProxy.default.logger.info(\"\".concat(LOG_HEADER, \" Adding Media.\"));\n\n      _metrics.default.postEvent({\n        event: _config.eventType.MEDIA_CAPABILITIES,\n        meeting: this,\n        data: {\n          mediaCapabilities: {\n            rx: {\n              audio: false,\n              share: false,\n              share_audio: false,\n              video: false,\n              whiteboard: false\n            },\n            tx: {\n              audio: false,\n              share: false,\n              share_audio: false,\n              video: false,\n              whiteboard: false\n            }\n          }\n        }\n      });\n\n      return _util.default.validateOptions(options).then(function () {\n        _this39.mediaProperties.setMediaPeerConnection(_util2.default.createPeerConnection());\n\n        _this39.setMercuryListener();\n\n        _peerConnectionManager.default.setPeerConnectionEvents(_this39);\n\n        return _this39.preMedia(localStream, localShare, mediaSettings);\n      }).then(function () {\n        return _media.default.attachMedia(_this39.mediaProperties, {\n          meetingId: _this39.id,\n          remoteQualityLevel: _this39.mediaProperties.remoteQualityLevel,\n          enableRtx: _this39.config.enableRtx,\n          enableExtmap: _this39.config.enableExtmap,\n          setStartLocalSDPGenRemoteSDPRecvDelay: _this39.setStartLocalSDPGenRemoteSDPRecvDelay.bind(_this39)\n        }).then(function (peerConnection) {\n          return _this39.getDevices().then(function (devices) {\n            _util.default.handleDeviceLogging(devices);\n\n            return peerConnection;\n          });\n        }).then(function (peerConnection) {\n          _this39.handleMediaLogging(_this39.mediaProperties);\n\n          _loggerProxy.default.logger.info(\"\".concat(LOG_HEADER, \" PeerConnection Received from attachMedia \"));\n\n          _this39.setRemoteStream(peerConnection);\n\n          _util.default.startInternalStats(_this39);\n\n          if (_this39.config.metrics.autoSendMQA) {\n            _this39.startMediaQualityMetrics();\n          }\n\n          if (_this39.config.stats.enableStatsAnalyzer) {\n            // TODO: ** Dont re create StatsAnalyzer on reconnect or rejoin\n            _this39.networkQualityMonitor = new _networkQualityMonitor.default(_this39.config.stats);\n            _this39.statsAnalyzer = new _statsAnalyzer.default(_this39.config.stats, _this39.networkQualityMonitor);\n\n            _this39.statsAnalyzer.on(_constants.EVENT_TRIGGERS.MEDIA_QUALITY, function (options) {\n              var _this39$webex$meeting; // TODO:  might have to send the same event to the developer\n              // Add ip address info if geo hint is present\n\n\n              options.data.intervalMetadata.peerReflexiveIP = ((_this39$webex$meeting = _this39.webex.meetings.geoHintInfo) === null || _this39$webex$meeting === void 0 ? void 0 : _this39$webex$meeting.clientAddress) || options.data.intervalMetadata.peerReflexiveIP || _constants.MQA_STATS.DEFAULT_IP;\n\n              _metrics.default.postEvent({\n                event: _config.eventType.MEDIA_QUALITY,\n                meeting: _this39,\n                data: {\n                  intervalData: options.data,\n                  networkType: options.networkType\n                }\n              });\n            });\n\n            _this39.networkQualityMonitor.on(_constants.EVENT_TRIGGERS.NETWORK_QUALITY, _this39.sendNetworkQualityEvent.bind(_this39));\n          }\n        }).catch(function (error) {\n          _loggerProxy.default.logger.error(\"\".concat(LOG_HEADER, \" Error adding media , setting up peerconnection, \"), error);\n\n          _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.ADD_MEDIA_FAILURE, {\n            correlation_id: _this39.correlationId,\n            locus_id: _this39.locusUrl.split('/').pop(),\n            reason: error.message,\n            stack: error.stack\n          });\n\n          throw error;\n        }).then(function () {\n          return new _promise.default(function (resolve, reject) {\n            var timerCount = 0; // eslint-disable-next-line func-names\n            // eslint-disable-next-line prefer-arrow-callback\n\n            if (_this39.type === _constants._CALL_) {\n              resolve();\n            }\n\n            var joiningTimer = setInterval(function () {\n              timerCount += 1;\n\n              if (_this39.meetingState === _constants.FULL_STATE.ACTIVE) {\n                clearInterval(joiningTimer);\n                resolve();\n              }\n\n              if (timerCount === 4) {\n                clearInterval(joiningTimer);\n                reject(new Error('Meeting is still not active '));\n              }\n            }, 1000);\n          });\n        }).then(function () {\n          return logRequest(_this39.roap.sendRoapMediaRequest({\n            sdp: _this39.mediaProperties.peerConnection.sdp,\n            roapSeq: _this39.roapSeq,\n            meeting: _this39 // or can pass meeting ID\n\n          }), {\n            header: \"\".concat(LOG_HEADER, \" Send Roap Media Request.\"),\n            success: \"\".concat(LOG_HEADER, \" Successfully send roap media request\"),\n            failure: \"\".concat(LOG_HEADER, \" Error joining the call on send roap media request, \")\n          });\n        }).then(function () {\n          var peerConnection = _this39.mediaProperties.peerConnection;\n          return new _promise.default(function (resolve, reject) {\n            if (peerConnection.connectionState === _constants.CONNECTION_STATE.CONNECTED) {\n              _loggerProxy.default.logger.info(\"\".concat(LOG_HEADER, \" PeerConnection CONNECTED\"));\n\n              resolve(peerConnection);\n              return;\n            } // Check if Peer Connection is STABLE (connected)\n\n\n            var stabilityTimeout = setTimeout(function () {\n              if (peerConnection.connectionState !== _constants.CONNECTION_STATE.CONNECTED) {\n                // TODO: Fix this after the error code pr goes in\n                reject((0, _webexErrors.createMeetingsError)(30202, 'Meeting connection failed'));\n              } else {\n                _loggerProxy.default.logger.info(\"\".concat(LOG_HEADER, \" PeerConnection CONNECTED\"));\n\n                resolve(peerConnection);\n              }\n            }, _constants.PC_BAIL_TIMEOUT);\n\n            _this39.once(_constants.EVENT_TRIGGERS.MEDIA_READY, function () {\n              _loggerProxy.default.logger.info(\"\".concat(LOG_HEADER, \" PeerConnection CONNECTED, clearing stability timer.\"));\n\n              clearTimeout(stabilityTimeout);\n              resolve(peerConnection);\n            });\n          });\n        }).then(function () {\n          if (mediaSettings && mediaSettings.sendShare && localShare) {\n            if (_this39.state === _constants.MEETING_STATE.STATES.JOINED) {\n              return _this39.share();\n            } // When the self state changes to JOINED then request the floor\n\n\n            _this39.floorGrantPending = true;\n          }\n\n          _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.ADD_MEDIA_SUCCESS, {\n            correlation_id: _this39.correlationId,\n            locus_id: _this39.locusUrl.split('/').pop()\n          });\n\n          return _promise.default.resolve();\n        });\n      }).catch(function (error) {\n        // Clean up stats analyzer, peer connection, and turn off listeners\n        if (_this39.statsAnalyzer) {\n          _this39.statsAnalyzer.stopAnalyzer();\n\n          _this39.statsAnalyzer = null;\n        }\n\n        if (_this39.mediaProperties.peerConnection) {\n          _this39.closePeerConnections();\n\n          _this39.unsetPeerConnections();\n        }\n\n        _loggerProxy.default.logger.error(\"\".concat(LOG_HEADER, \" Error adding media failed to initiate PC and send request, \"), error);\n\n        _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.ADD_MEDIA_FAILURE, {\n          correlation_id: _this39.correlationId,\n          locus_id: _this39.locusUrl.split('/').pop(),\n          reason: error.message,\n          stack: error.stack,\n          code: error.code\n        }); // Upload logs on error while adding media\n\n\n        _triggerProxy.default.trigger(_this39, {\n          file: 'meeting/index',\n          function: 'addMedia'\n        }, _constants.EVENTS.REQUEST_UPLOAD_LOGS, _this39); // If addMedia failes for not establishing connection then\n        // leave the meeting with reson connection failed as meeting anyways will end\n        // and cannot be connected unless network condition is checked for firewall\n\n\n        if (error.code === _webexErrors.InvalidSdpError.CODE) {\n          _this39.leave({\n            reason: _constants.MEETING_REMOVED_REASON.MEETING_CONNECTION_FAILED\n          });\n        }\n\n        throw error;\n      });\n    }\n    /**\n     * Informs if the peer connection is in a state that can be updated with updateMedia (audio/video/share)\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"canUpdateMedia\",\n    value: function canUpdateMedia() {\n      return this.mediaProperties.peerConnection.signalingState === _constants.SDP.STABLE && !_collection.default.isBusy(this.correlationId);\n    }\n    /**\n     * Enqueues a media update operation.\n     * @param {String} mediaUpdateType one of MEDIA_UPDATE_TYPE values\n     * @param {Object} options\n     * @returns {Promise}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"enqueueMediaUpdate\",\n    value: function enqueueMediaUpdate(mediaUpdateType, options) {\n      var _this40 = this;\n\n      return new _promise.default(function (resolve, reject) {\n        var queueItem = {\n          pendingPromiseResolve: resolve,\n          pendingPromiseReject: reject,\n          mediaUpdateType: mediaUpdateType,\n          options: options\n        };\n\n        _loggerProxy.default.logger.log(\"Meeting:index#enqueueMediaUpdate --> enqueuing media update type=\".concat(mediaUpdateType));\n\n        _this40.queuedMediaUpdates.push(queueItem);\n      });\n    }\n    /**\n     * emits event when the negotation is completed\n     * @returns {void}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"updateMedia\",\n    value:\n    /**\n     * A confluence of updateAudio, updateVideo, and updateShare\n     * this function re-establishes all of the media streams with new options\n     * @param {Object} options\n     * @param {MediaStream} options.localStream\n     * @param {MediaStream} options.localShare\n     * @param {MediaDirection} options.mediaSettings\n     * @returns {Promise}\n     * @todo fix setRemoteStream for updateMedia\n     * @public\n     * @memberof Meeting\n     */\n    function updateMedia() {\n      var _this41 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var LOG_HEADER = 'Meeting:index#updateMedia -->';\n\n      if (!this.canUpdateMedia()) {\n        return this.enqueueMediaUpdate(MEDIA_UPDATE_TYPE.ALL, options);\n      }\n\n      var localStream = options.localStream,\n          localShare = options.localShare,\n          mediaSettings = options.mediaSettings;\n      var previousSendShareStatus = this.mediaProperties.mediaDirection.sendShare;\n      return _util.default.validateOptions(options).then(function () {\n        return _this41.preMedia(localStream, localShare, mediaSettings);\n      }).then(function () {\n        return _media.default.updateMedia(_this41.mediaProperties, {\n          meetingId: _this41.id,\n          remoteQualityLevel: _this41.mediaProperties.remoteQualityLevel,\n          enableRtx: _this41.config.enableRtx,\n          enableExtmap: _this41.config.enableExtmap\n        }).then(function (peerConnection) {\n          _loggerProxy.default.logger.info(\"\".concat(LOG_HEADER, \" PeerConnection received from updateMedia, \").concat(peerConnection));\n\n          _this41.setRemoteStream(peerConnection);\n\n          if (mediaSettings.receiveShare || localShare) {\n            _peerConnectionManager.default.setContentSlides(peerConnection);\n          }\n        }).catch(function (error) {\n          _loggerProxy.default.logger.error(\"\".concat(LOG_HEADER, \" Error updatedMedia, \"), error);\n\n          _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.UPDATE_MEDIA_FAILURE, {\n            correlation_id: _this41.correlationId,\n            locus_id: _this41.locusUrl.split('/').pop(),\n            reason: error.message,\n            stack: error.stack\n          });\n\n          throw error;\n        }).then(function () {\n          return logRequest(_this41.roap.sendRoapMediaRequest({\n            sdp: _this41.mediaProperties.peerConnection.sdp,\n            roapSeq: _this41.roapSeq,\n            meeting: _this41 // or can pass meeting ID\n\n          }), {\n            header: \"\".concat(LOG_HEADER, \" sendRoapMediaRequest being sent\"),\n            success: \"\".concat(LOG_HEADER, \" sendRoadMediaRequest successful\"),\n            failure: \"\".concat(LOG_HEADER, \" Error updateMedia on send roap media request, \")\n          });\n        }).then(function () {\n          return _this41.checkForStopShare(mediaSettings.sendShare, previousSendShareStatus);\n        }).then(function (startShare) {\n          // This is a special case if we do an /floor grant followed by /media\n          // we actually get a OFFER from the server and a GLAR condition happens\n          if (startShare) {\n            // We are assuming that the clients are connected when doing an update\n            return _this41.share();\n          }\n\n          return _promise.default.resolve();\n        });\n      });\n    }\n    /**\n     * Update the main audio track with new parameters\n     * @param {Object} options\n     * @param {boolean} options.sendAudio\n     * @param {boolean} options.receiveAudio\n     * @param {MediaStream} options.stream Stream that contains the audio track to update\n     * @returns {Promise}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"updateAudio\",\n    value: function updateAudio(options) {\n      var _this42 = this;\n\n      if (!this.canUpdateMedia()) {\n        return this.enqueueMediaUpdate(MEDIA_UPDATE_TYPE.AUDIO, options);\n      }\n\n      var sendAudio = options.sendAudio,\n          receiveAudio = options.receiveAudio,\n          stream = options.stream;\n      var audioTransceiver = this.mediaProperties.peerConnection.audioTransceiver;\n\n      var track = _util.default.getTrack(stream).audioTrack;\n\n      if (typeof sendAudio !== 'boolean' || typeof receiveAudio !== 'boolean') {\n        return _promise.default.reject(new _parameter.default('Pass sendAudio and receiveAudio parameter'));\n      }\n\n      return _util.default.validateOptions({\n        sendAudio: sendAudio,\n        localStream: stream\n      }).then(function () {\n        var previousMediaDirection = {};\n\n        if (_this42.mediaProperties.mediaDirection) {\n          previousMediaDirection = {\n            sendTrack: _this42.mediaProperties.mediaDirection.sendAudio,\n            receiveTrack: _this42.mediaProperties.mediaDirection.receiveAudio\n          };\n        } else {\n          _this42.mediaProperties.mediaDirection = {};\n        }\n\n        return _util.default.updateTransceiver({\n          type: 'audio',\n          sendTrack: options.sendAudio,\n          receiveTrack: options.receiveAudio,\n          track: track,\n          transceiver: audioTransceiver,\n          peerConnection: _this42.mediaProperties.peerConnection,\n          previousMediaDirection: previousMediaDirection\n        }, {\n          mediaProperties: _this42.mediaProperties,\n          meeting: _this42,\n          id: _this42.id\n        });\n      }).then(function () {\n        _this42.setLocalAudioTrack(track);\n\n        _this42.mediaProperties.mediaDirection.sendAudio = sendAudio;\n        _this42.mediaProperties.mediaDirection.receiveAudio = receiveAudio; // audio state could be undefined if you have not sent audio before\n\n        _this42.audio = _this42.audio || (0, _muteState.default)(_constants.AUDIO, _this42, _this42.mediaProperties.mediaDirection);\n      });\n    }\n    /**\n     * Update the main video track with new parameters\n     * @param {Object} options\n     * @param {boolean} options.sendVideo\n     * @param {boolean} options.receiveVideo\n     * @param {MediaStream} options.stream Stream that contains the video track to update\n     * @returns {Promise}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"updateVideo\",\n    value: function updateVideo(options) {\n      var _this43 = this;\n\n      if (!this.canUpdateMedia()) {\n        return this.enqueueMediaUpdate(MEDIA_UPDATE_TYPE.VIDEO, options);\n      }\n\n      var sendVideo = options.sendVideo,\n          receiveVideo = options.receiveVideo,\n          stream = options.stream;\n      var videoTransceiver = this.mediaProperties.peerConnection.videoTransceiver;\n\n      var track = _util.default.getTrack(stream).videoTrack;\n\n      if (typeof sendVideo !== 'boolean' || typeof receiveVideo !== 'boolean') {\n        return _promise.default.reject(new _parameter.default('Pass sendVideo and receiveVideo parameter'));\n      }\n\n      return _util.default.validateOptions({\n        sendVideo: sendVideo,\n        localStream: stream\n      }).then(function () {\n        return _util.default.updateTransceiver({\n          type: 'video',\n          sendTrack: options.sendVideo,\n          receiveTrack: options.receiveVideo,\n          track: track,\n          transceiver: videoTransceiver,\n          peerConnection: _this43.mediaProperties.peerConnection,\n          previousMediaDirection: {\n            sendTrack: _this43.mediaProperties.mediaDirection.sendVideo,\n            receiveTrack: _this43.mediaProperties.mediaDirection.receiveVideo\n          }\n        }, {\n          mediaProperties: _this43.mediaProperties,\n          meeting: _this43,\n          id: _this43.id\n        });\n      }).then(function () {\n        _this43.setLocalVideoTrack(track);\n\n        _this43.mediaProperties.mediaDirection.sendVideo = sendVideo;\n        _this43.mediaProperties.mediaDirection.receiveVideo = receiveVideo; // video state could be undefined if you have not sent video before\n\n        _this43.video = _this43.video || (0, _muteState.default)(_constants.VIDEO, _this43, _this43.mediaProperties.mediaDirection);\n      });\n    }\n    /**\n     * Internal function when stopping a share stream, cleanup\n     * @param {boolean} sendShare\n     * @param {boolean} previousShareStatus\n     * @returns {Promise}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"checkForStopShare\",\n    value: function checkForStopShare(sendShare, previousShareStatus) {\n      if (sendShare && !previousShareStatus) {\n        // When user starts sharing\n        return _promise.default.resolve(true);\n      }\n\n      if (!sendShare && previousShareStatus) {\n        // When user stops sharing\n        return this.stopFloorRequest().then(function () {\n          return _promise.default.resolve(false);\n        });\n      }\n\n      return _promise.default.resolve();\n    }\n    /**\n     * Update the share streams, can be used to start sharing\n     * @param {Object} options\n     * @param {boolean} options.sendShare\n     * @param {boolean} options.receiveShare\n     * @returns {Promise}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"updateShare\",\n    value: function updateShare(options) {\n      var _this44 = this;\n\n      if (!options.skipSignalingCheck && !this.canUpdateMedia()) {\n        return this.enqueueMediaUpdate(MEDIA_UPDATE_TYPE.SHARE, options);\n      }\n\n      var sendShare = options.sendShare,\n          receiveShare = options.receiveShare,\n          stream = options.stream;\n      var shareTransceiver = this.mediaProperties.peerConnection.shareTransceiver;\n\n      var track = _util.default.getTrack(stream).videoTrack;\n\n      if (typeof sendShare !== 'boolean' || typeof receiveShare !== 'boolean') {\n        return _promise.default.reject(new _parameter.default('Pass sendShare and receiveShare parameter'));\n      }\n\n      var previousSendShareStatus = this.mediaProperties.mediaDirection.sendShare;\n      this.setLocalShareTrack(stream);\n      return _util.default.validateOptions({\n        sendShare: sendShare,\n        localShare: stream\n      }).then(function () {\n        return _this44.checkForStopShare(sendShare, previousSendShareStatus);\n      }).then(function (startShare) {\n        return _util.default.updateTransceiver({\n          type: 'video',\n          sendTrack: sendShare,\n          receiveTrack: receiveShare,\n          track: track,\n          transceiver: shareTransceiver,\n          peerConnection: _this44.mediaProperties.peerConnection,\n          previousMediaDirection: {\n            sendTrack: _this44.mediaProperties.mediaDirection.sendShare,\n            receiveTrack: _this44.mediaProperties.mediaDirection.receiveShare\n          }\n        }, {\n          mediaProperties: _this44.mediaProperties,\n          meeting: _this44,\n          id: _this44.id\n        }).then(function () {\n          if (startShare) {\n            return _this44.share();\n          }\n\n          return _promise.default.resolve();\n        });\n      }).then(function () {\n        _this44.mediaProperties.mediaDirection.sendShare = sendShare;\n        _this44.mediaProperties.mediaDirection.receiveShare = receiveShare;\n      }).catch(function (error) {\n        _this44.unsetLocalShareTrack(stream);\n\n        throw error;\n      }).finally(function () {\n        var delay = 1e3; // Check to see if share was stopped natively before onended was assigned.\n\n        var sharingModeIsActive = _this44.mediaProperties.peerConnection.shareTransceiver.direction === _constants.SENDRECV;\n        var isSharingOutOfSync = sharingModeIsActive && !_this44.isLocalShareLive;\n\n        if (isSharingOutOfSync) {\n          // Adding a delay to avoid a 409 from server\n          // which results in user still appearing as if sharing.\n          // Also delay give time for changes to peerConnection.\n          setTimeout(function () {\n            return _this44.handleShareTrackEnded(stream);\n          }, delay);\n        }\n      });\n    }\n    /**\n     * Do all the attach media pre set up before executing the actual attach\n     * @param {MediaStream} localStream\n     * @param {MediaStream} localShare\n     * @param {MediaDirection} mediaSettings\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"preMedia\",\n    value: function preMedia(localStream, localShare, mediaSettings) {\n      // eslint-disable-next-line no-warning-comments\n      // TODO wire into default config. There's currently an issue with the stateless plugin or how we register\n      this.mediaProperties.setMediaDirection((0, _assign.default)(this.config.mediaSettings, mediaSettings)); // add a setup a function move the create and setup media in future\n      // TODO: delete old audio and video if stale\n\n      this.audio = this.audio || (0, _muteState.default)(_constants.AUDIO, this, this.mediaProperties.mediaDirection);\n      this.video = this.video || (0, _muteState.default)(_constants.VIDEO, this, this.mediaProperties.mediaDirection); // Validation is already done in addMedia so no need to check if the lenght is greater then 0\n\n      this.setLocalTracks(localStream);\n      this.setLocalShareTrack(localShare);\n    }\n    /**\n     * Acknowledge the meeting, outgoing or incoming\n     * @param {String} type\n     * @returns {Promise} resolve {message, ringing, response}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"acknowledge\",\n    value: function acknowledge(type) {\n      var _this45 = this;\n\n      if (!type) {\n        return _promise.default.reject(new _parameter.default('Type must be set to acknowledge the meeting.'));\n      }\n\n      if (type === _constants._INCOMING_) {\n        return this.meetingRequest.acknowledgeMeeting({\n          locusUrl: this.locusUrl,\n          deviceUrl: this.deviceUrl,\n          correlationId: this.correlationId\n        }).then(function (response) {\n          return _promise.default.resolve(response);\n        }).then(function (response) {\n          _this45.meetingFiniteStateMachine.ring(type);\n\n          _metrics.default.postEvent({\n            event: _config.eventType.ALERT_DISPLAYED,\n            meeting: _this45\n          });\n\n          return _promise.default.resolve({\n            response: response\n          });\n        });\n      } // TODO: outside of 1:1 incoming, and all outgoing calls\n\n\n      return _promise.default.resolve({\n        message: 'noop'\n      });\n    }\n    /**\n     * Decline this meeting\n     * @param {String} reason\n     * @returns {undefined}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"decline\",\n    value: function decline(reason) {\n      var _this46 = this;\n\n      return _util.default.declineMeeting(this, reason).then(function (decline) {\n        _this46.meetingFiniteStateMachine.decline();\n\n        return _promise.default.resolve(decline);\n      }).catch(function (error) {\n        _this46.meetingFiniteStateMachine.fail(error);\n\n        return _promise.default.reject(error);\n      });\n    }\n    /**\n     * Leave the current meeting\n     * @param {Object} options leave options\n     * @param {String} options.resourceId the device with which to leave from, empty if just the computer\n     * @returns {Promise}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"leave\",\n    value: function leave() {\n      var _this47 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _metrics.default.postEvent({\n        event: _config.eventType.LEAVE,\n        meeting: this,\n        data: {\n          trigger: _config.trigger.USER_INTERACTION,\n          canProceed: false\n        }\n      });\n\n      var leaveReason = options.reason || _constants.MEETING_REMOVED_REASON.CLIENT_LEAVE_REQUEST;\n\n      _loggerProxy.default.logger.log('Meeting:index#leave --> Leaving a meeting');\n\n      return _util.default.leaveMeeting(this, options).then(function (leave) {\n        _this47.meetingFiniteStateMachine.leave();\n\n        _this47.audio = null;\n        _this47.video = null;\n        _this47.isSharing = false;\n\n        if (_this47.shareStatus === _constants.SHARE_STATUS.LOCAL_SHARE_ACTIVE) {\n          _this47.shareStatus = _constants.SHARE_STATUS.NO_SHARE;\n        }\n\n        _this47.queuedMediaUpdates = [];\n\n        if (_this47.transcription) {\n          _this47.transcription.closeSocket();\n\n          _this47.triggerStopReceivingTranscriptionEvent();\n\n          _this47.transcription = undefined;\n        } // upload logs on leave irrespective of meeting delete\n\n\n        _triggerProxy.default.trigger(_this47, {\n          file: 'meeting/index',\n          function: 'leave'\n        }, _constants.EVENTS.REQUEST_UPLOAD_LOGS, _this47); // TODO: more testing before we remove this code, we are not sure the scenarios for destroy here\n\n\n        if (_this47.wirelessShare || _this47.guest) {\n          // If screen sharing clean the meeting object\n          _triggerProxy.default.trigger(_this47, {\n            file: 'meeting/index',\n            function: 'leave'\n          }, _constants.EVENTS.DESTROY_MEETING, {\n            reason: options.reason,\n            meetingId: _this47.id\n          });\n        }\n\n        _loggerProxy.default.logger.log('Meeting:index#leave --> LEAVE REASON ', leaveReason);\n\n        return leave;\n      }).catch(function (error) {\n        _this47.meetingFiniteStateMachine.fail(error);\n\n        _loggerProxy.default.logger.error('Meeting:index#leave --> Failed to leave ', error); // upload logs on leave irrespective of meeting delete\n\n\n        _triggerProxy.default.trigger(_this47, {\n          file: 'meeting/index',\n          function: 'leave'\n        }, _constants.EVENTS.REQUEST_UPLOAD_LOGS, _this47);\n\n        _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.MEETING_LEAVE_FAILURE, {\n          correlation_id: _this47.correlationId,\n          locus_id: _this47.locusUrl.split('/').pop(),\n          reason: error.message,\n          stack: error.stack,\n          code: error.code\n        });\n\n        return _promise.default.reject(error);\n      });\n    }\n    /**\n     * Start sharing whiteboard given channelUrl\n     * @param {string} channelUrl whiteboard url\n     * @param {String} resourceToken token created by authorize media injector\n     * @returns {Promise}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"startWhiteboardShare\",\n    value: function startWhiteboardShare(channelUrl, resourceToken) {\n      var _this48 = this;\n\n      var whiteboard = this.locusInfo.mediaShares.find(function (element) {\n        return element.name === 'whiteboard';\n      });\n\n      if (!channelUrl) {\n        return _promise.default.reject(new _parameter.default('Cannot share without channelUrl.'));\n      }\n\n      if (whiteboard) {\n        _metrics.default.postEvent({\n          event: _config.eventType.WHITEBOARD_SHARE_INITIATED,\n          meeting: this\n        });\n\n        var body = {\n          disposition: _constants.FLOOR_ACTION.GRANTED,\n          personUrl: this.locusInfo.self.url,\n          deviceUrl: this.deviceUrl,\n          uri: whiteboard.url,\n          resourceUrl: channelUrl\n        };\n\n        if (resourceToken) {\n          body.resourceToken = resourceToken;\n        }\n\n        return this.meetingRequest.changeMeetingFloor(body).then(function () {\n          _this48.isSharing = false;\n          return _promise.default.resolve();\n        }).catch(function (error) {\n          _loggerProxy.default.logger.error('Meeting:index#startWhiteboardShare --> Error ', error);\n\n          _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.MEETING_START_WHITEBOARD_SHARE_FAILURE, {\n            correlation_id: _this48.correlationId,\n            locus_id: _this48.locusUrl.split('/').pop(),\n            reason: error.message,\n            stack: error.stack,\n            board: {\n              channelUrl: channelUrl\n            }\n          });\n\n          return _promise.default.reject(error);\n        });\n      }\n\n      return _promise.default.reject(new _parameter.default('Cannot share without whiteboard.'));\n    }\n    /**\n     * Stop sharing whiteboard given channelUrl\n     * @param {string} channelUrl whiteboard url\n     * @returns {Promise}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"stopWhiteboardShare\",\n    value: function stopWhiteboardShare(channelUrl) {\n      var _this49 = this;\n\n      var whiteboard = this.locusInfo.mediaShares.find(function (element) {\n        return element.name === 'whiteboard';\n      });\n\n      if (whiteboard) {\n        _metrics.default.postEvent({\n          event: _config.eventType.WHITEBOARD_SHARE_STOPPED,\n          meeting: this\n        });\n\n        return this.meetingRequest.changeMeetingFloor({\n          disposition: _constants.FLOOR_ACTION.RELEASED,\n          personUrl: this.locusInfo.self.url,\n          deviceUrl: this.deviceUrl,\n          uri: whiteboard.url\n        }).catch(function (error) {\n          _loggerProxy.default.logger.error('Meeting:index#stopWhiteboardShare --> Error ', error);\n\n          _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.STOP_WHITEBOARD_SHARE_FAILURE, {\n            correlation_id: _this49.correlationId,\n            locus_id: _this49.locusUrl.split('/').pop(),\n            reason: error.message,\n            stack: error.stack,\n            board: {\n              channelUrl: channelUrl\n            }\n          });\n\n          return _promise.default.reject(error);\n        }).finally(function () {});\n      }\n\n      return _promise.default.reject(new _parameter.default('Cannot stop share without whiteboard.'));\n    }\n    /**\n     * Start sharing content with server\n     * @returns {Promise} see #meetingRequest.changeMeetingFloor\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"share\",\n    value: function share() {\n      var _this50 = this;\n\n      var content = this.locusInfo.mediaShares.find(function (element) {\n        return element.name === _constants.CONTENT;\n      });\n\n      if (content && this.shareStatus !== _constants.SHARE_STATUS.LOCAL_SHARE_ACTIVE) {\n        _metrics.default.postEvent({\n          event: _config.eventType.SHARE_INITIATED,\n          meeting: this\n        });\n\n        return this.meetingRequest.changeMeetingFloor({\n          disposition: _constants.FLOOR_ACTION.GRANTED,\n          personUrl: this.locusInfo.self.url,\n          deviceUrl: this.deviceUrl,\n          uri: content.url,\n          resourceUrl: this.resourceUrl\n        }).then(function () {\n          _this50.isSharing = true;\n          return _promise.default.resolve();\n        }).catch(function (error) {\n          _loggerProxy.default.logger.error('Meeting:index#share --> Error ', error);\n\n          _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.MEETING_SHARE_FAILURE, {\n            correlation_id: _this50.correlationId,\n            locus_id: _this50.locusUrl.split('/').pop(),\n            reason: error.message,\n            stack: error.stack\n          });\n\n          return _promise.default.reject(error);\n        });\n      }\n\n      return _promise.default.reject(new _parameter.default('Cannot share without content.'));\n    }\n    /**\n     * Stops the screen share\n     * @returns {Promise} see #updateShare\n     * @public\n     * @memberof Meeting\n     */\n    // Internal only, temporarily allows optional params\n    // eslint-disable-next-line valid-jsdoc\n\n  }, {\n    key: \"stopShare\",\n    value: function stopShare() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.updateShare(_objectSpread({\n        sendShare: false,\n        receiveShare: this.mediaProperties.mediaDirection.receiveShare\n      }, options));\n    }\n    /**\n     * sends stops floor request\n     * @returns {Promise} see #meetingRequest.changeMeetingFloor\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"stopFloorRequest\",\n    value: function stopFloorRequest() {\n      var _this51 = this;\n\n      var content = this.locusInfo.mediaShares.find(function (element) {\n        return element.name === _constants.CONTENT;\n      });\n\n      if (content && this.mediaProperties.mediaDirection.sendShare) {\n        _metrics.default.postEvent({\n          event: _config.eventType.SHARE_STOPPED,\n          meeting: this\n        });\n\n        _media.default.stopTracks(this.mediaProperties.shareTrack);\n\n        if (content.floor.beneficiary.id !== this.selfId) {\n          // remote participant started sharing and caused our sharing to stop, we don't want to send any floor action request in that case\n          this.isSharing = false;\n          return _promise.default.resolve();\n        }\n\n        return this.meetingRequest.changeMeetingFloor({\n          disposition: _constants.FLOOR_ACTION.RELEASED,\n          personUrl: this.locusInfo.self.url,\n          deviceUrl: this.deviceUrl,\n          uri: content.url,\n          resourceUrl: this.resourceUrl\n        }).catch(function (error) {\n          _loggerProxy.default.logger.error('Meeting:index#stopFloorRequest --> Error ', error);\n\n          _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.STOP_FLOOR_REQUEST_FAILURE, {\n            correlation_id: _this51.correlationId,\n            locus_id: _this51.locusUrl.split('/').pop(),\n            reason: error.message,\n            stack: error.stack\n          });\n\n          return _promise.default.reject(error);\n        }).finally(function () {\n          _this51.isSharing = false;\n        });\n      }\n\n      return _promise.default.reject(new _parameter.default('Cannot stop share without content'));\n    }\n    /**\n     * Intiate a recording of this meeting\n     * @returns {Promise}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"startRecording\",\n    value: function startRecording() {\n      return _util.default.startRecording(this.meetingRequest, this.locusUrl, this.locusInfo);\n    }\n    /**\n     * End the recording of this meeting\n     * @returns {Promise}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"stopRecording\",\n    value: function stopRecording() {\n      return _util.default.stopRecording(this.meetingRequest, this.locusUrl, this.locusInfo);\n    }\n    /**\n     * Pauses the recording of this meeting\n     * @returns {Promise}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"pauseRecording\",\n    value: function pauseRecording() {\n      return _util.default.pauseRecording(this.meetingRequest, this.locusUrl, this.locusInfo);\n    }\n    /**\n     * Resumes the recording of this meeting\n     * @returns {Promise}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"resumeRecording\",\n    value: function resumeRecording() {\n      return _util.default.resumeRecording(this.meetingRequest, this.locusUrl, this.locusInfo);\n    }\n    /**\n     * Locks the current meeting if possible\n     * @returns {Promise}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"lockMeeting\",\n    value: function lockMeeting() {\n      return _util.default.lockMeeting(this.inMeetingActions, this.meetingRequest, this.locusUrl);\n    }\n    /**\n     * Unlocks the current meeting if possible\n     * @returns {Promise}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"unlockMeeting\",\n    value: function unlockMeeting() {\n      return _util.default.unlockMeeting(this.inMeetingActions, this.meetingRequest, this.locusUrl);\n    }\n    /**\n     * Logs an error message and returns a rejected promise with same message\n     * @param {String} message\n     * @returns {Promise}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"rejectWithErrorLog\",\n    value: function rejectWithErrorLog(message) {\n      _loggerProxy.default.logger.error(message);\n\n      return _promise.default.reject(new Error(message));\n    }\n    /**\n     * Sends DTMF tones to the current meeting\n     * @param {String} tones a string of one or more DTMF tones to send\n     * @returns {Promise}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"sendDTMF\",\n    value: function sendDTMF(tones) {\n      if (this.locusInfo && this.locusInfo.self) {\n        if (this.locusInfo.self.enableDTMF) {\n          return this.meetingRequest.sendDTMF({\n            locusUrl: this.locusInfo.self.url,\n            deviceUrl: this.deviceUrl,\n            tones: tones\n          });\n        }\n\n        return this.rejectWithErrorLog('Meeting:index#sendDTMF --> cannot send DTMF, meeting does not have DTMF enabled');\n      }\n\n      return this.rejectWithErrorLog('Meeting:index#sendDTMF --> cannot send DTMF, meeting does not have a connection to the \"locus\" call control service. Have you joined?');\n    }\n    /**\n     * Sends request to change layout type for the current meeting for the specific participant/device only\n     * @param {String} layoutType a layout type that should be available in meeting constants LAYOUT_TYPES\n     * @param {Object} renderInfo preferred dimensions for the remote main and content streams (server can ignore it)\n     * @param {Object} renderInfo.main preferred dimensions for the remote main video stream\n     * @param {Number} renderInfo.main.width preferred width of main video stream\n     * @param {Number} renderInfo.main.height preferred height of main video stream\n     * @param {Object} renderInfo.content preferred dimensions for the remote content share stream\n     * @param {Number} renderInfo.content.width preferred width of content share stream\n     * @param {Number} renderInfo.content.height preferred height of content share stream\n     * @returns {Promise}\n     * @public\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"changeVideoLayout\",\n    value: function changeVideoLayout(layoutType) {\n      var _this52 = this;\n\n      var renderInfo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var main = renderInfo.main,\n          content = renderInfo.content;\n      var _this$mediaProperties3 = this.mediaProperties,\n          mediaDirection = _this$mediaProperties3.mediaDirection,\n          remoteShare = _this$mediaProperties3.remoteShare,\n          remoteVideoTrack = _this$mediaProperties3.remoteVideoTrack;\n      var layoutInfo = (0, _cloneDeep2.default)(this.lastVideoLayoutInfo); // TODO: We need a real time value for Audio, Video and Share send indicator\n\n      if (mediaDirection.receiveVideo !== true || !remoteVideoTrack) {\n        return this.rejectWithErrorLog('Meeting:index#changeVideoLayout --> cannot change video layout, you are not recieving any video/share stream');\n      }\n\n      if (_constants.LAYOUT_TYPES.includes(layoutType)) {\n        layoutInfo.layoutType = layoutType;\n      } else {\n        return this.rejectWithErrorLog('Meeting:index#changeVideoLayout --> cannot change video layout, invalid layoutType recieved.');\n      }\n\n      if (main) {\n        var mainWidth = Math.round(main.width);\n        var mainHeight = Math.round(main.height); // Stop any \"twitching\" caused by very slight size changes\n\n        if (!this.lastVideoLayoutInfo.main || Math.abs(this.lastVideoLayoutInfo.main.height - mainHeight) > 2 || Math.abs(this.lastVideoLayoutInfo.main.width - mainWidth) > 2) {\n          layoutInfo.main = {\n            width: mainWidth,\n            height: mainHeight\n          };\n        }\n      }\n\n      if (content) {\n        if (this.mediaProperties.mediaDirection.receiveShare && remoteShare) {\n          var contentWidth = Math.round(content.width);\n          var contentHeight = Math.round(content.height); // Stop any \"twitching\" caused by very slight size changes\n\n          if (!this.lastVideoLayoutInfo.content || Math.abs(this.lastVideoLayoutInfo.content.height - contentHeight) > 2 || Math.abs(this.lastVideoLayoutInfo.content.width - contentWidth) > 2) {\n            layoutInfo.content = {\n              width: contentWidth,\n              height: contentHeight\n            };\n          }\n        } else {\n          return this.rejectWithErrorLog('Meeting:index#changeVideoLayout --> unable to send renderInfo for content, you are not receiving remote share');\n        }\n      }\n\n      if ((0, _isEqual2.default)(layoutInfo, this.lastVideoLayoutInfo)) {\n        // nothing changed, no need to send any request\n        return _promise.default.resolve();\n      }\n\n      this.lastVideoLayoutInfo = (0, _cloneDeep2.default)(layoutInfo);\n      return this.meetingRequest.changeVideoLayoutDebounced({\n        locusUrl: this.locusInfo.self.url,\n        deviceUrl: this.deviceUrl,\n        layoutType: layoutType,\n        main: layoutInfo.main,\n        content: layoutInfo.content\n      }).then(function (response) {\n        if (response && response.body && response.body.locus) {\n          _this52.locusInfo.onFullLocus(response.body.locus);\n        }\n      }).catch(function (error) {\n        _loggerProxy.default.logger.error('Meeting:index#changeVideoLayout --> Error ', error);\n\n        return _promise.default.reject(error);\n      });\n    }\n    /**\n     * Sets the quality of the local video stream\n     * @param {String} level {LOW|MEDIUM|HIGH}\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"setLocalVideoQuality\",\n    value: function setLocalVideoQuality(level) {\n      var _this53 = this;\n\n      _loggerProxy.default.logger.log(\"Meeting:index#setLocalVideoQuality --> Setting quality to \".concat(level));\n\n      if (!_constants.VIDEO_RESOLUTIONS[level]) {\n        return this.rejectWithErrorLog(\"Meeting:index#setLocalVideoQuality --> \".concat(level, \" not defined\"));\n      }\n\n      if (!this.mediaProperties.mediaDirection.sendVideo) {\n        return this.rejectWithErrorLog('Meeting:index#setLocalVideoQuality --> unable to change video quality, sendVideo is disabled');\n      } // If level is already the same, don't do anything\n\n\n      if (level === this.mediaProperties.localQualityLevel) {\n        _loggerProxy.default.logger.warn(\"Meeting:index#setLocalQualityLevel --> Quality already set to \".concat(level));\n\n        return _promise.default.resolve();\n      } // Set the quality level in properties\n\n\n      this.mediaProperties.setLocalQualityLevel(level);\n      var mediaDirection = {\n        sendAudio: this.mediaProperties.mediaDirection.sendAudio,\n        sendVideo: this.mediaProperties.mediaDirection.sendVideo,\n        sendShare: this.mediaProperties.mediaDirection.sendShare\n      };\n      return this.getMediaStreams(mediaDirection, _constants.VIDEO_RESOLUTIONS[level]).then(function (_ref11) {\n        var _ref12 = (0, _slicedToArray2.default)(_ref11, 1),\n            localStream = _ref12[0];\n\n        return _this53.updateVideo({\n          sendVideo: true,\n          receiveVideo: true,\n          stream: localStream\n        });\n      });\n    }\n    /**\n     * Sets the quality level of the remote incoming media\n     * @param {String} level {LOW|MEDIUM|HIGH}\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"setRemoteQualityLevel\",\n    value: function setRemoteQualityLevel(level) {\n      _loggerProxy.default.logger.log(\"Meeting:index#setRemoteQualityLevel --> Setting quality to \".concat(level));\n\n      if (!_constants.QUALITY_LEVELS[level]) {\n        return this.rejectWithErrorLog(\"Meeting:index#setRemoteQualityLevel --> \".concat(level, \" not defined\"));\n      }\n\n      if (!this.mediaProperties.mediaDirection.receiveAudio && !this.mediaProperties.mediaDirection.receiveVideo) {\n        return this.rejectWithErrorLog('Meeting:index#setRemoteQualityLevel --> unable to change remote quality, receiveVideo and receiveAudio is disabled');\n      } // If level is already the same, don't do anything\n\n\n      if (level === this.mediaProperties.remoteQualityLevel) {\n        _loggerProxy.default.logger.warn(\"Meeting:index#setRemoteQualityLevel --> Quality already set to \".concat(level));\n\n        return _promise.default.resolve();\n      } // Set the quality level in properties\n\n\n      this.mediaProperties.setRemoteQualityLevel(level);\n      return this.updateMedia({\n        mediaSettings: this.mediaProperties.mediaDirection\n      });\n    }\n    /**\n     * Sets the quality level of all meeting media (incoming/outgoing)\n     * @param {String} level {LOW|MEDIUM|HIGH}\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"setMeetingQuality\",\n    value: function setMeetingQuality(level) {\n      var _this54 = this;\n\n      _loggerProxy.default.logger.log(\"Meeting:index#setMeetingQuality --> Setting quality to \".concat(level));\n\n      if (!_constants.QUALITY_LEVELS[level]) {\n        return this.rejectWithErrorLog(\"Meeting:index#setMeetingQuality --> \".concat(level, \" not defined\"));\n      }\n\n      var previousLevel = {\n        local: this.mediaProperties.localQualityLevel,\n        remote: this.mediaProperties.remoteQualityLevel\n      }; // If level is already the same, don't do anything\n\n      if (level === this.mediaProperties.localQualityLevel && level === this.mediaProperties.remoteQualityLevel) {\n        _loggerProxy.default.logger.warn(\"Meeting:index#setMeetingQuality --> Quality already set to \".concat(level));\n\n        return _promise.default.resolve();\n      } // Determine the direction of our current media\n\n\n      var _this$mediaProperties4 = this.mediaProperties.mediaDirection,\n          receiveAudio = _this$mediaProperties4.receiveAudio,\n          receiveVideo = _this$mediaProperties4.receiveVideo,\n          sendVideo = _this$mediaProperties4.sendVideo;\n      return (sendVideo ? this.setLocalVideoQuality(level) : _promise.default.resolve()).then(function () {\n        return receiveAudio || receiveVideo ? _this54.setRemoteQualityLevel(level) : _promise.default.resolve();\n      }).catch(function (error) {\n        // From troubleshooting it seems that the stream itself doesn't change the max-fs if the peer connection isn't stable\n        _this54.mediaProperties.setLocalQualityLevel(previousLevel.local);\n\n        _this54.mediaProperties.setRemoteQualityLevel(previousLevel.remote);\n\n        _loggerProxy.default.logger.error(\"Meeting:index#setMeetingQuality --> \".concat(error.message));\n\n        _metrics.default.sendBehavioralMetric(_constants.BEHAVIORAL_METRICS.SET_MEETING_QUALITY_FAILURE, {\n          correlation_id: _this54.correlationId,\n          locus_id: _this54.locusUrl.split('/').pop(),\n          reason: error.message,\n          stack: error.stack\n        }, {\n          type: error.name\n        });\n\n        return _promise.default.reject(error);\n      });\n    }\n    /**\n    * @param {Object} options parameter\n    * @param {Boolean} options.sendAudio send audio from the display share\n    * @param {Boolean} options.sendShare send video from the display share\n    * @param {Object} options.sharePreferences\n    * @param {MediaTrackConstraints} options.sharePreferences.shareConstraints constraints to apply to video\n    *   @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints}\n    * @param {Boolean} options.sharePreferences.highFrameRate if shareConstraints isn't provided, set default values based off of this boolean\n    * @returns {Promise}\n    */\n\n  }, {\n    key: \"shareScreen\",\n    value: function shareScreen() {\n      var _this55 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _loggerProxy.default.logger.log('Meeting:index#shareScreen --> Getting local share');\n\n      var shareConstraints = _objectSpread({\n        sendShare: true,\n        sendAudio: false\n      }, options);\n\n      return _media.default.getDisplayMedia(shareConstraints, this.config).then(function (shareStream) {\n        return _this55.updateShare({\n          sendShare: true,\n          receiveShare: _this55.mediaProperties.mediaDirection.receiveShare,\n          stream: shareStream\n        });\n      }).catch(function (error) {\n        // Whenever there is a failure when trying to access a user's display\n        // report it as an Behavioral metric\n        // This gives visibility into common errors and can help\n        // with further troubleshooting\n        // This metrics will get erros for getDisplayMedia and share errors for now\n        // TODO: The getDisplayMedia errors need to be moved inside `media.getDisplayMedia`\n        var metricName = _constants.BEHAVIORAL_METRICS.GET_DISPLAY_MEDIA_FAILURE;\n        var data = {\n          correlation_id: _this55.correlationId,\n          locus_id: _this55.locusUrl.split('/').pop(),\n          reason: error.message,\n          stack: error.stack\n        };\n        var metadata = {\n          type: error.name\n        };\n\n        _metrics.default.sendBehavioralMetric(metricName, data, metadata);\n\n        throw new _media2.default('Unable to retrieve display media stream', error);\n      });\n    }\n    /**\n     * Functionality for when a share is ended.\n     * @private\n     * @memberof Meeting\n     * @param {MediaStream} localShare\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"handleShareTrackEnded\",\n    value: function handleShareTrackEnded(localShare) {\n      if (this.wirelessShare) {\n        this.leave({\n          reason: _constants.MEETING_REMOVED_REASON.USER_ENDED_SHARE_STREAMS\n        });\n      } else {\n        // Skip checking for a stable peerConnection\n        // to allow immediately stopping screenshare\n        this.stopShare({\n          skipSignalingCheck: true\n        }).catch(function (error) {\n          _loggerProxy.default.logger.log('Meeting:index#handleShareTrackEnded --> Error stopping share: ', error);\n        });\n      }\n\n      _triggerProxy.default.trigger(this, {\n        file: 'meeting/index',\n        function: 'handleShareTrackEnded'\n      }, _constants.EVENT_TRIGGERS.MEETING_STOPPED_SHARING_LOCAL, {\n        type: _constants.EVENT_TYPES.LOCAL_SHARE,\n        stream: localShare\n      });\n    }\n    /**\n     * Emits the 'network:quality' event\n     * 1 indicates an acceptable uplink network.\n     * 0 indicates an unacceptable uplink network based on a predefined threshold\n     * @returns {undefined}\n     * @param {Object} res - payload of emitNetworkQuality\n     * @property {string} mediaType {video|audio}\n     * @property {number} networkQualityScore - {1|0}\n     * @private\n     * @memberof Meeting\n     */\n\n  }, {\n    key: \"sendNetworkQualityEvent\",\n    value: function sendNetworkQualityEvent(res) {\n      _triggerProxy.default.trigger(this, {\n        file: 'meeting/index',\n        function: 'addMedia'\n      }, _constants.EVENT_TRIGGERS.NETWORK_QUALITY, {\n        networkQualityScore: res.networkQualityScore,\n        mediaType: res.mediaType\n      });\n    }\n    /**\n     * Handle logging the media\n     * @param {Object} audioTrack The audio track\n     * @param {Object} videoTrack The video track\n     * @private\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"handleMediaLogging\",\n    value: function handleMediaLogging(_ref13) {\n      var audioTrack = _ref13.audioTrack,\n          videoTrack = _ref13.videoTrack;\n\n      _util.default.handleVideoLogging(videoTrack);\n\n      _util.default.handleAudioLogging(audioTrack);\n    }\n    /**\n     * @param {string} typeMedia 'audio' or 'video'\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"setStartSetupDelay\",\n    value: function setStartSetupDelay(typeMedia) {\n      this[\"startSetupDelay\".concat(typeMedia)] = performance.now();\n      this[\"endSetupDelay\".concat(typeMedia)] = undefined;\n    }\n    /**\n     * @param {string} typeMedia 'audio' or 'video'\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"setEndSetupDelay\",\n    value: function setEndSetupDelay(typeMedia) {\n      this[\"endSetupDelay\".concat(typeMedia)] = performance.now();\n    }\n    /**\n     * @param {string} typeMedia 'audio' or 'video'\n     * @returns {string} duration between start and end of setup\n     */\n\n  }, {\n    key: \"getSetupDelayDuration\",\n    value: function getSetupDelayDuration(typeMedia) {\n      var start = this[\"startSetupDelay\".concat(typeMedia)];\n      var end = this[\"endSetupDelay\".concat(typeMedia)];\n      return start && end ? end - start : undefined;\n    }\n    /**\n     * @param {string} typeMedia 'audio' or 'video'\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"setStartSendingMediaDelay\",\n    value: function setStartSendingMediaDelay(typeMedia) {\n      this[\"startSendingMediaDelay\".concat(typeMedia)] = performance.now();\n      this[\"endSendingMediaDelay\".concat(typeMedia)] = undefined;\n    }\n    /**\n     * @param {string} typeMedia 'audio' or 'video'\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"setEndSendingMediaDelay\",\n    value: function setEndSendingMediaDelay(typeMedia) {\n      this[\"endSendingMediaDelay\".concat(typeMedia)] = performance.now();\n    }\n    /**\n     * @param {string} typeMedia 'audio' or 'video'\n     * @returns {string} duration between join response and first media tx\n     */\n\n  }, {\n    key: \"getSendingMediaDelayDuration\",\n    value: function getSendingMediaDelayDuration(typeMedia) {\n      var start = this[\"startSendingMediaDelay\".concat(typeMedia)];\n      var end = this[\"endSendingMediaDelay\".concat(typeMedia)];\n      return start && end ? end - start : undefined;\n    }\n    /**\n     *\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"setStartLocalSDPGenRemoteSDPRecvDelay\",\n    value: function setStartLocalSDPGenRemoteSDPRecvDelay() {\n      if (!this.startLocalSDPGenRemoteSDPRecvDelay) {\n        this.startLocalSDPGenRemoteSDPRecvDelay = performance.now();\n        this.endLocalSDPGenRemoteSDPRecvDelay = undefined;\n      }\n    }\n    /**\n     *\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"setEndLocalSDPGenRemoteSDPRecvDelay\",\n    value: function setEndLocalSDPGenRemoteSDPRecvDelay() {\n      if (!this.endLocalSDPGenRemoteSDPRecvDelay) {\n        this.endLocalSDPGenRemoteSDPRecvDelay = performance.now();\n      }\n    }\n    /**\n     *\n     * @returns {string} duration between local SDP generation and remote SDP reception\n     */\n\n  }, {\n    key: \"getLocalSDPGenRemoteSDPRecvDelay\",\n    value: function getLocalSDPGenRemoteSDPRecvDelay() {\n      var start = this.startLocalSDPGenRemoteSDPRecvDelay;\n      var end = this.endLocalSDPGenRemoteSDPRecvDelay;\n\n      if (start && end) {\n        var calculatedDelay = end - start;\n        return calculatedDelay > _constants.METRICS_JOIN_TIMES_MAX_DURATION ? undefined : calculatedDelay;\n      }\n\n      return undefined;\n    }\n    /**\n     *\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"setStartCallInitiateJoinReq\",\n    value: function setStartCallInitiateJoinReq() {\n      this.startCallInitiateJoinReq = performance.now();\n      this.endCallInitiateJoinReq = undefined;\n    }\n    /**\n     *\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"setEndCallInitiateJoinReq\",\n    value: function setEndCallInitiateJoinReq() {\n      this.endCallInitiateJoinReq = performance.now();\n    }\n    /**\n     *\n     * @returns {string} duration between call initiate and sending join request to locus\n     */\n\n  }, {\n    key: \"getCallInitiateJoinReq\",\n    value: function getCallInitiateJoinReq() {\n      var start = this.startCallInitiateJoinReq;\n      var end = this.endCallInitiateJoinReq;\n\n      if (start && end) {\n        var calculatedDelay = end - start;\n        return calculatedDelay > _constants.METRICS_JOIN_TIMES_MAX_DURATION ? undefined : calculatedDelay;\n      }\n\n      return undefined;\n    }\n    /**\n     *\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"setStartJoinReqResp\",\n    value: function setStartJoinReqResp() {\n      this.startJoinReqResp = performance.now();\n      this.endJoinReqResp = undefined;\n    }\n    /**\n     *\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"setEndJoinReqResp\",\n    value: function setEndJoinReqResp() {\n      this.endJoinReqResp = performance.now();\n    }\n    /**\n     *\n     * @returns {string} duration between sending locus join request and receiving join response\n     */\n\n  }, {\n    key: \"getJoinReqResp\",\n    value: function getJoinReqResp() {\n      var start = this.startJoinReqResp;\n      var end = this.endJoinReqResp;\n\n      if (start && end) {\n        var calculatedDelay = end - start;\n        return calculatedDelay > _constants.METRICS_JOIN_TIMES_MAX_DURATION ? undefined : calculatedDelay;\n      }\n\n      return undefined;\n    }\n    /**\n     *\n     * @returns {string} duration between call initiate and successful locus join (even if it is in lobby)\n     */\n\n  }, {\n    key: \"getTotalJmt\",\n    value: function getTotalJmt() {\n      var start = this.startCallInitiateJoinReq;\n      var end = this.endJoinReqResp;\n      return start && end ? end - start : undefined;\n    }\n  }]);\n  return Meeting;\n}(_webexCore.StatelessWebexPlugin);\n\nexports.default = Meeting;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;AAEA;;AAEA;;AAIA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AA2CA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,wBAAoB,gCAApB;AAAA,IAAOA,SAAP,qBAAOA,SAAP;;AAEA,IAAMC,UAAU,GAAG,SAAbA,UAAa,CAACC,OAAD,QAAwD;AAAA,yBAA7CC,MAA6C;AAAA,MAA7CA,MAA6C,4BAApC,EAAoC;AAAA,0BAAhCC,OAAgC;AAAA,MAAhCA,OAAgC,6BAAtB,EAAsB;AAAA,0BAAlBC,OAAkB;AAAA,MAAlBA,OAAkB,6BAAR,EAAQ;;AACzEC,uBAAYC,MAAZD,CAAmBE,IAAnBF,CAAwBH,MAAxBG;;AAEA,SAAOJ,OAAO,CACXO,IADIP,CACC,UAACQ,GAAD,EAAS;AACbJ,yBAAYC,MAAZD,CAAmBE,IAAnBF,CAAwBF,OAAxBE;;AAEA,WAAOI,GAAP;AAJG,KAMJC,KANIT,CAME,UAACU,KAAD,EAAW;AAChBN,yBAAYC,MAAZD,CAAmBM,KAAnBN,CAAyBD,OAAzBC,EAAkCM,KAAlCN;;AACA,UAAMM,KAAN;AARG,IAAP;AAHF;;AAeO,IAAMC,iBAAiB,GAAG;AAC/BC,KAAG,EAAE,KAD0B;AAE/BC,OAAK,EAAE,OAFwB;AAG/BC,OAAK,EAAE,OAHwB;AAI/BC,OAAK,EAAE;AAJwB,CAA1B;AAOP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;IACqBC,O;;;;AAGnB;AACF;AACA;AACA;AACA;AACA;;;AACE,mBAAYC,KAAZ,EAAmBC,QAAnB,EAA4B;AAAA;;AAAA;AAC1BC,8BAAM,EAAN,EAAUD,QAAV;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AAR8B,4FARhBE,mBAQgB;AAAA,kGAi6GV,UAChBC,cADgB,EAKb;AAAA,UAFHC,UAEG,uEAFUC,6BAAkBJ,MAAKK,eAAL,CAAqBC,iBAAvCF,CAEV;AAAA,UADHG,gBACG;;AACH,UACEL,cAAc,KAEZA,cAAc,CAACM,SAAfN,IACAA,cAAc,CAACO,SADfP,IAEAA,cAAc,CAACQ,SAJH,CADhB,EAOE;AACA,YAAIR,cAAc,IAEdA,cAAc,CAACM,SAFfN,IAGAA,cAAc,CAACO,SAHfP,IAIAA,cAAc,CAACQ,SAJfR,IAMFvB,SAAS,CAAC,QAAD,CANX,EAOE;AACAM,+BAAYC,MAAZD,CAAmB0B,IAAnB1B,CAAwB,kGAAxBA;;AAEAiB,wBAAc,CAACQ,SAAfR,GAA2B,KAA3BA;;AAEAjB,+BAAYC,MAAZD,CAAmB0B,IAAnB1B,CAAwB,oMAAxBA;;AACAA,+BAAYC,MAAZD,CAAmB0B,IAAnB1B,CAAwB,gJAAxBA;AAdF,UAiBA;;;AACA,oBAA0CkB,UAAU,IAAIA,UAAU,CAACS,KAAzBT,IAAkC;AAACU,kBAAQ,EAAE;AAAX,SAA5E;AAAA,YAAiBC,oBAAjB,SAAOD,QAAP;;AACA,YAAME,iBAAiB,GAAGf,MAAKK,eAAL,CAAqBW,gBAArB,EAA1B;;AAEA,YAAIF,oBAAJ,EAA0B;AACxB;AACAd,gBAAKK,eAAL,CAAqBY,gBAArB,CAAsCH,oBAAtC;AAFF,eAIK,IAAIC,iBAAJ,EAAuB;AAC1B;AACA;AACA;AACAZ,oBAAU,mCACLA,UADK;AAERS,iBAAK,kCACAT,UAAU,CAACS,KADX;AAEHC,sBAAQ,EAAEE;AAFP;AAFG,YAAVZ;AAOD;;AAED,eAAOe,eAAMC,kBAAND,CAAyB;AAC9BV,mBAAS,EAAEN,cAAc,CAACM,SADI;AAE9BC,mBAAS,EAAEP,cAAc,CAACO;AAFI,SAAzBS,EAIJ5B,KAJI4B,CAIE,UAAC3B,KAAD;AAAA,iBAAW6B,iBAAQC,MAAR,CAChB,IAAIC,eAAJ,CAAe,+EAAf,EAAgG/B,KAAhG,CADgB,CAAX;AAJF,WAOJH,IAPI8B,CAOC,UAACK,iBAAD;AAAA,iBACJL,eAAMM,YAANN,iCAEOhB,cAFP;AAGIM,qBAAS,EAAEe,iBAAiB,CAACf,SAHjC;AAIIC,qBAAS,EAAEc,iBAAiB,CAACd,SAJjC;AAKIgB,qBAAS,EAAEzB,MAAK0B,WAAL,KAAqBC,wBAAaC;AALjD,cAOEzB,UAPFe,EAQEX,gBARFW,EASElB,MAAK6B,MATPX,EAWG5B,KAXH4B,CAWS,UAAC3B,KAAD,EAAW;AAAA,gCAChB;AACA;AACA;AACA;;;AACA,gBAAMuC,UAAU,GAAGC,8BAAmBC,sBAAtC;AACA,gBAAMC,IAAI,GAAG;AACXC,4BAAc,EAAElC,MAAKmC,aADV;AAEXC,sBAAQ,oBAAEpC,MAAKqC,QAAP,mDAAEC,eAAeC,KAAf,CAAqB,GAArB,EAA0BC,GAA1B,EAFC;AAGXC,oBAAM,EAAElD,KAAK,CAACmD,OAHH;AAIXC,mBAAK,EAAEpD,KAAK,CAACoD;AAJF,aAAb;AAMA,gBAAMC,QAAQ,GAAG;AACfC,kBAAI,EAAEtD,KAAK,CAACuD;AADG,aAAjB;;AAIAC,6BAAQC,oBAARD,CAA6BjB,UAA7BiB,EAAyCd,IAAzCc,EAA+CH,QAA/CG;;AACA,kBAAM,IAAIzB,eAAJ,CAAe,kCAAf,EAAmD/B,KAAnD,CAAN;AA5BJ,YADI;AAPD,UAAP;AAsCD;;AAED,aAAO6B,iBAAQC,MAAR,CACL,IAAIC,eAAJ,CAAe,yDAAf,CADK,CAAP;AA5/G0B;AAAA,sGA0gHN;AAAA,kCAAEd,SAAF;AAAA,UAAEA,SAAF,gCAAc,IAAd;AAAA,kCAAoBC,SAApB;AAAA,UAAoBA,SAApB,gCAAgC,IAAhC;AAAA,aAA0CS,eAAMC,kBAAND,CAAyB;AAACV,iBAAS,EAATA,SAAD;AAAYC,iBAAS,EAATA;AAAZ,OAAzBS,CAA1C;AA1gHM;AAAA,6FAihHf;AAAA,aAAMA,eAAM+B,UAAN/B,EAAN;AAjhHe;AAAA,uGAoyHL,YAAM;AAC3B,UAAIlB,MAAK6B,MAAL,CAAYqB,YAAZ,CAAyBC,0BAA7B,EAAyD;AACvDlE,6BAAYC,MAAZD,CAAmBE,IAAnBF,CAAwB,0DAAxBA;;AACAmE,8BAAQC,OAARD,8CAEE;AACEE,cAAI,EAAE,eADR;AAEEC,kBAAQ,EAAE;AAFZ,SAFFH,EAMEI,0BAAeC,gBANjBL;AAQD;AA/yHyB;AAAA,+GAyzHG,YAAM;AACnC,UAAIpD,MAAK0D,cAAL,MAA0B1D,MAAK2D,kBAAL,CAAwBC,MAAxB,GAAiC,CAA/D,EAAmE;AACjE,oCAEI5D,MAAK2D,kBAAL,CAAwBE,KAAxB,EAFJ;AAAA,YACEC,qBADF,yBACEA,qBADF;AAAA,YACyBC,oBADzB,yBACyBA,oBADzB;AAAA,YAC+CC,eAD/C,yBAC+CA,eAD/C;AAAA,YACgEjE,OADhE,yBACgEA,OADhE;;AAIAd,6BAAYC,MAAZD,CAAmBgF,GAAnBhF,+FAA8G+E,eAA9G;;AACA,gBAAQA,eAAR;AACE,eAAKxE,iBAAiB,CAACC,GAAvB;AACEO,kBAAKkE,WAAL,CAAiBnE,OAAjB,EAA0BX,IAA1B,CAA+B0E,qBAA/B,EAAsDC,oBAAtD;;AACA;;AACF,eAAKvE,iBAAiB,CAACE,KAAvB;AACEM,kBAAKmE,WAAL,CAAiBpE,OAAjB,EAA0BX,IAA1B,CAA+B0E,qBAA/B,EAAsDC,oBAAtD;;AACA;;AACF,eAAKvE,iBAAiB,CAACG,KAAvB;AACEK,kBAAKoE,WAAL,CAAiBrE,OAAjB,EAA0BX,IAA1B,CAA+B0E,qBAA/B,EAAsDC,oBAAtD;;AACA;;AACF,eAAKvE,iBAAiB,CAACI,KAAvB;AACEI,kBAAKqE,WAAL,CAAiBtE,OAAjB,EAA0BX,IAA1B,CAA+B0E,qBAA/B,EAAsDC,oBAAtD;;AACA;;AACF;AACE9E,iCAAYC,MAAZD,CAAmBM,KAAnBN,wGAAyH+E,eAAzH;;AACA;AAfJ;AAiBD;AAj1HyB;AAS1BhE,UAAKF,KAAL,GAAaA,KAAb;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIE,UAAKD,OAAL,GAAeA,QAAf;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIC,UAAKsE,EAAL,GAAUC,cAAKC,EAALD,EAAV;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACIvE,UAAKmC,aAAL,GAAqBnC,MAAKsE,EAA1B;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACItE,UAAKyE,MAAL,GAAc3E,KAAK,CAAC2E,MAApB;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACIzE,UAAK0E,KAAL,GAAa5E,KAAK,CAAC4E,KAAnB;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI1E,UAAK2E,QAAL,GAAgB7E,KAAK,CAAC6E,QAAtB;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI3E,UAAK4E,SAAL,GAAiB9E,KAAK,CAAC8E,SAAvB;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACI5E,UAAK6E,OAAL,GAAeC,uBAAf;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACI;;AACA9E,UAAK+E,WAAL,GAAmB,EAAnB;AACA;AACJ;AACA;AACA;AACA;AACA;;AACI/E,UAAKgF,OAAL,GAAe,IAAIC,eAAJ,CAAY;AAAC5C,cAAQ,EAAGvC,KAAK,CAACoF,KAANpF,IAAeA,KAAK,CAACoF,KAANpF,CAAYqF;AAAvC,KAAZ,EAA0D;AAACC,YAAM,EAAEpF,MAAKqF;AAAd,KAA1D,CAAf;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIrF,UAAKsF,IAAL,GAAY,IAAIC,cAAJ,CAAS,EAAT,EAAa;AAACH,YAAM,EAAEpF,MAAKqF;AAAd,KAAb,CAAZ;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACIrF,UAAKwF,mBAAL,GAA2B,IAAIC,4BAAJ,6CAA3B;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIzF,UAAK0F,KAAL,GAAa,IAAb;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI1F,UAAKY,KAAL,GAAa,IAAb;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIZ,UAAK2F,yBAAL,GAAiCC,eAAoBC,MAApBD,6CAAjC;AACA;AACJ;AACA;AACA;AACA;AACA;;AACI5F,UAAK8F,KAAL,GAAa,IAAb;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI9F,UAAK+F,aAAL,GAAqB,IAArB;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI/F,UAAKgG,eAAL,GAAuB,IAAvB;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIhG,UAAKqC,QAAL,GAAiBvC,KAAK,CAACoF,KAANpF,IAAeA,KAAK,CAACoF,KAANpF,CAAYqF,GAA3BrF,IAAmC,IAApD;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIE,UAAKiG,MAAL,GAAc,IAAd;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIjG,UAAKkG,OAAL,GAAe,IAAf;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIlG,UAAK6C,IAAL,GAAY,IAAZ;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI7C,UAAKmG,KAAL,GAAa,IAAb;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACInG,UAAKoG,MAAL,GAAc,IAAd;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIpG,UAAKqG,MAAL,GAAc,IAAd;AACA;AACJ;AACA;AACA;AACA;AACA;;AACIrG,UAAKsG,cAAL,GAAsB,IAAIC,gBAAJ,CAAmB,EAAnB,EAAuBxG,QAAvB,CAAtB;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIC,UAAKwG,gBAAL,GAAwB,IAAxB;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIxG,UAAKyG,sBAAL,GAA8B,UAACD,gBAAD,EAAsB;AAClD,UAAI,CAAC,uBAAQxG,MAAKwG,gBAAb,EAA+BA,gBAA/B,CAAL,EAAuD;AACrD;AACAxG,cAAKwG,gBAAL,GAAwBA,gBAAgB,CAACE,KAAjBF,CAAuB,CAAC,CAAxBA,CAAxB;AACD;AAJH;AAMA;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIxG,UAAKK,eAAL,GAAuB,IAAIsG,mBAAJ,EAAvB;AACA;AACJ;AACA;AACA;AACA;AACA;;AACI3G,UAAK4G,gBAAL,GAAwB,IAAIC,yBAAJ,EAAxB;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACI7G,UAAKyB,SAAL,GAAiB,KAAjB;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIzB,UAAK0B,WAAL,GAAmBC,wBAAamF,QAAhC;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI,+EAA4B,kBAA5B,EAAgD;AAC9CC,SAAG,EAAE,eAAM;AAAA;;AACT,YAAOC,gBAAP,GAA2BhH,MAAKK,eAAL,CAAqB4G,cAArB,CAApBD,gBAAP;AACA,YAAME,cAAc,GAAGF,gBAAH,SAAGA,oBAAH,WAAGA,GAAH,MAAGA,mBAAgB,CAAEG,SAAzC;AACA,YAAMC,eAAe,GAAGJ,gBAAH,SAAGA,oBAAH,WAAGA,GAAH,MAAGA,GAAH,yBAAGA,gBAAgB,CAAEK,MAArB,oFAAGC,sBAA0BC,KAA7B,2DAAGC,uBAAiCC,UAAzD;AACA,YAAMC,WAAW,GAAGN,eAAe,KAAKO,eAAxC;AACA,YAAMC,gBAAgB,GAAGV,cAAc,KAAKW,mBAA5C;;AAEA,YAAIH,WAAW,IAAIE,gBAAnB,EAAqC;AACnC,iBAAO,IAAP;AACD;;AAED,eAAO,KAAP;AAZ4C;AAc9CE,kBAAY,EAAE;AAdgC,KAAhD;AAgBA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI9H,UAAK+H,UAAL,GAAkB,EAAlB;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI/H,UAAKgI,iBAAL,GAAyB,KAAzB;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACIhI,UAAKiI,kBAAL,GAA0BC,uBAAYC,OAAtC;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACInI,UAAKoI,SAAL,GAAiB,EAAjB;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACIpI,UAAKqI,mBAAL,GAA2BH,uBAAYC,OAAvC;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACInI,UAAKsI,UAAL,GAAkB,EAAlB;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACItI,UAAKuI,mBAAL,GAA2B,IAA3B;AACA;AACJ;AACA;AACA;AACA;AACA;;AACIvI,UAAKwI,aAAL,GAAqB,IAArB;AACA;AACJ;AACA;AACA;AACA;AACA;;AACIxI,UAAKyI,qBAAL,GAA6B,IAA7B;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIzI,UAAK0I,YAAL,GAAoB,IAApB;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI1I,UAAK2I,aAAL,GAAqB,IAArB;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI3I,UAAK4I,SAAL,GAAiB,IAAIC,kBAAJ,CAAc7I,MAAK8I,mBAAL,CAAyBC,IAAzB,6CAAd,EAAmD/I,MAAKqF,KAAxD,EAA+DrF,MAAKsE,EAApE,CAAjB,CAxY0B,CAyY1B;;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACItE,UAAKgJ,SAAL,GAAiB,IAAjB;AAEA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIhJ,UAAKiJ,SAAL,GAAiBC,SAAjB;AAEA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIlJ,UAAKmJ,qBAAL,GAA6BnJ,MAAKqF,KAAL,CAAW+D,QAAX,CAAoBC,OAApB,CAA4BC,SAAzD;AAEA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACItJ,UAAKuJ,mBAAL,GAA2B;AAACC,gBAAU,EAAEN,SAAb;AAAwBO,UAAI,EAAEP,SAA9B;AAAyCQ,aAAO,EAAER;AAAlD,KAA3B;AAEA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIlJ,UAAK2D,kBAAL,GAA0B,EAA1B;AAEA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI3D,UAAK2J,aAAL,GAAqBT,SAArB;AAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACIlJ,UAAK4J,cAAL,GAAsBC,2BAAgB1B,OAAtC;AAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACInI,UAAK8J,eAAL,GAAuB,IAAvB;AAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACI9J,UAAK+J,wBAAL,GAAgCb,SAAhC;;AAEAlJ,UAAKgK,uBAAL;;AACAhK,UAAK4I,SAAL,CAAeqB,IAAf,CAAoBnK,KAAK,CAACoF,KAANpF,GAAcA,KAAK,CAACoF,KAApBpF,GAA4B,EAAhD;;AACAE,UAAKkK,aAAL,GAAqB,KAArB;AApe0B;AAqe3B;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;sGACE;AAAA;;AAAA;AAAA;AAAA;AAAA;AACEC,2BADF,SACEA,aAAatH,IADf,SACeA,IAAbsH,EADFC,uBACqBC,QAAnBF,EAAmBE,QADrB,+BACgC,IADhC,iBACEF,EADFG,0BACsCC,WAApCJ,EAAoCI,WADtC,kCACoD,IADpD,oBACEJ;;AADF,sBAGMI,WAAW,IAAI,CAAC,KAAKT,eAH3B;AAAAU;AAAA;AAAA;;AAAA,iDAIWpJ,iBAAQC,MAAR,CAAe,IAAIoJ,KAAJ,CAAU,0EAAV,CAAf,CAJX;;AAAA;AAAA,sBAMMJ,QAAQ,IAAK,KAAKT,cAAL,KAAwBC,2BAAgBa,QAArDL,IAAiE,KAAKT,cAAL,KAAwBC,2BAAgB1B,OAN/G;AAAAqC;AAAA;AAAA;;AAAA,iDAOWpJ,iBAAQC,MAAR,CAAe,IAAIoJ,KAAJ,CAAU,wEAAV,CAAf,CAPX;;AAAA;AAAAD;AAWUG,2BAXV,GAWwBJ,WAAW,GAAG;AAACK,sBAAI,EAAEL,WAAP;AAAoBjG,oBAAE,EAAE,KAAKwF,eAAL,CAAqBe;AAA7C,iBAAH,GAA6D,IAAtFF;AAXVH;AAAA,uBAauB,KAAK1K,KAAL,CAAWgL,mBAAX,CAA+BC,gBAA/B,CAAgDZ,WAAhD,EAA6DtH,IAA7D,EAAmEwH,QAAnE,EAA6EM,WAA7E,CAbvB;;AAAA;AAaUxL,oBAbV,gBAaUA;AAEN,qBAAK6L,gBAAL,CAAsB7L,IAAtB;AACA,qBAAK4F,WAAL,GAAmB5F,IAAI,GAAGA,IAAI,CAAC8L,IAAR,GAAe,IAAtC;AACA,qBAAKlB,wBAAL,GAAgCmB,uCAA4BC,IAA5D;AACA,qBAAKrB,eAAL,GAAuB,IAAvB;;AACA,oBAAK,KAAKF,cAAL,KAAwBC,2BAAgBa,QAAxC,IAAsD,KAAKd,cAAL,KAAwBC,2BAAgBuB,QAAnG,EAA8G;AAC5G,uBAAKxB,cAAL,GAAsBC,2BAAgBuB,QAAtC;AADF,uBAGK;AACH,uBAAKxB,cAAL,GAAsBC,2BAAgBwB,YAAtC;AACD;;AAxBL,iDA0BWjK,iBAAQkK,OAAR,EA1BX;;AAAA;AAAAd;AAAAA;;AAAA,sBA6BQA,uBAAee,wCA7BvB;AAAAf;AAAA;AAAA;;AA8BMvL,qCAAYC,MAAZD,CAAmBE,IAAnBF,oFAAoGkL,WAApG,+GAA6IK,YAAKS,IAAlJ,8CAA6IO,UAAWZ,IAAxJ,SA9BN,CAgCM;;;AACA,oBAAIJ,YAAIzF,WAAR,EAAqB;AACnB,uBAAKA,WAAL,GAAmByF,YAAIzF,WAAvB;AACA,uBAAK0G,aAAL,GAAqBjB,YAAIzF,WAAJ,CAAgB0G,aAArC;AACD;;AAED,qBAAK7B,cAAL,GAAsBC,2BAAgBa,QAAtC;AACA,qBAAKX,wBAAL,GAAgCmB,uCAA4BQ,cAA5D;;AAvCN,qBAwCU,KAAK5B,eAxCf;AAAAU;AAAA;AAAA;;AAAAA;AAAA,uBA0Cc,KAAKmB,cAAL,EA1Cd;;AAAA;AAAA,sBA6Ca,IAAIC,sBAAJ,EA7Cb;;AAAA;AAAA,sBA+CapB,uBAAeqB,uCA/C5B;AAAArB;AAAA;AAAA;;AAgDMvL,qCAAYC,MAAZD,CAAmBE,IAAnBF,oFAAoGkL,WAApG,+GAA4IK,YAAKS,IAAjJ,+CAA4Ia,WAAWlB,IAAvJ;;AAEA,qBAAKb,wBAAL,GAAiC,KAAKD,eAAL,GAC/BoB,uCAA4Ba,aADG,GAE/Bb,uCAA4BQ,cAF9B;;AAIA,oBAAIlB,YAAIwB,kBAAR,EAA4B;AAC1B,uBAAKpC,cAAL,GAAsBC,2BAAgBa,QAAtC;AACD;;AAED,qBAAKZ,eAAL,GAAuBU,YAAIG,WAA3B;AA1DN,sBA2Da,IAAIsB,qBAAJ,EA3Db;;AAAA;AA8DM,qBAAKlC,wBAAL,GAAgCmB,uCAA4BgB,KAA5D;AA9DN;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAoEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,wBAAe7B,QAAf,EAAyBE,WAAzB,EAAsC;AAAA;;AACpC,aAAO,KAAKQ,gBAAL,CAAsB;AAC3BZ,mBAAW,EAAE,KAAKlE,MADS;AACDpD,YAAI,EAAEsJ,oBADL;AACgB9B,gBAAQ,EAARA,QADhB;AAC0BE,mBAAW,EAAXA;AAD1B,OAAtB,EAGJnL,IAHI,CAGC;AAAA,eAAO;AAACgN,yBAAe,EAAE,IAAlB;AAAwBtC,yBAAe,EAAE,IAAzC;AAA+CuC,uBAAa,EAAEnB,uCAA4BC;AAA1F,SAAP;AAHD,SAIJ7L,KAJI,CAIE,UAACC,KAAD,EAAW;AAChB,YAAIA,KAAK,YAAYqM,sBAAjBrM,IAAkCA,KAAK,YAAY0M,qBAAvD,EAAqE;AACnE,iBAAO;AACLG,2BAAe,EAAEE,MAAI,CAAC1C,cAAL,KAAwBC,2BAAgBuB,QADpD;AAELtB,2BAAe,EAAEwC,MAAI,CAACxC,eAFjB;AAGLuC,yBAAa,EAAEC,MAAI,CAACvC;AAHf,WAAP;AAKD;;AACD,cAAOxK,KAAP;AAZG,QAAP;AAcD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,0BAAiB;AAAA;;AACf,UAAI,CAAC,KAAKuK,eAAV,EAA2B;AACzB,eAAO1I,iBAAQC,MAAR,CAAe,IAAIoJ,KAAJ,CAAU,gCAAV,CAAf,CAAP;AAFa,QAKf;AACA;;;AACA,iBAAmB,IAAI8B,GAAJ,CAAQ,KAAKzC,eAAL,CAAqB0C,UAA7B,CAAnB;AAAA,UAAOC,QAAP,QAAOA,QAAP;;AAEA,aAAO,KAAKnG,cAAL,CAAoBqF,cAApB,CAAmC;AACxCe,yBAAiB,YAAK,KAAK5C,eAAL,CAAqB0C,UAA1B,2BAAqDC,QAArD,CADuB;AAExC5B,iBAAS,EAAE,KAAKf,eAAL,CAAqBe;AAFQ,OAAnC,EAIJzL,IAJI,CAIC,UAACuN,QAAD,EAAc;AAClBC,cAAI,CAAC9C,eAAL,CAAqBe,SAArB,GAAiC8B,QAAQ,CAAC1B,IAAT0B,CAAcE,SAA/C;AACAD,cAAI,CAAC9C,eAAL,CAAqBgD,oBAArB,GAA4CH,QAAQ,CAAC1B,IAAT0B,CAAcG,oBAA1D;AACAF,cAAI,CAAC9C,eAAL,CAAqBiD,oBAArB,GAA4CJ,QAAQ,CAAC1B,IAAT0B,CAAcI,oBAA1D;AAPG,QAAP;AASD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,mCAA0B;AACxB;AACA,WAAKC,0BAAL;AACA,WAAKC,6BAAL,GAHwB,CAIxB;;AACA,WAAKC,2BAAL;AACA,WAAKC,qBAAL;AACA,WAAKC,sBAAL;AACA,WAAKC,sBAAL;AACA,WAAKC,8BAAL;AACA,WAAKC,0BAAL;AACA,WAAKC,6BAAL;AACA,WAAKC,iCAAL;AACA,WAAKC,gCAAL;AACA,WAAKC,mCAAL;AACD;AAGD;AACF;AACA;AACA;AACA;AACA;;;;WACE,+CAAsC;AAAA,yBACpC;;;AACA,WAAK/E,SAAL,CAAegF,EAAf,CAAkBC,kBAAOC,4BAAzB,EAAuD,UAACC,GAAD,EAAS;AAC9D;AACA;AACA;AACAhL,yBAAQC,oBAARD,CACEhB,8BAAmB+L,4BADrB/K,EAEE;AACEb,wBAAc,EAAE8L,MAAI,CAAC7L,aADvB;AAEEC,kBAAQ,EAAE4L,MAAI,CAACC;AAFjB,SAFFlL,EAJ8D,CAY9D;AACA;;;AACAK,8BAAQC,OAARD,CACE4K,MADF5K,EAEE;AACEE,cAAI,EAAE,eADR;AAEEC,kBAAQ,EAAE;AAFZ,SAFFH,EAMEyK,kBAAOK,mBANT9K,EAOE4K,MAPF5K;;AAUAnE,6BAAYC,MAAZD,CAAmBM,KAAnBN,yGAA0H8O,GAAG,CAACtL,MAA9H;;AAEA,YAAIuL,MAAI,CAACnM,MAAL,CAAYsM,YAAZ,CAAyBC,UAA7B,EAAyC;AACvCJ,gBAAI,CAACK,SAAL;AADF,eAGK;AACHjL,gCAAQC,OAARD,CACE4K,MADF5K,EAEE;AACEE,gBAAI,EAAE,eADR;AAEEC,oBAAQ,EAAE;AAFZ,WAFFH,EAMEI,0BAAe8K,iBANjBlL,EAOE2K,GAAG,CAACtL,MAPNW;AASD;AAvCH;AAyCD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,4CAAmC;AAAA;;AACjC,WAAKwF,SAAL,CAAegF,EAAf,CAAkBC,kBAAOU,0BAAzB,EAAqD,UAACC,OAAD,EAAa;AAChEpL,8BAAQC,OAARD,CACEqL,MADFrL,EAEE;AACEE,cAAI,EAAE,eADR;AAEEC,kBAAQ,EAAE;AAFZ,SAFFH,EAMEI,0BAAekL,sBANjBtL,EAOE;AACEuL,uBAAa,EAAEH,OAAO,CAACG,aADzB;AAEEC,iBAAO,EAAEH,MAAI,CAAC7H,gBAAL,CAAsBiI,UAAtB,EAFX;AAGEC,mBAAS,EAAEL,MAAI,CAAC7H,gBAAL,CAAsBmI,YAAtB;AAHb,SAPF3L;;AAaAqL,cAAI,CAAC7H,gBAAL,CAAsBoI,gBAAtB,CAAuCR,OAAO,CAACG,aAA/C;AAdF;AAgBD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,uCAA8B;AAAA;;AAC5B,WAAK/F,SAAL,CAAegF,EAAf,CAAkBqB,qBAAUpB,MAAVoB,CAAiBC,+BAAnC,EAAoE,UAACV,OAAD,EAAa;AAC/EpL,8BAAQC,OAARD,CACE+L,MADF/L,EAEE;AACEE,cAAI,EAAE,eADR;AAEEC,kBAAQ,EAAE;AAFZ,SAFFH,EAMEI,0BAAe4L,oBANjBhM,EAOE;AACEoL,iBAAO,EAAPA;AADF,SAPFpL;AADF;AAcA,WAAKwF,SAAL,CAAegF,EAAf,CAAkBqB,qBAAUpB,MAAVoB,CAAiBI,sBAAnC,EAA2D,UAACb,OAAD,EAAa;AACtEW,cAAI,CAACnK,OAAL,CAAasK,wBAAb,CAAsCd,OAAtC;AADF;AAGD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,sCAA6BzO,OAA7B,EAAsC;AACpC,UAAIA,OAAJ,EAAa;AACX,YACEwP,KADF,GAIIxP,OAJJ,CACEwP,KADF;AAAA,YAEEC,UAFF,GAIIzP,OAJJ,CAEEyP,UAFF;AAAA,YAGEhJ,gBAHF,GAIIzG,OAJJ,CAGEyG,gBAHF;;AAMA,YAAI,CAAC+I,KAAL,EAAY;AACVtQ,+BAAYC,MAAZD,CAAmBM,KAAnBN,CAAyB,2EAAzBA,EAAsGsQ,KAAK,IAAI,EAA/GtQ,iDAA2J,KAAKkD,aAAhK;;AAEA,iBAAO,IAAP;AACD;;AAED,YAAMsN,WAAW,GAAG;AAClBtN,uBAAa,EAAE,KAAKA,aADF;AAElBsC,gBAAM,EAAE,KAAKA,MAFK;AAGlB5D,kBAAQ,EAAE,KAAK+D,SAHG;AAIlBF,eAAK,EAAE,KAAKA,KAJM;AAKlBrC,kBAAQ,EAAE,KAAKgD,KAAL,CAAW+D,QAAX,CAAoBsG,QAApB,CAA6B3I,GAA7B,CAAiC,OAAjC;AALQ,SAApB;;AAQA,YAAI,KAAK1E,QAAL,IAAiB,KAAKuG,SAAL,CAAe+G,SAApC,EAA+C;AAC7CF,qBAAW,CAACpN,QAAZoN,GAAuB,KAAKpN,QAA5BoN;AACAA,qBAAW,CAACxB,OAAZwB,GAAsB,KAAKpN,QAAL,IAAiB,KAAKA,QAAL,CAAcE,KAAd,CAAoB,GAApB,EAAyBC,GAAzB,EAAvCiN;AACAA,qBAAW,CAACG,cAAZH,GAA6B,KAAK7G,SAAL,CAAe+G,SAAf,IAA4B,KAAK/G,SAAL,CAAe+G,SAAf,CAAyBE,UAAlFJ;AAxBS,UA2BX;;;AACA,YAAIjJ,gBAAJ,EAAsB;AACpBiJ,qBAAW,CAACK,eAAZL,GAA8BjJ,gBAA9B,SAA8BA,oBAA9B,WAA8BA,GAA9B,MAA8BA,mBAAgB,CAAG,CAAH,CAAhBA,CAAsBsJ,eAApDL;AACAA,qBAAW,CAACM,iBAAZN,GAAgCjJ,gBAAhC,SAAgCA,oBAAhC,WAAgCA,GAAhC,MAAgCA,mBAAgB,CAAG,CAAH,CAAhBA,CAAsBuJ,iBAAtDN;AACAA,qBAAW,CAACO,iBAAZP,GAAgCjJ,gBAAhC,SAAgCA,oBAAhC,WAAgCA,GAAhC,MAAgCA,mBAAgB,CAAG,CAAH,CAAhBA,CAAsBwJ,iBAAtDP;AAHF,eAKK,IAAI,KAAKjJ,gBAAT,EAA2B;AAAA;;AAC9BiJ,qBAAW,CAACK,eAAZL,4BAA8B,KAAKjJ,gBAAnC,0DAA8ByJ,sBAAwB,CAAxB,EAA2BH,eAAzDL;AACAA,qBAAW,CAACM,iBAAZN,6BAAgC,KAAKjJ,gBAArC,2DAAgC0J,uBAAwB,CAAxB,EAA2BH,iBAA3DN;AACAA,qBAAW,CAACO,iBAAZP,6BAAgC,KAAKjJ,gBAArC,2DAAgC2J,uBAAwB,CAAxB,EAA2BH,iBAA3DP;AACD;;AAED,YAAI1P,OAAO,CAACyP,UAAZ,EAAwB;AACtBC,qBAAW,CAACD,UAAZC,GAAyBD,UAAzBC;AACD;;AAED,YAAIjB,OAAO,GAAG,EAAd;AAEA,YAAM4B,oBAAoB,GAAG,KAAKC,qBAAL,CAA2B,OAA3B,CAA7B;;AAEA,YAAID,oBAAJ,EAA0B;AACxBrQ,iBAAO,CAACuQ,eAARvQ,GAA0B;AACxBwQ,2BAAe,EAAEH;AADO,WAA1BrQ;AAGD;;AAED,YAAMyQ,oBAAoB,GAAG,KAAKH,qBAAL,CAA2B,OAA3B,CAA7B;;AAEA,YAAID,oBAAJ,EAA0B;AACxBrQ,iBAAO,CAAC0Q,eAAR1Q,GAA0B;AACxBwQ,2BAAe,EAAEC;AADO,WAA1BzQ;AAGD;;AAED,YAAM2Q,oBAAoB,GAAG,KAAKC,4BAAL,CAAkC,OAAlC,CAA7B;;AAEA,YAAID,oBAAJ,EAA0B;AACxB3Q,iBAAO,CAACuQ,eAARvQ,mCACKA,OAAO,CAACuQ,eADb;AAEEM,2BAAe,EAAEF;AAFnB;AAID;;AAED,YAAMG,oBAAoB,GAAG,KAAKF,4BAAL,CAAkC,OAAlC,CAA7B;;AAEA,YAAIE,oBAAJ,EAA0B;AACxB9Q,iBAAO,CAAC0Q,eAAR1Q,mCACKA,OAAO,CAAC0Q,eADb;AAEEG,2BAAe,EAAEC;AAFnB;AAID;;AAED,YAAMC,wBAAwB,GAAG,KAAKC,gCAAL,EAAjC;;AAEA,YAAID,wBAAJ,EAA8B;AAC5B/Q,iBAAO,CAACiR,SAARjR,mCACKA,OAAO,CAACiR,SADb;AAEEF,oCAAwB,EAAxBA;AAFF;AAID;;AAED,YAAMG,mBAAmB,GAAG,KAAKC,sBAAL,EAA5B;;AAEA,YAAID,mBAAJ,EAAyB;AACvBlR,iBAAO,CAACiR,SAARjR,mCACKA,OAAO,CAACiR,SADb;AAEEC,+BAAmB,EAAnBA;AAFF;AAID;;AAED,YAAME,WAAW,GAAG,KAAKC,cAAL,EAApB;;AAEA,YAAID,WAAJ,EAAiB;AACfpR,iBAAO,CAACiR,SAARjR,mCACKA,OAAO,CAACiR,SADb;AAEEG,uBAAW,EAAXA;AAFF;AAID;;AAED,YAAME,WAAW,GAAG,KAAKA,WAAL,EAApB;;AAEA,YAAIA,WAAJ,EAAiB;AACftR,iBAAO,CAACiR,SAARjR,mCACKA,OAAO,CAACiR,SADb;AAEEK,uBAAW,EAAXA;AAFF;AAID;;AAED,YAAItR,OAAO,CAAC8C,IAAR9C,KAAiBuR,qBAAUC,OAA/B,EAAwC;AACtC/C,iBAAO,GAAGzL,iBAAQyO,gBAARzO,CAAyBhD,OAAO,CAACwP,KAAjCxM,EAAwC0M,WAAxC1M,EAAqDhD,OAArDgD,CAAVyL;AADF,eAGK;AACHA,iBAAO,GAAGzL,iBAAQ0O,WAAR1O,CAAoBhD,OAAO,CAACwP,KAA5BxM,EAAmC0M,WAAnC1M,EAAgDhD,OAAhDgD,CAAVyL;AACD;;AAED,eAAOA,OAAP;AACD;;AAED,aAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,iCAAwBzO,OAAxB,EAAiC;AAC/B,UAAMyO,OAAO,GAAG,KAAKkD,4BAAL,iCACX,oBAAK,KAAK7P,MAAL,CAAY8P,OAAjB,EAA0B,CAAC,YAAD,EAAe,eAAf,CAA1B,CADW,GAEX5R,OAFW,EAAhB;AAKA,aAAO,KAAKsF,KAAL,CAAW+D,QAAX,CAAoBuI,OAApB,CAA4BC,0BAA5B,CAAuDpD,OAAvD,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,yCAAgCzO,OAAhC,EAAyC;AACvC,UAAMyO,OAAO,GAAG,KAAKkD,4BAAL;AACd7O,YAAI,EAAEyO,qBAAUC;AADF,SAEX,oBAAK,KAAK1P,MAAL,CAAY8P,OAAjB,EAA0B,CAAC,YAAD,EAAe,eAAf,CAA1B,CAFW,GAGX5R,OAHW,EAAhB;AAMA,aAAO,KAAKsF,KAAL,CAAW+D,QAAX,CAAoBuI,OAApB,CAA4BC,0BAA5B,CAAuDpD,OAAvD,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,0BAAiB7F,aAAjB,EAAgC;AAC9B,UAAIA,aAAa,KAAKkJ,0BAAeC,YAArC,EAAmD;AACjD1O,8BAAQC,OAARD,CACE,IADFA,EAEE;AACEE,cAAI,EAAE,eADR;AAEEC,kBAAQ,EAAE;AAFZ,SAFFH,EAMEI,0BAAeuO,6BANjB3O;AADF,aAUK,IAAIuF,aAAa,KAAKkJ,0BAAeG,SAAjCrJ,IAA8C,KAAKA,aAAL,KAAuBkJ,0BAAeC,YAAxF,EAAsG;AACzG1O,8BAAQC,OAARD,CACE,IADFA,EAEE;AACEE,cAAI,EAAE,eADR;AAEEC,kBAAQ,EAAE;AAFZ,SAFFH,EAMEI,0BAAeyO,0BANjB7O;AAQD;;AAED,WAAKuF,aAAL,GAAqBA,aAArB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,kCAAyB;AAAA;;AACvB,WAAKC,SAAL,CAAegF,EAAf,CAAkBC,kBAAOqE,sBAAzB,EAAiD,UAAC1D,OAAD,EAAa;AAC5D2D,cAAI,CAACnN,OAAL,CAAaoN,eAAb,CAA6B5D,OAA7B;;AACA2D,cAAI,CAACE,UAAL,CAAgB7D,OAAhB,EAF4D,CAI5D;;;AACA,YAAI2D,MAAI,CAACnK,iBAAL,IAA0BwG,OAAO,CAAC8D,OAAR9D,CAAgB+D,KAAhB/D,KAA0BgE,yBAAcC,MAAdD,CAAqBE,MAA7E,EAAqF;AACnFP,gBAAI,CAACQ,KAAL,GACGvT,IADH,CACQ,YAAM;AAAE+S,kBAAI,CAACnK,iBAAL,GAAyB,KAAzB;AADhB;AAED;AARH;AAUD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,oBAAWwG,OAAX,EAAoB;AAAA;;AAClB,UAAI,KAAK5F,SAAL,CAAegK,IAAnB,EAAyB;AAAA;;AACvB,YAAMC,gBAAgB,uBAAGrE,OAAO,CAAC8D,OAAX,qDAAGQ,iBAAiBC,WAAjB,CAA6BC,IAA7B,CAAkC,UAACC,MAAD;AAAA,iBAAYA,MAAM,CAAC9N,GAAP8N,KAAeC,MAAI,CAAC9K,SAAhC;AAAlC,UAAzB;AACA,YAAM+K,iBAAiB,wBAAG3E,OAAO,CAAC8D,OAAX,sDAAGc,kBAAiBL,WAAjB,CAA6BC,IAA7B,CAAkC,UAACC,MAAD;AAAA,iBAAYA,MAAM,CAAC9N,GAAP8N,KAAeC,MAAI,CAAC5K,UAAhC;AAAlC,UAA1B;AACA,YAAI+K,OAAO,GAAG,KAAd;;AAEA,YAAIR,gBAAJ,EAAsB;AAAA;;AACpB,cAAMS,SAAS,4BAAGT,gBAAgB,CAACU,aAApB,yEAAqCV,gBAAgB,CAACN,KAArE;;AAEA,cAAIe,SAAS,KAAK,KAAKrL,kBAAvB,EAA2C;AACzC,iBAAKA,kBAAL,GAA0BqL,SAA1B;AACAD,mBAAO,GAAG,IAAVA;AACD;AACF;;AAED,YAAIF,iBAAJ,EAAuB;AAAA;;AACrB,cAAMG,UAAS,4BAAGH,iBAAiB,CAACI,aAArB,yEAAsCJ,iBAAiB,CAACZ,KAAvE;;AAEA,cAAIe,UAAS,KAAK,KAAKjL,mBAAvB,EAA4C;AAC1C,iBAAKA,mBAAL,GAA2BiL,UAA3B;AACAD,mBAAO,GAAG,IAAVA;AACD;AACF;;AAED,YAAIA,OAAJ,EAAa;AACXjQ,gCAAQC,OAARD,CACE,IADFA,EAEE;AACEE,gBAAI,EAAE,eADR;AAEEC,oBAAQ,EAAE;AAFZ,WAFFH,EAMEI,0BAAegQ,+BANjBpQ,EAOE;AACEqQ,kBAAM,EAAE;AACNC,oBAAM,EAAE,KAAKzL,kBADP;AAEN0L,wBAAU,EAAEd,gBAAF,SAAEA,oBAAF,WAAEA,GAAF,MAAEA,mBAAgB,CAAEc;AAFxB,aADV;AAKEC,mBAAO,EAAE;AACPF,oBAAM,EAAE,KAAKrL,mBADN;AAEPsL,wBAAU,EAAER,iBAAF,SAAEA,qBAAF,WAAEA,GAAF,MAAEA,oBAAiB,CAAEQ;AAFxB;AALX,WAPFvQ;AAkBD;AACF;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,kCAAyB;AAAA;;AACvB,WAAKwF,SAAL,CAAegF,EAAf,CAAkBC,kBAAOgG,sBAAzB,EAAiD,UAACrF,OAAD,EAAa;AAC5DsF,cAAI,CAAC9O,OAAL,CAAa+O,eAAb,CAA6BvF,OAA7B;AADF;AAGD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,0CAAiC;AAAA;;AAC/B,WAAK5F,SAAL,CAAegF,EAAf,CAAkBC,kBAAOmG,8BAAzB,EAAyD,UAACxF,OAAD,EAAa;AACpEyF,eAAI,CAACjP,OAAL,CAAakP,uBAAb,CAAqC1F,OAArC;AADF;AAGD;AAGD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,sCAA6B;AAAA;;AAC3B,WAAK5F,SAAL,CAAegF,EAAf,CAAkBqB,qBAAUpB,MAAVoB,CAAiBkF,0BAAnC,EACE,iBAAuC;AAAA,YAArC5B,KAAqC,SAArCA,KAAqC;AAAA,YAA9B6B,UAA8B,SAA9BA,UAA8B;AAAA,YAAlBC,YAAkB,SAAlBA,YAAkB;AACrC,YAAI9E,KAAJ;;AAEA,gBAAQgD,KAAR;AACE,eAAK+B,2BAAgBC,SAArB;AACEhF,iBAAK,GAAG/L,0BAAegR,yBAAvBjF;AACA;;AACF,eAAK+E,2BAAgBG,IAArB;AACElF,iBAAK,GAAG/L,0BAAekR,yBAAvBnF;AACA;;AACF,eAAK+E,2BAAgBK,MAArB;AACEpF,iBAAK,GAAG/L,0BAAeoR,wBAAvBrF;AACA;;AACF,eAAK+E,2BAAgBO,OAArB;AACEtF,iBAAK,GAAG/L,0BAAesR,yBAAvBvF;AACA;;AACF;AACEA,iBAAK,GAAG,IAARA;AACA;AAfJ,SAHqC,CAqBrC;;;AACAwF,eAAI,CAAC/L,SAAL,GAAiB;AACfuJ,eAAK,EAAEA,KAAK,KAAK+B,2BAAgBO,OAA1BtC,GAAoC+B,2BAAgBC,SAApDhC,GAAgEA,KADxD;AAEf6B,oBAAU,EAAVA,UAFe;AAGfC,sBAAY,EAAZA;AAHe,SAAjB;;AAMAjR,8BAAQC,OAARD,CACE2R,OADF3R,EAEE;AACEE,cAAI,EAAE,eADR;AAEEC,kBAAQ,EAAE;AAFZ,SAFFH,EAMEmM,KANFnM,EAOE2R,OAAI,CAAC/L,SAPP5F;AA7BJ;AAuCD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,yCAAgC;AAAA,0BAC9B;;;AACA,WAAKwF,SAAL,CAAegF,EAAf,CAAkBC,kBAAOmH,8BAAzB,EAAyD,UAACxG,OAAD,EAAa;AAAA;;AACpE,+BAA6DA,OAAO,CAACyG,OAArE;AAAA,YAAgBC,YAAhB,oBAAOxL,OAAP;AAAA,YAA0CyL,eAA1C,oBAA8BC,UAA9B;AACA,YAAMC,oBAAoB,wBAAG7G,OAAO,CAAC8G,QAAX,sDAAGC,kBAAkB7L,OAA/C;AACA,YAAM8L,uBAAuB,yBAAGhH,OAAO,CAAC8G,QAAX,uDAAGG,mBAAkBL,UAAlD;;AAEA,YACGF,YAAY,CAACQ,aAAbR,MAA+BG,oBAA/B,SAA+BA,wBAA/B,WAA+BA,GAA/B,MAA+BA,uBAAoB,CAAEK,aAArDR,KACCA,YAAY,CAACS,WAAbT,MAA6BG,oBAA7B,SAA6BA,wBAA7B,WAA6BA,GAA7B,MAA6BA,uBAAoB,CAAEM,WAAnDT,CADDA,IAEAC,eAAe,CAACO,aAAhBP,MAAkCK,uBAAlC,SAAkCA,2BAAlC,WAAkCA,GAAlC,MAAkCA,0BAAuB,CAAEE,aAA3DP,CAFAD,IAGCC,eAAe,CAACQ,WAAhBR,MAAgCK,uBAAhC,SAAgCA,2BAAhC,WAAgCA,GAAhC,MAAgCA,0BAAuB,CAAEG,WAAzDR,CAHDD,IAICC,eAAe,CAACS,WAAhBT,MAAgCK,uBAAhC,SAAgCA,2BAAhC,WAAgCA,GAAhC,MAAgCA,0BAAuB,CAAEI,WAAzDT,CALJ,EAME;AACA;AACA;AACA;AACD;;AAED,YAAIU,cAAc,GAAGC,OAAI,CAACpU,WAA1B,CAjBoE,CAmBpE;;AACA,YACEoU,OAAI,CAACC,MAAL,KAAgBb,YAAY,CAACQ,aAA7B,IACAR,YAAY,CAACS,WAAbT,KAA6Bc,wBAAaC,OAF5C,EAGE;AACA;AACAJ,wBAAc,GAAGlU,wBAAauU,mBAA9BL;AALF,UAOA;AAPA,aAQK,IACHC,OAAI,CAACC,MAAL,KAAgBb,YAAY,CAACQ,aAA7B,IACAR,YAAY,CAACS,WAAbT,KAA6Bc,wBAAaC,OAFvC,EAGH;AAAA;;AACA,cAAI,iCAAI,CAAC5V,eAAL,CAAqB8V,UAArB,gFAAiC1O,UAAjC,MAAgD,OAApD,EAA6D;AAC3DqO,mBAAI,CAACM,SAAL,CAAe;AACbC,gCAAkB,EAAE;AADP,aAAf,EAGG/W,KAHH,CAGS,UAACC,KAAD,EAAW;AAChBN,mCAAYC,MAAZD,CAAmBgF,GAAnBhF,CAAuB,wEAAvBA,EAAiGM,KAAjGN;AAJJ;AADF,iBAQK;AACH;AACA4W,0BAAc,GAAGlU,wBAAaC,kBAA9BiU;AACD;AAfE,UAiBL;AACA;AACA;AAnBK,aAoBA,IAAIV,eAAe,CAACQ,WAAhBR,KAAgCa,wBAAaC,OAAjD,EAA0D;AAC7D;AACAJ,wBAAc,GAAGlU,wBAAa2U,uBAA9BT;AAFG,UAIL;AAJK,aAKA,IACH,CAACR,oBAAoB,IAClBH,YAAY,CAACS,WAAbT,KAA6Bc,wBAAaO,QAD5ClB,IAC0DH,YAAY,CAACS,WAAbT,KAA6B,IADxF,MAECM,uBAAuB,IACrBL,eAAe,CAACQ,WAAhBR,KAAgCa,wBAAaO,QAD/Cf,IAC6DL,eAAe,CAACQ,WAAhBR,KAAgC,IAH9F,CADG,EAKH;AACAU,wBAAc,GAAGlU,wBAAamF,QAA9B+O;AACD;;AAED,YAAIA,cAAc,KAAKC,OAAI,CAACpU,WAA5B,EAAyC;AACvC,cAAM8U,cAAc,GAAGV,OAAI,CAACpU,WAA5B,CADuC,CAGvC;;AACAoU,iBAAI,CAACpU,WAAL,GAAmBmU,cAAnB,CAJuC,CAMvC;;AACA,kBAAQW,cAAR;AACE,iBAAK7U,wBAAauU,mBAAlB;AACE9S,oCAAQC,OAARD,CACE0S,OADF1S,EAEE;AACEE,oBAAI,EAAE,gBADR;AAEEC,wBAAQ,EAAE;AAFZ,eAFFH,EAMEI,0BAAeiT,8BANjBrT;;AAQA;;AAEF,iBAAKzB,wBAAaC,kBAAlB;AACEwB,oCAAQC,OAARD,CACE0S,OADF1S,EAEE;AACEE,oBAAI,EAAE,eADR;AAEEC,wBAAQ,EAAE;AAFZ,eAFFH,EAMEI,0BAAekT,6BANjBtT,EAOE;AACEX,sBAAM,EAAEkU,gCAAqBC;AAD/B,eAPFxT;;AAWA;;AAEF,iBAAKzB,wBAAa2U,uBAAlB;AACElT,oCAAQC,OAARD,CACE0S,OADF1S,EAEE;AACEE,oBAAI,EAAE,eADR;AAEEC,wBAAQ,EAAE;AAFZ,eAFFH,EAMEI,0BAAeqT,kCANjBzT;;AAQA;;AAEF,iBAAKzB,wBAAamF,QAAlB;AACE;AACA;;AAEF;AACE;AA1CJ,WAPuC,CAoDvC;;;AACA,kBAAQ+O,cAAR;AACE,iBAAKlU,wBAAauU,mBAAlB;AAAuC;AAAA;;AACrC,oBAAMY,wBAAwB,GAAG,SAA3BA,wBAA2B,GAAM;AACrC1T,wCAAQC,OAARD,CACE0S,OADF1S,EAEE;AACEE,wBAAI,EAAE,gBADR;AAEEC,4BAAQ,EAAE;AAFZ,mBAFFH,EAMEI,0BAAeuT,8BANjB3T,EAOE;AACE4T,4BAAQ,EAAE9B,YAAY,CAACQ;AADzB,mBAPFtS;AADF,kBADqC,CAerC;;;AACA,oBAAI,4BAAC0S,OAAI,CAACzV,eAAL,CAAqBH,cAAtB,mDAAC+W,uBAAqCvW,SAAtC,KAAmD8V,cAAc,KAAK7U,wBAAa2U,uBAAvF,EAAgH;AAC9GQ,0CAAwB;AAD1B,uBAGK;AACHhB,yBAAI,CAACzR,WAAL,CAAiB;AACf3D,6BAAS,EAAE,KADI;AAEfwW,gCAAY,EAAEpB,OAAI,CAACzV,eAAL,CAAqBH,cAArB,CAAoCgX;AAFnC,mBAAjB,EAIGC,OAJH,CAIW,YAAM;AACbL,4CAAwB;AAL5B;AAOD;;AACD;AACD;;AAED,iBAAKnV,wBAAaC,kBAAlB;AACEwB,oCAAQC,OAARD,CACE0S,OADF1S,EAEE;AACEE,oBAAI,EAAE,eADR;AAEEC,wBAAQ,EAAE;AAFZ,eAFFH,EAMEI,0BAAe4T,6BANjBhU;;AAQAL,+BAAQsU,SAARtU,CAAkB;AAACwM,qBAAK,EAAE+H,kBAAUC,yBAAlB;AAA6CC,uBAAO,EAAE1B;AAAtD,eAAlB/S;;AACA;;AAEF,iBAAKpB,wBAAa2U,uBAAlB;AACElT,oCAAQC,OAARD,CACE0S,OADF1S,EAEE;AACEE,oBAAI,EAAE,eADR;AAEEC,wBAAQ,EAAE;AAFZ,eAFFH,EAMEI,0BAAeiU,kCANjBrU,EAOE;AACEwS,2BAAW,EAAET,eAAe,CAACS,WAD/B;AAEEoB,wBAAQ,EAAE7B,eAAe,CAACO;AAF5B,eAPFtS;;AAYAL,+BAAQsU,SAARtU,CAAkB;AAACwM,qBAAK,EAAE+H,kBAAUI,8BAAlB;AAAkDF,uBAAO,EAAE1B;AAA3D,eAAlB/S;;AACA;;AAEF,iBAAKpB,wBAAamF,QAAlB;AACA;AACE;;AAEF;AACE;AAjEJ;;AAoEAgP,iBAAI,CAAC9Q,OAAL,CAAa2S,sBAAb,CAAoCnJ,OAApC;AAzHF,eA2HK,IAAIqH,cAAc,KAAKlU,wBAAauU,mBAApC,EAAyD;AAC5D;AACA;AACA9S,gCAAQC,OAARD,CACE0S,OADF1S,EAEE;AACEE,gBAAI,EAAE,gBADR;AAEEC,oBAAQ,EAAE;AAFZ,WAFFH,EAMEI,0BAAeuT,8BANjB3T,EAOE;AACE4T,oBAAQ,EAAE9B,YAAY,CAACQ;AADzB,WAPFtS;;AAWA0S,iBAAI,CAAC9Q,OAAL,CAAa2S,sBAAb,CAAoCnJ,OAApC;AAdG,eAgBA,IAAIqH,cAAc,KAAKlU,wBAAa2U,uBAApC,EAA6D;AAChE;AACA;AACAlT,gCAAQC,OAARD,CACE0S,OADF1S,EAEE;AACEE,gBAAI,EAAE,eADR;AAEEC,oBAAQ,EAAE;AAFZ,WAFFH,EAMEI,0BAAeiU,kCANjBrU,EAOE;AACEwS,uBAAW,EAAET,eAAe,CAACS,WAD/B;AAEEoB,oBAAQ,EAAE7B,eAAe,CAACO;AAF5B,WAPFtS;;AAYAL,2BAAQsU,SAARtU,CAAkB;AAACwM,iBAAK,EAAE+H,kBAAUI,8BAAlB;AAAkDF,mBAAO,EAAE1B;AAA3D,WAAlB/S;;AACA+S,iBAAI,CAAC9Q,OAAL,CAAa2S,sBAAb,CAAoCnJ,OAApC;AACD;AA1NH;AA4ND;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,iCAAwB;AAAA;;AACtB,WAAK5F,SAAL,CAAegF,EAAf,CAAkBC,kBAAO+J,qBAAzB,EAAgD,UAACpJ,OAAD,EAAa;AAAA;;AAC3DqJ,eAAI,CAAC7S,OAAL,CAAa8S,cAAb,CAA4BtJ,OAA5B;;AACAqJ,eAAI,CAACxV,QAAL,GAAgBmM,OAAhB;AACAqJ,eAAI,CAAC5J,OAAL,uBAAe4J,OAAI,CAACxV,QAApB,qDAAe0V,iBAAexV,KAAf,CAAqB,GAArB,EAA0BC,GAA1B,EAAf;AAHF;AAKD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,6CAAoC;AAAA;;AAClC,WAAKoG,SAAL,CAAegF,EAAf,CAAkBqB,qBAAUpB,MAAVoB,CAAiB+I,cAAnC,EAAmD,UAACxJ,OAAD,EAAa;AAC9D,YAAIA,OAAJ,EAAa;AACXpL,gCAAQC,OAARD,CACE6U,OADF7U,EAEE;AACEE,gBAAI,EAAE,eADR;AAEEC,oBAAQ,EAAE;AAFZ,WAFFH,EAMEI,0BAAewU,cANjB5U,EAOE;AACEoL,mBAAO,EAAPA;AADF,WAPFpL;AAWD;AAbH;AAeA,WAAKwF,SAAL,CAAegF,EAAf,CAAkBqB,qBAAUpB,MAAVoB,CAAiBiJ,gBAAnC,EAAqD,UAAC1J,OAAD,EAAa;AAChE,YAAIA,OAAJ,EAAa;AACXpL,gCAAQC,OAARD,CACE6U,OADF7U,EAEE;AACEE,gBAAI,EAAE,eADR;AAEEC,oBAAQ,EAAE;AAFZ,WAFFH,EAMEI,0BAAe0U,gBANjB9U,EAOE;AACEoL,mBAAO,EAAPA;AADF,WAPFpL;AAWD;AAbH;AAeA,WAAKwF,SAAL,CAAegF,EAAf,CAAkBqB,qBAAUpB,MAAVoB,CAAiBkJ,oBAAnC,EAAyD,UAAC3J,OAAD,EAAa;AACpE,YAAIA,OAAO,IAAIA,OAAO,CAACrP,IAAvB,EAA6B;AAC3B,cAAIiZ,UAAJ;AACA,cAAIC,YAAJ;;AAEA,cAAI7J,OAAO,CAACoE,IAARpE,IAAgB,CAACA,OAAO,CAACoE,IAARpE,CAAa8J,SAAlC,EAA6C;AAC3CF,sBAAU,GAAG,KAAbA;AACAC,wBAAY,GAAG,KAAfA;AAFF,iBAIK;AACHD,sBAAU,GAAGG,cAAYC,WAAZD,CAAwB/J,OAAO,CAACrP,IAARqP,CAAa8J,SAArCC,EAAgD/J,OAAO,CAACrP,IAARqP,CAAanI,MAA7DkS,CAAbH;AACAC,wBAAY,GAAGE,cAAYE,aAAZF,CAA0B/J,OAAO,CAACrP,IAARqP,CAAa8J,SAAvCC,EAAkD/J,OAAO,CAACrP,IAARqP,CAAanI,MAA/DkS,CAAfF;AACD;;AAED,cAAID,UAAU,IAAI,CAACH,OAAI,CAACrR,gBAAL,CAAsBgI,OAAzC,EAAkD;AAChDxL,kCAAQC,OAARD,CACE6U,OADF7U,EAEE;AACEE,kBAAI,EAAE,eADR;AAEEC,sBAAQ,EAAE;AAFZ,aAFFH,EAMEI,0BAAekL,sBANjBtL,EAOE;AACEwL,qBAAO,EAAE,IADX;AAEEE,uBAAS,EAAE,KAFb;AAGEH,2BAAa,EAAEsJ,OAAI,CAACrR,gBAAL,CAAsB8R,gBAAtB;AAHjB,aAPFtV;AAaD;;AACD,cAAIiV,YAAY,IAAI,CAACJ,OAAI,CAACrR,gBAAL,CAAsBkI,SAAvCuJ,IAAoD,CAACD,UAAzD,EAAqE;AACnEhV,kCAAQC,OAARD,CACE6U,OADF7U,EAEE;AACEE,kBAAI,EAAE,eADR;AAEEC,sBAAQ,EAAE;AAFZ,aAFFH,EAMEI,0BAAekL,sBANjBtL,EAOE;AACEwL,qBAAO,EAAE,KADX;AAEEE,uBAAS,EAAE,IAFb;AAGEH,2BAAa,EAAEsJ,OAAI,CAACrR,gBAAL,CAAsB8R,gBAAtB;AAHjB,aAPFtV;AAaD;;AACD6U,iBAAI,CAACrR,gBAAL,CAAsB+R,UAAtB,CAAiCP,UAAU,IAAI,KAA/C;;AACAH,iBAAI,CAACrR,gBAAL,CAAsBgS,YAAtB,CAAmCP,YAAY,IAAI,KAAnD;AACD;AA9CH;AAgDD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,sCAA6B;AAAA;;AAC3B,WAAKzP,SAAL,CAAegF,EAAf,CAAkBqB,qBAAUpB,MAAVoB,CAAiB4J,qBAAnC,EAA0D,UAACrK,OAAD,EAAa;AACrE,YAAIsK,OAAI,CAACpT,KAAT,EAAgB;AACdoT,iBAAI,CAACpT,KAAL,CAAWqT,+BAAX,CAA2CD,OAA3C;;AACA1V,gCAAQC,OAARD,CACE0V,OADF1V,EAEE;AACEE,gBAAI,EAAE,eADR;AAEEC,oBAAQ,EAAE;AAFZ,WAFFH,EAMEI,0BAAewV,8BANjB5V,EAOE;AACEoL,mBAAO,EAAPA;AADF,WAPFpL;AAWD;AAdH;AAgBA,WAAKwF,SAAL,CAAegF,EAAf,CAAkBqB,qBAAUpB,MAAVoB,CAAiBgK,+BAAnC,EAAoE,UAACzK,OAAD,EAAa;AAC/E,YAAIA,OAAJ,EAAa;AAAA;;AACX,cAAIsK,OAAI,CAACpT,KAAT,EAAgB;AACdoT,mBAAI,CAACpT,KAAL,CAAWwT,4BAAX,CAAwC1K,OAAO,CAAC2K,KAAhD,EAAuD3K,OAAO,CAAC4K,aAA/D;AAFS,YAIX;AACA;AACA;;;AACA,cAAI5K,OAAO,CAAC2K,KAAR3K,IAAkB,mBAACsK,OAAI,CAACpT,KAAN,0CAAC2T,cAAYC,OAAZ,EAAD,CAAtB,EAA+C;AAC7ClW,kCAAQC,OAARD,CACE0V,OADF1V,EAEE;AACEE,kBAAI,EAAE,eADR;AAEEC,sBAAQ,EAAE;AAFZ,aAFFH,EAMEoL,OAAO,CAAC2K,KAAR3K,GAAgBhL,0BAAe+V,4BAA/B/K,GAA8DhL,0BAAewV,8BAN/E5V,EAOE;AACEoL,qBAAO,EAAPA;AADF,aAPFpL;AAWD;AACF;AArBH;AAuBA,WAAKwF,SAAL,CAAegF,EAAf,CAAkBqB,qBAAUpB,MAAVoB,CAAiBuK,sBAAnC,EAA2D,UAAChL,OAAD,EAAa;AACtEpL,8BAAQC,OAARD,CACE0V,OADF1V,EAEE;AACEE,cAAI,EAAE,eADR;AAEEC,kBAAQ,EAAE;AAFZ,SAFFH,EAMEI,0BAAeiW,gCANjBrW,EAOE;AACEoL,iBAAO,EAAPA;AADF,SAPFpL;AADF;AAaA,WAAKwF,SAAL,CAAegF,EAAf,CAAkBqB,qBAAUpB,MAAVoB,CAAiByK,qBAAnC,EAA0D,UAAClL,OAAD,EAAa;AACrE,YAAIA,OAAJ,EAAa;AACXpL,gCAAQC,OAARD,CACE0V,OADF1V,EAEE;AACEE,gBAAI,EAAE,eADR;AAEEC,oBAAQ,EAAE;AAFZ,WAFFH,EAMEI,0BAAemW,0BANjBvW,EAOE;AACEoL,mBAAO,EAAPA;AADF,WAPFpL;;AAYAL,2BAAQsU,SAARtU,CAAkB;AAChBwM,iBAAK,EAAE+H,kBAAUsC,aADD;AAEhBpC,mBAAO,EAAEsB;AAFO,WAAlB/V;AAID;AAlBH;AAoBA,WAAK6F,SAAL,CAAegF,EAAf,CAAkBqB,qBAAUpB,MAAVoB,CAAiB4K,mBAAnC,EAAwD,UAACrL,OAAD,EAAa;AACnE,YAAIA,OAAJ,EAAa;AACXpL,gCAAQC,OAARD,CACE0V,OADF1V,EAEE;AACEE,gBAAI,EAAE,eADR;AAEEC,oBAAQ,EAAE;AAFZ,WAFFH,EAMEI,0BAAesW,2BANjB1W,EAOE;AACEoL,mBAAO,EAAPA;AADF,WAPFpL;;AAYAL,2BAAQsU,SAARtU,CAAkB;AAChBwM,iBAAK,EAAE+H,kBAAUyC,YADD;AAEhBvC,mBAAO,EAAEsB;AAFO,WAAlB/V;AAID;AAlBH;AAqBA,WAAK6F,SAAL,CAAegF,EAAf,CAAkBqB,qBAAUpB,MAAVoB,CAAiB+K,gBAAnC,EAAqD,YAAM;AACzDjX,yBAAQC,oBAARD,CACEhB,8BAAmBkY,sBADrBlX,EAEE;AACEb,wBAAc,EAAE4W,OAAI,CAAC3W,aADvB;AAEEC,kBAAQ,EAAE0W,OAAI,CAAC7K;AAFjB,SAFFlL;;AAOA+V,eAAI,CAACzK,SAAL;AARF,SA9F2B,CAyG3B;AACA;AACA;;AACA,WAAKzF,SAAL,CAAegF,EAAf,CAAkBqB,qBAAUpB,MAAVoB,CAAiBiL,mBAAnC,EAAwD,UAACxG,MAAD,EAAY;AAClE,YAAIoF,OAAI,CAACtQ,aAAT,EAAwB;AAAA;;AACtBsQ,iBAAI,CAACtQ,aAAL,CAAmB2R,iBAAnB,CAAqC;AACnCC,kBAAM,EAAE1G,MAD2B;AAEnC2G,oBAAQ,EAAE;AACR;AACA7Z,uBAAS,EAAE,iCAAI,CAACH,eAAL,CAAqBH,cAArB,gFAAqCM,SAArC,KAAkD,oBAACsY,OAAI,CAACpT,KAAN,2CAAC4U,eAAYhB,OAAZ,EAAD,CAFrD;AAGR7Y,uBAAS,EAAE,kCAAI,CAACJ,eAAL,CAAqBH,cAArB,kFAAqCO,SAArC,KAAkD,mBAACqY,OAAI,CAAClY,KAAN,0CAAC2Z,cAAYjB,OAAZ,EAAD,CAHrD;AAIR5Y,uBAAS,4BAAEoY,OAAI,CAACzY,eAAL,CAAqBH,cAAvB,2DAAEsa,uBAAqC9Z,SAJxC;AAKR+Z,0BAAY,4BAAE3B,OAAI,CAACzY,eAAL,CAAqBH,cAAvB,2DAAEwa,uBAAqCD,YAL3C;AAMRE,0BAAY,4BAAE7B,OAAI,CAACzY,eAAL,CAAqBH,cAAvB,2DAAE0a,uBAAqCD,YAN3C;AAORzD,0BAAY,4BAAE4B,OAAI,CAACzY,eAAL,CAAqBH,cAAvB,2DAAE2a,uBAAqC3D;AAP3C;AAFyB,WAArC;AAYD;AAdH;AAgBD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,yCAAgC;AAAA;;AAC9B,WAAKtO,SAAL,CAAegF,EAAf,CAAkBC,kBAAOiN,eAAzB,EAA0C,UAACtM,OAAD,EAAa;AACrDuM,eAAI,CAACpV,yBAAL,CAA+BqV,MAA/B,CAAsCxM,OAAtC;;AAEA,YAAIA,OAAO,CAACyM,cAAZ,EAA4B;AAC1BF,iBAAI,CAACG,KAAL,CAAW;AAACzY,kBAAM,EAAE+L,OAAO,CAAC/L;AAAjB,WAAX,EAAqCrD,IAArC,CAA0C,YAAM;AAC9CH,iCAAYC,MAAZD,CAAmBE,IAAnBF,CAAwB,+FAAxBA;AADF,aAEGK,KAFH,CAES,UAACC,KAAD,EAAW;AAClBN,iCAAYC,MAAZD,CAAmBM,KAAnBN,uIAAwJ8b,OAAI,CAACvD,OAA7J,sBAAgLjY,KAAhL;AAHF;AAKD;AATH;AAWA,WAAKqJ,SAAL,CAAegF,EAAf,CAAkBC,kBAAOsN,eAAzB,EAA0C,UAAC3M,OAAD,EAAa;AACrD;AAEA;AACA,YAAIuM,OAAI,CAACK,aAAT,EAAwB;AACtB,cAAIL,OAAI,CAAC1a,eAAL,CAAqB8V,UAAzB,EAAqC;AACnC4E,mBAAI,CAAC1a,eAAL,CAAqB8V,UAArB,CAAgCkF,OAAhC,GAA0C,IAA1C;;AACAN,mBAAI,CAAC1a,eAAL,CAAqB8V,UAArB,CAAgCmF,IAAhC;AACD;AARkD,UAUrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,YAAI9M,OAAO,CAAC+M,WAAZ,EAAyB;AACvB;AAEAR,iBAAI,CAACG,KAAL,CAAW;AAACzY,kBAAM,EAAE+L,OAAO,CAAC/L;AAAjB,WAAX,EAAqCrD,IAArC,CAA0C,YAAM;AAC9CH,iCAAYC,MAAZD,CAAmB0B,IAAnB1B,CAAwB,iKAAxBA;AADF,aAEGK,KAFH,CAES,UAACC,KAAD,EAAW;AAClBN,iCAAYC,MAAZD,CAAmBM,KAAnBN,uIAAwJ8b,OAAI,CAACvD,OAA7J,sBAAgLjY,KAAhL;AAHF;AAHF,eASK;AACHN,+BAAYC,MAAZD,CAAmBE,IAAnBF,CAAwB,wEAAxBA,EAAkGuP,OAAO,CAAC/L,MAA1GxD;;AAEAsZ,wBAAYiD,OAAZjD,CAAoBwC,OAApBxC;;AACAnV,gCAAQC,OAARD,CACE2X,OADF3X,EAEE;AACEE,gBAAI,EAAE,eADR;AAEEC,oBAAQ,EAAE;AAFZ,WAFFH,EAMEyK,kBAAOsN,eANT/X,EAOE;AACEX,kBAAM,EAAE+L,OAAO,CAAC/L,MADlB;AAEEgZ,qBAAS,EAAEV,OAAI,CAACzW;AAFlB,WAPFlB;AAYD;AA3CH;AA6CD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,6BAAoBsY,MAApB,EAA4B;AAAA,0BAC1B;AACA;AACA;;;AACA,UAAIA,MAAM,IAAI,mBAAYA,MAAZ,EAAoB9X,MAAlC,EAA0C;AACxC,2BAAY8X,MAAZ,EAAoBC,OAApB,CAA4B,UAACC,GAAD,EAAS;AACnCC,iBAAI,CAACD,GAAD,CAAJ,GAAYF,MAAM,CAACE,GAAD,CAAlB;AADF;AAGD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,gBAAOE,OAAP,EAAsC;AAAA,UAAtBC,aAAsB,uEAAN,IAAM;AACpC,aAAO,KAAK/W,OAAL,CAAagX,SAAb,CAAuBF,OAAvB,EAAgCC,aAAhC,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,2BAAkBD,OAAlB,EAA2B;AACzB,aAAO,KAAK9W,OAAL,CAAaiX,iBAAb,CAA+BH,OAA/B,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,eAAMI,SAAN,EAAiB;AACf,aAAO,KAAKlX,OAAL,CAAamX,YAAb,CAA0BD,SAA1B,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,gBAAOlF,QAAP,EAAiB;AACf,aAAO,KAAKhS,OAAL,CAAaoX,YAAb,CAA0BpF,QAA1B,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,cAAKA,QAAL,EAA4B;AAAA,UAAbqF,KAAa,uEAAN,IAAM;;AAC1B,aAAO,KAAKrX,OAAL,CAAasX,UAAb,CAAwBtF,QAAxB,EAAkCqF,KAAlC,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,kBAASrF,QAAT,EAAqC;AAAA,UAAlBsB,SAAkB,uEAAN,IAAM;AACnC,aAAO,KAAKtT,OAAL,CAAauX,oBAAb,CAAkCvF,QAAlC,EAA4CsB,SAA5C,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,sBAAa;AACX,aAAO,KAAKtT,OAAZ;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,4BAAmB;AACjB,UAAI,KAAKwX,WAAT,EAAsB;AACpBC,qBAAa,CAAC,KAAKD,WAAN,CAAbC;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,oCAA2B;AAAA;;AACzB,UAAMC,gBAAgB,GAAG,IAAIC,iBAAJ,CAAiB;AAAC9a,cAAM,EAAE,KAAKA;AAAd,OAAjB,CAAzB;AAEA,UAAMiE,KAAK,GAAG,KAAK8W,QAAL,CAAcF,gBAAgB,CAACG,UAAjBH,EAAd,EAA6C,IAA7C,CAAd;AAEA,WAAKnU,mBAAL,GAA2BmU,gBAA3B;AAEA,WAAKnU,mBAAL,CAAyBuU,QAAzB,CAAkChX,KAAlC;AAEA,WAAK0W,WAAL,GAAmBO,WAAW,CAAC;AAAA,eAAMC,OAAI,CAACC,cAAL,EAAN;AAAD,SAA8B,KAAKpb,MAAL,CAAY8P,OAAZ,CAAoBuL,kBAAlD,CAA9B;AAEA,aAAOR,gBAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;;WACE,0BAAiB;AAAA;;AACf,UAAI,CAAC,KAAKhU,YAAV,EAAwB;AACtB,aAAKA,YAAL,GAAoB,IAAIyU,qBAAJ,EAApB;AACD;;AAED7L,2BAAU8L,eAAV9L,CAA0BqK,OAA1BrK,CAAkC,UAACsK,GAAD,EAAS;AACzC,YAAIyB,OAAI,CAAC9U,mBAAL,IAA4B8U,OAAI,CAAC9U,mBAAL,CAAyBzC,KAAzD,EAAgE;AAC9D,cAAIwX,YAAJ;;AAEA,cAAI1B,GAAG,CAAC2B,WAAJ3B,GAAkB4B,QAAlB5B,CAA2B6B,iBAAMC,MAAjC9B,CAAJ,EAA8C;AAC5C0B,wBAAY,GAAGD,OAAI,CAAC9U,mBAAL,CAAyBzC,KAAzB,CAA+B6X,SAA/B,CAAyC/B,GAAzC,CAAf0B;AADF,iBAGK,IAAI1B,GAAG,CAAC2B,WAAJ3B,GAAkB4B,QAAlB5B,CAA2B6B,iBAAMG,QAAjChC,CAAJ,EAAgD;AACnD0B,wBAAY,GAAGD,OAAI,CAAC9U,mBAAL,CAAyBzC,KAAzB,CAA+B+X,WAA/B,CAA2CjC,GAA3C,CAAf0B;AACD;;AACD,cAAIQ,GAAJ;;AAEA,cAAIR,YAAJ,EAAkB;AAChBQ,eAAG,GAAGR,YAAY,CAACS,MAAbT,EAANQ;AACD;;AACD,cAAIA,GAAJ,EAAS;AACP,gBAAME,QAAQ,GAAGF,GAAG,CAACG,QAAJH,CAAaT,OAAI,CAACxb,MAAL,CAAY8P,OAAZ,CAAoBuL,kBAApB,GAAyC,IAAtDY,CAAjB,CADO,CACuE;;AAE9ET,mBAAI,CAAC3U,YAAL,CAAkBwV,OAAlB,CAA0BtC,GAA1B,EAA+BoC,QAA/B;AACD;AACF;AApBH;AAsBD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,kBAASje,OAAT,EAAkBoe,QAAlB,EAA4B;AAC1B,UAAI,CAAC,KAAKrY,KAAV,EAAiB;AACf,eAAO,KAAKsY,WAAL,CAAiBre,OAAjB,CAAP;AACD;;AACD,UAAIoe,QAAJ,EAAc;AACZ,YAAI,KAAKrY,KAAT,EAAgB;AACd7G,+BAAYC,MAAZD,CAAmBgF,GAAnBhF,CAAuB,sHAAvBA;AACD;;AAED,eAAO,KAAKmf,WAAL,CAAiBre,OAAjB,CAAP;AACD;;AAED,aAAO,KAAK+F,KAAZ;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,uBAA0B;AAAA,UAAd/F,OAAc,uEAAJ,EAAI;;AACxBse,qBAAUC,eAAVD,CAA0Bte,OAA1Bse,EAAmCZ,iBAAMc,MAAzCF,EAAiD,IAAjDA;;AAEAte,aAAO,CAAC8B,MAAR9B,GAAiB0d,iBAAMc,MAAvBxe;AAEA,WAAK+F,KAAL,GAAa,IAAI0Y,eAAJ,CAAgB,KAAK1e,KAArB,EAA4B,KAAKC,OAAjC,EAA0CA,OAA1C,CAAb;AAEA,aAAO,KAAK+F,KAAZ;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,qBAAY;AACV,UAAI,KAAKA,KAAT,EAAgB;AACd,aAAKA,KAAL,CAAW2Y,cAAX;AACA,aAAK3Y,KAAL,CAAW4Y,gBAAX;AACA,aAAK5Y,KAAL,GAAa,IAAb;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,4BAAmB;AACjB,aAAO,CAAC,CAAC,KAAKJ,KAAd;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,wBAAe;AACb,aAAO,KAAKA,KAAL,IAAc,KAAKA,KAAL,CAAW4T,OAAX,EAArB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,uBAAc;AACZ,aAAO,KAAK5T,KAAL,IAAc,KAAKA,KAAL,CAAWiZ,MAAX,EAArB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,4BAAmB;AACjB,aAAO,CAAC,CAAC,KAAK/d,KAAd;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,wBAAe;AACb,aAAO,KAAKA,KAAL,IAAc,KAAKA,KAAL,CAAW0Y,OAAX,EAArB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,uBAAc;AACZ,aAAO,KAAK1Y,KAAL,IAAc,KAAKA,KAAL,CAAW+d,MAAX,EAArB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,0BAAiB5Z,WAAjB,EAA8B;AAC5B,UAAM6Z,gBAAgB,GAAG7Z,WAAH,SAAGA,eAAH,WAAGA,GAAH,MAAGA,cAAW,CAAEkG,IAAtC,CAD4B,CAG5B;;AACA,UAAI2T,gBAAgB,IAAI,EAAE7Z,WAAW,CAAC8Z,MAAZ9Z,IAAsBA,WAAW,CAAC8Z,MAAZ9Z,CAAmBnB,MAAnBmB,GAA4B,CAApD,CAAxB,EAAgF;AAC9E,aAAKiB,eAAL,GAAuB4Y,gBAAgB,CAAC5Y,eAAjB4Y,IAAoC,KAAK5Y,eAAhE;AACA,aAAK3D,QAAL,GAAgBuc,gBAAgB,CAACvc,QAAjBuc,IAA6B,KAAKvc,QAAlD;AACA,aAAKyc,SAAL,CAAe,KAAKjd,MAAL,CAAYqB,YAAZ,CAAyB6b,qBAAzB,GAAiDH,gBAAgB,CAACI,MAAlE,GAA2EJ,gBAAgB,CAACK,aAAjBL,IAAkC,KAAK3Y,MAAjI;;AACA,YAAI,KAAKpE,MAAL,CAAYqB,YAAZ,CAAyB6b,qBAA7B,EAAoD;AAClD,eAAKtT,aAAL,GAAqBmT,gBAAgB,CAACnT,aAAtC;AACA,eAAKyT,cAAL,GAAsBN,gBAAgB,CAACM,cAAvC;AACD;;AACD,aAAK/Y,KAAL,GAAayY,gBAAgB,CAACzY,KAAjByY,IAA0BA,gBAAgB,CAACxY,MAA3CwY,IAAqD,KAAKzY,KAAvE;AACA,aAAKgZ,eAAL,GAAuBP,gBAAgB,CAACO,eAAxC;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,oBAAWja,KAAX,EAAkB;AAChB,UAAIA,KAAJ,EAAW;AACT,aAAK7C,QAAL,GAAgB6C,KAAK,CAACC,GAAtB,CADS,CAET;;AACA,aAAKia,QAAL,CAAcla,KAAd,EAHS,CAKT;AACA;;AACA,YAAIA,KAAK,CAACma,YAANna,IAAsBA,KAAK,CAAC0N,IAAhC,EAAsC;AACpC,eAAK1M,OAAL,GAAeqS,cAAY+G,eAAZ/G,CAA4BrT,KAAK,CAACma,YAAlC9G,EAAgDrT,KAAK,CAAC0N,IAAtD2F,CAAf;AARO,UAWT;;;AACA,YAAI,CAAC,KAAKtS,MAAN,IAAgB,KAAKC,OAArB,IAAgC,KAAKrD,IAAL,KAAc0c,iBAAlD,EAA0D;AACxD,eAAKT,SAAL,CAAe,KAAK5Y,OAAL,CAAasZ,MAAb,CAAoBR,MAApB,IAA8B,KAAK9Y,OAAL,CAAasZ,MAAb,CAAoBlb,EAAjE;AACD;AACF;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,mBAAU2B,MAAV,EAAkB;AAChB;AACA,WAAKA,MAAL,GAAcA,MAAd;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,oBAAWwZ,GAAX,EAAgB;AACd,UAAIA,GAAG,IAAI,CAAX,EAAc;AACZ,aAAK5a,OAAL,GAAe4a,GAAf;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,kBAASva,KAAT,EAAgB;AACd,UAAMwa,QAAQ,GAAGxa,KAAK,CAACA,KAANA,IAAeA,KAAhC,CADc,CAGd;AACA;;AACA,WAAKsB,gBAAL,GAAwBtB,KAAK,CAACsB,gBAA9B;AACA,WAAKnE,QAAL,GAAgB6C,KAAK,CAAC7C,QAAN6C,IAAkBA,KAAK,CAACC,GAAxC;AACA,WAAK8I,OAAL,GAAe/I,KAAK,CAAC+I,OAArB;AACA,WAAK8H,MAAL,GAAc7Q,KAAK,CAAC6Q,MAApB;AACA,WAAK4J,OAAL,GAAeza,KAAK,CAACya,OAArB;AACA,WAAKvZ,MAAL,GAAcsZ,QAAQ,CAACE,IAATF,GAAgBA,QAAQ,CAACE,IAATF,CAAcpb,EAA9Bob,GAAmC,KAAKtZ,MAAtD;AACA,WAAKwC,SAAL,CAAeiX,YAAf,CAA4BH,QAA5B;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,yBAAgBI,EAAhB,EAAoB;AAAA;;AAClB,UAAI,CAACA,EAAL,EAAS;AACP;AAFgB,QAIlB;;;AACAA,QAAE,CAACC,OAAHD,GAAa,UAACvQ,KAAD,EAAW;AACtB;AACA;AACA;AACA;AACA;AACAtQ,6BAAYC,MAAZD,CAAmBgF,GAAnBhF,wFAAuGsQ,KAAvG;;AAEA,YAAMyQ,QAAQ,GAAG;AACfC,qBAAW,EAAE,GADE;AAEfC,qBAAW,EAAE,GAFE;AAGfC,qBAAW,EAAE;AAHE,SAAjB;AAKA,YAAI7I,SAAS,GAAG,IAAhB;AACA,YAAM8I,UAAU,GAAG7Q,KAAK,CAAChI,KAAzB;AACA,YAAI8Y,YAAY,GAAG,IAAnB,CAfsB,CAkBtB;AACA;;AACA,YAAI9Q,KAAK,CAAC+Q,WAAN/Q,IAAqBA,KAAK,CAAC+Q,WAAN/Q,CAAkBgR,GAA3C,EAAgD;AAC9CF,sBAAY,GAAG9Q,KAAK,CAAC+Q,WAAN/Q,CAAkBgR,GAAjCF;AADF,eAGK;AACH,8BAA+D9Q,KAAK,CAACiR,MAArE;AAAA,cAAOC,gBAAP,iBAAOA,gBAAP;AAAA,cAAyBC,gBAAzB,iBAAyBA,gBAAzB;AAAA,cAA2C1Z,gBAA3C,iBAA2CA,gBAA3C,CADG,CAGH;;AACA,cAAIoZ,UAAU,CAAC9b,EAAX8b,KAAkBK,gBAAgB,CAACE,QAAjBF,CAA0BlZ,KAA1BkZ,CAAgCnc,EAAtD,EAA0D;AACxD+b,wBAAY,GAAG,GAAfA;AADF,iBAIA,IAAID,UAAU,CAAC9b,EAAX8b,KAAkBM,gBAAgB,CAACC,QAAjBD,CAA0BnZ,KAA1BmZ,CAAgCpc,EAAtD,EAA0D;AACxD+b,wBAAY,GAAG,GAAfA;AADF,iBAIA,IAAID,UAAU,CAAC9b,EAAX8b,KAAkBpZ,gBAAgB,CAAC2Z,QAAjB3Z,CAA0BO,KAA1BP,CAAgC1C,EAAtD,EAA0D;AACxD+b,wBAAY,GAAG,GAAfA;AADF,iBAGK;AACHA,wBAAY,GAAG,IAAfA;;AACAtd,6BAAQC,oBAARD,CACEhB,8BAAmB6e,kBADrB7d,EAEE;AACEb,4BAAc,EAAE2e,OAAI,CAAC1e,aADvB;AAEEC,sBAAQ,EAAEye,OAAI,CAACxe,QAAL,CAAcE,KAAd,CAAoB,GAApB,EAAyBC,GAAzB;AAFZ,aAFFO;AAOD;AACF;;AAGD,gBAAQsd,YAAR;AACE,eAAKL,QAAQ,CAACC,WAAd;AACE3I,qBAAS,GAAGwJ,uBAAYC,YAAxBzJ;;AACAuJ,mBAAI,CAACxgB,eAAL,CAAqB2gB,mBAArB,CAAyCZ,UAAzC;;AACA;;AACF,eAAKJ,QAAQ,CAACE,WAAd;AACE5I,qBAAS,GAAGwJ,uBAAYG,YAAxB3J;;AACAuJ,mBAAI,CAACxgB,eAAL,CAAqB6gB,mBAArB,CAAyCd,UAAzC;;AACA;;AACF,eAAKJ,QAAQ,CAACG,WAAd;AACE,gBAAI5Q,KAAK,CAAChI,KAAV,EAAiB;AACf+P,uBAAS,GAAGwJ,uBAAYK,YAAxB7J;;AACAuJ,qBAAI,CAACxgB,eAAL,CAAqB+gB,cAArB,CAAoChB,UAApC;AACD;;AACD;;AACF;AAAS;AACPnhB,mCAAYC,MAAZD,CAAmBgF,GAAnBhF,CAAuB,8DAAvBA;AACD;AAjBH,SAnDsB,CAuEtB;;;AAEA4hB,eAAI,CAACrY,aAAL,CAAmB6Y,aAAnB,CAAiCR,OAAI,CAACxgB,eAAL,CAAqB4G,cAAtD;;AAEA,YAAIqQ,SAAS,IAAI8I,UAAjB,EAA6B;AAC3Bhd,gCAAQC,OAARD,CACEyd,OADFzd,EAEE;AACEE,gBAAI,EAAE,eADR;AAEEC,oBAAQ,EAAE;AAFZ,WAFFH,EAMEI,0BAAe8d,WANjBle,EAOE;AACEP,gBAAI,EAAEyU,SADR;AAEEiK,kBAAM,EAAEC,eAAUC,iBAAVD,CAA4B,CAACpB,UAAD,CAA5BoB;AAFV,WAPFpe;AAYD;AAxFH;AA0FD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,sBAAsE;AAAA,UAA3DrD,OAA2D,uEAAjD;AAACuD,YAAI,EAAE,eAAP;AAAwBC,gBAAQ,EAAE;AAAlC,OAAiD;;AACpEH,4BAAQC,OAARD,CACE,IADFA,EAEErD,OAFFqD,EAGEyK,kBAAOK,mBAHT9K,EAIE,IAJFA;AAMD;AAGD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,6BAAoB;AAClBnE,2BAAYC,MAAZD,CAAmB0B,IAAnB1B,CAAwB,gHAAxBA;;AACA,WAAKoB,eAAL,CAAqBqhB,gBAArB;AACD;AAED;AACF;AACA;AACA;;;;WACE,6BAAoB;AAClB,WAAKrhB,eAAL,CAAqBshB,iBAArB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,6BAAoB;AAClB1iB,2BAAYC,MAAZD,CAAmB0B,IAAnB1B,CAAwB,gHAAxBA;;AACA,WAAK2iB,iBAAL;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,6BAAoB;AAAA;;AAClB,kCAII,KAAKvhB,eAJT;AAAA,UACEwhB,gBADF,yBACEA,gBADF;AAAA,UAEEC,gBAFF,yBAEEA,gBAFF;AAAA,UAGEC,WAHF,yBAGEA,WAHF;AAMA;AACJ;AACA;AACA;AACA;AACA;;AACI,UAAMC,wBAAwB,GAAG,SAA3BA,wBAA2B,CAACC,SAAD,EAAe;AAC9C7e,8BAAQC,OAARD,CACE8e,OADF9e,EAEE;AACEE,cAAI,EAAE,eADR;AAEEC,kBAAQ,EAAE;AAFZ,SAFFH,EAMEI,0BAAe2e,aANjB/e,EAOE;AACEP,cAAI,EAAEof;AADR,SAPF7e;AADF;AAcA;AACJ;AACA;AACA;AACA;AACA;AACA;AACI;;;AACA,UAAMgf,SAAS,GAAG,SAAZA,SAAY,CAAC7a,KAAD,EAAQ1E,IAAR,EAAiB;AACjC,eAAO3B,eAAMmhB,UAANnhB,CAAiBqG,KAAjBrG,EACJ9B,IADI8B,CACC,YAAM;AACV,cAAMohB,cAAc,GAAG/a,KAAK,IAAIA,KAAK,CAACE,UAANF,KAAqBgb,gBAArD;AACA,cAAMC,iBAAiB,GAAGjb,KAAK,IAAI,CAAC+a,cAApC;;AAEA,cAAIA,cAAJ,EAAoB;AAClBN,oCAAwB,CAACnf,IAAD,CAAxBmf;AADF,iBAGK,IAAIQ,iBAAJ,EAAuB;AAC1BvjB,iCAAYC,MAAZD,CAAmB0B,IAAnB1B,qFAAqGsI,KAAK,CAACE,UAA3G,kBAA6H5E,IAA7H;AACD;AAVE,UAAP;AADF;;AAeA,aAAOzB,iBAAQqhB,GAAR,CAAY,CACjBL,SAAS,CAACP,gBAAD,EAAmBf,uBAAYC,YAA/B,CADQ,EAEjBqB,SAAS,CAACN,gBAAD,EAAmBhB,uBAAYG,YAA/B,CAFQ,EAGjBmB,SAAS,CAACL,WAAD,EAAcjB,uBAAYK,YAA1B,CAHQ,CAAZ,CAAP;AAKD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,oCAA2B;AACzB/d,4BAAQC,OAARD,CACE,IADFA,EAEE;AACEE,YAAI,EAAE,eADR;AAEEC,gBAAQ,EAAE;AAFZ,OAFFH,EAMEI,0BAAe8d,WANjBle,EAOE;AACEP,YAAI,EAAEie,uBAAY4B,KADpB;AAEEnB,cAAM,EAAEC,eAAUC,iBAAVD,CAA4B,CAAC,KAAKnhB,eAAL,CAAqBsiB,UAAtB,EAAkC,KAAKtiB,eAAL,CAAqBuiB,UAAvD,CAA5BpB;AAFV,OAPFpe;AAYD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,4BAAmBuf,UAAnB,EAAiD;AAAA,UAAlBE,SAAkB,uEAAN,IAAM;;AAC/C,UAAIF,UAAJ,EAAgB;AACd,YAAMG,QAAQ,GAAGH,UAAU,CAACI,WAAXJ,EAAjB;AAEA,aAAKtiB,eAAL,CAAqB2iB,gBAArB,CAAsC,OAAtC,EAA+C;AAC7CC,0BAAgB,EAAEH,QAAQ,CAACG,gBADkB;AAE7CC,0BAAgB,EAAEJ,QAAQ,CAACI;AAFkB,SAA/C;;AAKAjkB,6BAAYC,MAAZD,CAAmBgF,GAAnBhF,CAAuB,sDAAvBA,EAA+E,wBAAe,KAAKoB,eAAL,CAAqB8iB,aAArB,CAAmCzd,KAAlD,CAA/EzG;;AACA,aAAKoB,eAAL,CAAqB+iB,kBAArB,CAAwCT,UAAxC;AACA,YAAI,KAAKjd,KAAT,EAAgB,KAAKA,KAAL,CAAW2d,uBAAX,CAAmC,IAAnC;AACjB;;AAED,UAAIR,SAAJ,EAAe;AACb,aAAKS,wBAAL;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,4BAAmBV,UAAnB,EAAiD;AAAA,UAAlBC,SAAkB,uEAAN,IAAM;;AAC/C,UAAID,UAAJ,EAAgB;AACd,oCAEIA,UAAU,CAACG,WAAXH,EAFJ;AAAA,YACEW,WADF,yBACEA,WADF;AAAA,YACeC,SADf,yBACeA,SADf;AAAA,YAC0BC,MAD1B,yBAC0BA,MAD1B;AAAA,YACkCC,KADlC,yBACkCA,KADlC;AAAA,YACyC7iB,QADzC,yBACyCA,QADzC;;AAIA,aAAKR,eAAL,CAAqBsjB,kBAArB,CAAwCf,UAAxC;AACA,YAAI,KAAKhiB,KAAT,EAAgB,KAAKA,KAAL,CAAWyiB,uBAAX,CAAmC,IAAnC;AAEhB,aAAKhjB,eAAL,CAAqB2iB,gBAArB,CAAsC,OAAtC,EAA+C;AAC7CO,qBAAW,EAAXA,WAD6C;AAChCC,mBAAS,EAATA,SADgC;AACrBC,gBAAM,EAANA,MADqB;AACbC,eAAK,EAALA;AADa,SAA/C,EARc,CAWd;;AACA,YAAI7iB,QAAJ,EAAc;AACZ,eAAKR,eAAL,CAAqBY,gBAArB,CAAsCJ,QAAtC;AACD;;AACD5B,6BAAYC,MAAZD,CAAmBgF,GAAnBhF,CAAuB,sDAAvBA,EAA+E,wBAAe,KAAKoB,eAAL,CAAqB8iB,aAArB,CAAmCviB,KAAlD,CAA/E3B;AACD;;AAED,UAAI4jB,SAAJ,EAAe;AACb,aAAKS,wBAAL;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,wBAAeM,WAAf,EAA4B;AAC1B,UAAIA,WAAJ,EAAiB;AACf,oCAAiCrL,cAAYsL,QAAZtL,CAAqBqL,WAArBrL,CAAjC;AAAA,YAAOoK,UAAP,yBAAOA,UAAP;AAAA,YAAmBC,UAAnB,yBAAmBA,UAAnB;;AAEA,aAAKQ,kBAAL,CAAwBT,UAAxB,EAAoC,KAApC;AACA,aAAKgB,kBAAL,CAAwBf,UAAxB,EAAoC,KAApC;AAEA,aAAKU,wBAAL;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,4BAAmBQ,UAAnB,EAA+B;AAAA;;AAC7B,UAAIhB,QAAQ,GAAG,IAAf;;AAEA,UAAIgB,UAAJ,EAAgB;AACd,aAAKzjB,eAAL,CAAqB0jB,kBAArB,CAAwCxL,cAAYsL,QAAZtL,CAAqBuL,UAArBvL,EAAiCqK,UAAzE;AACA,YAAMoB,aAAa,GAAG,KAAK3jB,eAAL,CAAqB8V,UAA3C;;AAEA,YAAI6N,aAAJ,EAAmB;AACjBlB,kBAAQ,GAAGkB,aAAa,CAACjB,WAAdiB,EAAXlB;AACA,eAAKziB,eAAL,CAAqB2iB,gBAArB,CAAsC,QAAtC,EAAgD;AAC9CO,uBAAW,EAAET,QAAQ,CAACS,WADwB;AAE9CC,qBAAS,EAAEV,QAAQ,CAACU,SAF0B;AAG9CC,kBAAM,EAAEX,QAAQ,CAACW,MAH6B;AAI9CC,iBAAK,EAAEZ,QAAQ,CAACY,KAJ8B;AAK9CO,0BAAc,EAAEnB,QAAQ,CAACmB,cALqB;AAM9CC,kBAAM,EAAEpB,QAAQ,CAACoB;AAN6B,WAAhD;;AAQAjlB,+BAAYC,MAAZD,CAAmBgF,GAAnBhF,CAAuB,uDAAvBA,EAAgF,wBAAe,KAAKoB,eAAL,CAAqB8iB,aAArB,CAAmCgB,MAAlD,CAAhFllB;AACD;;AAED+kB,qBAAa,CAAC3I,OAAd2I,GAAwB;AAAA,iBAAMI,OAAI,CAACC,qBAAL,CAA2BP,UAA3B,CAAN;AAAxB;;AAEA1gB,8BAAQC,OAARD,CACE,IADFA,EAEE;AACEE,cAAI,EAAE,eADR;AAEEC,kBAAQ,EAAE;AAFZ,SAFFH,EAMEI,0BAAe8d,WANjBle,EAOE;AACEP,cAAI,EAAEie,uBAAYwD,WADpB;AAEE/C,gBAAM,EAAEuC;AAFV,SAPF1gB;AAYD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,4BAAmB;AAAA;;AACjB,mCAAiC,KAAK/C,eAAtC;AAAA,UAAOsiB,UAAP,0BAAOA,UAAP;AAAA,UAAmBC,UAAnB,0BAAmBA,UAAnB;AAEA,aAAO1hB,eAAMmhB,UAANnhB,CAAiByhB,UAAjBzhB,EACJ9B,IADI8B,CACC;AAAA,eAAMA,eAAMmhB,UAANnhB,CAAiB0hB,UAAjB1hB,CAAN;AADD,SAEJ9B,IAFI8B,CAEC,YAAM;AACV,YAAMqjB,YAAY,GAAG5B,UAAU,IAAIA,UAAU,CAAClb,UAAXkb,KAA0BJ,gBAA7D;AACA,YAAMiC,YAAY,GAAG5B,UAAU,IAAIA,UAAU,CAACnb,UAAXmb,KAA0BL,gBAA7D;;AAEA,YAAIgC,YAAY,IAAIC,YAApB,EAAkC;AAChCphB,gCAAQC,OAARD,CACEqhB,OADFrhB,EAEE;AACEE,gBAAI,EAAE,eADR;AAEEC,oBAAQ,EAAE;AAFZ,WAFFH,EAMEI,0BAAe2e,aANjB/e,EAMgC;AAC5BP,gBAAI,EAAEie,uBAAY4B;AADU,WANhCtf;AADF,eAYK,IAAIuf,UAAU,IAAIC,UAAlB,EAA8B;AACjC3jB,+BAAYC,MAAZD,CAAmB0B,IAAnB1B,CAAwB,qFAAxBA;AACD;AApBE,QAAP;AAsBD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,2BAAkB;AAAA;;AAChB,UAAMsI,KAAK,GAAG,KAAKlH,eAAL,CAAqB8V,UAAnC;AAEA,aAAOjV,eAAMmhB,UAANnhB,CAAiBqG,KAAjBrG,EAAwB9B,IAAxB8B,CAA6B,YAAM;AACxC,YAAIqG,KAAK,IAAIA,KAAK,CAACE,UAANF,KAAqBgb,gBAAlC,EAAyC;AACvCnf,gCAAQC,OAARD,CACEshB,OADFthB,EAEE;AACEE,gBAAI,EAAE,eADR;AAEEC,oBAAQ,EAAE;AAFZ,WAFFH,EAMEI,0BAAe2e,aANjB/e,EAMgC;AAC5BP,gBAAI,EAAEie,uBAAYwD;AADU,WANhClhB;AADF,eAYK,IAAImE,KAAJ,EAAW;AACd;AACAtI,+BAAYC,MAAZD,CAAmB0B,IAAnB1B,mFAAmGsI,KAAK,CAACE,UAAzG;AACD;AAhBI,QAAP;AAkBD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,gCAAuB;AACrB,WAAKpH,eAAL,CAAqBskB,oBAArB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,gCAAuB;AACrB,WAAKtkB,eAAL,CAAqBukB,oBAArB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,8BAAqB;AAAA,0BACnB;AACA;;;AACA,WAAKvf,KAAL,CAAW+D,QAAX,CAAoBC,OAApB,CAA4BuE,EAA5B,CAA+BiX,iBAA/B,EAAuC,YAAM;AAC3C5lB,6BAAYC,MAAZD,CAAmBE,IAAnBF,CAAwB,wDAAxBA,EAD2C,CAG3C;;;AACA,YAAI,CAAC6lB,OAAI,CAAC3b,qBAAV,EAAiC;AAC/BpG,2BAAQsU,SAARtU,CAAkB;AAChBwM,iBAAK,EAAE+H,kBAAUyN,2BADD;AAEhBvN,mBAAO,EAAEsN;AAFO,WAAlB/hB;;AAIAA,2BAAQC,oBAARD,CACEhB,8BAAmBgjB,2BADrBhiB,EAEE;AACEb,0BAAc,EAAE4iB,OAAI,CAAC3iB;AADvB,WAFFY;AAMD;;AACD+hB,eAAI,CAAC3b,qBAAL,GAA6B,IAA7B;AAhBF;AAmBA,WAAK9D,KAAL,CAAW+D,QAAX,CAAoBC,OAApB,CAA4BuE,EAA5B,CAA+BoX,kBAA/B,EAAwC,YAAM;AAC5C/lB,6BAAYC,MAAZD,CAAmBM,KAAnBN,CAAyB,yDAAzBA;;AACA8D,yBAAQsU,SAARtU,CAAkB;AAChBwM,eAAK,EAAE+H,kBAAU2N,uBADD;AAEhBzN,iBAAO,EAAEsN;AAFO,SAAlB/hB;;AAIAA,yBAAQC,oBAARD,CACEhB,8BAAmBmjB,0BADrBniB,EAEE;AACEb,wBAAc,EAAE4iB,OAAI,CAAC3iB;AADvB,SAFFY;AANF;AAaD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,gCAAuB;AACrB,aAAOoiB,+BAAsBC,KAAtBD,CAA4B,KAAK9kB,eAAL,CAAqB4G,cAAjDke,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,gCAAuB;AACrB,WAAK9kB,eAAL,CAAqBglB,mBAArB;;AACA,UAAI,KAAKxjB,MAAL,CAAYsM,YAAZ,CAAyBmX,SAA7B,EAAwC;AACtC,aAAKjgB,KAAL,CAAW+D,QAAX,CAAoBC,OAApB,CAA4Bkc,GAA5B,CAAgCV,iBAAhC;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,0BAAiBvgB,EAAjB,EAAqB;AACnB,WAAKnC,aAAL,GAAqBmC,EAArB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,qBAAY;AAAA;;AACV,UAAI,CAACiU,cAAYiN,mBAAZjN,CAAgC,KAAK3P,SAArC2P,CAAL,EAAsD;AACpD,eAAOnX,iBAAQC,MAAR,CAAe,IAAIokB,+BAAJ,EAAf,CAAP;AACD;;AAED,UAAI,CAAC,KAAK9F,OAAV,EAAmB;AACjB;AACA,eAAOve,iBAAQC,MAAR,CAAe,IAAIqkB,uCAAJ,EAAf,CAAP;AACD;;AAED,UAAI,CAAC,KAAKhgB,KAAV,EAAiB;AACf,eAAOtE,iBAAQC,MAAR,CAAe,IAAIskB,kBAAJ,CAAmB,4CAAnB,CAAf,CAAP;AACD;;AAED,UAAMC,UAAU,GAAG,6BAAnB,CAdU,CAgBV;;AACA,aAAOhnB,UAAU,CAAC,KAAK8G,KAAL,CAAWmgB,mBAAX,CAA+B,IAA/B,EAAqC,IAArC,EACfzmB,IADe,CACV,YAAM;AACVmZ,sBAAYuN,kBAAZvN,CAA+BwN,OAAI,CAAC1lB,eAAL,CAAqBsiB,UAApDpK;;AACAxV,yBAAQsU,SAARtU,CAAkB;AAChBwM,eAAK,EAAE+H,kBAAU0O,KADD;AAEhBxO,iBAAO,EAAEuO,OAFO;AAGhB9jB,cAAI,EAAE;AAACoB,mBAAO,EAAEA,gBAAQ4iB,gBAAlB;AAAoChE,qBAAS,EAAEA,kBAAUviB;AAAzD;AAHU,SAAlBqD;AAHc,SAQbzD,KARa,CAQP,UAACC,KAAD,EAAW;AAClBwD,yBAAQC,oBAARD,CACEhB,8BAAmB6e,kBADrB7d,EAEE;AACEb,wBAAc,EAAE6jB,OAAI,CAAC5jB,aADvB;AAEEC,kBAAQ,EAAE2jB,OAAI,CAAC1jB,QAAL,CAAcE,KAAd,CAAoB,GAApB,EAAyBC,GAAzB,EAFZ;AAGEC,gBAAM,EAAElD,KAAK,CAACmD,OAHhB;AAIEC,eAAK,EAAEpD,KAAK,CAACoD;AAJf,SAFFI;;AAUA,cAAMxD,KAAN;AAnBc,QAAD,EAqBjB;AACET,cAAM,YAAK8mB,UAAL,kBADR;AAEE7mB,eAAO,YAAK6mB,UAAL,8BAFT;AAGE5mB,eAAO,YAAK4mB,UAAL;AAHT,OArBiB,CAAjB;AA0BD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,uBAAc;AAAA;;AACZ,UAAI,CAACrN,cAAYiN,mBAAZjN,CAAgC,KAAK3P,SAArC2P,CAAL,EAAsD;AACpD,eAAOnX,iBAAQC,MAAR,CAAe,IAAIokB,+BAAJ,EAAf,CAAP;AACD;;AAED,UAAI,CAAC,KAAK9F,OAAV,EAAmB;AACjB;AACA,eAAOve,iBAAQC,MAAR,CAAe,IAAIqkB,uCAAJ,EAAf,CAAP;AACD;;AAED,UAAI,CAAC,KAAKhgB,KAAV,EAAiB;AACf,eAAOtE,iBAAQC,MAAR,CAAe,IAAIskB,kBAAJ,CAAmB,4CAAnB,CAAf,CAAP;AACD;;AAED,UAAMC,UAAU,GAAG,+BAAnB,CAdY,CAgBZ;;AACA,aAAOhnB,UAAU,CAAC,KAAK8G,KAAL,CAAWmgB,mBAAX,CAA+B,IAA/B,EAAqC,KAArC,EACfzmB,IADe,CACV,YAAM;AACVmZ,sBAAYuN,kBAAZvN,CAA+B2N,OAAI,CAAC7lB,eAAL,CAAqBsiB,UAApDpK;;AACAxV,yBAAQsU,SAARtU,CAAkB;AAChBwM,eAAK,EAAE+H,kBAAU6O,OADD;AAEhB3O,iBAAO,EAAE0O,OAFO;AAGhBjkB,cAAI,EAAE;AAACoB,mBAAO,EAAEA,gBAAQ4iB,gBAAlB;AAAoChE,qBAAS,EAAEA,kBAAUviB;AAAzD;AAHU,SAAlBqD;AAHc,SAQbzD,KARa,CAQP,UAACC,KAAD,EAAW;AAClBwD,yBAAQC,oBAARD,CACEhB,8BAAmBqkB,oBADrBrjB,EAEE;AACEb,wBAAc,EAAEgkB,OAAI,CAAC/jB,aADvB;AAEEC,kBAAQ,EAAE8jB,OAAI,CAAC7jB,QAAL,CAAcE,KAAd,CAAoB,GAApB,EAAyBC,GAAzB,EAFZ;AAGEC,gBAAM,EAAElD,KAAK,CAACmD,OAHhB;AAIEC,eAAK,EAAEpD,KAAK,CAACoD;AAJf,SAFFI;;AAUA,cAAMxD,KAAN;AAnBc,QAAD,EAqBjB;AACET,cAAM,YAAK8mB,UAAL,oBADR;AAEE7mB,eAAO,YAAK6mB,UAAL,gCAFT;AAGE5mB,eAAO,YAAK4mB,UAAL;AAHT,OArBiB,CAAjB;AA0BD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,qBAAY;AAAA;;AACV,UAAI,CAACrN,cAAYiN,mBAAZjN,CAAgC,KAAK3P,SAArC2P,CAAL,EAAsD;AACpD,eAAOnX,iBAAQC,MAAR,CAAe,IAAIokB,+BAAJ,EAAf,CAAP;AACD;;AAED,UAAI,CAAC,KAAK9F,OAAV,EAAmB;AACjB;AACA,eAAOve,iBAAQC,MAAR,CAAe,IAAIqkB,uCAAJ,EAAf,CAAP;AACD;;AAED,UAAI,CAAC,KAAK9kB,KAAV,EAAiB;AACf,eAAOQ,iBAAQC,MAAR,CAAe,IAAIskB,kBAAJ,CAAmB,4CAAnB,CAAf,CAAP;AACD;;AAED,UAAMC,UAAU,GAAG,6BAAnB;AAEA,aAAOhnB,UAAU,CAAC,KAAKgC,KAAL,CAAWilB,mBAAX,CAA+B,IAA/B,EAAqC,IAArC,EACfzmB,IADe,CACV,YAAM;AACVmZ,sBAAY8N,kBAAZ9N,CAA+B+N,OAAI,CAACjmB,eAAL,CAAqBuiB,UAApDrK;;AACAxV,yBAAQsU,SAARtU,CAAkB;AAChBwM,eAAK,EAAE+H,kBAAU0O,KADD;AAEhBxO,iBAAO,EAAE8O,OAFO;AAGhBrkB,cAAI,EAAE;AAACoB,mBAAO,EAAEA,gBAAQ4iB,gBAAlB;AAAoChE,qBAAS,EAAEA,kBAAUtiB;AAAzD;AAHU,SAAlBoD;AAHc,SAQbzD,KARa,CAQP,UAACC,KAAD,EAAW;AAClBwD,yBAAQC,oBAARD,CACEhB,8BAAmBwkB,kBADrBxjB,EAEE;AACEb,wBAAc,EAAEokB,OAAI,CAACnkB,aADvB;AAEEC,kBAAQ,EAAEkkB,OAAI,CAACjkB,QAAL,CAAcE,KAAd,CAAoB,GAApB,EAAyBC,GAAzB,EAFZ;AAGEC,gBAAM,EAAElD,KAAK,CAACmD,OAHhB;AAIEC,eAAK,EAAEpD,KAAK,CAACoD;AAJf,SAFFI;;AAUA,cAAMxD,KAAN;AAnBc,QAAD,EAqBjB;AACET,cAAM,YAAK8mB,UAAL,kBADR;AAEE7mB,eAAO,YAAK6mB,UAAL,8BAFT;AAGE5mB,eAAO,YAAK4mB,UAAL;AAHT,OArBiB,CAAjB;AA0BD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,uBAAc;AAAA;;AACZ,UAAI,CAACrN,cAAYiN,mBAAZjN,CAAgC,KAAK3P,SAArC2P,CAAL,EAAsD;AACpD,eAAOnX,iBAAQC,MAAR,CAAe,IAAIokB,+BAAJ,EAAf,CAAP;AACD;;AAED,UAAI,CAAC,KAAK9F,OAAV,EAAmB;AACjB;AACA,eAAOve,iBAAQC,MAAR,CAAe,IAAIqkB,uCAAJ,EAAf,CAAP;AACD;;AAED,UAAI,CAAC,KAAK9kB,KAAV,EAAiB;AACf,eAAOQ,iBAAQC,MAAR,CAAe,IAAIskB,kBAAJ,CAAmB,4CAAnB,CAAf,CAAP;AACD;;AAED,UAAMC,UAAU,GAAG,+BAAnB;AAEA,aAAOhnB,UAAU,CAAC,KAAKgC,KAAL,CAAWilB,mBAAX,CAA+B,IAA/B,EAAqC,KAArC,EACfzmB,IADe,CACV,YAAM;AACVmZ,sBAAY8N,kBAAZ9N,CAA+BiO,OAAI,CAACnmB,eAAL,CAAqBuiB,UAApDrK;;AACAxV,yBAAQsU,SAARtU,CAAkB;AAChBwM,eAAK,EAAE+H,kBAAU6O,OADD;AAEhB3O,iBAAO,EAAEgP,OAFO;AAGhBvkB,cAAI,EAAE;AAACoB,mBAAO,EAAEA,gBAAQ4iB,gBAAlB;AAAoChE,qBAAS,EAAEA,kBAAUtiB;AAAzD;AAHU,SAAlBoD;AAHc,SAQbzD,KARa,CAQP,UAACC,KAAD,EAAW;AAClBwD,yBAAQC,oBAARD,CACEhB,8BAAmB0kB,oBADrB1jB,EAEE;AACEb,wBAAc,EAAEskB,OAAI,CAACrkB,aADvB;AAEEC,kBAAQ,EAAEokB,OAAI,CAACnkB,QAAL,CAAcE,KAAd,CAAoB,GAApB,EAAyBC,GAAzB,EAFZ;AAGEC,gBAAM,EAAElD,KAAK,CAACmD,OAHhB;AAIEC,eAAK,EAAEpD,KAAK,CAACoD;AAJf,SAFFI;;AAUA,cAAMxD,KAAN;AAnBc,QAAD,EAqBjB;AACET,cAAM,YAAK8mB,UAAL,oBADR;AAEE7mB,eAAO,YAAK6mB,UAAL,gCAFT;AAGE5mB,eAAO,YAAK4mB,UAAL;AAHT,OArBiB,CAAjB;AA0BD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,yBAA4B;AAAA;;AAAA,UAAd7lB,OAAc,uEAAJ,EAAI,EAC1B;;AACA,UAAOojB,aAAP,GAAwDpjB,OAAxD,CAAOojB,aAAP;AAAA,UAAsBuD,WAAtB,GAAwD3mB,OAAxD,CAAsB2mB,WAAtB;AAAA,UAAmCC,iBAAnC,GAAwD5mB,OAAxD,CAAmC4mB,iBAAnC;AAEA,aAAO,KAAKC,IAAL,CAAUF,WAAV,EACJtnB,IADI,CACC,UAACynB,YAAD;AAAA,eACJC,OAAI,CAACC,eAAL,CAAqB5D,aAArB,EAAoCwD,iBAApC,EAAuDvnB,IAAvD,CAA4D;AAAA;AAAA,cAAEwkB,WAAF;AAAA,cAAeE,UAAf;;AAAA,iBAC1DgD,OAAI,CAACE,QAAL,CAAc;AACZ7D,yBAAa,EAAbA,aADY;AAEZW,sBAAU,EAAVA,UAFY;AAGZF,uBAAW,EAAXA;AAHY,WAAd,EAIGxkB,IAJH,CAIQ,UAAC6nB,aAAD;AAAA,mBAAoB;AAC1BL,kBAAI,EAAEC,YADoB;AAE1BK,mBAAK,EAAED,aAFmB;AAG1BE,mBAAK,EAAE,CAACvD,WAAD,EAAcE,UAAd;AAHmB,aAApB;AAJR,YAD0D;AAA5D,UADI;AADD,SAYJxkB,KAZI,CAYE,UAACC,KAAD,EAAW;AAChBN,6BAAYC,MAAZD,CAAmBM,KAAnBN,CAAyB,kCAAzBA,EAA6DM,KAA7DN;;AAEA8D,yBAAQC,oBAARD,CACEhB,8BAAmBqlB,uBADrBrkB,EAEE;AACEb,wBAAc,EAAE4kB,OAAI,CAAC3kB,aADvB;AAEEC,kBAAQ,EAAE0kB,OAAI,CAACzkB,QAAL,CAAcE,KAAd,CAAoB,GAApB,EAAyBC,GAAzB,EAFZ;AAGEC,gBAAM,EAAElD,KAAK,CAACmD,OAHhB;AAIEC,eAAK,EAAEpD,KAAK,CAACoD;AAJf,SAFFI,EAQE;AACEF,cAAI,EAAEtD,KAAK,CAACuD;AADd,SARFC;;AAaA,eAAO3B,iBAAQC,MAAR,CAAe9B,KAAf,CAAP;AA5BG,QAAP;AA8BD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,mBAAUQ,OAAV,EAAmB;AAAA;;AACjBd,2BAAYC,MAAZD,CAAmBgF,GAAnBhF,uEAAsF,KAAKqF,EAA3F;;AAEA,UAAI,CAAC,KAAKkB,mBAAN,IAA6B,CAAC,KAAKA,mBAAL,CAAyB6I,SAA3D,EAAsE;AACpE,eAAOjN,iBAAQC,MAAR,CAAe,IAAIskB,kBAAJ,CAAmB,8DAAnB,CAAf,CAAP;AACD;;AAED,UAAI,CAACpN,cAAY8O,kBAAZ9O,CAA+B,KAAK+O,kBAApC/O,CAAL,EAA8D;AAC5D,eAAOnX,iBAAQC,MAAR,CAAe,IAAIskB,kBAAJ,CAAmB,0DAAnB,CAAf,CAAP;AACD;;AAED,UAAI;AACF1mB,6BAAYC,MAAZD,CAAmBE,IAAnBF,CAAwB,2DAAxBA;;AACA,aAAKuG,mBAAL,CAAyB+hB,QAAzB;AAFF,QAIA,OAAOhoB,KAAP,EAAc;AACZ;AACA,YAAIA,KAAK,YAAYioB,+BAArB,EAA0C;AACxCvoB,+BAAYC,MAAZD,CAAmBE,IAAnBF,CAAwB,4EAAxBA;AADF,eAGK;AACHA,+BAAYC,MAAZD,CAAmBgF,GAAnBhF,CAAuB,kDAAvBA,EAA2EM,KAA3EN;AACD;;AAED,eAAOmC,iBAAQkK,OAAR,EAAP;AACD;;AAEDlI,4BAAQC,OAARD,CACE,IADFA,EAEE;AACEE,YAAI,EAAE,eADR;AAEEC,gBAAQ,EAAE;AAFZ,OAFFH,EAMEI,0BAAeikB,6BANjBrkB;;AAUA,aAAO,KAAKoC,mBAAL,CACJ6I,SADI,CACMtO,OADN,EAEJX,IAFI,CAEC,YAAM;AACVgE,8BAAQC,OAARD,CACEskB,OADFtkB,EAEE;AACEE,cAAI,EAAE,eADR;AAEEC,kBAAQ,EAAE;AAFZ,SAFFH,EAMEI,0BAAemkB,4BANjBvkB;;AAQAnE,6BAAYC,MAAZD,CAAmBgF,GAAnBhF,CAAuB,uDAAvBA;AAXG,SAaJK,KAbI,CAaE,UAACC,KAAD,EAAW;AAChB6D,8BAAQC,OAARD,CACEskB,OADFtkB,EAEE;AACEE,cAAI,EAAE,eADR;AAEEC,kBAAQ,EAAE;AAFZ,SAFFH,EAMEI,0BAAeokB,4BANjBxkB,EAOE;AACE7D,eAAK,EAAE,IAAIsoB,qBAAJ,CAAsB,4BAAtB,EAAoDtoB,KAApD;AADT,SAPF6D;;AAYAnE,6BAAYC,MAAZD,CAAmBM,KAAnBN,CAAyB,sDAAzBA,EAAiFM,KAAjFN;;AAEA8D,yBAAQC,oBAARD,CACEhB,8BAAmB+lB,yBADrB/kB,EAEE;AACEb,wBAAc,EAAEwlB,OAAI,CAACvlB,aADvB;AAEEC,kBAAQ,EAAEslB,OAAI,CAACrlB,QAAL,CAAcE,KAAd,CAAoB,GAApB,EAAyBC,GAAzB,EAFZ;AAGEC,gBAAM,EAAElD,KAAK,CAACmD,OAHhB;AAIEC,eAAK,EAAEpD,KAAK,CAACoD;AAJf,SAFFI;;AAUA2kB,eAAI,CAACK,UAAL,CAAgB;AACdzkB,cAAI,EAAE,eADQ;AAEdC,kBAAQ,EAAE;AAFI,SAAhB;;AAKA,eAAOnC,iBAAQC,MAAR,CAAe,IAAIwmB,qBAAJ,CAAsB,4BAAtB,EAAoDtoB,KAApD,CAAf,CAAP;AA3CG,SA6CJ4X,OA7CI,CA6CI,YAAM;AACbuQ,eAAI,CAACliB,mBAAL,CAAyBwiB,KAAzB;AA9CG,QAAP;AAgDD;AAED;AACF;AACA;AACA;AACA;;;;WACE,oCAA2B;AAAA;;AACzB,0BAAI,KAAK3hB,MAAT,yCAAI4hB,aAAaC,6BAAjB,EAAgD;AAC9C,eAAO,IAAP;AACD;;AAEDjpB,2BAAYC,MAAZD,CAAmBM,KAAnBN,CACE,6EADFA;;AAIA,aAAO,KAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;;WACE,gDAAuC;AAAA;;AACrC,WAAK0K,aAAL,CAAmBwe,aAAnB,CAAiC,UAAC5Y,KAAD,EAAW;AAC1CtQ,6BAAYC,MAAZD,CAAmBE,IAAnBF,2KAIIsQ,KAJJ;;AAOA6Y,eAAI,CAACC,sCAAL;AARF;AAWA,WAAK1e,aAAL,CAAmB2e,aAAnB,CAAiC,UAAC/Y,KAAD,EAAW;AAC1CtQ,6BAAYC,MAAZD,CAAmBM,KAAnBN,iLAIIsQ,KAJJ;;AAOA6Y,eAAI,CAACC,sCAAL;;AAEAtlB,yBAAQC,oBAARD,CACEhB,8BAAmBwmB,6BADrBxlB,EAEE;AACEb,wBAAc,EAAEkmB,OAAI,CAACjmB,aADvB;AAEEM,gBAAM,EAAE,8EAFV;AAGE8M,eAAK,EAALA;AAHF,SAFFxM;AAVF;AAmBD;AAED;AACF;AACA;AACA;AACA;;;;;0GACE;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AACE9D,qCAAYC,MAAZD,CAAmBE,IAAnBF;;AADFupB;AAOWC,8BAPX,GAO6B,KAAK7f,SAAL,CAAezJ,IAAf,CAAlBspB;AAPXD;AAAA,uBAQyC,KAAK3pB,OAAL,CAAa;AAChD6pB,wBAAM,EAAEC,sBAAWC,IAD6B;AAEhDC,qBAAG,EAAEJ,cAF2C;AAGhDxd,sBAAI,EAAE;AAACrG,6BAAS,EAAE,KAAKA;AAAjB;AAH0C,iBAAb,CARzC;;AAAA;AAAAkkB;AAQkBC,4BARlB,uBAQW9d,IARX,CAQkB8d;;AAMd9pB,qCAAYC,MAAZD,CAAmBE,IAAnBF;;AAKA,qBAAK0K,aAAL,GAAqB,IAAIqf,sBAAJ,CACnBD,YADmB,EAEnB,KAAK1jB,KAAL,CAAW4jB,SAFQ,EAGnB,KAAKjkB,OAHc,CAArB;;AAMA/F,qCAAYC,MAAZD,CAAmBE,IAAnBF,mGAzBJ,CA8BI;;;AACA,qBAAK0K,aAAL,CAAmBuf,SAAnB,CAA6B,UAAC1a,OAAD,EAAa;AACxCpL,wCAAQC,OAARD,CACE+lB,OADF/lB,EAEE;AACEE,wBAAI,EAAE,eADR;AAEEC,4BAAQ,EAAE;AAFZ,mBAFFH,EAMEI,0BAAe4lB,uCANjBhmB,EAOEoL,OAPFpL;AADF;AAYA,qBAAKimB,oCAAL;AACA,qBAAK1f,aAAL,CAAmB2f,OAAnB,CAA2B,KAAKjkB,KAAL,CAAWkkB,WAAX,CAAuBC,UAAvB,CAAkCC,YAA7D;AA5CJjB;AAAA;;AAAA;AAAAA;AAAAA;;AA+CIvpB,qCAAYC,MAAZD,CAAmBM,KAAnBN;;AACA8D,iCAAQC,oBAARD,CACEhB,8BAAmBwmB,6BADrBxlB,EAEE;AACEb,gCAAc,EAAE,KAAKC,aADvB;AAEEM,wBAAM,EAAE+lB,aAAM9lB,OAFhB;AAGEC,uBAAK,EAAE6lB,aAAM7lB;AAHf,iBAFFI;;AAhDJ;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AA2DA;AACF;AACA;AACA;AACA;;;;WACE,sCAA6B;AAC3B,UAAI,KAAK4G,aAAT,EAAwB;AACtB,aAAKA,aAAL,CAAmB+f,WAAnB;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,kDAAyC;AACvCzqB,2BAAYC,MAAZD,CAAmBE,IAAnBF;;AAKAmE,4BAAQC,OAARD,CACE,IADFA,EAEE;AACEE,YAAI,EAAE,SADR;AAEEC,gBAAQ,EAAE;AAFZ,OAFFH,EAMEI,0BAAemmB,uCANjBvmB;AAQD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,gBAAmB;AAAA;;AAAA,UAAdrD,OAAc,uEAAJ,EAAI,EACjB;;AACA,UAAI,KAAKkJ,SAAT,EAAoB;AAClB,eAAO,KAAKA,SAAZ;AAHe,QAMjB;;;AACA,UAAI2gB,UAAJ;AACA,UAAIC,WAAJ,CARiB,CAUjB;AACA;;AACA,WAAK5gB,SAAL,GAAiB,qBAAY,UAACqC,OAAD,EAAUjK,MAAV,EAAqB;AAChDuoB,kBAAU,GAAGvoB,MAAbuoB;AACAC,mBAAW,GAAGve,OAAdue;AAFe,QAAjB;;AAKA,UAAI,CAAC,KAAK3f,aAAV,EAAyB;AACvB,aAAKA,aAAL,GAAqB,IAArB;AADF,aAGK;AACHjL,6BAAYC,MAAZD,CAAmBgF,GAAnBhF,8EAA6F,KAAKqF,EAAlG;;AACArF,6BAAYC,MAAZD,CAAmBgF,GAAnBhF,0DAAyE,KAAKkD,aAA9E;;AACA,aAAK2nB,gBAAL,CAAsBvlB,cAAKC,EAALD,EAAtB;;AACAtF,6BAAYC,MAAZD,CAAmBgF,GAAnBhF,qDAAoE,KAAKkD,aAAzE;AACD;;AAED,UAAIpC,OAAO,CAACgqB,MAAZ,EAAoB;AAClB,aAAKpkB,yBAAL,CAA+BqiB,KAA/B;AACD;;AAEDjlB,uBAAQsU,SAARtU,CAAkB;AAChBwM,aAAK,EAAE+H,kBAAU0S,cADD;AAEhBxS,eAAO,EAAE,IAFO;AAGhBvV,YAAI,EAAE;AAACoB,iBAAO,EAAEA,gBAAQ4iB;AAAlB;AAHU,OAAlBljB;;AAMA9D,2BAAYC,MAAZD,CAAmBgF,GAAnBhF,CAAuB,0CAAvBA;;AAEA,UAAI,KAAK0G,yBAAL,CAA+B4M,KAA/B,KAAyC0X,iCAAsBxX,MAAtBwX,CAA6B1H,KAA1E,EAAiF;AAC/E,aAAK5c,yBAAL,CAA+BqiB,KAA/B;AACD;;AACD,UAAI,KAAKriB,yBAAL,CAA+B4M,KAA/B,KAAyC0X,iCAAsBxX,MAAtBwX,CAA6BC,OAA1E,EAAmF;AACjF,aAAKvkB,yBAAL,CAA+BwkB,IAA/B,CAAoCC,iBAApC;AA3Ce,QA8CjB;;;AACA,UAAIrqB,OAAO,CAACsqB,UAARtqB,IAAsB,KAAKoK,WAA3BpK,IAA0CA,OAAO,CAACsqB,UAARtqB,KAAuB,KAAKoK,WAA1E,EAAuF;AACrF,aAAKiR,aAAL,GAAqB,IAArB;AACD;;AAED,UAAIrb,OAAO,CAACuqB,cAAZ,EAA4B;AAC1B,YAAI,OAAOvqB,OAAO,CAACuqB,cAAf,KAAkC,QAAtC,EAAgD;AAC9C,cAAI,CAACC,0BAAexqB,OAAO,CAACuqB,cAAvBC,CAAL,EAA6C;AAC3C,gBAAMC,YAAY,oCAA6BzqB,OAAO,CAACuqB,cAArC,iBAAlB;AACA,gBAAM/qB,KAAK,GAAG,IAAIkL,KAAJ,CAAU+f,YAAV,CAAd;;AAEAvrB,iCAAYC,MAAZD,CAAmBM,KAAnBN,CAAyBurB,YAAzBvrB;;AAEA2qB,sBAAU,CAACrqB,KAAD,CAAVqqB;AACA,iBAAK3gB,SAAL,GAAiBC,SAAjB;AAEA,mBAAO9H,iBAAQC,MAAR,CAAe9B,KAAf,CAAP;AACD;;AAED,eAAKc,eAAL,CAAqBoqB,oBAArB,CAA0C1qB,OAAO,CAACuqB,cAAlD;AACA,eAAKjqB,eAAL,CAAqBqqB,qBAArB,CAA2C3qB,OAAO,CAACuqB,cAAnD;AACD;;AAED,YAAI,sBAAOvqB,OAAO,CAACuqB,cAAf,MAAkC,QAAtC,EAAgD;AAC9C,cACE,CAACC,0BAAexqB,OAAO,CAACuqB,cAARvqB,CAAuBonB,KAAtCoD,CAAD,IACA,CAACA,0BAAexqB,OAAO,CAACuqB,cAARvqB,CAAuBib,MAAtCuP,CAFH,EAGE;AACA,gBAAMC,aAAY,oCAChBzqB,OAAO,CAACuqB,cAARvqB,CAAuBonB,KAAvBpnB,IAAgCA,OAAO,CAACuqB,cAARvqB,CAAuBib,MADvC,iBAAlB;;AAIA/b,iCAAYC,MAAZD,CAAmBM,KAAnBN,CAAyBurB,aAAzBvrB;;AAEA,gBAAMM,MAAK,GAAG,IAAIkL,KAAJ,CAAU+f,aAAV,CAAd;;AAEAZ,sBAAU,CAACrqB,MAAD,CAAVqqB;AACA,iBAAK3gB,SAAL,GAAiBC,SAAjB;AAEA,mBAAO9H,iBAAQC,MAAR,CAAe,IAAIoJ,KAAJ,CAAU+f,aAAV,CAAf,CAAP;AACD;;AAED,cAAIzqB,OAAO,CAACuqB,cAARvqB,CAAuBonB,KAA3B,EAAkC;AAChC,iBAAK9mB,eAAL,CAAqBoqB,oBAArB,CAA0C1qB,OAAO,CAACuqB,cAARvqB,CAAuBonB,KAAjE;AACD;;AACD,cAAIpnB,OAAO,CAACuqB,cAARvqB,CAAuBib,MAA3B,EAAmC;AACjC,iBAAK3a,eAAL,CAAqBqqB,qBAArB,CAA2C3qB,OAAO,CAACuqB,cAARvqB,CAAuBib,MAAlE;AACD;AACF;AACF;;AAED,aAAOzC,cAAYoS,kBAAZpS,CAA+B,IAA/BA,EAAqCxY,OAArCwY,EACJnZ,IADImZ,CACC,UAACqO,IAAD,EAAU;AACdgE,eAAI,CAACjlB,yBAAL,CAA+BihB,IAA/B;;AACA3nB,6BAAYC,MAAZD,CAAmBgF,GAAnBhF,CAAuB,gCAAvBA;;AAEA,eAAO2nB,IAAP;AALG,SAOJxnB,IAPImZ,CAOC,UAACqO,IAAD,EAAU;AACdiD,mBAAW,CAACjD,IAAD,CAAXiD;AACAe,eAAI,CAAC3hB,SAAL,GAAiBC,SAAjB;;AACAnG,yBAAQC,oBAARD,CACEhB,8BAAmB8oB,YADrB9nB,EAEE;AACEb,wBAAc,EAAE0oB,OAAI,CAACzoB;AADvB,SAFFY;;AAOA,eAAO6jB,IAAP;AAjBG,SAkBFxnB,IAlBEmZ;AAAA,4FAkBG,kBAAOqO,IAAP;AAAA;AAAA;AAAA;AAAA;AAAA,uBACFjoB,SADE;AAAAmsB;AAAA;AAAA;;AAAA,wBAEAF,OAAI,CAAC/oB,MAAL,CAAYkpB,oBAAZ,IAAoChrB,OAAO,CAACgrB,oBAF5C;AAAAD;AAAA;AAAA;;AAAA,uBAGEF,OAAI,CAACI,wBAAL,EAHF;AAAAF;AAAA;AAAA;;AAAAA;AAAA,yBAIMF,OAAI,CAACG,oBAAL,EAJN;;AAAA;AAKA9rB,uCAAYC,MAAZD,CAAmBE,IAAnBF,CAAwB,0DAAxBA;;AALA;AAAA6rB;AAAA;;AAAA;AAUJ7rB,uCAAYC,MAAZD,CAAmBM,KAAnBN,CAAyB,iFAAzBA;;AAVI;AAAA,oDAcC2nB,IAdD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAlBH;;AAAA;AAAA;AAAA;AAAA,WAkCJtnB,KAlCIiZ,CAkCE,UAAChZ,KAAD,EAAW;AAAA;;AAChBqrB,eAAI,CAACjlB,yBAAL,CAA+BslB,IAA/B,CAAoC1rB,KAApC;;AACAN,6BAAYC,MAAZD,CAAmBM,KAAnBN,CAAyB,+BAAzBA,EAA0DM,KAA1DN,EAFgB,CAIhB;;;AACA8D,yBAAQC,oBAARD,CACEhB,8BAAmBmpB,YADrBnoB,EAEE;AACEb,wBAAc,EAAE0oB,OAAI,CAACzoB,aADvB;AAEEM,gBAAM,kBAAElD,KAAK,CAACA,KAAR,iDAAE4rB,aAAazoB,OAFvB;AAGEC,eAAK,EAAEpD,KAAK,CAACoD;AAHf,SAFFI,EALgB,CAchB;;;AACAK,8BAAQC,OAARD,CACEwnB,OADFxnB,EAEE;AACEE,cAAI,EAAE,eADR;AAEEC,kBAAQ,EAAE;AAFZ,SAFFH,EAMEyK,kBAAOK,mBANT9K,EAOEwnB,OAPFxnB;;AAUAwmB,kBAAU,CAACrqB,KAAD,CAAVqqB;AACAgB,eAAI,CAAC3hB,SAAL,GAAiBC,SAAjB;AAEA,eAAO9H,iBAAQC,MAAR,CAAe9B,KAAf,CAAP;AA9DG,QAAP;AAgED;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,uBAAc6rB,WAAd,EAA2B;AACzB,UAAI,CAACA,WAAL,EAAkB;AAChB,eAAO,KAAKC,UAAL,EAAP;AACD;;AAED,aAAO,KAAKC,WAAL,CAAiBF,WAAjB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,4BAAmBG,UAAnB,EAA+B;AAC7B,aAAO,CAACrjB,uBAAYwK,MAAb,EAAqBxK,uBAAY8J,SAAjC,EAA4C9J,uBAAYsjB,OAAxD,EAAiEC,QAAjE,CAA0EF,UAA1E,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,sBAAa;AAAA;;AACX,UAAI,KAAKG,kBAAL,CAAwB,KAAKzjB,kBAA7B,CAAJ,EAAsD,OAAO7G,iBAAQkK,OAAR,EAAP,CAD3C,CACqE;;AAEhF,UAAOnJ,aAAP,GAAkC,KAA3BA,aAAP;AAAA,UAAsBE,QAAtB,GAAkC,KAAZA,QAAtB;AAEA,UAAI,CAAC,KAAK+F,SAAV,EAAqB,KAAKA,SAAL,uBAA8B7D,cAAKC,EAALD,EAA9B;AAErB,aAAO,KAAK+B,cAAL,CAAoBmN,MAApB,CAA2B;AAChCtR,qBAAa,EAAbA,aADgC;AAEhCiG,iBAAS,EAAE,KAAKA,SAFgB;AAGhC/F,gBAAQ,EAARA,QAHgC;AAIhCspB,iBAAS,EAAE,KAAK/mB;AAJgB,OAA3B,EAKJxF,IALI,CAKC,UAAC2O,GAAD,EAAS;AACf6d,eAAI,CAAChjB,SAAL,CAAeijB,WAAf,CAA2B9d,GAAG,CAAC9C,IAAJ8C,CAAS7I,KAApC;AANK,SAOJ5F,KAPI,CAOE,UAACC,KAAD,EAAW;AAAA;;AAClBwD,yBAAQC,oBAARD,CACEhB,8BAAmB+pB,mBADrB/oB,EAEE;AACEb,wBAAc,EAAE0pB,OAAI,CAACzpB,aADvB;AAEE4pB,qBAAW,EAAEH,OAAI,CAACxjB,SAFpB;AAGEhG,kBAAQ,EAAEC,QAAQ,CAACE,KAATF,CAAe,GAAfA,EAAoBG,GAApBH,EAHZ;AAIE2pB,oBAAU,EAAEJ,OAAI,CAAChnB,SAJnB;AAKEnC,gBAAM,mBAAElD,KAAK,CAACA,KAAR,kDAAE0sB,cAAavpB,OALvB;AAMEC,eAAK,EAAEpD,KAAK,CAACoD;AANf,SAFFI;;AAYA,eAAO3B,iBAAQC,MAAR,CAAe9B,KAAf,CAAP;AApBK,QAAP;AAsBD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,qBAAY6rB,WAAZ,EAAyB;AAAA;;AACvB,UAAI,KAAKM,kBAAL,CAAwB,KAAKrjB,mBAA7B,CAAJ,EAAuD,OAAOjH,iBAAQkK,OAAR,EAAP,CADhC,CAC0D;;AAEjF,UAAOnJ,aAAP,GAAkC,KAA3BA,aAAP;AAAA,UAAsBE,QAAtB,GAAkC,KAAZA,QAAtB;AAEA,UAAI,CAAC,KAAKiG,UAAV,EAAsB,KAAKA,UAAL,wBAAgC/D,cAAKC,EAALD,EAAhC;AAEtB,aAAO,KAAK+B,cAAL,CAAoBsN,OAApB,CAA4B;AACjCzR,qBAAa,EAAbA,aADiC;AAEjCmG,kBAAU,EAAE,KAAKA,UAFgB;AAGjC8iB,mBAAW,EAAXA,WAHiC;AAIjC/oB,gBAAQ,EAARA,QAJiC;AAKjCspB,iBAAS,EAAE,KAAK/mB;AALiB,OAA5B,EAMJxF,IANI,CAMC,UAAC2O,GAAD,EAAS;AACfme,eAAI,CAACtjB,SAAL,CAAeijB,WAAf,CAA2B9d,GAAG,CAAC9C,IAAJ8C,CAAS7I,KAApC;AAPK,SAQJ5F,KARI,CAQE,UAACC,KAAD,EAAW;AAAA;;AAClBwD,yBAAQC,oBAARD,CACEhB,8BAAmBoqB,oBADrBppB,EAEE;AACEb,wBAAc,EAAEgqB,OAAI,CAAC/pB,aADvB;AAEEiqB,sBAAY,EAAEF,OAAI,CAAC5jB,UAFrB;AAGElG,kBAAQ,EAAEC,QAAQ,CAACE,KAATF,CAAe,GAAfA,EAAoBG,GAApBH,EAHZ;AAIE2pB,oBAAU,EAAEE,OAAI,CAACtnB,SAJnB;AAKEnC,gBAAM,mBAAElD,KAAK,CAACA,KAAR,kDAAE8sB,cAAa3pB,OALvB;AAMEC,eAAK,EAAEpD,KAAK,CAACoD;AANf,SAFFI;;AAYA,eAAO3B,iBAAQC,MAAR,CAAe9B,KAAf,CAAP;AArBK,QAAP;AAuBD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,gCAAuB;AACrB,aAAO6B,iBAAQqhB,GAAR,CAAY,CACjB,KAAKiJ,kBAAL,CAAwB,KAAKzjB,kBAA7B,IACEsQ,cAAY+T,oBAAZ/T,CAAiC,IAAjCA,EAAuC,KAAKnQ,SAA5CmQ,CADF,GAEEnX,iBAAQkK,OAAR,EAHe,EAIjB,KAAKogB,kBAAL,CAAwB,KAAKrjB,mBAA7B,IACEkQ,cAAY+T,oBAAZ/T,CAAiC,IAAjCA,EAAuC,KAAKjQ,UAA5CiQ,CADF,GAEEnX,iBAAQkK,OAAR,EANe,CAAZ,CAAP;AAQD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,gBAAO+e,UAAP,EAAmB;AAAA;;AACjB,UAAI,CAACA,UAAL,EAAiB;AACf,cAAM,IAAI1E,kBAAJ,CAAmB,wCAAnB,CAAN;AACD;;AAED5iB,uBAAQsU,SAARtU,CAAkB;AAChBwM,aAAK,EAAE+H,kBAAUiV,kBADD;AAEhB/U,eAAO,EAAE,IAFO;AAGhBvV,YAAI,EAAE;AACJuqB,2BAAiB,EAAE;AACjBC,cAAE,EAAE;AACF/mB,mBAAK,EAAE,KADL;AAEFiN,mBAAK,EAAE,KAFL;AAGF+Z,yBAAW,EAAE,KAHX;AAIF9rB,mBAAK,EAAE,KAJL;AAKFwU,wBAAU,EAAE;AALV,aADa;AAQjBuX,cAAE,EAAE;AACFjnB,mBAAK,EAAE,KADL;AAEFiN,mBAAK,EAAE,KAFL;AAGF+Z,yBAAW,EAAE,KAHX;AAIF9rB,mBAAK,EAAE,KAJL;AAKFwU,wBAAU,EAAE;AALV;AARa;AADf;AAHU,OAAlBrS;;AAuBAA,uBAAQsU,SAARtU,CAAkB;AAACwM,aAAK,EAAE+H,kBAAUsV,UAAlB;AAA8BpV,eAAO,EAAE;AAAvC,OAAlBzU;;AAEA,aAAOwV,cAAYoS,kBAAZpS,CAA+B,IAA/BA,EAAqC;AAAC8R,kBAAU,EAAVA,UAAD;AAAawC,sBAAc,EAAE;AAA7B,OAArCtU,EAAyEnZ,IAAzEmZ,CAA8E,YAAM;AACzFuU,eAAI,CAACnnB,yBAAL,CAA+BihB,IAA/B;;AAEA,eAAOkG,OAAI,CAAC5oB,WAAL,CAAiB;AACtBif,uBAAa,EAAE;AACb1iB,qBAAS,EAAE,KADE;AACKka,wBAAY,EAAE,KADnB;AAC0Bna,qBAAS,EAAE,KADrC;AAC4Cia,wBAAY,EAAE,KAD1D;AACiE/Z,qBAAS,EAAE,KAD5E;AACmFwW,wBAAY,EAAE;AADjG;AADO,SAAjB,EAIJ9X,IAJI,CAIC;AAAA,iBAAMgC,iBAAQkK,OAAR,CAAgBwhB,OAAhB,CAAN;AAJD,UAAP;AAHK,SAQJxtB,KARIiZ,CAQE,UAAChZ,KAAD,EAAW;AAClButB,eAAI,CAACnnB,yBAAL,CAA+BslB,IAA/B,CAAoC1rB,KAApC;;AAEA,eAAO6B,iBAAQC,MAAR,CAAe9B,KAAf,CAAP;AAXK,QAAP;AAaD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,kBAAS8qB,UAAT,EAAqB;AAAA;;AACnB,UAAI,CAACA,UAAL,EAAiB;AACf,cAAM,IAAI1E,kBAAJ,CAAmB,wCAAnB,CAAN;AACD;;AACD,UAAMoH,gBAAgB,GAAG,KAAK5qB,aAA9B;AAEA,WAAKmC,EAAL,GAAUC,cAAKC,EAALD,EAAV;AAEA,WAAKc,KAAL,CAAW2nB,QAAX,CAAoBC,iBAApB,CAAsCC,GAAtC,CAA0C,IAA1C;;AAEAnqB,uBAAQsU,SAARtU,CAAkB;AAChBwM,aAAK,EAAE+H,kBAAUiV,kBADD;AAEhB/U,eAAO,EAAE,IAFO;AAGhBvV,YAAI,EAAE;AACJuqB,2BAAiB,EAAE;AACjBC,cAAE,EAAE;AACF/mB,mBAAK,EAAE,IADL;AAEFiN,mBAAK,EAAE,IAFL;AAGF+Z,yBAAW,EAAE,IAHX;AAIF9rB,mBAAK,EAAE,IAJL;AAKFwU,wBAAU,EAAE;AALV,aADa;AAQjBuX,cAAE,EAAE;AACFjnB,mBAAK,EAAE,IADL;AAEFiN,mBAAK,EAAE,IAFL;AAGF+Z,yBAAW,EAAE,IAHX;AAIF9rB,mBAAK,EAAE,IAJL;AAKFwU,wBAAU,EAAE;AALV;AARa;AADf;AAHU,OAAlBrS;;AAsBAA,uBAAQsU,SAARtU,CAAkB;AAACwM,aAAK,EAAE+H,kBAAUsV,UAAlB;AAA8BpV,eAAO,EAAE;AAAvC,OAAlBzU;;AAEA,aAAOwV,cAAYoS,kBAAZpS,CAA+B,IAA/BA,EAAqCnZ,IAArCmZ,CAA0C,UAACqO,IAAD;AAAA,eAAUuG,OAAI,CAACpG,eAAL,CAAqB;AAACvmB,mBAAS,EAAE,IAAZ;AAAkBC,mBAAS,EAAE,IAA7B;AAAmCC,mBAAS,EAAE;AAA9C,SAArB,EACxDtB,IADwD,CACnD;AAAA;AAAA,cAAEwkB,WAAF;AAAA,cAAeE,UAAf;;AAAA,iBACJqJ,OAAI,CAACjpB,WAAL,CAAiB;AACfif,yBAAa,EAAE;AACb3iB,uBAAS,EAAE,IADE;AACIia,0BAAY,EAAE,IADlB;AACwBha,uBAAS,EAAE,IADnC;AACyCka,0BAAY,EAAE,IADvD;AAC6Dja,uBAAS,EAAE,KADxE;AAC+EwW,0BAAY,EAAE;AAD7F,aADA;AAIf0M,uBAAW,EAAXA,WAJe;AAKfE,sBAAU,EAAVA;AALe,WAAjB,EAOG1kB,IAPH,CAOQ;AAAA,mBAAMgC,iBAAQkK,OAAR,CAAgBsb,IAAhB,CAAN;AAPR,YADI;AADmD,WAUxDxnB,IAVwD,CAUnD;AAAA,iBAAMmZ,cAAY6U,YAAZ7U,CAAyB4U,OAAzB5U,EAA+B;AAAC8R,sBAAU,EAAVA,UAAD;AAAaloB,yBAAa,EAAE4qB,gBAA5B;AAA8CM,uBAAW,EAAE;AAA3D,WAA/B9U,CAAN;AAVmD,UAAV;AAA1C,SAWJnZ,IAXImZ,CAWC,YAAM;AACV4U,eAAI,CAAC9nB,KAAL,CAAW2nB,QAAX,CAAoBC,iBAApB,CAAsCK,MAAtC,CAA6CH,OAAI,CAAC7oB,EAAlD;;AAEA,eAAOlD,iBAAQkK,OAAR,EAAP;AAdG,QAAP;AAgBD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAmHE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,wBAAuB;AAAA;;AAAA,UAAdvL,OAAc,uEAAJ,EAAI;AACrB,UAAM6lB,UAAU,GAAG,4BAAnB;;AAEA,UAAI,KAAK2H,YAAL,KAAsBC,sBAAWC,MAArC,EAA6C;AAC3C,eAAOrsB,iBAAQC,MAAR,CAAe,IAAIqsB,kCAAJ,EAAf,CAAP;AACD;;AAED,UAAInV,cAAYoV,iBAAZpV,CAA8B,KAAK3P,SAAnC2P,CAAJ,EAAmD;AACjD,eAAOnX,iBAAQC,MAAR,CAAe,IAAIokB,+BAAJ,EAAf,CAAP;AARmB,QAUrB;;;AACA,UAAI,KAAKmI,KAAL,IAAcrV,cAAYsV,iBAAZtV,CAA8B,KAAK3P,SAAnC2P,CAAd,IAA+D,CAAC,KAAK6C,aAAzE,EAAwF;AACtF,eAAOha,iBAAQC,MAAR,CAAe,IAAIysB,6BAAJ,EAAf,CAAP;AACD;;AAED,UAAOlK,WAAP,GAAiD7jB,OAAjD,CAAO6jB,WAAP;AAAA,UAAoBE,UAApB,GAAiD/jB,OAAjD,CAAoB+jB,UAApB;AAAA,UAAgCX,aAAhC,GAAiDpjB,OAAjD,CAAgCojB,aAAhC;;AAEAlkB,2BAAYC,MAAZD,CAAmBE,IAAnBF,WAA2B2mB,UAA3B;;AAEA7iB,uBAAQsU,SAARtU,CAAkB;AAChBwM,aAAK,EAAE+H,kBAAUiV,kBADD;AAEhB/U,eAAO,EAAE,IAFO;AAGhBvV,YAAI,EAAE;AACJuqB,2BAAiB,EAAE;AACjBC,cAAE,EAAE;AACF/mB,mBAAK,EAAE,KADL;AAEFiN,mBAAK,EAAE,KAFL;AAGF+Z,yBAAW,EAAE,KAHX;AAIF9rB,mBAAK,EAAE,KAJL;AAKFwU,wBAAU,EAAE;AALV,aADa;AAQjBuX,cAAE,EAAE;AACFjnB,mBAAK,EAAE,KADL;AAEFiN,mBAAK,EAAE,KAFL;AAGF+Z,yBAAW,EAAE,KAHX;AAIF9rB,mBAAK,EAAE,KAJL;AAKFwU,wBAAU,EAAE;AALV;AARa;AADf;AAHU,OAAlBrS;;AAuBA,aAAOwV,cAAYwV,eAAZxV,CAA4BxY,OAA5BwY,EACJnZ,IADImZ,CACC,YAAM;AACVyV,eAAI,CAAC3tB,eAAL,CAAqB4tB,sBAArB,CAA4CzM,eAAU0M,oBAAV1M,EAA5C;;AACAwM,eAAI,CAACG,kBAAL;;AACAhJ,uCAAsBiJ,uBAAtBjJ,CAA8C6I,OAA9C7I;;AAEA,eAAO6I,OAAI,CAACK,QAAL,CAAczK,WAAd,EAA2BE,UAA3B,EAAuCX,aAAvC,CAAP;AANG,SAQJ/jB,IARImZ,CAQC;AAAA,eAAMrX,eAAMotB,WAANptB,CAAkB8sB,OAAI,CAAC3tB,eAAvBa,EAAwC;AAClDua,mBAAS,EAAEuS,OAAI,CAAC1pB,EADkC;AAElDiqB,4BAAkB,EAAEP,OAAI,CAAC3tB,eAAL,CAAqBkuB,kBAFS;AAGlDC,mBAAS,EAAER,OAAI,CAACnsB,MAAL,CAAY2sB,SAH2B;AAIlDC,sBAAY,EAAET,OAAI,CAACnsB,MAAL,CAAY4sB,YAJwB;AAKlDC,+CAAqC,EAAEV,OAAI,CAACU,qCAAL,CAA2C3lB,IAA3C,CAAgDilB,OAAhD;AALW,SAAxC9sB,EAOT9B,IAPS8B,CAOJ,UAAC+F,cAAD;AAAA,iBAAoB+mB,OAAI,CAAC/qB,UAAL,GAAkB7D,IAAlB,CAAuB,UAACuvB,OAAD,EAAa;AAC5DpW,0BAAYqW,mBAAZrW,CAAgCoW,OAAhCpW;;AAEA,mBAAOtR,cAAP;AAHwB,YAApB;AAPI,WAYT7H,IAZS8B,CAYJ,UAAC+F,cAAD,EAAoB;AACxB+mB,iBAAI,CAACa,kBAAL,CAAwBb,OAAI,CAAC3tB,eAA7B;;AACApB,+BAAYC,MAAZD,CAAmBE,IAAnBF,WAA2B2mB,UAA3B;;AAEAoI,iBAAI,CAACc,eAAL,CAAqB7nB,cAArB;;AACAsR,wBAAYwW,kBAAZxW,CAA+ByV,OAA/BzV;;AAEA,cAAIyV,OAAI,CAACnsB,MAAL,CAAY8P,OAAZ,CAAoBqd,WAAxB,EAAqC;AACnChB,mBAAI,CAACiB,wBAAL;AACD;;AAED,cAAIjB,OAAI,CAACnsB,MAAL,CAAYiE,KAAZ,CAAkBopB,mBAAtB,EAA2C;AACzC;AACAlB,mBAAI,CAACvlB,qBAAL,GAA6B,IAAI0mB,8BAAJ,CAA0BnB,OAAI,CAACnsB,MAAL,CAAYiE,KAAtC,CAA7B;AACAkoB,mBAAI,CAACxlB,aAAL,GAAqB,IAAI4mB,sBAAJ,CAAkBpB,OAAI,CAACnsB,MAAL,CAAYiE,KAA9B,EAAqCkoB,OAAI,CAACvlB,qBAA1C,CAArB;;AACAulB,mBAAI,CAACxlB,aAAL,CAAmBoF,EAAnB,CAAsBpK,0BAAe6rB,aAArC,EAAoD,UAACtvB,OAAD,EAAa;AAAA,yCAC/D;AACA;;;AACAA,qBAAO,CAACkC,IAARlC,CAAauvB,gBAAbvvB,CAA8BwvB,eAA9BxvB,GAAgD,iCAAI,CAACsF,KAAL,CAAW2nB,QAAX,CAAoBwC,WAApB,gFAAiCC,aAAjC,KAAkD1vB,OAAO,CAACkC,IAARlC,CAAauvB,gBAAbvvB,CAA8BwvB,eAAhF,IAAmGje,qBAAUoe,UAA7J3vB;;AACAgD,+BAAQsU,SAARtU,CAAkB;AAACwM,qBAAK,EAAE+H,kBAAU+X,aAAlB;AAAiC7X,uBAAO,EAAEwW,OAA1C;AAAgD/rB,oBAAI,EAAE;AAAC0tB,8BAAY,EAAE5vB,OAAO,CAACkC,IAAvB;AAA6B2tB,6BAAW,EAAE7vB,OAAO,CAAC6vB;AAAlD;AAAtD,eAAlB7sB;AAJF;;AAMAirB,mBAAI,CAACvlB,qBAAL,CAA2BmF,EAA3B,CAA8BpK,0BAAeqsB,eAA7C,EAA8D7B,OAAI,CAAC8B,uBAAL,CAA6B/mB,IAA7B,CAAkCilB,OAAlC,CAA9D;AACD;AAlCO,WAoCT1uB,KApCS4B,CAoCH,UAAC3B,KAAD,EAAW;AAChBN,+BAAYC,MAAZD,CAAmBM,KAAnBN,WAA4B2mB,UAA5B,wDAA2FrmB,KAA3FN;;AAEA8D,2BAAQC,oBAARD,CACEhB,8BAAmBguB,iBADrBhtB,EAEE;AACEb,0BAAc,EAAE8rB,OAAI,CAAC7rB,aADvB;AAEEC,oBAAQ,EAAE4rB,OAAI,CAAC3rB,QAAL,CAAcE,KAAd,CAAoB,GAApB,EAAyBC,GAAzB,EAFZ;AAGEC,kBAAM,EAAElD,KAAK,CAACmD,OAHhB;AAIEC,iBAAK,EAAEpD,KAAK,CAACoD;AAJf,WAFFI;;AAUA,gBAAMxD,KAAN;AAjDQ,WAmDTH,IAnDS8B,CAmDJ;AAAA,iBAAM,qBAAY,UAACoK,OAAD,EAAUjK,MAAV,EAAqB;AAC3C,gBAAI2uB,UAAU,GAAG,CAAjB,CAD2C,CAG3C;AACA;;AACA,gBAAIhC,OAAI,CAACnrB,IAAL,KAAc0c,iBAAlB,EAA0B;AACxBjU,qBAAO;AACR;;AACD,gBAAM2kB,YAAY,GAAGlT,WAAW,CAAC,YAAM;AACrCiT,wBAAU,IAAI,CAAdA;;AACA,kBAAIhC,OAAI,CAACT,YAAL,KAAsBC,sBAAWC,MAArC,EAA6C;AAC3ChR,6BAAa,CAACwT,YAAD,CAAbxT;AACAnR,uBAAO;AACR;;AAED,kBAAI0kB,UAAU,KAAK,CAAnB,EAAsB;AACpBvT,6BAAa,CAACwT,YAAD,CAAbxT;AACApb,sBAAM,CAAC,IAAIoJ,KAAJ,CAAU,8BAAV,CAAD,CAANpJ;AACD;AAV6B,eAW7B,IAX6B,CAAhC;AARU,YAAN;AAnDI,WAwETjC,IAxES8B,CAwEJ;AAAA,iBACJtC,UAAU,CAACovB,OAAI,CAAC1oB,IAAL,CACR4qB,oBADQ,CACa;AACpBC,eAAG,EAAEnC,OAAI,CAAC3tB,eAAL,CAAqB4G,cAArB,CAAoCkpB,GADrB;AAEpBtrB,mBAAO,EAAEmpB,OAAI,CAACnpB,OAFM;AAGpB2S,mBAAO,EAAEwW,OAHW,CAGN;;AAHM,WADb,CAAD,EAKJ;AACJlvB,kBAAM,YAAK8mB,UAAL,8BADF;AAEJ7mB,mBAAO,YAAK6mB,UAAL,0CAFH;AAGJ5mB,mBAAO,YAAK4mB,UAAL;AAHH,WALI,CADN;AAxEI,WAmFTxmB,IAnFS8B,CAmFJ,YAAM;AACV,cAAO+F,cAAP,GAAyB+mB,OAAI,CAAC3tB,eAAL,CAAlB4G,cAAP;AAEA,iBAAO,qBAAY,UAACqE,OAAD,EAAUjK,MAAV,EAAqB;AACtC,gBAAI4F,cAAc,CAACmpB,eAAfnpB,KAAmCopB,4BAAiBre,SAAxD,EAAmE;AACjE/S,mCAAYC,MAAZD,CAAmBE,IAAnBF,WAA2B2mB,UAA3B;;AAEAta,qBAAO,CAACrE,cAAD,CAAPqE;AAEA;AANoC,cAQtC;;;AACA,gBAAMglB,gBAAgB,GAAGC,UAAU,CAAC,YAAM;AACxC,kBAAItpB,cAAc,CAACmpB,eAAfnpB,KAAmCopB,4BAAiBre,SAAxD,EAAmE;AACjE;AACA3Q,sBAAM,CAAC,sCAAoB,KAApB,EAA2B,2BAA3B,CAAD,CAANA;AAFF,qBAIK;AACHpC,qCAAYC,MAAZD,CAAmBE,IAAnBF,WAA2B2mB,UAA3B;;AACAta,uBAAO,CAACrE,cAAD,CAAPqE;AACD;AARgC,eAShCklB,0BATgC,CAAnC;;AAWAxC,mBAAI,CAACyC,IAAL,CAAUjtB,0BAAe8d,WAAzB,EAAsC,YAAM;AAC1CriB,mCAAYC,MAAZD,CAAmBE,IAAnBF,WAA2B2mB,UAA3B;;AACA8K,0BAAY,CAACJ,gBAAD,CAAZI;AACAplB,qBAAO,CAACrE,cAAD,CAAPqE;AAHF;AApBK,YAAP;AAtFQ,WAiHTlM,IAjHS8B,CAiHJ,YAAM;AACV,cAAIiiB,aAAa,IAAIA,aAAa,CAACziB,SAA/ByiB,IAA4CW,UAAhD,EAA4D;AAC1D,gBAAIkK,OAAI,CAACzb,KAAL,KAAeC,yBAAcC,MAAdD,CAAqBE,MAAxC,EAAgD;AAC9C,qBAAOsb,OAAI,CAACrb,KAAL,EAAP;AAFwD,cAK1D;;;AACAqb,mBAAI,CAAChmB,iBAAL,GAAyB,IAAzB;AACD;;AAEDjF,2BAAQC,oBAARD,CACEhB,8BAAmB4uB,iBADrB5tB,EAEE;AACEb,0BAAc,EAAE8rB,OAAI,CAAC7rB,aADvB;AAEEC,oBAAQ,EAAE4rB,OAAI,CAAC3rB,QAAL,CAAcE,KAAd,CAAoB,GAApB,EAAyBC,GAAzB;AAFZ,WAFFO;;AAQA,iBAAO3B,iBAAQkK,OAAR,EAAP;AAnIQ,UAAN;AARD,SA6IJhM,KA7IIiZ,CA6IE,UAAChZ,KAAD,EAAW;AAChB;AACA,YAAIyuB,OAAI,CAACxlB,aAAT,EAAwB;AACtBwlB,iBAAI,CAACxlB,aAAL,CAAmBooB,YAAnB;;AACA5C,iBAAI,CAACxlB,aAAL,GAAqB,IAArB;AACD;;AACD,YAAIwlB,OAAI,CAAC3tB,eAAL,CAAqB4G,cAAzB,EAAyC;AACvC+mB,iBAAI,CAAC6C,oBAAL;;AACA7C,iBAAI,CAAC8C,oBAAL;AACD;;AAED7xB,6BAAYC,MAAZD,CAAmBM,KAAnBN,WAA4B2mB,UAA5B,mEAAsGrmB,KAAtGN;;AAEA8D,yBAAQC,oBAARD,CACEhB,8BAAmBguB,iBADrBhtB,EAEE;AACEb,wBAAc,EAAE8rB,OAAI,CAAC7rB,aADvB;AAEEC,kBAAQ,EAAE4rB,OAAI,CAAC3rB,QAAL,CAAcE,KAAd,CAAoB,GAApB,EAAyBC,GAAzB,EAFZ;AAGEC,gBAAM,EAAElD,KAAK,CAACmD,OAHhB;AAIEC,eAAK,EAAEpD,KAAK,CAACoD,KAJf;AAKEiI,cAAI,EAAErL,KAAK,CAACqL;AALd,SAFF7H,EAbgB,CAwBhB;;;AACAK,8BAAQC,OAARD,CACE4qB,OADF5qB,EAEE;AACEE,cAAI,EAAE,eADR;AAEEC,kBAAQ,EAAE;AAFZ,SAFFH,EAMEyK,kBAAOK,mBANT9K,EAOE4qB,OAPF5qB,EAzBgB,CAmChB;AACA;AACA;;;AACA,YAAI7D,KAAK,CAACqL,IAANrL,KAAewxB,6BAAgBC,IAAnC,EAAyC;AACvChD,iBAAI,CAAC9S,KAAL,CAAW;AAACzY,kBAAM,EAAEwuB,kCAAuBC;AAAhC,WAAX;AACD;;AAED,cAAM3xB,KAAN;AAvLG,QAAP;AAyLD;AAED;AACF;AACA;AACA;;;;WACE,0BAAiB;AACf,aAAO,KAAKc,eAAL,CAAqB4G,cAArB,CAAoCkqB,cAApC,KAAuDC,eAAIC,MAA3D,IAAqE,CAACC,oBAAeC,MAAfD,CAAsB,KAAKnvB,aAA3BmvB,CAA7E;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,4BAAmBttB,eAAnB,EAAoCjE,OAApC,EAA6C;AAAA;;AAC3C,aAAO,qBAAY,UAACuL,OAAD,EAAUjK,MAAV,EAAqB;AACtC,YAAMmwB,SAAS,GAAG;AAChB1tB,+BAAqB,EAAEwH,OADP;AACgBvH,8BAAoB,EAAE1C,MADtC;AAC8C2C,yBAAe,EAAfA,eAD9C;AAC+DjE,iBAAO,EAAPA;AAD/D,SAAlB;;AAIAd,6BAAYC,MAAZD,CAAmBgF,GAAnBhF,4EAA2F+E,eAA3F;;AACAytB,eAAI,CAAC9tB,kBAAL,CAAwB+tB,IAAxB,CAA6BF,SAA7B;AANK,QAAP;AAQD;AAED;AACF;AACA;AACA;AACA;AACA;;;;;AAiDE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,2BAA0B;AAAA;;AAAA,UAAdzxB,OAAc,uEAAJ,EAAI;AACxB,UAAM6lB,UAAU,GAAG,+BAAnB;;AAEA,UAAI,CAAC,KAAKliB,cAAL,EAAL,EAA4B;AAC1B,eAAO,KAAKiuB,kBAAL,CAAwBnyB,iBAAiB,CAACC,GAA1C,EAA+CM,OAA/C,CAAP;AACD;;AACD,UAAO6jB,WAAP,GAAiD7jB,OAAjD,CAAO6jB,WAAP;AAAA,UAAoBE,UAApB,GAAiD/jB,OAAjD,CAAoB+jB,UAApB;AAAA,UAAgCX,aAAhC,GAAiDpjB,OAAjD,CAAgCojB,aAAhC;AAEA,UAAMyO,uBAAuB,GAAG,KAAKvxB,eAAL,CAAqBH,cAArB,CAAoCQ,SAApE;AAEA,aAAO6X,cAAYwV,eAAZxV,CAA4BxY,OAA5BwY,EACJnZ,IADImZ,CACC;AAAA,eAAMsZ,OAAI,CAACxD,QAAL,CAAczK,WAAd,EAA2BE,UAA3B,EAAuCX,aAAvC,CAAN;AADD,SAEJ/jB,IAFImZ,CAEC;AAAA,eAAMrX,eAAMgD,WAANhD,CAAkB2wB,OAAI,CAACxxB,eAAvBa,EAAwC;AAClDua,mBAAS,EAAEoW,OAAI,CAACvtB,EADkC;AAElDiqB,4BAAkB,EAAEsD,OAAI,CAACxxB,eAAL,CAAqBkuB,kBAFS;AAGlDC,mBAAS,EAAEqD,OAAI,CAAChwB,MAAL,CAAY2sB,SAH2B;AAIlDC,sBAAY,EAAEoD,OAAI,CAAChwB,MAAL,CAAY4sB;AAJwB,SAAxCvtB,EAMT9B,IANS8B,CAMJ,UAAC+F,cAAD,EAAoB;AACxBhI,+BAAYC,MAAZD,CAAmBE,IAAnBF,WAA2B2mB,UAA3B,wDAAmF3e,cAAnF;;AACA4qB,iBAAI,CAAC/C,eAAL,CAAqB7nB,cAArB;;AACA,cAAIkc,aAAa,CAACjM,YAAdiM,IAA8BW,UAAlC,EAA8C;AAC5CqB,2CAAsB2M,gBAAtB3M,CAAuCle,cAAvCke;AACD;AAXO,WAaT7lB,KAbS4B,CAaH,UAAC3B,KAAD,EAAW;AAChBN,+BAAYC,MAAZD,CAAmBM,KAAnBN,WAA4B2mB,UAA5B,4BAA+DrmB,KAA/DN;;AAEA8D,2BAAQC,oBAARD,CACEhB,8BAAmBgwB,oBADrBhvB,EAEE;AACEb,0BAAc,EAAE2vB,OAAI,CAAC1vB,aADvB;AAEEC,oBAAQ,EAAEyvB,OAAI,CAACxvB,QAAL,CAAcE,KAAd,CAAoB,GAApB,EAAyBC,GAAzB,EAFZ;AAGEC,kBAAM,EAAElD,KAAK,CAACmD,OAHhB;AAIEC,iBAAK,EAAEpD,KAAK,CAACoD;AAJf,WAFFI;;AAUA,gBAAMxD,KAAN;AA1BQ,WA4BTH,IA5BS8B,CA4BJ;AAAA,iBACJtC,UAAU,CAACizB,OAAI,CAACvsB,IAAL,CACR4qB,oBADQ,CACa;AACpBC,eAAG,EAAE0B,OAAI,CAACxxB,eAAL,CAAqB4G,cAArB,CAAoCkpB,GADrB;AAEpBtrB,mBAAO,EAAEgtB,OAAI,CAAChtB,OAFM;AAGpB2S,mBAAO,EAAEqa,OAHW,CAGN;;AAHM,WADb,CAAD,EAMV;AACE/yB,kBAAM,YAAK8mB,UAAL,qCADR;AAEE7mB,mBAAO,YAAK6mB,UAAL,qCAFT;AAGE5mB,mBAAO,YAAK4mB,UAAL;AAHT,WANU,CADN;AA5BI,WAwCTxmB,IAxCS8B,CAwCJ;AAAA,iBAAM2wB,OAAI,CAACG,iBAAL,CAAuB7O,aAAa,CAACziB,SAArC,EAAgDkxB,uBAAhD,CAAN;AAxCI,WAyCTxyB,IAzCS8B,CAyCJ,UAAC+wB,UAAD,EAAgB;AACpB;AACA;AACA,cAAIA,UAAJ,EAAgB;AACd;AACA,mBAAOJ,OAAI,CAAClf,KAAL,EAAP;AACD;;AAED,iBAAOvR,iBAAQkK,OAAR,EAAP;AAjDQ,UAAN;AAFD,QAAP;AAqDD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,qBAAYvL,OAAZ,EAAqB;AAAA;;AACnB,UAAI,CAAC,KAAK2D,cAAL,EAAL,EAA4B;AAC1B,eAAO,KAAKiuB,kBAAL,CAAwBnyB,iBAAiB,CAACE,KAA1C,EAAiDK,OAAjD,CAAP;AACD;;AACD,UAAOS,SAAP,GAA0CT,OAA1C,CAAOS,SAAP;AAAA,UAAkBia,YAAlB,GAA0C1a,OAA1C,CAAkB0a,YAAlB;AAAA,UAAgC8G,MAAhC,GAA0CxhB,OAA1C,CAAgCwhB,MAAhC;AACA,UAAOd,gBAAP,GAA2B,KAAKpgB,eAAL,CAAqB4G,cAArB,CAApBwZ,gBAAP;;AACA,UAAMlZ,KAAK,GAAGgR,cAAYsL,QAAZtL,CAAqBgJ,MAArBhJ,EAA6BoK,UAA3C;;AAEA,UAAI,OAAOniB,SAAP,KAAqB,SAArB,IAAkC,OAAOia,YAAP,KAAwB,SAA9D,EAAyE;AACvE,eAAOrZ,iBAAQC,MAAR,CAAe,IAAIskB,kBAAJ,CAAmB,2CAAnB,CAAf,CAAP;AACD;;AAED,aAAOpN,cAAYwV,eAAZxV,CAA4B;AAAC/X,iBAAS,EAATA,SAAD;AAAYojB,mBAAW,EAAErC;AAAzB,OAA5BhJ,EACJnZ,IADImZ,CACC,YAAM;AACV,YAAI2Z,sBAAsB,GAAG,EAA7B;;AAEA,YAAIC,OAAI,CAAC9xB,eAAL,CAAqBH,cAAzB,EAAyC;AACvCgyB,gCAAsB,GAAG;AACvBE,qBAAS,EAAED,OAAI,CAAC9xB,eAAL,CAAqBH,cAArB,CAAoCM,SADxB;AAEvB6xB,wBAAY,EAAEF,OAAI,CAAC9xB,eAAL,CAAqBH,cAArB,CAAoCua;AAF3B,WAAzByX;AADF,eAMK;AACHC,iBAAI,CAAC9xB,eAAL,CAAqBH,cAArB,GAAsC,EAAtC;AACD;;AAED,eAAOqY,cAAY+Z,iBAAZ/Z,CACL;AACE1V,cAAI,EAAE,OADR;AAEEuvB,mBAAS,EAAEryB,OAAO,CAACS,SAFrB;AAGE6xB,sBAAY,EAAEtyB,OAAO,CAAC0a,YAHxB;AAIElT,eAAK,EAALA,KAJF;AAKE+Y,qBAAW,EAAEG,gBALf;AAMExZ,wBAAc,EAAEkrB,OAAI,CAAC9xB,eAAL,CAAqB4G,cANvC;AAOEirB,gCAAsB,EAAtBA;AAPF,SADK3Z,EAUL;AACElY,yBAAe,EAAE8xB,OAAI,CAAC9xB,eADxB;AAEEmX,iBAAO,EAAE2a,OAFX;AAGE7tB,YAAE,EAAE6tB,OAAI,CAAC7tB;AAHX,SAVKiU,CAAP;AAdG,SA+BJnZ,IA/BImZ,CA+BC,YAAM;AACV4Z,eAAI,CAAC/O,kBAAL,CAAwB7b,KAAxB;;AACA4qB,eAAI,CAAC9xB,eAAL,CAAqBH,cAArB,CAAoCM,SAApC,GAAgDA,SAAhD;AACA2xB,eAAI,CAAC9xB,eAAL,CAAqBH,cAArB,CAAoCua,YAApC,GAAmDA,YAAnD,CAHU,CAKV;;AACA0X,eAAI,CAACzsB,KAAL,GAAaysB,OAAI,CAACzsB,KAAL,IAAc,wBAAgBhG,gBAAhB,EAAuByyB,OAAvB,EAA6BA,OAAI,CAAC9xB,eAAL,CAAqBH,cAAlD,CAA3B;AArCG,QAAP;AAuCD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,qBAAYH,OAAZ,EAAqB;AAAA;;AACnB,UAAI,CAAC,KAAK2D,cAAL,EAAL,EAA4B;AAC1B,eAAO,KAAKiuB,kBAAL,CAAwBnyB,iBAAiB,CAACG,KAA1C,EAAiDI,OAAjD,CAAP;AACD;;AACD,UAAOU,SAAP,GAA0CV,OAA1C,CAAOU,SAAP;AAAA,UAAkBka,YAAlB,GAA0C5a,OAA1C,CAAkB4a,YAAlB;AAAA,UAAgC4G,MAAhC,GAA0CxhB,OAA1C,CAAgCwhB,MAAhC;AACA,UAAOb,gBAAP,GAA2B,KAAKrgB,eAAL,CAAqB4G,cAArB,CAApByZ,gBAAP;;AACA,UAAMnZ,KAAK,GAAGgR,cAAYsL,QAAZtL,CAAqBgJ,MAArBhJ,EAA6BqK,UAA3C;;AAEA,UAAI,OAAOniB,SAAP,KAAqB,SAArB,IAAkC,OAAOka,YAAP,KAAwB,SAA9D,EAAyE;AACvE,eAAOvZ,iBAAQC,MAAR,CAAe,IAAIskB,kBAAJ,CAAmB,2CAAnB,CAAf,CAAP;AACD;;AAED,aAAOpN,cAAYwV,eAAZxV,CAA4B;AAAC9X,iBAAS,EAATA,SAAD;AAAYmjB,mBAAW,EAAErC;AAAzB,OAA5BhJ,EACJnZ,IADImZ,CACC;AAAA,eAAMA,cAAY+Z,iBAAZ/Z,CAA8B;AACxC1V,cAAI,EAAE,OADkC;AAExCuvB,mBAAS,EAAEryB,OAAO,CAACU,SAFqB;AAGxC4xB,sBAAY,EAAEtyB,OAAO,CAAC4a,YAHkB;AAIxCpT,eAAK,EAALA,KAJwC;AAKxC+Y,qBAAW,EAAEI,gBAL2B;AAMxCzZ,wBAAc,EAAEsrB,OAAI,CAAClyB,eAAL,CAAqB4G,cANG;AAOxCirB,gCAAsB,EAAE;AACtBE,qBAAS,EAAEG,OAAI,CAAClyB,eAAL,CAAqBH,cAArB,CAAoCO,SADzB;AAEtB4xB,wBAAY,EAAEE,OAAI,CAAClyB,eAAL,CAAqBH,cAArB,CAAoCya;AAF5B;AAPgB,SAA9BpC,EAYZ;AACElY,yBAAe,EAAEkyB,OAAI,CAAClyB,eADxB;AAEEmX,iBAAO,EAAE+a,OAFX;AAGEjuB,YAAE,EAAEiuB,OAAI,CAACjuB;AAHX,SAZYiU,CAAN;AADD,SAkBJnZ,IAlBImZ,CAkBC,YAAM;AACVga,eAAI,CAAC5O,kBAAL,CAAwBpc,KAAxB;;AACAgrB,eAAI,CAAClyB,eAAL,CAAqBH,cAArB,CAAoCO,SAApC,GAAgDA,SAAhD;AACA8xB,eAAI,CAAClyB,eAAL,CAAqBH,cAArB,CAAoCya,YAApC,GAAmDA,YAAnD,CAHU,CAKV;;AACA4X,eAAI,CAAC3xB,KAAL,GAAa2xB,OAAI,CAAC3xB,KAAL,IAAc,wBAAgBjB,gBAAhB,EAAuB4yB,OAAvB,EAA6BA,OAAI,CAAClyB,eAAL,CAAqBH,cAAlD,CAA3B;AAxBG,QAAP;AA0BD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,2BAAkBQ,SAAlB,EAA6B8xB,mBAA7B,EAAkD;AAChD,UAAI9xB,SAAS,IAAI,CAAC8xB,mBAAlB,EAAuC;AACrC;AACA,eAAOpxB,iBAAQkK,OAAR,CAAgB,IAAhB,CAAP;AACD;;AAED,UAAI,CAAC5K,SAAD,IAAc8xB,mBAAlB,EAAuC;AACrC;AACA,eAAO,KAAKC,gBAAL,GACJrzB,IADI,CACC;AAAA,iBAAMgC,iBAAQkK,OAAR,CAAgB,KAAhB,CAAN;AADD,UAAP;AAED;;AAED,aAAOlK,iBAAQkK,OAAR,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,qBAAYvL,OAAZ,EAAqB;AAAA;;AACnB,UAAI,CAACA,OAAO,CAACsW,kBAAT,IAA+B,CAAC,KAAK3S,cAAL,EAApC,EAA2D;AACzD,eAAO,KAAKiuB,kBAAL,CAAwBnyB,iBAAiB,CAACI,KAA1C,EAAiDG,OAAjD,CAAP;AACD;;AACD,UAAOW,SAAP,GAA0CX,OAA1C,CAAOW,SAAP;AAAA,UAAkBwW,YAAlB,GAA0CnX,OAA1C,CAAkBmX,YAAlB;AAAA,UAAgCqK,MAAhC,GAA0CxhB,OAA1C,CAAgCwhB,MAAhC;AACA,UAAOva,gBAAP,GAA2B,KAAK3G,eAAL,CAAqB4G,cAArB,CAApBD,gBAAP;;AACA,UAAMO,KAAK,GAAGgR,cAAYsL,QAAZtL,CAAqBgJ,MAArBhJ,EAA6BqK,UAA3C;;AAEA,UAAI,OAAOliB,SAAP,KAAqB,SAArB,IAAkC,OAAOwW,YAAP,KAAwB,SAA9D,EAAyE;AACvE,eAAO9V,iBAAQC,MAAR,CAAe,IAAIskB,kBAAJ,CAAmB,2CAAnB,CAAf,CAAP;AACD;;AACD,UAAMiM,uBAAuB,GAAG,KAAKvxB,eAAL,CAAqBH,cAArB,CAAoCQ,SAApE;AAEA,WAAKqjB,kBAAL,CAAwBxC,MAAxB;AAEA,aAAOhJ,cAAYwV,eAAZxV,CAA4B;AAAC7X,iBAAS,EAATA,SAAD;AAAYojB,kBAAU,EAAEvC;AAAxB,OAA5BhJ,EACJnZ,IADImZ,CACC;AAAA,eAAMma,OAAI,CAACV,iBAAL,CAAuBtxB,SAAvB,EAAkCkxB,uBAAlC,CAAN;AADD,SAEJxyB,IAFImZ,CAEC,UAAC0Z,UAAD;AAAA,eAAgB1Z,cAAY+Z,iBAAZ/Z,CAA8B;AAClD1V,cAAI,EAAE,OAD4C;AAElDuvB,mBAAS,EAAE1xB,SAFuC;AAGlD2xB,sBAAY,EAAEnb,YAHoC;AAIlD3P,eAAK,EAALA,KAJkD;AAKlD+Y,qBAAW,EAAEtZ,gBALqC;AAMlDC,wBAAc,EAAEyrB,OAAI,CAACryB,eAAL,CAAqB4G,cANa;AAOlDirB,gCAAsB,EAAE;AACtBE,qBAAS,EAAEM,OAAI,CAACryB,eAAL,CAAqBH,cAArB,CAAoCQ,SADzB;AAEtB2xB,wBAAY,EAAEK,OAAI,CAACryB,eAAL,CAAqBH,cAArB,CAAoCgX;AAF5B;AAP0B,SAA9BqB,EAYtB;AACElY,yBAAe,EAAEqyB,OAAI,CAACryB,eADxB;AAEEmX,iBAAO,EAAEkb,OAFX;AAGEpuB,YAAE,EAAEouB,OAAI,CAACpuB;AAHX,SAZsBiU,EAiBnBnZ,IAjBmBmZ,CAiBd,YAAM;AACV,cAAI0Z,UAAJ,EAAgB;AACd,mBAAOS,OAAI,CAAC/f,KAAL,EAAP;AACD;;AAED,iBAAOvR,iBAAQkK,OAAR,EAAP;AAtBkB,UAAhB;AAFD,SA0BJlM,IA1BImZ,CA0BC,YAAM;AACVma,eAAI,CAACryB,eAAL,CAAqBH,cAArB,CAAoCQ,SAApC,GAAgDA,SAAhD;AACAgyB,eAAI,CAACryB,eAAL,CAAqBH,cAArB,CAAoCgX,YAApC,GAAmDA,YAAnD;AA5BG,SA8BJ5X,KA9BIiZ,CA8BE,UAAChZ,KAAD,EAAW;AAChBmzB,eAAI,CAAC9N,oBAAL,CAA0BrD,MAA1B;;AACA,cAAMhiB,KAAN;AAhCG,SAkCJ4X,OAlCIoB,CAkCI,YAAM;AACb,YAAMoa,KAAK,GAAG,GAAd,CADa,CAEb;;AACA,YAAMC,mBAAmB,GAAGF,OAAI,CAACryB,eAAL,CAAqB4G,cAArB,CAAoCD,gBAApC,CAAqDG,SAArD,KAAmEU,mBAA/F;AACA,YAAMgrB,kBAAkB,GAAGD,mBAAmB,IAAI,CAACF,OAAI,CAACI,gBAAxD;;AAEA,YAAID,kBAAJ,EAAwB;AACtB;AACA;AACA;AACAtC,oBAAU,CACR;AAAA,mBAAMmC,OAAI,CAACrO,qBAAL,CAA2B9C,MAA3B,CAAN;AADQ,aAERoR,KAFQ,CAAVpC;AAID;AAhDE,QAAP;AAkDD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,kBAAS3M,WAAT,EAAsBE,UAAtB,EAAkCX,aAAlC,EAAiD;AAC/C;AACA;AACA,WAAK9iB,eAAL,CAAqB0yB,iBAArB,CAAuC,qBAAc,KAAKlxB,MAAL,CAAYshB,aAA1B,EAAyCA,aAAzC,CAAvC,EAH+C,CAI/C;AACA;;AACA,WAAKzd,KAAL,GAAa,KAAKA,KAAL,IAAc,wBAAgBhG,gBAAhB,EAAuB,IAAvB,EAA6B,KAAKW,eAAL,CAAqBH,cAAlD,CAA3B;AACA,WAAKU,KAAL,GAAa,KAAKA,KAAL,IAAc,wBAAgBjB,gBAAhB,EAAuB,IAAvB,EAA6B,KAAKU,eAAL,CAAqBH,cAAlD,CAA3B,CAP+C,CAQ/C;;AACA,WAAK8yB,cAAL,CAAoBpP,WAApB;AACA,WAAKG,kBAAL,CAAwBD,UAAxB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,qBAAYjhB,IAAZ,EAAkB;AAAA;;AAChB,UAAI,CAACA,IAAL,EAAW;AACT,eAAOzB,iBAAQC,MAAR,CAAe,IAAIskB,kBAAJ,CAAmB,8CAAnB,CAAf,CAAP;AACD;;AACD,UAAI9iB,IAAI,KAAKowB,qBAAb,EAAyB;AACvB,eAAO,KAAK3sB,cAAL,CACJ4sB,kBADI,CACe;AAClB7wB,kBAAQ,EAAE,KAAKA,QADG;AAElBuC,mBAAS,EAAE,KAAKA,SAFE;AAGlBzC,uBAAa,EAAE,KAAKA;AAHF,SADf,EAMJ/C,IANI,CAMC,UAACuN,QAAD;AAAA,iBAAcvL,iBAAQkK,OAAR,CAAgBqB,QAAhB,CAAd;AAND,WAOJvN,IAPI,CAOC,UAACuN,QAAD,EAAc;AAClBwmB,iBAAI,CAACxtB,yBAAL,CAA+BwkB,IAA/B,CAAoCtnB,IAApC;;AACAE,2BAAQsU,SAARtU,CAAkB;AAACwM,iBAAK,EAAE+H,kBAAU8b,eAAlB;AAAmC5b,mBAAO,EAAE2b;AAA5C,WAAlBpwB;;AAEA,iBAAO3B,iBAAQkK,OAAR,CAAgB;AACrBqB,oBAAQ,EAARA;AADqB,WAAhB,CAAP;AAXG,UAAP;AALc,QAsBhB;;;AACA,aAAOvL,iBAAQkK,OAAR,CAAgB;AACrB5I,eAAO,EAAE;AADY,OAAhB,CAAP;AAGD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,iBAAQD,MAAR,EAAgB;AAAA;;AACd,aAAO8V,cAAY8a,cAAZ9a,CAA2B,IAA3BA,EAAiC9V,MAAjC8V,EAAyCnZ,IAAzCmZ,CAA8C,UAAC+a,OAAD,EAAa;AAChEC,eAAI,CAAC5tB,yBAAL,CAA+B2tB,OAA/B;;AAEA,eAAOlyB,iBAAQkK,OAAR,CAAgBgoB,OAAhB,CAAP;AAHK,SAIJh0B,KAJIiZ,CAIE,UAAChZ,KAAD,EAAW;AAClBg0B,eAAI,CAAC5tB,yBAAL,CAA+BslB,IAA/B,CAAoC1rB,KAApC;;AAEA,eAAO6B,iBAAQC,MAAR,CAAe9B,KAAf,CAAP;AAPK,QAAP;AASD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,iBAAoB;AAAA;;AAAA,UAAdQ,OAAc,uEAAJ,EAAI;;AAClBgD,uBAAQsU,SAARtU,CAAkB;AAACwM,aAAK,EAAE+H,kBAAUkc,KAAlB;AAAyBhc,eAAO,EAAE,IAAlC;AAAwCvV,YAAI,EAAE;AAACoB,iBAAO,EAAEA,gBAAQ4iB,gBAAlB;AAAoCwN,oBAAU,EAAE;AAAhD;AAA9C,OAAlB1wB;;AACA,UAAM2wB,WAAW,GAAG3zB,OAAO,CAAC0C,MAAR1C,IAAkBkxB,kCAAuB0C,oBAA7D;;AAEA10B,2BAAYC,MAAZD,CAAmBgF,GAAnBhF,CAAuB,2CAAvBA;;AAEA,aAAOsZ,cAAY6U,YAAZ7U,CAAyB,IAAzBA,EAA+BxY,OAA/BwY,EACJnZ,IADImZ,CACC,UAAC2C,KAAD,EAAW;AACf0Y,eAAI,CAACjuB,yBAAL,CAA+BuV,KAA/B;;AACA0Y,eAAI,CAACluB,KAAL,GAAa,IAAb;AACAkuB,eAAI,CAAChzB,KAAL,GAAa,IAAb;AACAgzB,eAAI,CAACnyB,SAAL,GAAiB,KAAjB;;AACA,YAAImyB,OAAI,CAAClyB,WAAL,KAAqBC,wBAAaC,kBAAtC,EAA0D;AACxDgyB,iBAAI,CAAClyB,WAAL,GAAmBC,wBAAamF,QAAhC;AACD;;AACD8sB,eAAI,CAACjwB,kBAAL,GAA0B,EAA1B;;AAEA,YAAIiwB,OAAI,CAACjqB,aAAT,EAAwB;AACtBiqB,iBAAI,CAACjqB,aAAL,CAAmB+f,WAAnB;;AACAkK,iBAAI,CAACvL,sCAAL;;AACAuL,iBAAI,CAACjqB,aAAL,GAAqBT,SAArB;AAba,UAgBf;;;AACA9F,8BAAQC,OAARD,CACEwwB,OADFxwB,EAEE;AACEE,cAAI,EAAE,eADR;AAEEC,kBAAQ,EAAE;AAFZ,SAFFH,EAMEyK,kBAAOK,mBANT9K,EAOEwwB,OAPFxwB,EAjBe,CA2Bf;;;AACA,YAAIwwB,OAAI,CAACxY,aAAL,IAAsBwY,OAAI,CAAChG,KAA/B,EAAsC;AACpC;AACAxqB,gCAAQC,OAARD,CACEwwB,OADFxwB,EAEE;AACEE,gBAAI,EAAE,eADR;AAEEC,oBAAQ,EAAE;AAFZ,WAFFH,EAMEyK,kBAAOsN,eANT/X,EAOE;AACEX,kBAAM,EAAE1C,OAAO,CAAC0C,MADlB;AAEEgZ,qBAAS,EAAEmY,OAAI,CAACtvB;AAFlB,WAPFlB;AAYD;;AACDnE,6BAAYC,MAAZD,CAAmBgF,GAAnBhF,CAAuB,uCAAvBA,EAAgEy0B,WAAhEz0B;;AAEA,eAAOic,KAAP;AA9CG,SA+CF5b,KA/CEiZ,CA+CI,UAAChZ,KAAD,EAAW;AAClBq0B,eAAI,CAACjuB,yBAAL,CAA+BslB,IAA/B,CAAoC1rB,KAApC;;AACAN,6BAAYC,MAAZD,CAAmBM,KAAnBN,CAAyB,0CAAzBA,EAAqEM,KAArEN,EAFkB,CAGlB;;;AACAmE,8BAAQC,OAARD,CACEwwB,OADFxwB,EAEE;AACEE,cAAI,EAAE,eADR;AAEEC,kBAAQ,EAAE;AAFZ,SAFFH,EAMEyK,kBAAOK,mBANT9K,EAOEwwB,OAPFxwB;;AASAL,yBAAQC,oBAARD,CACEhB,8BAAmB8xB,qBADrB9wB,EAEE;AACEb,wBAAc,EAAE0xB,OAAI,CAACzxB,aADvB;AAEEC,kBAAQ,EAAEwxB,OAAI,CAACvxB,QAAL,CAAcE,KAAd,CAAoB,GAApB,EAAyBC,GAAzB,EAFZ;AAGEC,gBAAM,EAAElD,KAAK,CAACmD,OAHhB;AAIEC,eAAK,EAAEpD,KAAK,CAACoD,KAJf;AAKEiI,cAAI,EAAErL,KAAK,CAACqL;AALd,SAFF7H;;AAWA,eAAO3B,iBAAQC,MAAR,CAAe9B,KAAf,CAAP;AAvEG,QAAP;AAyED;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,8BAAqBu0B,UAArB,EAAiCC,aAAjC,EAAgD;AAAA;;AAC9C,UAAM3e,UAAU,GAAG,KAAKxM,SAAL,CAAeorB,WAAf,CAA2BhhB,IAA3B,CAAgC,UAACihB,OAAD;AAAA,eAAaA,OAAO,CAACnxB,IAARmxB,KAAiB,YAA9B;AAAhC,QAAnB;;AAEA,UAAI,CAACH,UAAL,EAAiB;AACf,eAAO1yB,iBAAQC,MAAR,CAAe,IAAIskB,kBAAJ,CAAmB,kCAAnB,CAAf,CAAP;AACD;;AAED,UAAIvQ,UAAJ,EAAgB;AACdrS,yBAAQsU,SAARtU,CAAkB;AAACwM,eAAK,EAAE+H,kBAAU4c,0BAAlB;AAA8C1c,iBAAO,EAAE;AAAvD,SAAlBzU;;AAEA,YAAMkI,IAAI,GAAG;AACX0K,qBAAW,EAAEK,wBAAaC,OADf;AAEXke,mBAAS,EAAE,KAAKvrB,SAAL,CAAegK,IAAf,CAAoBzN,GAFpB;AAGXP,mBAAS,EAAE,KAAKA,SAHL;AAIXikB,aAAG,EAAEzT,UAAU,CAACjQ,GAJL;AAKXyQ,qBAAW,EAAEke;AALF,SAAb;;AAQA,YAAIC,aAAJ,EAAmB;AACjB9oB,cAAI,CAAC8oB,aAAL9oB,GAAqB8oB,aAArB9oB;AACD;;AAED,eAAO,KAAK3E,cAAL,CAAoB8tB,kBAApB,CAAuCnpB,IAAvC,EACJ7L,IADI,CACC,YAAM;AACVi1B,iBAAI,CAAC5yB,SAAL,GAAiB,KAAjB;AAEA,iBAAOL,iBAAQkK,OAAR,EAAP;AAJG,WAMJhM,KANI,CAME,UAACC,KAAD,EAAW;AAChBN,+BAAYC,MAAZD,CAAmBM,KAAnBN,CAAyB,+CAAzBA,EAA0EM,KAA1EN;;AAEA8D,2BAAQC,oBAARD,CACEhB,8BAAmBuyB,sCADrBvxB,EAEE;AACEb,0BAAc,EAAEmyB,OAAI,CAAClyB,aADvB;AAEEC,oBAAQ,EAAEiyB,OAAI,CAAChyB,QAAL,CAAcE,KAAd,CAAoB,GAApB,EAAyBC,GAAzB,EAFZ;AAGEC,kBAAM,EAAElD,KAAK,CAACmD,OAHhB;AAIEC,iBAAK,EAAEpD,KAAK,CAACoD,KAJf;AAKE4xB,iBAAK,EAAE;AAACT,wBAAU,EAAVA;AAAD;AALT,WAFF/wB;;AAWA,iBAAO3B,iBAAQC,MAAR,CAAe9B,KAAf,CAAP;AApBG,UAAP;AAsBD;;AAED,aAAO6B,iBAAQC,MAAR,CAAe,IAAIskB,kBAAJ,CAAmB,kCAAnB,CAAf,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,6BAAoBmO,UAApB,EAAgC;AAAA;;AAC9B,UAAM1e,UAAU,GAAG,KAAKxM,SAAL,CAAeorB,WAAf,CAA2BhhB,IAA3B,CAAgC,UAACihB,OAAD;AAAA,eAAaA,OAAO,CAACnxB,IAARmxB,KAAiB,YAA9B;AAAhC,QAAnB;;AAEA,UAAI7e,UAAJ,EAAgB;AACdrS,yBAAQsU,SAARtU,CAAkB;AAACwM,eAAK,EAAE+H,kBAAUkd,wBAAlB;AAA4Chd,iBAAO,EAAE;AAArD,SAAlBzU;;AAEA,eAAO,KAAKuD,cAAL,CAAoB8tB,kBAApB,CAAuC;AAC5Cze,qBAAW,EAAEK,wBAAaO,QADkB;AAE5C4d,mBAAS,EAAE,KAAKvrB,SAAL,CAAegK,IAAf,CAAoBzN,GAFa;AAG5CP,mBAAS,EAAE,KAAKA,SAH4B;AAI5CikB,aAAG,EAAEzT,UAAU,CAACjQ;AAJ4B,SAAvC,EAMJ7F,KANI,CAME,UAACC,KAAD,EAAW;AAChBN,+BAAYC,MAAZD,CAAmBM,KAAnBN,CAAyB,8CAAzBA,EAAyEM,KAAzEN;;AAEA8D,2BAAQC,oBAARD,CACEhB,8BAAmB0yB,6BADrB1xB,EAEE;AACEb,0BAAc,EAAEwyB,OAAI,CAACvyB,aADvB;AAEEC,oBAAQ,EAAEsyB,OAAI,CAACryB,QAAL,CAAcE,KAAd,CAAoB,GAApB,EAAyBC,GAAzB,EAFZ;AAGEC,kBAAM,EAAElD,KAAK,CAACmD,OAHhB;AAIEC,iBAAK,EAAEpD,KAAK,CAACoD,KAJf;AAKE4xB,iBAAK,EAAE;AAACT,wBAAU,EAAVA;AAAD;AALT,WAFF/wB;;AAWA,iBAAO3B,iBAAQC,MAAR,CAAe9B,KAAf,CAAP;AApBG,WAsBJ4X,OAtBI,CAsBI,YAAM,CAtBV,EAAP;AAwBD;;AAED,aAAO/V,iBAAQC,MAAR,CAAe,IAAIskB,kBAAJ,CAAmB,uCAAnB,CAAf,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,iBAAQ;AAAA;;AACN,UAAMjc,OAAO,GAAG,KAAKd,SAAL,CAAeorB,WAAf,CAA2BhhB,IAA3B,CAAgC,UAACihB,OAAD;AAAA,eAAaA,OAAO,CAACnxB,IAARmxB,KAAiBU,kBAA9B;AAAhC,QAAhB;;AAEA,UAAIjrB,OAAO,IAAK,KAAKhI,WAAL,KAAqBC,wBAAaC,kBAAlD,EAAuE;AACrEmB,yBAAQsU,SAARtU,CAAkB;AAACwM,eAAK,EAAE+H,kBAAUsd,eAAlB;AAAmCpd,iBAAO,EAAE;AAA5C,SAAlBzU;;AAEA,eAAO,KAAKuD,cAAL,CAAoB8tB,kBAApB,CAAuC;AAC5Cze,qBAAW,EAAEK,wBAAaC,OADkB;AAE5Cke,mBAAS,EAAE,KAAKvrB,SAAL,CAAegK,IAAf,CAAoBzN,GAFa;AAG5CP,mBAAS,EAAE,KAAKA,SAH4B;AAI5CikB,aAAG,EAAEnf,OAAO,CAACvE,GAJ+B;AAK5CyQ,qBAAW,EAAE,KAAKA;AAL0B,SAAvC,EAOJxW,IAPI,CAOC,YAAM;AACVy1B,iBAAI,CAACpzB,SAAL,GAAiB,IAAjB;AAEA,iBAAOL,iBAAQkK,OAAR,EAAP;AAVG,WAYJhM,KAZI,CAYE,UAACC,KAAD,EAAW;AAChBN,+BAAYC,MAAZD,CAAmBM,KAAnBN,CAAyB,gCAAzBA,EAA2DM,KAA3DN;;AAEA8D,2BAAQC,oBAARD,CACEhB,8BAAmB+yB,qBADrB/xB,EAEE;AACEb,0BAAc,EAAE2yB,OAAI,CAAC1yB,aADvB;AAEEC,oBAAQ,EAAEyyB,OAAI,CAACxyB,QAAL,CAAcE,KAAd,CAAoB,GAApB,EAAyBC,GAAzB,EAFZ;AAGEC,kBAAM,EAAElD,KAAK,CAACmD,OAHhB;AAIEC,iBAAK,EAAEpD,KAAK,CAACoD;AAJf,WAFFI;;AAUA,iBAAO3B,iBAAQC,MAAR,CAAe9B,KAAf,CAAP;AAzBG,UAAP;AA2BD;;AAED,aAAO6B,iBAAQC,MAAR,CAAe,IAAIskB,kBAAJ,CAAmB,+BAAnB,CAAf,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACE;AACA;;;;WACA,qBAAwB;AAAA,UAAd5lB,OAAc,uEAAJ,EAAI;AACtB,aAAO,KAAKsE,WAAL;AACL3D,iBAAS,EAAE,KADN;AAELwW,oBAAY,EAAE,KAAK7W,eAAL,CAAqBH,cAArB,CAAoCgX;AAF7C,SAGFnX,OAHE,EAAP;AAKD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,4BAAmB;AAAA;;AACjB,UAAM2J,OAAO,GAAG,KAAKd,SAAL,CAAeorB,WAAf,CAA2BhhB,IAA3B,CAAgC,UAACihB,OAAD;AAAA,eAAaA,OAAO,CAACnxB,IAARmxB,KAAiBU,kBAA9B;AAAhC,QAAhB;;AAEA,UAAIjrB,OAAO,IAAK,KAAKrJ,eAAL,CAAqBH,cAArB,CAAoCQ,SAApD,EAAgE;AAC9DqC,yBAAQsU,SAARtU,CAAkB;AAACwM,eAAK,EAAE+H,kBAAUyd,aAAlB;AAAiCvd,iBAAO,EAAE;AAA1C,SAAlBzU;;AACA7B,uBAAMmhB,UAANnhB,CAAiB,KAAKb,eAAL,CAAqB8V,UAAtCjV;;AAEA,YAAIwI,OAAO,CAACsrB,KAARtrB,CAAcurB,WAAdvrB,CAA0BpF,EAA1BoF,KAAiC,KAAKqM,MAA1C,EAAkD;AAChD;AACA,eAAKtU,SAAL,GAAiB,KAAjB;AAEA,iBAAOL,iBAAQkK,OAAR,EAAP;AACD;;AAED,eAAO,KAAKhF,cAAL,CAAoB8tB,kBAApB,CAAuC;AAC5Cze,qBAAW,EAAEK,wBAAaO,QADkB;AAE5C4d,mBAAS,EAAE,KAAKvrB,SAAL,CAAegK,IAAf,CAAoBzN,GAFa;AAG5CP,mBAAS,EAAE,KAAKA,SAH4B;AAI5CikB,aAAG,EAAEnf,OAAO,CAACvE,GAJ+B;AAK5CyQ,qBAAW,EAAE,KAAKA;AAL0B,SAAvC,EAOJtW,KAPI,CAOE,UAACC,KAAD,EAAW;AAChBN,+BAAYC,MAAZD,CAAmBM,KAAnBN,CAAyB,2CAAzBA,EAAsEM,KAAtEN;;AAEA8D,2BAAQC,oBAARD,CACEhB,8BAAmBmzB,0BADrBnyB,EAEE;AACEb,0BAAc,EAAEizB,OAAI,CAAChzB,aADvB;AAEEC,oBAAQ,EAAE+yB,OAAI,CAAC9yB,QAAL,CAAcE,KAAd,CAAoB,GAApB,EAAyBC,GAAzB,EAFZ;AAGEC,kBAAM,EAAElD,KAAK,CAACmD,OAHhB;AAIEC,iBAAK,EAAEpD,KAAK,CAACoD;AAJf,WAFFI;;AAUA,iBAAO3B,iBAAQC,MAAR,CAAe9B,KAAf,CAAP;AApBG,WAsBJ4X,OAtBI,CAsBI,YAAM;AACbge,iBAAI,CAAC1zB,SAAL,GAAiB,KAAjB;AAvBG,UAAP;AAyBD;;AAED,aAAOL,iBAAQC,MAAR,CAAe,IAAIskB,kBAAJ,CAAmB,mCAAnB,CAAf,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,0BAAiB;AACf,aAAOpN,cAAY6c,cAAZ7c,CAA2B,KAAKjS,cAAhCiS,EAAgD,KAAKlW,QAArDkW,EAA+D,KAAK3P,SAApE2P,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,yBAAgB;AACd,aAAOA,cAAY8c,aAAZ9c,CAA0B,KAAKjS,cAA/BiS,EAA+C,KAAKlW,QAApDkW,EAA8D,KAAK3P,SAAnE2P,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,0BAAiB;AACf,aAAOA,cAAY+c,cAAZ/c,CAA2B,KAAKjS,cAAhCiS,EAAgD,KAAKlW,QAArDkW,EAA+D,KAAK3P,SAApE2P,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,2BAAkB;AAChB,aAAOA,cAAYgd,eAAZhd,CAA4B,KAAKjS,cAAjCiS,EAAiD,KAAKlW,QAAtDkW,EAAgE,KAAK3P,SAArE2P,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,uBAAc;AACZ,aAAOA,cAAYid,WAAZjd,CAAwB,KAAK3R,gBAA7B2R,EAA+C,KAAKjS,cAApDiS,EAAoE,KAAKlW,QAAzEkW,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,yBAAgB;AACd,aAAOA,cAAYkd,aAAZld,CAA0B,KAAK3R,gBAA/B2R,EAAiD,KAAKjS,cAAtDiS,EAAsE,KAAKlW,QAA3EkW,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,4BAAmB7V,OAAnB,EAA4B;AAC1BzD,2BAAYC,MAAZD,CAAmBM,KAAnBN,CAAyByD,OAAzBzD;;AAEA,aAAOmC,iBAAQC,MAAR,CAAe,IAAIoJ,KAAJ,CAAU/H,OAAV,CAAf,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,kBAASgzB,KAAT,EAAgB;AACd,UAAI,KAAK9sB,SAAL,IAAkB,KAAKA,SAAL,CAAegK,IAArC,EAA2C;AACzC,YAAI,KAAKhK,SAAL,CAAegK,IAAf,CAAoB+iB,UAAxB,EAAoC;AAClC,iBAAO,KAAKrvB,cAAL,CACJsvB,QADI,CACK;AACRvzB,oBAAQ,EAAE,KAAKuG,SAAL,CAAegK,IAAf,CAAoBzN,GADtB;AAERP,qBAAS,EAAE,KAAKA,SAFR;AAGR8wB,iBAAK,EAALA;AAHQ,WADL,CAAP;AAMD;;AAED,eAAO,KAAKG,kBAAL,CAAwB,iFAAxB,CAAP;AACD;;AAED,aAAO,KAAKA,kBAAL,CAAwB,uIAAxB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,2BAAkBrsB,UAAlB,EAA+C;AAAA;;AAAA,UAAjBssB,UAAiB,uEAAJ,EAAI;AAC7C,UAAOrsB,IAAP,GAAwBqsB,UAAxB,CAAOrsB,IAAP;AAAA,UAAaC,OAAb,GAAwBosB,UAAxB,CAAapsB,OAAb;AACA,mCAAwD,KAAKrJ,eAA7D;AAAA,UAAOH,cAAP,0BAAOA,cAAP;AAAA,UAAuB6hB,WAAvB,0BAAuBA,WAAvB;AAAA,UAAoCD,gBAApC,0BAAoCA,gBAApC;AAEA,UAAMiU,UAAU,GAAG,yBAAU,KAAKxsB,mBAAf,CAAnB,CAJ6C,CAM7C;;AACA,UAAIrJ,cAAc,CAACya,YAAfza,KAAgC,IAAhCA,IAAwC,CAAC4hB,gBAA7C,EAA+D;AAC7D,eAAO,KAAK+T,kBAAL,CAAwB,8GAAxB,CAAP;AACD;;AAED,UAAIG,wBAAavK,QAAbuK,CAAsBxsB,UAAtBwsB,CAAJ,EAAuC;AACrCD,kBAAU,CAACvsB,UAAXusB,GAAwBvsB,UAAxBusB;AADF,aAGK;AACH,eAAO,KAAKF,kBAAL,CAAwB,8FAAxB,CAAP;AACD;;AAED,UAAIpsB,IAAJ,EAAU;AACR,YAAMwsB,SAAS,GAAGC,IAAI,CAACC,KAALD,CAAWzsB,IAAI,CAACia,KAAhBwS,CAAlB;AACA,YAAME,UAAU,GAAGF,IAAI,CAACC,KAALD,CAAWzsB,IAAI,CAACga,MAAhByS,CAAnB,CAFQ,CAIR;;AACA,YACE,CAAC,KAAK3sB,mBAAL,CAAyBE,IAA1B,IACAysB,IAAI,CAACG,GAALH,CAAS,KAAK3sB,mBAAL,CAAyBE,IAAzB,CAA8Bga,MAA9B,GAAuC2S,UAAhDF,IAA8D,CAD9D,IAEAA,IAAI,CAACG,GAALH,CAAS,KAAK3sB,mBAAL,CAAyBE,IAAzB,CAA8Bia,KAA9B,GAAsCuS,SAA/CC,IAA4D,CAH9D,EAIE;AACAH,oBAAU,CAACtsB,IAAXssB,GAAkB;AAACrS,iBAAK,EAAEuS,SAAR;AAAmBxS,kBAAM,EAAE2S;AAA3B,WAAlBL;AACD;AACF;;AAED,UAAIrsB,OAAJ,EAAa;AACX,YAAI,KAAKrJ,eAAL,CAAqBH,cAArB,CAAoCgX,YAApC,IAAoD6K,WAAxD,EAAqE;AACnE,cAAMuU,YAAY,GAAGJ,IAAI,CAACC,KAALD,CAAWxsB,OAAO,CAACga,KAAnBwS,CAArB;AACA,cAAMK,aAAa,GAAGL,IAAI,CAACC,KAALD,CAAWxsB,OAAO,CAAC+Z,MAAnByS,CAAtB,CAFmE,CAInE;;AACA,cAAI,CAAC,KAAK3sB,mBAAL,CAAyBG,OAA1B,IACFwsB,IAAI,CAACG,GAALH,CAAS,KAAK3sB,mBAAL,CAAyBG,OAAzB,CAAiC+Z,MAAjC,GAA0C8S,aAAnDL,IAAoE,CADlE,IAEFA,IAAI,CAACG,GAALH,CAAS,KAAK3sB,mBAAL,CAAyBG,OAAzB,CAAiCga,KAAjC,GAAyC4S,YAAlDJ,IAAkE,CAFpE,EAGE;AACAH,sBAAU,CAACrsB,OAAXqsB,GAAqB;AAACrS,mBAAK,EAAE4S,YAAR;AAAsB7S,oBAAM,EAAE8S;AAA9B,aAArBR;AACD;AAVH,eAYK;AACH,iBAAO,KAAKF,kBAAL,CAAwB,+GAAxB,CAAP;AACD;AACF;;AAED,UAAI,uBAAQE,UAAR,EAAoB,KAAKxsB,mBAAzB,CAAJ,EAAmD;AACjD;AACA,eAAOnI,iBAAQkK,OAAR,EAAP;AACD;;AACD,WAAK/B,mBAAL,GAA2B,yBAAUwsB,UAAV,CAA3B;AAEA,aAAO,KAAKzvB,cAAL,CACJkwB,0BADI,CACuB;AAC1Bn0B,gBAAQ,EAAE,KAAKuG,SAAL,CAAegK,IAAf,CAAoBzN,GADJ;AAE1BP,iBAAS,EAAE,KAAKA,SAFU;AAG1B4E,kBAAU,EAAVA,UAH0B;AAI1BC,YAAI,EAAEssB,UAAU,CAACtsB,IAJS;AAK1BC,eAAO,EAAEqsB,UAAU,CAACrsB;AALM,OADvB,EAQJtK,IARI,CAQC,UAACuN,QAAD,EAAc;AAClB,YAAIA,QAAQ,IAAIA,QAAQ,CAAC1B,IAArB0B,IAA6BA,QAAQ,CAAC1B,IAAT0B,CAAczH,KAA/C,EAAsD;AACpDuxB,iBAAI,CAAC7tB,SAAL,CAAeijB,WAAf,CAA2Blf,QAAQ,CAAC1B,IAAT0B,CAAczH,KAAzC;AACD;AAXE,SAaJ5F,KAbI,CAaE,UAACC,KAAD,EAAW;AAChBN,6BAAYC,MAAZD,CAAmBM,KAAnBN,CAAyB,4CAAzBA,EAAuEM,KAAvEN;;AAEA,eAAOmC,iBAAQC,MAAR,CAAe9B,KAAf,CAAP;AAhBG,QAAP;AAkBD;AAED;AACF;AACA;AACA;AACA;;;;WACE,8BAAqBm3B,KAArB,EAA4B;AAAA;;AAC1Bz3B,2BAAYC,MAAZD,CAAmBgF,GAAnBhF,qEAAoFy3B,KAApF;;AAEA,UAAI,CAACt2B,6BAAkBs2B,KAAlBt2B,CAAL,EAA+B;AAC7B,eAAO,KAAKy1B,kBAAL,kDAAkEa,KAAlE,kBAAP;AACD;;AAED,UAAI,CAAC,KAAKr2B,eAAL,CAAqBH,cAArB,CAAoCO,SAAzC,EAAoD;AAClD,eAAO,KAAKo1B,kBAAL,CAAwB,8FAAxB,CAAP;AARwB,QAW1B;;;AACA,UAAIa,KAAK,KAAK,KAAKr2B,eAAL,CAAqBC,iBAAnC,EAAsD;AACpDrB,6BAAYC,MAAZD,CAAmB0B,IAAnB1B,yEAAyFy3B,KAAzF;;AAEA,eAAOt1B,iBAAQkK,OAAR,EAAP;AAfwB,QAkB1B;;;AACA,WAAKjL,eAAL,CAAqBoqB,oBAArB,CAA0CiM,KAA1C;AAEA,UAAMx2B,cAAc,GAAG;AACrBM,iBAAS,EAAE,KAAKH,eAAL,CAAqBH,cAArB,CAAoCM,SAD1B;AAErBC,iBAAS,EAAE,KAAKJ,eAAL,CAAqBH,cAArB,CAAoCO,SAF1B;AAGrBC,iBAAS,EAAE,KAAKL,eAAL,CAAqBH,cAArB,CAAoCQ;AAH1B,OAAvB;AAMA,aAAO,KAAKqmB,eAAL,CAAqB7mB,cAArB,EAAqCE,6BAAkBs2B,KAAlBt2B,CAArC,EACJhB,IADI,CACC;AAAA;AAAA,YAAEwkB,WAAF;;AAAA,eACJ+S,OAAI,CAACvyB,WAAL,CAAiB;AACf3D,mBAAS,EAAE,IADI;AAEfka,sBAAY,EAAE,IAFC;AAGf4G,gBAAM,EAAEqC;AAHO,SAAjB,CADI;AADD,QAAP;AAOD;AAED;AACF;AACA;AACA;AACA;;;;WACE,+BAAsB8S,KAAtB,EAA6B;AAC3Bz3B,2BAAYC,MAAZD,CAAmBgF,GAAnBhF,sEAAqFy3B,KAArF;;AAEA,UAAI,CAACnM,0BAAemM,KAAfnM,CAAL,EAA4B;AAC1B,eAAO,KAAKsL,kBAAL,mDAAmEa,KAAnE,kBAAP;AACD;;AAED,UAAI,CAAC,KAAKr2B,eAAL,CAAqBH,cAArB,CAAoCua,YAArC,IAAqD,CAAC,KAAKpa,eAAL,CAAqBH,cAArB,CAAoCya,YAA9F,EAA4G;AAC1G,eAAO,KAAKkb,kBAAL,CAAwB,oHAAxB,CAAP;AARyB,QAW3B;;;AACA,UAAIa,KAAK,KAAK,KAAKr2B,eAAL,CAAqBkuB,kBAAnC,EAAuD;AACrDtvB,6BAAYC,MAAZD,CAAmB0B,IAAnB1B,0EAA0Fy3B,KAA1F;;AAEA,eAAOt1B,iBAAQkK,OAAR,EAAP;AAfyB,QAkB3B;;;AACA,WAAKjL,eAAL,CAAqBqqB,qBAArB,CAA2CgM,KAA3C;AAEA,aAAO,KAAKxyB,WAAL,CAAiB;AAACif,qBAAa,EAAE,KAAK9iB,eAAL,CAAqBH;AAArC,OAAjB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;;WACE,2BAAkBw2B,KAAlB,EAAyB;AAAA;;AACvBz3B,2BAAYC,MAAZD,CAAmBgF,GAAnBhF,kEAAiFy3B,KAAjF;;AAEA,UAAI,CAACnM,0BAAemM,KAAfnM,CAAL,EAA4B;AAC1B,eAAO,KAAKsL,kBAAL,+CAA+Da,KAA/D,kBAAP;AACD;;AAED,UAAME,aAAa,GAAG;AACpBzP,aAAK,EAAE,KAAK9mB,eAAL,CAAqBC,iBADR;AAEpB0a,cAAM,EAAE,KAAK3a,eAAL,CAAqBkuB;AAFT,OAAtB,CAPuB,CAYvB;;AACA,UACEmI,KAAK,KAAK,KAAKr2B,eAAL,CAAqBC,iBAA/Bo2B,IACAA,KAAK,KAAK,KAAKr2B,eAAL,CAAqBkuB,kBAFjC,EAGE;AACAtvB,6BAAYC,MAAZD,CAAmB0B,IAAnB1B,sEAAsFy3B,KAAtF;;AAEA,eAAOt1B,iBAAQkK,OAAR,EAAP;AAnBqB,QAsBvB;;;AACA,mCAAgD,KAAKjL,eAAL,CAAqBH,cAArE;AAAA,UAAOua,YAAP,0BAAOA,YAAP;AAAA,UAAqBE,YAArB,0BAAqBA,YAArB;AAAA,UAAmCla,SAAnC,0BAAmCA,SAAnC;AAEA,aAAO,CAACA,SAAS,GAAG,KAAKo2B,oBAAL,CAA0BH,KAA1B,CAAH,GAAsCt1B,iBAAQkK,OAAR,EAAhD,EACJlM,IADI,CACC;AAAA,eACFqb,YAAY,IAAIE,YAAhBF,GACAqc,OAAI,CAACpM,qBAAL,CAA2BgM,KAA3B,CADAjc,GAEArZ,iBAAQkK,OAAR,EAHE;AADD,SAKJhM,KALI,CAKE,UAACC,KAAD,EAAW;AAChB;AACAu3B,eAAI,CAACz2B,eAAL,CAAqBoqB,oBAArB,CAA0CmM,aAAa,CAACzP,KAAxD;;AACA2P,eAAI,CAACz2B,eAAL,CAAqBqqB,qBAArB,CAA2CkM,aAAa,CAAC5b,MAAzD;;AAEA/b,6BAAYC,MAAZD,CAAmBM,KAAnBN,+CAAgEM,KAAK,CAACmD,OAAtE;;AAEAK,yBAAQC,oBAARD,CACEhB,8BAAmBg1B,2BADrBh0B,EAEE;AACEb,wBAAc,EAAE40B,OAAI,CAAC30B,aADvB;AAEEC,kBAAQ,EAAE00B,OAAI,CAACz0B,QAAL,CAAcE,KAAd,CAAoB,GAApB,EAAyBC,GAAzB,EAFZ;AAGEC,gBAAM,EAAElD,KAAK,CAACmD,OAHhB;AAIEC,eAAK,EAAEpD,KAAK,CAACoD;AAJf,SAFFI,EAQE;AACEF,cAAI,EAAEtD,KAAK,CAACuD;AADd,SARFC;;AAaA,eAAO3B,iBAAQC,MAAR,CAAe9B,KAAf,CAAP;AAzBG,QAAP;AA2BD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,uBAA0B;AAAA;;AAAA,UAAdQ,OAAc,uEAAJ,EAAI;;AACxBd,2BAAYC,MAAZD,CAAmBgF,GAAnBhF,CAAuB,mDAAvBA;;AAEA,UAAM+3B,gBAAgB;AACpBt2B,iBAAS,EAAE,IADS;AAEpBF,iBAAS,EAAE;AAFS,SAGjBT,OAHiB,CAAtB;;AAMA,aAAOmB,eAAM+1B,eAAN/1B,CAAsB81B,gBAAtB91B,EAAwC,KAAKW,MAA7CX,EACJ9B,IADI8B,CACC,UAACg2B,WAAD;AAAA,eAAiBC,OAAI,CAAC9yB,WAAL,CAAiB;AACtC3D,mBAAS,EAAE,IAD2B;AAEtCwW,sBAAY,EAAEigB,OAAI,CAAC92B,eAAL,CAAqBH,cAArB,CAAoCgX,YAFZ;AAGtCqK,gBAAM,EAAE2V;AAH8B,SAAjB,CAAjB;AADD,SAMJ53B,KANI4B,CAME,UAAC3B,KAAD,EAAW;AAChB;AACA;AACA;AACA;AAEA;AACA;AACA,YAAMuC,UAAU,GAAGC,8BAAmBq1B,yBAAtC;AACA,YAAMn1B,IAAI,GAAG;AACXC,wBAAc,EAAEi1B,OAAI,CAACh1B,aADV;AAEXC,kBAAQ,EAAE+0B,OAAI,CAAC90B,QAAL,CAAcE,KAAd,CAAoB,GAApB,EAAyBC,GAAzB,EAFC;AAGXC,gBAAM,EAAElD,KAAK,CAACmD,OAHH;AAIXC,eAAK,EAAEpD,KAAK,CAACoD;AAJF,SAAb;AAMA,YAAMC,QAAQ,GAAG;AACfC,cAAI,EAAEtD,KAAK,CAACuD;AADG,SAAjB;;AAIAC,yBAAQC,oBAARD,CAA6BjB,UAA7BiB,EAAyCd,IAAzCc,EAA+CH,QAA/CG;;AACA,cAAM,IAAIzB,eAAJ,CAAe,yCAAf,EAA0D/B,KAA1D,CAAN;AA1BG,QAAP;AA4BD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,+BAAsBukB,UAAtB,EAAkC;AAChC,UAAI,KAAK1I,aAAT,EAAwB;AACtB,aAAKF,KAAL,CAAW;AAACzY,gBAAM,EAAEwuB,kCAAuBoG;AAAhC,SAAX;AADF,aAGK;AACH;AACA;AACA,aAAKjhB,SAAL,CAAe;AACbC,4BAAkB,EAAE;AADP,SAAf,EAGG/W,KAHH,CAGS,UAACC,KAAD,EAAW;AAChBN,+BAAYC,MAAZD,CAAmBgF,GAAnBhF,CAAuB,gEAAvBA,EAAyFM,KAAzFN;AAJJ;AAMD;;AAEDmE,4BAAQC,OAARD,CACE,IADFA,EAEE;AACEE,YAAI,EAAE,eADR;AAEEC,gBAAQ,EAAE;AAFZ,OAFFH,EAMEI,0BAAekT,6BANjBtT,EAOE;AACEP,YAAI,EAAEie,uBAAYwD,WADpB;AAEE/C,cAAM,EAAEuC;AAFV,OAPF1gB;AAYD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,iCAAwB2K,GAAxB,EAA6B;AAC3B3K,4BAAQC,OAARD,CACE,IADFA,EAEE;AACEE,YAAI,EAAE,eADR;AAEEC,gBAAQ,EAAE;AAFZ,OAFFH,EAMEI,0BAAeqsB,eANjBzsB,EAOE;AACEk0B,2BAAmB,EAAEvpB,GAAG,CAACupB,mBAD3B;AAEErV,iBAAS,EAAElU,GAAG,CAACkU;AAFjB,OAPF7e;AAYD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,oCAA6C;AAAA,UAAzBuf,UAAyB,UAAzBA,UAAyB;AAAA,UAAbC,UAAa,UAAbA,UAAa;;AAC3CrK,oBAAY8N,kBAAZ9N,CAA+BqK,UAA/BrK;;AACAA,oBAAYuN,kBAAZvN,CAA+BoK,UAA/BpK;AACD;AAED;AACF;AACA;AACA;;;;WACE,4BAAmBgf,SAAnB,EAA8B;AAC5B,oCAAuBA,SAAvB,KAAsCC,WAAW,CAACC,GAAZD,EAAtC;AACA,kCAAqBD,SAArB,KAAoCruB,SAApC;AACD;AAED;AACF;AACA;AACA;;;;WACE,0BAAiBquB,SAAjB,EAA4B;AAC1B,kCAAqBA,SAArB,KAAoCC,WAAW,CAACC,GAAZD,EAApC;AACD;AAED;AACF;AACA;AACA;;;;WACE,+BAAsBD,SAAtB,EAAiC;AAC/B,UAAMG,KAAK,GAAG,8BAAuBH,SAAvB,EAAd;AACA,UAAMI,GAAG,GAAG,4BAAqBJ,SAArB,EAAZ;AAEA,aAAQG,KAAK,IAAIC,GAATD,GAAgBC,GAAG,GAAGD,KAAtBA,GAA8BxuB,SAAtC;AACD;AAED;AACF;AACA;AACA;;;;WACE,mCAA0BquB,SAA1B,EAAqC;AACnC,2CAA8BA,SAA9B,KAA6CC,WAAW,CAACC,GAAZD,EAA7C;AACA,yCAA4BD,SAA5B,KAA2CruB,SAA3C;AACD;AAED;AACF;AACA;AACA;;;;WACE,iCAAwBquB,SAAxB,EAAmC;AACjC,yCAA4BA,SAA5B,KAA2CC,WAAW,CAACC,GAAZD,EAA3C;AACD;AAED;AACF;AACA;AACA;;;;WACE,sCAA6BD,SAA7B,EAAwC;AACtC,UAAMG,KAAK,GAAG,qCAA8BH,SAA9B,EAAd;AACA,UAAMI,GAAG,GAAG,mCAA4BJ,SAA5B,EAAZ;AAEA,aAAQG,KAAK,IAAIC,GAATD,GAAgBC,GAAG,GAAGD,KAAtBA,GAA8BxuB,SAAtC;AACD;AAED;AACF;AACA;AACA;;;;WACE,iDAAwC;AACtC,UAAI,CAAC,KAAK0uB,kCAAV,EAA8C;AAC5C,aAAKA,kCAAL,GAA0CJ,WAAW,CAACC,GAAZD,EAA1C;AACA,aAAKK,gCAAL,GAAwC3uB,SAAxC;AACD;AACF;AAED;AACF;AACA;AACA;;;;WACE,+CAAsC;AACpC,UAAI,CAAC,KAAK2uB,gCAAV,EAA4C;AAC1C,aAAKA,gCAAL,GAAwCL,WAAW,CAACC,GAAZD,EAAxC;AACD;AACF;AAED;AACF;AACA;AACA;;;;WACE,4CAAmC;AACjC,UAAME,KAAK,GAAG,KAAKE,kCAAnB;AACA,UAAMD,GAAG,GAAG,KAAKE,gCAAjB;;AAEA,UAAIH,KAAK,IAAIC,GAAb,EAAkB;AAChB,YAAMG,eAAe,GAAGH,GAAG,GAAGD,KAA9B;AAEA,eAAOI,eAAe,GAAGC,0CAAlBD,GACL5uB,SADK4uB,GAELA,eAFF;AAGD;;AAED,aAAO5uB,SAAP;AACD;AAED;AACF;AACA;AACA;;;;WACE,uCAA8B;AAC5B,WAAK8uB,wBAAL,GAAgCR,WAAW,CAACC,GAAZD,EAAhC;AACA,WAAKS,sBAAL,GAA8B/uB,SAA9B;AACD;AAED;AACF;AACA;AACA;;;;WACE,qCAA4B;AAC1B,WAAK+uB,sBAAL,GAA8BT,WAAW,CAACC,GAAZD,EAA9B;AACD;AAED;AACF;AACA;AACA;;;;WACE,kCAAyB;AACvB,UAAME,KAAK,GAAG,KAAKM,wBAAnB;AACA,UAAML,GAAG,GAAG,KAAKM,sBAAjB;;AAEA,UAAIP,KAAK,IAAIC,GAAb,EAAkB;AAChB,YAAMG,eAAe,GAAGH,GAAG,GAAGD,KAA9B;AAEA,eAAOI,eAAe,GAAGC,0CAAlBD,GACL5uB,SADK4uB,GAELA,eAFF;AAGD;;AAED,aAAO5uB,SAAP;AACD;AAED;AACF;AACA;AACA;;;;WACE,+BAAsB;AACpB,WAAKgvB,gBAAL,GAAwBV,WAAW,CAACC,GAAZD,EAAxB;AACA,WAAKW,cAAL,GAAsBjvB,SAAtB;AACD;AAED;AACF;AACA;AACA;;;;WACE,6BAAoB;AAClB,WAAKivB,cAAL,GAAsBX,WAAW,CAACC,GAAZD,EAAtB;AACD;AAED;AACF;AACA;AACA;;;;WACE,0BAAiB;AACf,UAAME,KAAK,GAAG,KAAKQ,gBAAnB;AACA,UAAMP,GAAG,GAAG,KAAKQ,cAAjB;;AAEA,UAAIT,KAAK,IAAIC,GAAb,EAAkB;AAChB,YAAMG,eAAe,GAAGH,GAAG,GAAGD,KAA9B;AAEA,eAAOI,eAAe,GAAGC,0CAAlBD,GACL5uB,SADK4uB,GAELA,eAFF;AAGD;;AAED,aAAO5uB,SAAP;AACD;AAED;AACF;AACA;AACA;;;;WACE,uBAAc;AACZ,UAAMwuB,KAAK,GAAG,KAAKM,wBAAnB;AACA,UAAML,GAAG,GAAG,KAAKQ,cAAjB;AAEA,aAAQT,KAAK,IAAIC,GAATD,GAAgBC,GAAG,GAAGD,KAAtBA,GAA8BxuB,SAAtC;AACD;;;EA5lKkCkvB,+B","names":["isBrowser","logRequest","request","header","success","failure","LoggerProxy","logger","info","then","arg","catch","error","MEDIA_UPDATE_TYPE","ALL","AUDIO","VIDEO","SHARE","Meeting","attrs","options","_this","MEETINGS","mediaDirection","audioVideo","VIDEO_RESOLUTIONS","mediaProperties","localQualityLevel","sharePreferences","sendAudio","sendVideo","sendShare","warn","video","deviceId","preferredVideoDevice","lastVideoDeviceId","getVideoDeviceId","setVideoDeviceId","Media","getSupportedDevice","_promise","reject","MediaError","devicePermissions","getUserMedia","isSharing","shareStatus","SHARE_STATUS","LOCAL_SHARE_ACTIVE","config","metricName","BEHAVIORAL_METRICS","GET_USER_MEDIA_FAILURE","data","correlation_id","correlationId","locus_id","locusUrl","_this$locusUrl","split","pop","reason","message","stack","metadata","type","name","Metrics","sendBehavioralMetric","getDevices","experimental","enableMediaNegotiatedEvent","Trigger","trigger","file","function","EVENT_TRIGGERS","MEDIA_NEGOTIATED","canUpdateMedia","queuedMediaUpdates","length","shift","pendingPromiseResolve","pendingPromiseReject","mediaUpdateType","log","updateMedia","updateAudio","updateVideo","updateShare","id","uuid","v4","userId","orgId","resource","deviceUrl","roapSeq","ROAP_SEQ_PRE","meetingInfo","members","Members","locus","url","parent","webex","roap","Roap","reconnectionManager","ReconnectionManager","audio","meetingFiniteStateMachine","MeetingStateMachine","create","stats","internalStats","conversationUrl","sipUri","partner","owner","hostId","policy","meetingRequest","MeetingRequest","mediaConnections","updateMediaConnections","slice","MediaProperties","inMeetingActions","InMeetingActions","NO_SHARE","get","shareTransceiver","peerConnection","shareDirection","direction","trackReadyState","sender","_shareTransceiver$sen","track","_shareTransceiver$sen2","readyState","activeShare","LIVE","offersToSendData","SENDRECV","configurable","callEvents","floorGrantPending","dialInDeviceStatus","PSTN_STATUS","UNKNOWN","dialInUrl","dialOutDeviceStatus","dialOutUrl","mediaQualityMetrics","statsAnalyzer","networkQualityMonitor","mqaProcessor","networkStatus","locusInfo","LocusInfo","updateMeetingObject","bind","recording","deferJoin","undefined","hasWebsocketConnected","internal","mercury","connected","lastVideoLayoutInfo","layoutType","main","content","transcription","passwordStatus","PASSWORD_STATUS","requiredCaptcha","meetingInfoFailureReason","setUpLocusInfoListeners","init","hasJoinedOnce","destination","_ref4$password","password","_ref4$captchaCode","captchaCode","_context","Error","REQUIRED","captchaInfo","code","captchaId","meetingInfoProvider","fetchMeetingInfo","parseMeetingInfo","body","MEETING_INFO_FAILURE_REASON","NONE","VERIFIED","NOT_REQUIRED","resolve","MeetingInfoV2PasswordError","_err$body","meetingNumber","WRONG_PASSWORD","refreshCaptcha","PasswordError","MeetingInfoV2CaptchaError","_err$body2","WRONG_CAPTCHA","isPasswordRequired","CaptchaError","OTHER","_SIP_URI_","isPasswordValid","failureReason","_this2","URL","refreshURL","hostname","captchaRefreshUrl","response","_this3","captchaID","verificationImageURL","verificationAudioURL","setUpLocusInfoSelfListener","setUpLocusInfoMeetingListener","setUpLocusFullStateListener","setUpLocusUrlListener","setUpLocusHostListener","setUpLocusSelfListener","setUpLocusParticipantsListener","setupLocusControlsListener","setUpLocusMediaSharesListener","setUpLocusInfoMeetingInfoListener","setUpLocusInfoAssignHostListener","setUpLocusInfoMediaInactiveListener","on","EVENTS","DISCONNECT_DUE_TO_INACTIVITY","res","_this4","locusId","REQUEST_UPLOAD_LOGS","reconnection","autoRejoin","reconnect","MEETING_SELF_LEFT","LOCUS_INFO_CAN_ASSIGN_HOST","payload","_this5","MEETING_ACTIONS_UPDATE","canAssignHost","canLock","getCanLock","canUnlock","getCanUnlock","setCanAssignHost","LOCUSINFO","FULL_STATE_MEETING_STATE_CHANGE","_this6","MEETING_STATE_CHANGE","FULL_STATE_TYPE_UPDATE","locusFullStateTypeUpdate","event","trackingId","identifiers","services","fullState","locusStartTime","lastActive","mediaAgentAlias","mediaAgentGroupId","mediaAgentCluster","_this$mediaConnection","_this$mediaConnection2","_this$mediaConnection3","joinRespRxStartAudio","getSetupDelayDuration","audioSetupDelay","joinRespRxStart","joinRespRxStartVideo","videoSetupDelay","joinRespTxStartAudio","getSendingMediaDelayDuration","joinRespTxStart","joinRespTxStartVideo","localSDPGenRemoteSDPRecv","getLocalSDPGenRemoteSDPRecvDelay","joinTimes","callInitiateJoinReq","getCallInitiateJoinReq","joinReqResp","getJoinReqResp","getTotalJmt","MQA_STATS","CA_TYPE","initMediaPayload","initPayload","getAnalyzerMetricsPrePayload","metrics","submitCallDiagnosticEvents","NETWORK_STATUS","DISCONNECTED","MEETINGS_NETWORK_DISCONNECTED","CONNECTED","MEETINGS_NETWORK_CONNECTED","LOCUS_INFO_UPDATE_SELF","_this7","locusSelfUpdate","pstnUpdate","newSelf","state","MEETING_STATE","STATES","JOINED","share","self","dialInPstnDevice","_payload$newSelf","pstnDevices","find","device","_this8","dialOutPstnDevice","_payload$newSelf2","changed","newStatus","dialingStatus","MEETING_SELF_PHONE_AUDIO_UPDATE","dialIn","status","attendeeId","dialOut","LOCUS_INFO_UPDATE_HOST","_this9","locusHostUpdate","LOCUS_INFO_UPDATE_PARTICIPANTS","_this10","locusParticipantsUpdate","CONTROLS_RECORDING_UPDATED","modifiedBy","lastModified","RECORDING_STATE","RECORDING","MEETING_STARTED_RECORDING","IDLE","MEETING_STOPPED_RECORDING","PAUSED","MEETING_PAUSED_RECORDING","RESUMED","MEETING_RESUMED_RECORDING","_this11","LOCUS_INFO_UPDATE_MEDIA_SHARES","current","contentShare","whiteboardShare","whiteboard","previousContentShare","previous","_payload$previous","previousWhiteboardShare","_payload$previous2","beneficiaryId","disposition","resourceUrl","newShareStatus","_this12","selfId","FLOOR_ACTION","GRANTED","REMOTE_SHARE_ACTIVE","shareTrack","stopShare","skipSignalingCheck","WHITEBOARD_SHARE_ACTIVE","RELEASED","oldShareStatus","MEETING_STOPPED_SHARING_REMOTE","MEETING_STOPPED_SHARING_LOCAL","SHARE_STOPPED_REASON","SELF_STOPPED","MEETING_STOPPED_SHARING_WHITEBOARD","sendStartedSharingRemote","MEETING_STARTED_SHARING_REMOTE","memberId","_this12$mediaProperti2","receiveShare","finally","MEETING_STARTED_SHARING_LOCAL","postEvent","eventType","LOCAL_SHARE_FLOOR_GRANTED","meeting","MEETING_STARTED_SHARING_WHITEBOARD","WHITEBOARD_SHARE_FLOOR_GRANTED","locusMediaSharesUpdate","LOCUS_INFO_UPDATE_URL","_this13","locusUrlUpdate","_this13$locusUrl","MEETING_LOCKED","_this14","MEETING_UNLOCKED","MEETING_INFO_UPDATED","newCanLock","newCanUnlock","moderator","MeetingUtil","canUserLock","canUserUnlock","getCanAssignHost","setCanLock","setCanUnlock","LOCAL_UNMUTE_REQUIRED","_this15","handleServerLocalUnmuteRequired","MEETING_SELF_UNMUTED_BY_OTHERS","SELF_REMOTE_MUTE_STATUS_UPDATED","handleServerRemoteMuteUpdate","muted","unmuteAllowed","_this15$audio","isMuted","MEETING_SELF_MUTED_BY_OTHERS","LOCAL_UNMUTE_REQUESTED","MEETING_SELF_REQUESTED_TO_UNMUTE","SELF_UNADMITTED_GUEST","MEETING_SELF_LOBBY_WAITING","LOBBY_ENTERED","SELF_ADMITTED_GUEST","MEETING_SELF_GUEST_ADMITTED","LOBBY_EXITED","MEDIA_INACTIVITY","MEETING_MEDIA_INACTIVE","MEDIA_STATUS_CHANGE","updateMediaStatus","actual","expected","_this15$audio2","_this15$video","_this15$mediaProperti3","receiveAudio","_this15$mediaProperti4","receiveVideo","_this15$mediaProperti5","_this15$mediaProperti6","REMOTE_RESPONSE","_this16","remote","remoteDeclined","leave","DESTROY_MEETING","wirelessShare","onended","stop","shouldLeave","cleanUp","meetingId","object","forEach","key","_this17","invitee","alertIfActive","addMember","cancelPhoneInvite","memberIds","admitMembers","removeMember","mute","muteMember","transferHostToMember","mqaInterval","clearInterval","automaticMetrics","StatsMetrics","getStats","initialize","setStats","setInterval","_this18","processMQAData","mqaMetricsInterval","MQAProcessor","DATA_PLACEMENTS","_this19","sendRecvData","toLowerCase","endsWith","STATS","SENDER","getSender","RECEIVER","getReceiver","mqa","getMQA","interval","getSlice","process","override","createStats","StatsUtil","generateOptions","CONFIG","WebRTCStats","destroySenders","destroyReceivers","isSelf","webexMeetingInfo","errors","setSipUri","enableUnifiedMeetings","sipUrl","sipMeetingUri","meetingJoinUrl","permissionToken","setLocus","participants","getLocusPartner","_CALL_","person","seq","mtgLocus","mediaId","host","initialSetup","pc","ontrack","MEDIA_ID","AUDIO_TRACK","VIDEO_TRACK","SHARE_TRACK","mediaTrack","trackMediaID","transceiver","mid","target","audioTransceiver","videoTransceiver","receiver","MUTE_AUDIO_FAILURE","_this20","EVENT_TYPES","REMOTE_AUDIO","setRemoteAudioTrack","REMOTE_VIDEO","setRemoteVideoTrack","REMOTE_SHARE","setRemoteShare","startAnalyzer","MEDIA_READY","stream","MediaUtil","createMediaStream","unsetRemoteMedia","unsetRemoteTracks","closeRemoteTracks","remoteAudioTrack","remoteVideoTrack","remoteShare","triggerMediaStoppedEvent","mediaType","_this21","MEDIA_STOPPED","stopTrack","stopTracks","isTrackStopped","ENDED","isWrongReadyState","all","LOCAL","audioTrack","videoTrack","emitEvent","settings","getSettings","setMediaSettings","echoCancellation","noiseSuppression","mediaSettings","setLocalAudioTrack","applyClientStateLocally","sendLocalMediaReadyEvent","aspectRatio","frameRate","height","width","setLocalVideoTrack","localStream","getTrack","localShare","setLocalShareTrack","contentTracks","displaySurface","cursor","screen","_this22","handleShareTrackEnded","LOCAL_SHARE","audioStopped","videoStopped","_this23","_this24","unsetLocalVideoTrack","unsetLocalShareTrack","ONLINE","_this25","MERCURY_CONNECTION_RESTORED","OFFLINE","MERCURY_CONNECTION_LOST","MERCURY_CONNECTION_FAILURE","PeerConnectionManager","close","unsetPeerConnection","detection","off","isUserInJoinedState","UserNotJoinedError","NoMediaEstablishedYetError","ParameterError","LOG_HEADER","handleClientRequest","handleAudioLogging","_this26","MUTED","USER_INTERACTION","_this27","UNMUTED","UNMUTE_AUDIO_FAILURE","handleVideoLogging","_this28","MUTE_VIDEO_FAILURE","_this29","UNMUTE_VIDEO_FAILURE","joinOptions","audioVideoOptions","join","joinResponse","_this30","getMediaStreams","addMedia","mediaResponse","media","local","JOIN_WITH_MEDIA_FAILURE","isMediaEstablished","currentMediaStatus","validate","ReconnectInProgress","MEETING_RECONNECTION_STARTING","_this31","MEETING_RECONNECTION_SUCCESS","MEETING_RECONNECTION_FAILURE","ReconnectionError","MEETING_RECONNECT_FAILURE","uploadLogs","reset","_this$policy","WEBEX_ASSISTANT_STATUS_ACTIVE","onCloseSocket","_this32","triggerStopReceivingTranscriptionEvent","onErrorSocket","RECEIVE_TRANSCRIPTION_FAILURE","_context2","datachannelUrl","method","HTTP_VERBS","POST","uri","_yield$this$request","webSocketUrl","Transcription","sessionId","subscribe","_this33","MEETING_STARTED_RECEIVING_TRANSCRIPTION","monitorTranscriptionSocketConnection","connect","credentials","supertoken","access_token","closeSocket","MEETING_STOPPED_RECEIVING_TRANSCRIPTION","joinFailed","joinSuccess","setCorrelationId","rejoin","CALL_INITIATED","MEETING_STATE_MACHINE","RINGING","ring","_JOIN_","resourceId","meetingQuality","QUALITY_LEVELS","errorMessage","setLocalQualityLevel","setRemoteQualityLevel","joinMeetingOptions","_this34","JOIN_SUCCESS","_context3","receiveTranscription","isTranscriptionSupported","fail","JOIN_FAILURE","_error$error","phoneNumber","dialInPstn","dialOutPstn","pstnStatus","SUCCESS","includes","isPhoneProvisioned","clientUrl","_this35","onFullLocus","ADD_DIAL_IN_FAILURE","dial_in_url","client_url","_error$error2","_this36","ADD_DIAL_OUT_FAILURE","dial_out_url","_error$error3","disconnectPhoneAudio","MEDIA_CAPABILITIES","mediaCapabilities","rx","share_audio","tx","MOVE_MEDIA","moveToResource","_this37","oldCorrelationId","meetings","meetingCollection","set","_this38","leaveMeeting","moveMeeting","delete","meetingState","FULL_STATE","ACTIVE","MeetingNotActiveError","isUserInLeftState","guest","isUserInIdleState","UserInLobbyError","validateOptions","_this39","setMediaPeerConnection","createPeerConnection","setMercuryListener","setPeerConnectionEvents","preMedia","attachMedia","remoteQualityLevel","enableRtx","enableExtmap","setStartLocalSDPGenRemoteSDPRecvDelay","devices","handleDeviceLogging","handleMediaLogging","setRemoteStream","startInternalStats","autoSendMQA","startMediaQualityMetrics","enableStatsAnalyzer","NetworkQualityMonitor","StatsAnalyzer","MEDIA_QUALITY","intervalMetadata","peerReflexiveIP","geoHintInfo","clientAddress","DEFAULT_IP","intervalData","networkType","NETWORK_QUALITY","sendNetworkQualityEvent","ADD_MEDIA_FAILURE","timerCount","joiningTimer","sendRoapMediaRequest","sdp","connectionState","CONNECTION_STATE","stabilityTimeout","setTimeout","PC_BAIL_TIMEOUT","once","clearTimeout","ADD_MEDIA_SUCCESS","stopAnalyzer","closePeerConnections","unsetPeerConnections","InvalidSdpError","CODE","MEETING_REMOVED_REASON","MEETING_CONNECTION_FAILED","signalingState","SDP","STABLE","RoapCollection","isBusy","queueItem","_this40","push","enqueueMediaUpdate","previousSendShareStatus","_this41","setContentSlides","UPDATE_MEDIA_FAILURE","checkForStopShare","startShare","previousMediaDirection","_this42","sendTrack","receiveTrack","updateTransceiver","_this43","previousShareStatus","stopFloorRequest","_this44","delay","sharingModeIsActive","isSharingOutOfSync","isLocalShareLive","setMediaDirection","setLocalTracks","_INCOMING_","acknowledgeMeeting","_this45","ALERT_DISPLAYED","declineMeeting","decline","_this46","LEAVE","canProceed","leaveReason","CLIENT_LEAVE_REQUEST","_this47","MEETING_LEAVE_FAILURE","channelUrl","resourceToken","mediaShares","element","WHITEBOARD_SHARE_INITIATED","personUrl","changeMeetingFloor","_this48","MEETING_START_WHITEBOARD_SHARE_FAILURE","board","WHITEBOARD_SHARE_STOPPED","STOP_WHITEBOARD_SHARE_FAILURE","_this49","CONTENT","SHARE_INITIATED","_this50","MEETING_SHARE_FAILURE","SHARE_STOPPED","floor","beneficiary","STOP_FLOOR_REQUEST_FAILURE","_this51","startRecording","stopRecording","pauseRecording","resumeRecording","lockMeeting","unlockMeeting","tones","enableDTMF","sendDTMF","rejectWithErrorLog","renderInfo","layoutInfo","LAYOUT_TYPES","mainWidth","Math","round","mainHeight","abs","contentWidth","contentHeight","changeVideoLayoutDebounced","_this52","level","_this53","previousLevel","setLocalVideoQuality","_this54","SET_MEETING_QUALITY_FAILURE","shareConstraints","getDisplayMedia","shareStream","_this55","GET_DISPLAY_MEDIA_FAILURE","USER_ENDED_SHARE_STREAMS","networkQualityScore","typeMedia","performance","now","start","end","startLocalSDPGenRemoteSDPRecvDelay","endLocalSDPGenRemoteSDPRecvDelay","calculatedDelay","METRICS_JOIN_TIMES_MAX_DURATION","startCallInitiateJoinReq","endCallInitiateJoinReq","startJoinReqResp","endJoinReqResp","StatelessWebexPlugin"],"sources":["index.js"],"sourcesContent":["/* globals performance */\nimport uuid from 'uuid';\nimport {cloneDeep, isEqual, pick} from 'lodash';\nimport {StatelessWebexPlugin} from '@webex/webex-core';\n\nimport {\n  MeetingNotActiveError, createMeetingsError, UserInLobbyError,\n  NoMediaEstablishedYetError, UserNotJoinedError, InvalidSdpError\n} from '../common/errors/webex-errors';\nimport StatsAnalyzer from '../statsAnalyzer';\nimport NetworkQualityMonitor from '../networkQualityMonitor';\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport Trigger from '../common/events/trigger-proxy';\nimport Roap from '../roap/index';\nimport Media from '../media';\nimport MediaProperties from '../media/properties';\nimport MeetingStateMachine from '../meeting/state';\nimport createMuteState from '../meeting/muteState';\nimport LocusInfo from '../locus-info';\nimport PeerConnectionManager from '../peer-connection-manager';\nimport Metrics from '../metrics';\nimport {trigger, mediaType, eventType} from '../metrics/config';\nimport ReconnectionManager from '../reconnection-manager';\nimport MeetingRequest from '../meeting/request';\nimport Members from '../members/index';\nimport MeetingUtil from '../meeting/util';\nimport MediaUtil from '../media/util';\nimport WebRTCStats from '../stats/index';\nimport StatsMetrics from '../stats/metrics';\nimport StatsUtil from '../stats/util';\nimport Transcription from '../transcription';\nimport PasswordError from '../common/errors/password-error';\nimport CaptchaError from '../common/errors/captcha-error';\nimport ReconnectionError from '../common/errors/reconnection';\nimport ReconnectInProgress from '../common/errors/reconnection-in-progress';\nimport {\n  _CALL_,\n  _INCOMING_,\n  _JOIN_,\n  _SIP_URI_,\n  AUDIO,\n  CONNECTION_STATE,\n  CONTENT,\n  ENDED,\n  EVENT_TRIGGERS,\n  EVENT_TYPES,\n  EVENTS,\n  FLOOR_ACTION,\n  FULL_STATE,\n  LAYOUT_TYPES,\n  LIVE,\n  LOCUSINFO,\n  MEETING_INFO_FAILURE_REASON,\n  MEETING_REMOVED_REASON,\n  MEETING_STATE_MACHINE,\n  MEETING_STATE,\n  MEETINGS,\n  METRICS_JOIN_TIMES_MAX_DURATION,\n  BEHAVIORAL_METRICS,\n  MQA_STATS,\n  NETWORK_STATUS,\n  ONLINE,\n  OFFLINE,\n  PASSWORD_STATUS,\n  PC_BAIL_TIMEOUT,\n  PSTN_STATUS,\n  QUALITY_LEVELS,\n  RECORDING_STATE,\n  ROAP_SEQ_PRE,\n  SDP,\n  SENDRECV,\n  SHARE_STATUS,\n  SHARE_STOPPED_REASON,\n  STATS,\n  VIDEO_RESOLUTIONS,\n  VIDEO,\n  HTTP_VERBS\n} from '../constants';\nimport ParameterError from '../common/errors/parameter';\nimport MediaError from '../common/errors/media';\nimport {MeetingInfoV2PasswordError, MeetingInfoV2CaptchaError} from '../meeting-info/meeting-info-v2';\nimport MQAProcessor from '../metrics/mqa-processor';\nimport BrowserDetection from '../common/browser-detection';\nimport RoapCollection from '../roap/collection';\n\nimport InMeetingActions from './in-meeting-actions';\n\nconst {isBrowser} = BrowserDetection();\n\nconst logRequest = (request, {header = '', success = '', failure = ''}) => {\n  LoggerProxy.logger.info(header);\n\n  return request\n    .then((arg) => {\n      LoggerProxy.logger.info(success);\n\n      return arg;\n    })\n    .catch((error) => {\n      LoggerProxy.logger.error(failure, error);\n      throw error;\n    });\n};\n\nexport const MEDIA_UPDATE_TYPE = {\n  ALL: 'ALL',\n  AUDIO: 'AUDIO',\n  VIDEO: 'VIDEO',\n  SHARE: 'SHARE'\n};\n\n/**\n * MediaDirection\n * @typedef {Object} MediaDirection\n * @property {boolean} sendAudio\n * @property {boolean} receiveAudio\n * @property {boolean} sendVideo\n * @property {boolean} receiveVideo\n * @property {boolean} sendShare\n * @property {boolean} receiveShare\n * @property {boolean} isSharing\n */\n\n/**\n  * AudioVideo\n  * @typedef {Object} AudioVideo\n  * @property {Object} audio\n  * @property {String} audio.deviceId\n  * @property {Object} video\n  * @property {String} video.deviceId\n  */\n\n/**\n   * SharePreferences\n   * @typedef {Object} SharePreferences\n   * @property {Object} [shareConstraints]\n   * @property {Boolean} [highFrameRate]\n   */\n\n/**\n * JoinOptions\n * @typedef {Object} JoinOptions\n * @property {String} [resourceId]\n * @property {String} [pin]\n * @property {Boolean} [moderator]\n * @property {String|Object} [meetingQuality]\n * @property {String} [meetingQuality.local]\n * @property {String} [meetingQuality.remote]\n * @property {Boolean} [rejoin]\n */\n\n/**\n * SendOptions\n * @typedef {Object} SendOptions\n * @property {Boolean} sendAudio\n * @property {Boolean} sendVideo\n * @property {Boolean} sendShare\n */\n\n/**\n * Recording\n * @typedef {Object} Recording\n * @property {Object} state\n * @property {String} modifiedBy\n */\n\n/**\n  * Meeting State Change Event\n  * Emitted when ever there is a meeting state change\n  * @event meeting:stateChange\n  * @instance\n  * @type {Object}\n  * @property {String} currentState current state of the meeting\n  * @property {String} previousState previous state of the meeting\n  * @memberof Meeting\n  */\n\n/**\n  * Media Ready Event\n  * Emitted when a stream is ready to be rendered\n  * @event media:ready\n  * @instance\n  * @type {Object}\n  * @property {MediaStream} stream the media stream\n  * @property {String} type what type of stream, remote, local\n  * @memberof Meeting\n  */\n\n/**\n  * Media Stopped Event\n  * Emitted when a stream has stopped sending\n  * @event media:stopped\n  * @instance\n  * @type {Object}\n  * @property {String} type what type of stream, remote, local\n  * @memberof Meeting\n  */\n\n/**\n * Meeting Ringing Event\n * Emitted when this client should play a ringing sound, because this member is getting an incoming meeting\n * or sending out an incoming meeting\n * @event meeting:ringing\n * @instance\n * @type {Object}\n * @property {String} type // INCOMING or JOIN\n * @property {String} id\n * @memberof Meeting\n */\n\n/**\n * Meeting Ringing Stop Event\n * Emitted when this client should stop playing a ringing sound\n * @event meeting:ringingStop\n * @instance\n * @type {Object}\n * @property {Object} type\n * @property {Boolean} type.remoteAnswered\n * @property {Boolean} type.remoteDeclined\n * @property {String} id\n * @memberof Meeting\n */\n\n/**\n * Meeting Started Sharing Local Event\n * Emitted when this member starts sharing\n * @event meeting:startedSharingLocal\n * @instance\n * @type {Object}\n * @memberof Meeting\n */\n\n/**\n * Meeting Stopped Sharing Local Event\n * Emitted when this member stops sharing\n * @event meeting:stoppedSharingLocal\n * @instance\n * @type {Object}\n * @memberof Meeting\n */\n\n/**\n * Meeting Started Sharing Remote Event\n * Emitted when remote sharing starts\n * @event meeting:startedSharingRemote\n * @instance\n * @type {Object}\n * @property {Boolean} memberId id of the meeting member that started screen share\n * @memberof Meeting\n */\n\n/**\n * Meeting Stopped Sharing Remote Event\n * Emitted when remote screen sharing ends\n * @event meeting:stoppedSharingRemote\n * @instance\n * @type {Object}\n * @memberof Meeting\n */\n\n/**\n * Meeting Locked Event\n * Emitted when a meeting is locked\n * @event meeting:locked\n * @instance\n * @type {Object}\n * @property {Object} info\n * @memberof Meeting\n */\n\n/**\n * Meeting Unlocked Event\n * Emitted when a meeting is unlocked\n * @event meeting:unlocked\n * @instance\n * @type {Object}\n * @property {Object} info\n * @memberof Meeting\n */\n\n/**\n * Meeting Actions Update Event\n * Emitted when a user can take actions on a meeting such as lock, unlock, assign host\n * @event meeting:actionsUpdate\n * @instance\n * @type {Object}\n * @property {Boolean} canLock\n * @property {Boolean} canUnlock\n * @property {Boolean} canAssignHost\n * @memberof Meeting\n */\n\n/**\n * Meeting Unmuted By Others Event\n * Emitted when a member is unmuted by another member\n * @event meeting:self:unmutedByOthers\n * @instance\n * @type {Object}\n * @property {Object} payload\n * @memberof Meeting\n */\n\n/**\n * Meeting Muted By Others Event\n * Emitted when a member is muted by another member\n * @event meeting:self:mutedByOthers\n * @instance\n * @type {Object}\n * @property {Object} payload\n * @property {Boolean} payload.unmuteAllowed - whether the user is allowed to unmute self\n * @memberof Meeting\n */\n\n/**\n * Meeting Muted By Others Event\n * Emitted when the host(moderator)/co-host requests a user to unmute\n * @event meeting:self:requestedToUnmute\n * @instance\n * @type {Object}\n * @property {Object} payload\n * @memberof Meeting\n */\n\n\n/**\n * Meeting Self Guest Admitted Event\n * Emitted when a joined user get admitted to the meeting by another member or host\n * @event meeting:self:guestAdmitted\n * @instance\n * @type {Object}\n * @property {Object} payload\n * @memberof Meeting\n */\n\n/**\n * Meeting Self Lobby Waiting Event\n * Emitted when joined user enters the lobby and is waiting for the webex meeting to begin\n * @event meeting:self:lobbyWaiting\n * @instance\n * @type {Object}\n * @property {Object} reason Reason why user left the meeting\n * @memberof Meeting\n */\n\n/**\n * Meeting Self Left State\n * Emitted when user is inactive for more then 40 seconds, User can rejoin the meeting again\n * @event meeting:self:left\n * @instance\n * @type {Object}\n * @property {Object} payload\n * @memberof Meeting\n */\n\n/**\n  * Reconnection Starting Event\n  * Emitted when reconnection of media to the active meeting was successful\n  * @event meeting:reconnectionStarting\n  * @instance\n  * @memberof Meeting\n  */\n\n/**\n  * Reconnection Success Event\n  * Emitted when reconnection of media to the active meeting was successful\n  * @event meeting:reconnectionSuccess\n  * @instance\n  * @type {Object}\n  * @property {Object} reconnect\n  * @memberof Meeting\n  */\n\n/**\n  * Reconnection Failure Event\n  * Emitted when reconnection of media to the active meeting was successful\n  * @event meeting:reconnectionFailure\n  * @instance\n  * @type {Object}\n  * @property {Error} error\n  * @memberof Meeting\n  */\n\n/**\n  * Meeting network quality event\n  * Emitted on each interval of retrieving stats Analyzer data\n  * @event network:quality\n  * @type {Object}\n  * @property {string} mediaType {video|audio}\n  * @property {number} networkQualityScore - {1|0} 1 indicates acceptable uplink 0 indicates unacceptable uplink based on threshold\n  * @memberof Meeting\n  */\n\n/**\n * @description Meeting is the crux of the plugin\n * @export\n * @class Meeting\n */\nexport default class Meeting extends StatelessWebexPlugin {\n  namespace = MEETINGS;\n\n  /**\n   * @param {Object} attrs\n   * @param {Object} options\n   * @constructor\n   * @memberof Meeting\n  */\n  constructor(attrs, options) {\n    super({}, options);\n    /**\n     * @instance\n     * @type {Object}\n     * @readonly\n     * @private\n     * @memberof Meeting\n     */\n    this.attrs = attrs;\n    /**\n     * @instance\n     * @type {Object}\n     * @readonly\n     * @private\n     * @memberof Meeting\n     */\n    this.options = options;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n    this.id = uuid.v4();\n    /**\n     * Correlation ID used for network tracking of meeting join\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n    this.correlationId = this.id;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n    this.userId = attrs.userId;\n    /**\n     * Organization ID\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n    this.orgId = attrs.orgId;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n    this.resource = attrs.resource;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n    this.deviceUrl = attrs.deviceUrl;\n    /**\n     * @description set you -1 as default values is 0 (used to idenfify if 1st roap request was sent)\n     * @instance\n     * @type {Number}\n     * @readonly\n     * @private\n     * @memberof Meeting\n     */\n    this.roapSeq = ROAP_SEQ_PRE;\n    /**\n     * @instance\n     * @type {Object}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n    // TODO: needs to be defined as a class\n    this.meetingInfo = {};\n    /**\n     * @instance\n     * @type {Members}\n     * @public\n     * @memberof Meeting\n     */\n    this.members = new Members({locusUrl: (attrs.locus && attrs.locus.url)}, {parent: this.webex});\n    /**\n     * @instance\n     * @type {Roap}\n     * @readonly\n     * @private\n     * @memberof Meeting\n     */\n    this.roap = new Roap({}, {parent: this.webex});\n    /**\n     * created later\n     * @instance\n     * @type {ReconnectionManager}\n     * @readonly\n     * @private\n     * @memberof Meeting\n     */\n    this.reconnectionManager = new ReconnectionManager(this);\n    /**\n     * created later\n     * @instance\n     * @type {MuteState}\n     * @private\n     * @memberof Meeting\n     */\n    this.audio = null;\n    /**\n     * created later\n     * @instance\n     * @type {MuteState}\n     * @private\n     * @memberof Meeting\n     */\n    this.video = null;\n    /**\n     * @instance\n     * @type {MeetingStateMachine}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n    this.meetingFiniteStateMachine = MeetingStateMachine.create(this);\n    /**\n     * @instance\n     * @type {WebRTCStats}\n     * @public\n     * @memberof Meeting\n     */\n    this.stats = null;\n    /**\n     * @instance\n     * @type {WebRTCStats}\n     * @readonly\n     * @private\n     * @memberof Meeting\n     */\n    this.internalStats = null;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n    this.conversationUrl = null;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n    this.locusUrl = (attrs.locus && attrs.locus.url) || null;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n    this.sipUri = null;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n    this.partner = null;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n    this.type = null;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n    this.owner = null;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n    this.hostId = null;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n    this.policy = null;\n    /**\n     * @instance\n     * @type {MeetingRequest}\n     * @private\n     * @memberof Meeting\n     */\n    this.meetingRequest = new MeetingRequest({}, options);\n    /**\n     * @instance\n     * @type {Array}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n    this.mediaConnections = null;\n    /**\n     * Update the MediaConnections property with new information\n     * @param {array} mediaConnections\n     * @returns {undefined}\n     * @private\n     * @memberof Meeting\n     */\n    this.updateMediaConnections = (mediaConnections) => {\n      if (!isEqual(this.mediaConnections, mediaConnections)) {\n        // grab last/latest item in the new mediaConnections information\n        this.mediaConnections = mediaConnections.slice(-1);\n      }\n    };\n    /**\n     * Passing only info as we send basic info for meeting added event\n     * @instance\n     * @type {MediaProperties}\n     * @public\n     * @memberof Meeting\n     */\n    this.mediaProperties = new MediaProperties();\n    /**\n     * @instance\n     * @type {InMeetingActions}\n     * @public\n     * @memberof Meeting\n    */\n    this.inMeetingActions = new InMeetingActions();\n    /**\n     * This is deprecated, please use shareStatus instead.\n     * @instance\n     * @type {Boolean}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     * @deprecated after v1.118.13\n     */\n    this.isSharing = false;\n    /**\n     * @instance\n     * @type {Boolean}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n    this.shareStatus = SHARE_STATUS.NO_SHARE;\n    /**\n     * @instance\n     * @type {Boolean}\n     * @readonly\n     * @private\n     * @memberof Meeting\n     */\n    Object.defineProperty(this, 'isLocalShareLive', {\n      get: () => {\n        const {shareTransceiver} = this.mediaProperties.peerConnection;\n        const shareDirection = shareTransceiver?.direction;\n        const trackReadyState = shareTransceiver?.sender?.track?.readyState;\n        const activeShare = trackReadyState === LIVE;\n        const offersToSendData = shareDirection === SENDRECV;\n\n        if (activeShare && offersToSendData) {\n          return true;\n        }\n\n        return false;\n      },\n      configurable: true\n    });\n    /**\n     * @instance\n     * @type {Array}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n    this.callEvents = [];\n    /**\n     * There is a pending floor requested by the user\n     * @instance\n     * @type {floorGrantPending}\n     * @private\n     * @memberof Meeting\n     */\n    this.floorGrantPending = false;\n    /**\n     * The latest status of the dial in device (can be \"JOINED\", \"CONNECTED\", \"LEFT\",\n     * \"TRANSFERRING\", \"SUCCESS\" or \"\")\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Meeting\n     */\n    this.dialInDeviceStatus = PSTN_STATUS.UNKNOWN;\n    /**\n     * the url for provisioned device used to dial in\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Meeting\n     */\n    this.dialInUrl = '';\n    /**\n     * The latest status of the dial out device (can be \"JOINED\", \"CONNECTED\", \"LEFT\",\n     * \"TRANSFERRING\", \"SUCCESS\" or \"\")\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Meeting\n     */\n    this.dialOutDeviceStatus = PSTN_STATUS.UNKNOWN;\n    /**\n     * the url for provisioned device used to dial out\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof Meeting\n     */\n    this.dialOutUrl = '';\n    /**\n     * @instance\n     * @type {MediaMetrics}\n     * @readonly\n     * @private\n     * @memberof Meeting\n     */\n    this.mediaQualityMetrics = null;\n    /**\n     * @instance\n     * @type {StatsAnalyzer}\n     * @private\n     * @memberof Meeting\n     */\n    this.statsAnalyzer = null;\n    /**\n     * @instance\n     * @type {NetworkQualityMonitor}\n     * @private\n     * @memberof Meeting\n     */\n    this.networkQualityMonitor = null;\n    /**\n     * @instance\n     * @type {MQAProcessor}\n     * @readonly\n     * @private\n     * @memberof Meeting\n     */\n    this.mqaProcessor = null;\n    /**\n     * @instance\n     * @type {String}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n    this.networkStatus = null;\n    /**\n     * Passing only info as we send basic info for meeting added event\n     * @instance\n     * @type {MeetingRequest}\n     * @private\n     * @memberof Meeting\n     */\n    this.locusInfo = new LocusInfo(this.updateMeetingObject.bind(this), this.webex, this.id);\n    // We had to add listeners first before setting up the locus instance\n    /**\n     * @instance\n     * @type {Recording}\n     * @readonly\n     * @public\n     * @memberof Meeting\n     */\n    this.recording = null;\n\n    /**\n     * Promise that exists if joining, and resolves upon method completion.\n     * @instance\n     * @type {Promise}\n     * @private\n     * @memberof Meeting\n     */\n    this.deferJoin = undefined;\n\n    /**\n     * Staus of websocket connection/mercury connection.\n     * @instance\n     * @type {Boolean}\n     * @private\n     * @memberof Meeting\n     */\n    this.hasWebsocketConnected = this.webex.internal.mercury.connected;\n\n    /**\n     * Last sent render information\n     * @instance\n     * @type {Object}\n     * @private\n     * @memberof Meeting\n     */\n    this.lastVideoLayoutInfo = {layoutType: undefined, main: undefined, content: undefined};\n\n    /**\n     * Queue of pending media updates requested by the app\n     * @instance\n     * @type {Array}\n     * @private\n     * @memberof Meeting\n     */\n    this.queuedMediaUpdates = [];\n\n    /**\n     * Meeting transcription object\n     * @instance\n     * @type {Transcription}\n     * @private\n     * @memberof Meeting\n     */\n    this.transcription = undefined;\n\n    /**\n     * Password status. If it's PASSWORD_STATUS.REQUIRED then verifyPassword() needs to be called\n     * with the correct password before calling join()\n     * @instance\n     * @type {PASSWORD_STATUS}\n     * @public\n     * @memberof Meeting\n     */\n    this.passwordStatus = PASSWORD_STATUS.UNKNOWN;\n\n    /**\n     * Information about required captcha. If null, then no captcha is required. status. If it's PASSWORD_STATUS.REQUIRED then verifyPassword() needs to be called\n     * with the correct password before calling join()\n     * @instance\n     * @type {Object}\n     * @property {string} captchaId captcha id\n     * @property {string} verificationImageURL Url of the captcha image\n     * @property {string} verificationAudioURL Url of the captcha audio file\n     * @property {string} refreshURL Url used for refreshing the captcha (don't use it directly, call refreshCaptcha() instead)\n     * @public\n     * @memberof Meeting\n     */\n    this.requiredCaptcha = null;\n\n    /**\n     * Indicates the reason for last failure to obtain meeting.meetingInfo. MEETING_INFO_FAILURE_REASON.NONE if meeting info was\n     * retrieved successfully\n     * @instance\n     * @type {MEETING_INFO_FAILURE_REASON}\n     * @private\n     * @memberof Meeting\n     */\n    this.meetingInfoFailureReason = undefined;\n\n    this.setUpLocusInfoListeners();\n    this.locusInfo.init(attrs.locus ? attrs.locus : {});\n    this.hasJoinedOnce = false;\n  }\n\n  /**\n   * Fetches meeting information.\n   * @param {Object} options\n   * @param {String} options.destination\n   * @param {String} options.type\n   * @private\n   * @memberof Meeting\n   * @returns {Promise}\n   */\n  async fetchMeetingInfo({\n    destination, type, password = null, captchaCode = null\n  }) {\n    if (captchaCode && !this.requiredCaptcha) {\n      return Promise.reject(new Error('fetchMeetingInfo() called with captchaCode when captcha was not required'));\n    }\n    if (password && (this.passwordStatus !== PASSWORD_STATUS.REQUIRED && this.passwordStatus !== PASSWORD_STATUS.UNKNOWN)) {\n      return Promise.reject(new Error('fetchMeetingInfo() called with password when password was not required'));\n    }\n\n    try {\n      const captchaInfo = captchaCode ? {code: captchaCode, id: this.requiredCaptcha.captchaId} : null;\n\n      const info = await this.attrs.meetingInfoProvider.fetchMeetingInfo(destination, type, password, captchaInfo);\n\n      this.parseMeetingInfo(info);\n      this.meetingInfo = info ? info.body : null;\n      this.meetingInfoFailureReason = MEETING_INFO_FAILURE_REASON.NONE;\n      this.requiredCaptcha = null;\n      if ((this.passwordStatus === PASSWORD_STATUS.REQUIRED) || (this.passwordStatus === PASSWORD_STATUS.VERIFIED)) {\n        this.passwordStatus = PASSWORD_STATUS.VERIFIED;\n      }\n      else {\n        this.passwordStatus = PASSWORD_STATUS.NOT_REQUIRED;\n      }\n\n      return Promise.resolve();\n    }\n    catch (err) {\n      if (err instanceof MeetingInfoV2PasswordError) {\n        LoggerProxy.logger.info(`Meeting:index#fetchMeetingInfo --> Info Unable to fetch meeting info for ${destination} - password required (code=${err?.body?.code}).`);\n\n        // when wbxappapi requires password it still populates partial meeting info in the response\n        if (err.meetingInfo) {\n          this.meetingInfo = err.meetingInfo;\n          this.meetingNumber = err.meetingInfo.meetingNumber;\n        }\n\n        this.passwordStatus = PASSWORD_STATUS.REQUIRED;\n        this.meetingInfoFailureReason = MEETING_INFO_FAILURE_REASON.WRONG_PASSWORD;\n        if (this.requiredCaptcha) {\n          // this is a workaround for captcha service bug, see WEBEX-224862\n          await this.refreshCaptcha();\n        }\n\n        throw (new PasswordError());\n      }\n      else if (err instanceof MeetingInfoV2CaptchaError) {\n        LoggerProxy.logger.info(`Meeting:index#fetchMeetingInfo --> Info Unable to fetch meeting info for ${destination} - captcha required (code=${err?.body?.code}).`);\n\n        this.meetingInfoFailureReason = (this.requiredCaptcha) ?\n          MEETING_INFO_FAILURE_REASON.WRONG_CAPTCHA :\n          MEETING_INFO_FAILURE_REASON.WRONG_PASSWORD;\n\n        if (err.isPasswordRequired) {\n          this.passwordStatus = PASSWORD_STATUS.REQUIRED;\n        }\n\n        this.requiredCaptcha = err.captchaInfo;\n        throw (new CaptchaError());\n      }\n      else {\n        this.meetingInfoFailureReason = MEETING_INFO_FAILURE_REASON.OTHER;\n        throw (err);\n      }\n    }\n  }\n\n  /**\n   * Checks if the supplied password/host key is correct. It returns a promise with information whether the\n   * password and captcha code were correct or not.\n   * @param {String} password - this can be either a password or a host key, can be undefined if only captcha was required\n   * @param {String} captchaCode - can be undefined if captcha was not required by the server\n   * @public\n   * @memberof Meeting\n   * @returns {Promise<{isPasswordValid: boolean, requiredCaptcha: boolean, failureReason: MEETING_INFO_FAILURE_REASON}>}\n   */\n  verifyPassword(password, captchaCode) {\n    return this.fetchMeetingInfo({\n      destination: this.sipUri, type: _SIP_URI_, password, captchaCode\n    })\n      .then(() => ({isPasswordValid: true, requiredCaptcha: null, failureReason: MEETING_INFO_FAILURE_REASON.NONE}))\n      .catch((error) => {\n        if (error instanceof PasswordError || error instanceof CaptchaError) {\n          return {\n            isPasswordValid: this.passwordStatus === PASSWORD_STATUS.VERIFIED,\n            requiredCaptcha: this.requiredCaptcha,\n            failureReason: this.meetingInfoFailureReason\n          };\n        }\n        throw (error);\n      });\n  }\n\n  /**\n   * Refreshes the captcha. As a result the meeting will have new captcha id, image and audio.\n   * If the refresh operation fails, meeting remains with the old captcha properties.\n   * @public\n   * @memberof Meeting\n   * @returns {Promise}\n   */\n  refreshCaptcha() {\n    if (!this.requiredCaptcha) {\n      return Promise.reject(new Error('There is no captcha to refresh'));\n    }\n\n    // in order to get fully populated uris for captcha audio and image in response to refresh captcha request\n    // we have to pass the wbxappapi hostname as the siteFullName parameter\n    const {hostname} = new URL(this.requiredCaptcha.refreshURL);\n\n    return this.meetingRequest.refreshCaptcha({\n      captchaRefreshUrl: `${this.requiredCaptcha.refreshURL}&siteFullName=${hostname}`,\n      captchaId: this.requiredCaptcha.captchaId\n    })\n      .then((response) => {\n        this.requiredCaptcha.captchaId = response.body.captchaID;\n        this.requiredCaptcha.verificationImageURL = response.body.verificationImageURL;\n        this.requiredCaptcha.verificationAudioURL = response.body.verificationAudioURL;\n      });\n  }\n\n  /**\n   * Proxy function for all the listener set ups\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   */\n  setUpLocusInfoListeners() {\n    // meeting update listeners\n    this.setUpLocusInfoSelfListener();\n    this.setUpLocusInfoMeetingListener();\n    // members update listeners\n    this.setUpLocusFullStateListener();\n    this.setUpLocusUrlListener();\n    this.setUpLocusHostListener();\n    this.setUpLocusSelfListener();\n    this.setUpLocusParticipantsListener();\n    this.setupLocusControlsListener();\n    this.setUpLocusMediaSharesListener();\n    this.setUpLocusInfoMeetingInfoListener();\n    this.setUpLocusInfoAssignHostListener();\n    this.setUpLocusInfoMediaInactiveListener();\n  }\n\n\n  /**\n   * Set up the locus info listener for meetings disconnected due to inactivity\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   */\n  setUpLocusInfoMediaInactiveListener() {\n    // User gets kicked off the meeting due to inactivity or user did a refresh\n    this.locusInfo.on(EVENTS.DISCONNECT_DUE_TO_INACTIVITY, (res) => {\n      // https:// jira-eng-gpk2.cisco.com/jira/browse/SPARK-240520\n      // TODO: send custom parameter explaining why the inactivity happened\n      // refresh , no media or network got dsconnected or something else\n      Metrics.sendBehavioralMetric(\n        BEHAVIORAL_METRICS.DISCONNECT_DUE_TO_INACTIVITY,\n        {\n          correlation_id: this.correlationId,\n          locus_id: this.locusId\n        }\n      );\n\n      // Upload logs on media inactivity\n      // Normally media should not be inactive\n      Trigger.trigger(\n        this,\n        {\n          file: 'meeting/index',\n          function: 'setUpLocusInfoMediaInactiveListener'\n        },\n        EVENTS.REQUEST_UPLOAD_LOGS,\n        this\n      );\n\n      LoggerProxy.logger.error(`Meeting:index#setUpLocusInfoMediaInactiveListener --> Meeting disconnected due to inactivity: ${res.reason}`);\n\n      if (this.config.reconnection.autoRejoin) {\n        this.reconnect();\n      }\n      else {\n        Trigger.trigger(\n          this,\n          {\n            file: 'meeting/index',\n            function: 'setUpLocusInfoMediaInactiveListener'\n          },\n          EVENT_TRIGGERS.MEETING_SELF_LEFT,\n          res.reason\n        );\n      }\n    });\n  }\n\n  /**\n   * Set up the locus info listener for assign host permissions on a meeting\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   */\n  setUpLocusInfoAssignHostListener() {\n    this.locusInfo.on(EVENTS.LOCUS_INFO_CAN_ASSIGN_HOST, (payload) => {\n      Trigger.trigger(\n        this,\n        {\n          file: 'meeting/index',\n          function: 'setUpLocusInfoAssignHostListener'\n        },\n        EVENT_TRIGGERS.MEETING_ACTIONS_UPDATE,\n        {\n          canAssignHost: payload.canAssignHost,\n          canLock: this.inMeetingActions.getCanLock(),\n          canUnlock: this.inMeetingActions.getCanUnlock()\n        }\n      );\n      this.inMeetingActions.setCanAssignHost(payload.canAssignHost);\n    });\n  }\n\n  /**\n   * Set up the internal locus info full state object listener\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   */\n  setUpLocusFullStateListener() {\n    this.locusInfo.on(LOCUSINFO.EVENTS.FULL_STATE_MEETING_STATE_CHANGE, (payload) => {\n      Trigger.trigger(\n        this,\n        {\n          file: 'meeting/index',\n          function: 'setUpLocusFullStateListener'\n        },\n        EVENT_TRIGGERS.MEETING_STATE_CHANGE,\n        {\n          payload\n        }\n      );\n    });\n\n    this.locusInfo.on(LOCUSINFO.EVENTS.FULL_STATE_TYPE_UPDATE, (payload) => {\n      this.members.locusFullStateTypeUpdate(payload);\n    });\n  }\n\n  /**\n   * get the metrics payload pre\n   * @param {Object} options\n   * @param {String} options.event\n   * @param {String} options.trackingId\n   * @param {Object} options.locus\n   * @param {Array} options.mediaConnections\n   * @returns {Object}\n   * @memberof Meeting\n   */\n  getAnalyzerMetricsPrePayload(options) {\n    if (options) {\n      const {\n        event,\n        trackingId,\n        mediaConnections\n      } = options;\n\n      if (!event) {\n        LoggerProxy.logger.error('Meeting:index#getAnalyzerMetricsPrePayload --> Error [Call Analyzer Event', event || '', `]: invalid identifers or event type! ${this.correlationId}`);\n\n        return null;\n      }\n\n      const identifiers = {\n        correlationId: this.correlationId,\n        userId: this.userId,\n        deviceId: this.deviceUrl,\n        orgId: this.orgId,\n        locusUrl: this.webex.internal.services.get('locus')\n      };\n\n      if (this.locusUrl && this.locusInfo.fullState) {\n        identifiers.locusUrl = this.locusUrl;\n        identifiers.locusId = this.locusUrl && this.locusUrl.split('/').pop();\n        identifiers.locusStartTime = this.locusInfo.fullState && this.locusInfo.fullState.lastActive;\n      }\n\n      // Check if mediaConnections has been passed in or else use this.mediaConnections\n      if (mediaConnections) {\n        identifiers.mediaAgentAlias = mediaConnections?.[0].mediaAgentAlias;\n        identifiers.mediaAgentGroupId = mediaConnections?.[0].mediaAgentGroupId;\n        identifiers.mediaAgentCluster = mediaConnections?.[0].mediaAgentCluster;\n      }\n      else if (this.mediaConnections) {\n        identifiers.mediaAgentAlias = this.mediaConnections?.[0].mediaAgentAlias;\n        identifiers.mediaAgentGroupId = this.mediaConnections?.[0].mediaAgentGroupId;\n        identifiers.mediaAgentCluster = this.mediaConnections?.[0].mediaAgentCluster;\n      }\n\n      if (options.trackingId) {\n        identifiers.trackingId = trackingId;\n      }\n\n      let payload = {};\n\n      const joinRespRxStartAudio = this.getSetupDelayDuration('audio');\n\n      if (joinRespRxStartAudio) {\n        options.audioSetupDelay = {\n          joinRespRxStart: joinRespRxStartAudio\n        };\n      }\n\n      const joinRespRxStartVideo = this.getSetupDelayDuration('video');\n\n      if (joinRespRxStartAudio) {\n        options.videoSetupDelay = {\n          joinRespRxStart: joinRespRxStartVideo\n        };\n      }\n\n      const joinRespTxStartAudio = this.getSendingMediaDelayDuration('audio');\n\n      if (joinRespTxStartAudio) {\n        options.audioSetupDelay = {\n          ...options.audioSetupDelay,\n          joinRespTxStart: joinRespTxStartAudio\n        };\n      }\n\n      const joinRespTxStartVideo = this.getSendingMediaDelayDuration('video');\n\n      if (joinRespTxStartVideo) {\n        options.videoSetupDelay = {\n          ...options.videoSetupDelay,\n          joinRespTxStart: joinRespTxStartVideo\n        };\n      }\n\n      const localSDPGenRemoteSDPRecv = this.getLocalSDPGenRemoteSDPRecvDelay();\n\n      if (localSDPGenRemoteSDPRecv) {\n        options.joinTimes = {\n          ...options.joinTimes,\n          localSDPGenRemoteSDPRecv\n        };\n      }\n\n      const callInitiateJoinReq = this.getCallInitiateJoinReq();\n\n      if (callInitiateJoinReq) {\n        options.joinTimes = {\n          ...options.joinTimes,\n          callInitiateJoinReq\n        };\n      }\n\n      const joinReqResp = this.getJoinReqResp();\n\n      if (joinReqResp) {\n        options.joinTimes = {\n          ...options.joinTimes,\n          joinReqResp\n        };\n      }\n\n      const getTotalJmt = this.getTotalJmt();\n\n      if (getTotalJmt) {\n        options.joinTimes = {\n          ...options.joinTimes,\n          getTotalJmt\n        };\n      }\n\n      if (options.type === MQA_STATS.CA_TYPE) {\n        payload = Metrics.initMediaPayload(options.event, identifiers, options);\n      }\n      else {\n        payload = Metrics.initPayload(options.event, identifiers, options);\n      }\n\n      return payload;\n    }\n\n    return null;\n  }\n\n  /**\n   * Send the metrics to call-analyzer dashboard\n   * @param {Object} options\n   * @param {String} options.event\n   * @param {String} options.trackingId\n   * @param {Object} options.locus\n   * @returns {Promise}\n   * @private\n   * @memberof Meeting\n   */\n  sendCallAnalyzerMetrics(options) {\n    const payload = this.getAnalyzerMetricsPrePayload({\n      ...pick(this.config.metrics, ['clientType', 'subClientType']),\n      ...options\n    });\n\n    return this.webex.internal.metrics.submitCallDiagnosticEvents(payload);\n  }\n\n  /**\n   * Send the metrics to Media Quality Analyzer dashboard\n   * @param {Object} options\n   * @param {String} options.event\n   * @param {String} options.trackingId\n   * @param {Object} options.locus\n   * @returns {Promise}\n   * @private\n   * @memberof Meeting\n   */\n  sendMediaQualityAnalyzerMetrics(options) {\n    const payload = this.getAnalyzerMetricsPrePayload({\n      type: MQA_STATS.CA_TYPE,\n      ...pick(this.config.metrics, ['clientType', 'subClientType']),\n      ...options\n    });\n\n    return this.webex.internal.metrics.submitCallDiagnosticEvents(payload);\n  }\n\n  /**\n   * sets the network status on meeting object\n   * @param {String} networkStatus\n   * @private\n   * @returns {undefined}\n   * @memberof Meeting\n   */\n  setNetworkStatus(networkStatus) {\n    if (networkStatus === NETWORK_STATUS.DISCONNECTED) {\n      Trigger.trigger(\n        this,\n        {\n          file: 'meeting/index',\n          function: 'setNetworkStatus'\n        },\n        EVENT_TRIGGERS.MEETINGS_NETWORK_DISCONNECTED,\n      );\n    }\n    else if (networkStatus === NETWORK_STATUS.CONNECTED && this.networkStatus === NETWORK_STATUS.DISCONNECTED) {\n      Trigger.trigger(\n        this,\n        {\n          file: 'meeting/index',\n          function: 'setNetworkStatus'\n        },\n        EVENT_TRIGGERS.MEETINGS_NETWORK_CONNECTED,\n      );\n    }\n\n    this.networkStatus = networkStatus;\n  }\n\n  /**\n   * Set up the locus info self listener\n   * update self value for members and updates the member\n   * notifies consumer with members:self:update {activeSelfId endedSelfId}\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   */\n  setUpLocusSelfListener() {\n    this.locusInfo.on(EVENTS.LOCUS_INFO_UPDATE_SELF, (payload) => {\n      this.members.locusSelfUpdate(payload);\n      this.pstnUpdate(payload);\n\n      // If user moved to a JOINED state and there is a pending floor grant trigger it\n      if (this.floorGrantPending && payload.newSelf.state === MEETING_STATE.STATES.JOINED) {\n        this.share()\n          .then(() => { this.floorGrantPending = false; });\n      }\n    });\n  }\n\n  /**\n   * Notify any changes on the pstn devices\n   * @param {Object} payload\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   */\n  pstnUpdate(payload) {\n    if (this.locusInfo.self) {\n      const dialInPstnDevice = payload.newSelf?.pstnDevices.find((device) => device.url === this.dialInUrl);\n      const dialOutPstnDevice = payload.newSelf?.pstnDevices.find((device) => device.url === this.dialOutUrl);\n      let changed = false;\n\n      if (dialInPstnDevice) {\n        const newStatus = dialInPstnDevice.dialingStatus ?? dialInPstnDevice.state;\n\n        if (newStatus !== this.dialInDeviceStatus) {\n          this.dialInDeviceStatus = newStatus;\n          changed = true;\n        }\n      }\n\n      if (dialOutPstnDevice) {\n        const newStatus = dialOutPstnDevice.dialingStatus ?? dialOutPstnDevice.state;\n\n        if (newStatus !== this.dialOutDeviceStatus) {\n          this.dialOutDeviceStatus = newStatus;\n          changed = true;\n        }\n      }\n\n      if (changed) {\n        Trigger.trigger(\n          this,\n          {\n            file: 'meeting/index',\n            function: 'setUpLocusSelfListener'\n          },\n          EVENT_TRIGGERS.MEETING_SELF_PHONE_AUDIO_UPDATE,\n          {\n            dialIn: {\n              status: this.dialInDeviceStatus,\n              attendeeId: dialInPstnDevice?.attendeeId\n            },\n            dialOut: {\n              status: this.dialOutDeviceStatus,\n              attendeeId: dialOutPstnDevice?.attendeeId\n            }\n          }\n        );\n      }\n    }\n  }\n\n  /**\n   * Set up the locus info host listener\n   * update host value for members and updates the member\n   * notifies consumer with members:host:update: {activeHostId, endedHostId}\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   */\n  setUpLocusHostListener() {\n    this.locusInfo.on(EVENTS.LOCUS_INFO_UPDATE_HOST, (payload) => {\n      this.members.locusHostUpdate(payload);\n    });\n  }\n\n  /**\n   * Set up the locus info participants update listener\n   * update members collection value for members\n   * notifies consumer with members:update\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   */\n  setUpLocusParticipantsListener() {\n    this.locusInfo.on(EVENTS.LOCUS_INFO_UPDATE_PARTICIPANTS, (payload) => {\n      this.members.locusParticipantsUpdate(payload);\n    });\n  }\n\n\n  /**\n   * Set up the locus info recording update listener\n   * update recording value for the meeting\n   * notifies consumer with:\n   *  meeting:recording:started\n   *  meeting:recording:stopped\n   *  meeting:recording:paused\n   *  meeting:recording:resumed\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   */\n  setupLocusControlsListener() {\n    this.locusInfo.on(LOCUSINFO.EVENTS.CONTROLS_RECORDING_UPDATED,\n      ({state, modifiedBy, lastModified}) => {\n        let event;\n\n        switch (state) {\n          case RECORDING_STATE.RECORDING:\n            event = EVENT_TRIGGERS.MEETING_STARTED_RECORDING;\n            break;\n          case RECORDING_STATE.IDLE:\n            event = EVENT_TRIGGERS.MEETING_STOPPED_RECORDING;\n            break;\n          case RECORDING_STATE.PAUSED:\n            event = EVENT_TRIGGERS.MEETING_PAUSED_RECORDING;\n            break;\n          case RECORDING_STATE.RESUMED:\n            event = EVENT_TRIGGERS.MEETING_RESUMED_RECORDING;\n            break;\n          default:\n            event = null;\n            break;\n        }\n\n        // `RESUMED` state should be converted to `RECORDING` after triggering the event\n        this.recording = {\n          state: state === RECORDING_STATE.RESUMED ? RECORDING_STATE.RECORDING : state,\n          modifiedBy,\n          lastModified\n        };\n\n        Trigger.trigger(\n          this,\n          {\n            file: 'meeting/index',\n            function: 'setupLocusControlsListener'\n          },\n          event,\n          this.recording\n        );\n      });\n  }\n\n  /**\n   * Set up the locus info media shares listener\n   * update content and whiteboard sharing id value for members, and updates the member\n   * notifies consumer with members:content:update {activeContentSharingId, endedContentSharingId}\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   */\n  setUpLocusMediaSharesListener() {\n    // Will get triggered on local and remote share\n    this.locusInfo.on(EVENTS.LOCUS_INFO_UPDATE_MEDIA_SHARES, (payload) => {\n      const {content: contentShare, whiteboard: whiteboardShare} = payload.current;\n      const previousContentShare = payload.previous?.content;\n      const previousWhiteboardShare = payload.previous?.whiteboard;\n\n      if (\n        (contentShare.beneficiaryId === previousContentShare?.beneficiaryId &&\n          contentShare.disposition === previousContentShare?.disposition) &&\n        (whiteboardShare.beneficiaryId === previousWhiteboardShare?.beneficiaryId &&\n          whiteboardShare.disposition === previousWhiteboardShare?.disposition &&\n          whiteboardShare.resourceUrl === previousWhiteboardShare?.resourceUrl)\n      ) {\n        // nothing changed, so ignore\n        // (this happens when we steal presentation from remote)\n        return;\n      }\n\n      let newShareStatus = this.shareStatus;\n\n      // REMOTE - check if remote started sharing\n      if (\n        this.selfId !== contentShare.beneficiaryId &&\n        contentShare.disposition === FLOOR_ACTION.GRANTED\n      ) {\n        // CONTENT - sharing content remote\n        newShareStatus = SHARE_STATUS.REMOTE_SHARE_ACTIVE;\n      }\n      // LOCAL - check if we started sharing content\n      else if (\n        this.selfId === contentShare.beneficiaryId &&\n        contentShare.disposition === FLOOR_ACTION.GRANTED\n      ) {\n        if (this.mediaProperties.shareTrack?.readyState === 'ended') {\n          this.stopShare({\n            skipSignalingCheck: true\n          })\n            .catch((error) => {\n              LoggerProxy.logger.log('Meeting:index#setUpLocusMediaSharesListener --> Error stopping share: ', error);\n            });\n        }\n        else {\n          // CONTENT - sharing content local\n          newShareStatus = SHARE_STATUS.LOCAL_SHARE_ACTIVE;\n        }\n      }\n      // If we did not hit the cases above, no one is sharng content, so we check if we are sharing whiteboard\n      // There is no concept of local/remote share for whiteboard\n      // It does not matter who requested to share the whiteboard, everyone gets the same view\n      else if (whiteboardShare.disposition === FLOOR_ACTION.GRANTED) {\n        // WHITEBOARD - sharing whiteboard\n        newShareStatus = SHARE_STATUS.WHITEBOARD_SHARE_ACTIVE;\n      }\n      // or if content share is either released or null and whiteboard share is either released or null, no one is sharing\n      else if (\n        (previousContentShare &&\n          (contentShare.disposition === FLOOR_ACTION.RELEASED) || (contentShare.disposition === null)) &&\n        (previousWhiteboardShare &&\n          (whiteboardShare.disposition === FLOOR_ACTION.RELEASED) || (whiteboardShare.disposition === null))\n      ) {\n        newShareStatus = SHARE_STATUS.NO_SHARE;\n      }\n\n      if (newShareStatus !== this.shareStatus) {\n        const oldShareStatus = this.shareStatus;\n\n        // update our state before we send out any notifications\n        this.shareStatus = newShareStatus;\n\n        // send out \"stop\" notifications for the old state\n        switch (oldShareStatus) {\n          case SHARE_STATUS.REMOTE_SHARE_ACTIVE:\n            Trigger.trigger(\n              this,\n              {\n                file: 'meetings/index',\n                function: 'remoteShare'\n              },\n              EVENT_TRIGGERS.MEETING_STOPPED_SHARING_REMOTE\n            );\n            break;\n\n          case SHARE_STATUS.LOCAL_SHARE_ACTIVE:\n            Trigger.trigger(\n              this,\n              {\n                file: 'meeting/index',\n                function: 'stopFloorRequest'\n              },\n              EVENT_TRIGGERS.MEETING_STOPPED_SHARING_LOCAL,\n              {\n                reason: SHARE_STOPPED_REASON.SELF_STOPPED\n              }\n            );\n            break;\n\n          case SHARE_STATUS.WHITEBOARD_SHARE_ACTIVE:\n            Trigger.trigger(\n              this,\n              {\n                file: 'meeting/index',\n                function: 'stopWhiteboardShare'\n              },\n              EVENT_TRIGGERS.MEETING_STOPPED_SHARING_WHITEBOARD\n            );\n            break;\n\n          case SHARE_STATUS.NO_SHARE:\n            // nothing to do\n            break;\n\n          default:\n            break;\n        }\n\n        // send \"start\" notifications for the new state\n        switch (newShareStatus) {\n          case SHARE_STATUS.REMOTE_SHARE_ACTIVE: {\n            const sendStartedSharingRemote = () => {\n              Trigger.trigger(\n                this,\n                {\n                  file: 'meetings/index',\n                  function: 'remoteShare'\n                },\n                EVENT_TRIGGERS.MEETING_STARTED_SHARING_REMOTE,\n                {\n                  memberId: contentShare.beneficiaryId\n                }\n              );\n            };\n\n            // if a remote participant is stealing the presentation from us\n            if (!this.mediaProperties.mediaDirection?.sendShare || oldShareStatus === SHARE_STATUS.WHITEBOARD_SHARE_ACTIVE) {\n              sendStartedSharingRemote();\n            }\n            else {\n              this.updateShare({\n                sendShare: false,\n                receiveShare: this.mediaProperties.mediaDirection.receiveShare\n              })\n                .finally(() => {\n                  sendStartedSharingRemote();\n                });\n            }\n            break;\n          }\n\n          case SHARE_STATUS.LOCAL_SHARE_ACTIVE:\n            Trigger.trigger(\n              this,\n              {\n                file: 'meeting/index',\n                function: 'share'\n              },\n              EVENT_TRIGGERS.MEETING_STARTED_SHARING_LOCAL,\n            );\n            Metrics.postEvent({event: eventType.LOCAL_SHARE_FLOOR_GRANTED, meeting: this});\n            break;\n\n          case SHARE_STATUS.WHITEBOARD_SHARE_ACTIVE:\n            Trigger.trigger(\n              this,\n              {\n                file: 'meeting/index',\n                function: 'startWhiteboardShare'\n              },\n              EVENT_TRIGGERS.MEETING_STARTED_SHARING_WHITEBOARD,\n              {\n                resourceUrl: whiteboardShare.resourceUrl,\n                memberId: whiteboardShare.beneficiaryId\n              }\n            );\n            Metrics.postEvent({event: eventType.WHITEBOARD_SHARE_FLOOR_GRANTED, meeting: this});\n            break;\n\n          case SHARE_STATUS.NO_SHARE:\n          // nothing to do\n            break;\n\n          default:\n            break;\n        }\n\n        this.members.locusMediaSharesUpdate(payload);\n      }\n      else if (newShareStatus === SHARE_STATUS.REMOTE_SHARE_ACTIVE) {\n        // if we got here, then some remote participant has stolen\n        // the presentation from another remote participant\n        Trigger.trigger(\n          this,\n          {\n            file: 'meetings/index',\n            function: 'remoteShare'\n          },\n          EVENT_TRIGGERS.MEETING_STARTED_SHARING_REMOTE,\n          {\n            memberId: contentShare.beneficiaryId\n          }\n        );\n        this.members.locusMediaSharesUpdate(payload);\n      }\n      else if (newShareStatus === SHARE_STATUS.WHITEBOARD_SHARE_ACTIVE) {\n        // if we got here, then some remote participant has stolen\n        // the presentation from another remote participant\n        Trigger.trigger(\n          this,\n          {\n            file: 'meeting/index',\n            function: 'startWhiteboardShare'\n          },\n          EVENT_TRIGGERS.MEETING_STARTED_SHARING_WHITEBOARD,\n          {\n            resourceUrl: whiteboardShare.resourceUrl,\n            memberId: whiteboardShare.beneficiaryId\n          }\n        );\n        Metrics.postEvent({event: eventType.WHITEBOARD_SHARE_FLOOR_GRANTED, meeting: this});\n        this.members.locusMediaSharesUpdate(payload);\n      }\n    });\n  }\n\n  /**\n   * Set up the locus info url listener\n   * update locus_url value for members\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   */\n  setUpLocusUrlListener() {\n    this.locusInfo.on(EVENTS.LOCUS_INFO_UPDATE_URL, (payload) => {\n      this.members.locusUrlUpdate(payload);\n      this.locusUrl = payload;\n      this.locusId = this.locusUrl?.split('/').pop();\n    });\n  }\n\n  /**\n   * Set up the locus info meeting info listener\n   * @returns {undefined}\n   * @private\n   * @memberof meeting\n   */\n  setUpLocusInfoMeetingInfoListener() {\n    this.locusInfo.on(LOCUSINFO.EVENTS.MEETING_LOCKED, (payload) => {\n      if (payload) {\n        Trigger.trigger(\n          this,\n          {\n            file: 'meeting/index',\n            function: 'setUpLocusInfoMeetingInfoListener'\n          },\n          EVENT_TRIGGERS.MEETING_LOCKED,\n          {\n            payload\n          }\n        );\n      }\n    });\n    this.locusInfo.on(LOCUSINFO.EVENTS.MEETING_UNLOCKED, (payload) => {\n      if (payload) {\n        Trigger.trigger(\n          this,\n          {\n            file: 'meeting/index',\n            function: 'setUpLocusInfoMeetingInfoListener'\n          },\n          EVENT_TRIGGERS.MEETING_UNLOCKED,\n          {\n            payload\n          }\n        );\n      }\n    });\n    this.locusInfo.on(LOCUSINFO.EVENTS.MEETING_INFO_UPDATED, (payload) => {\n      if (payload && payload.info) {\n        let newCanLock;\n        let newCanUnlock;\n\n        if (payload.self && !payload.self.moderator) {\n          newCanLock = false;\n          newCanUnlock = false;\n        }\n        else {\n          newCanLock = MeetingUtil.canUserLock(payload.info.moderator, payload.info.policy);\n          newCanUnlock = MeetingUtil.canUserUnlock(payload.info.moderator, payload.info.policy);\n        }\n\n        if (newCanLock && !this.inMeetingActions.canLock) {\n          Trigger.trigger(\n            this,\n            {\n              file: 'meeting/index',\n              function: 'setUpLocusInfoMeetingInfoListener'\n            },\n            EVENT_TRIGGERS.MEETING_ACTIONS_UPDATE,\n            {\n              canLock: true,\n              canUnlock: false,\n              canAssignHost: this.inMeetingActions.getCanAssignHost()\n            }\n          );\n        }\n        if (newCanUnlock && !this.inMeetingActions.canUnlock || !newCanLock) {\n          Trigger.trigger(\n            this,\n            {\n              file: 'meeting/index',\n              function: 'setUpLocusInfoMeetingInfoListener'\n            },\n            EVENT_TRIGGERS.MEETING_ACTIONS_UPDATE,\n            {\n              canLock: false,\n              canUnlock: true,\n              canAssignHost: this.inMeetingActions.getCanAssignHost()\n            }\n          );\n        }\n        this.inMeetingActions.setCanLock(newCanLock || false);\n        this.inMeetingActions.setCanUnlock(newCanUnlock || false);\n      }\n    });\n  }\n\n  /**\n   * Internal function to listen to the self object changes\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   */\n  setUpLocusInfoSelfListener() {\n    this.locusInfo.on(LOCUSINFO.EVENTS.LOCAL_UNMUTE_REQUIRED, (payload) => {\n      if (this.audio) {\n        this.audio.handleServerLocalUnmuteRequired(this);\n        Trigger.trigger(\n          this,\n          {\n            file: 'meeting/index',\n            function: 'setUpLocusInfoSelfListener'\n          },\n          EVENT_TRIGGERS.MEETING_SELF_UNMUTED_BY_OTHERS,\n          {\n            payload\n          }\n        );\n      }\n    });\n    this.locusInfo.on(LOCUSINFO.EVENTS.SELF_REMOTE_MUTE_STATUS_UPDATED, (payload) => {\n      if (payload) {\n        if (this.audio) {\n          this.audio.handleServerRemoteMuteUpdate(payload.muted, payload.unmuteAllowed);\n        }\n        // with \"mute on entry\" server will send us remote mute even if we don't have media configured,\n        // so if being muted by others, always send the notification,\n        // but if being unmuted, only send it if we are also locally unmuted\n        if (payload.muted || (!this.audio?.isMuted())) {\n          Trigger.trigger(\n            this,\n            {\n              file: 'meeting/index',\n              function: 'setUpLocusInfoSelfListener'\n            },\n            payload.muted ? EVENT_TRIGGERS.MEETING_SELF_MUTED_BY_OTHERS : EVENT_TRIGGERS.MEETING_SELF_UNMUTED_BY_OTHERS,\n            {\n              payload\n            },\n          );\n        }\n      }\n    });\n    this.locusInfo.on(LOCUSINFO.EVENTS.LOCAL_UNMUTE_REQUESTED, (payload) => {\n      Trigger.trigger(\n        this,\n        {\n          file: 'meeting/index',\n          function: 'setUpLocusInfoSelfListener'\n        },\n        EVENT_TRIGGERS.MEETING_SELF_REQUESTED_TO_UNMUTE,\n        {\n          payload\n        }\n      );\n    });\n    this.locusInfo.on(LOCUSINFO.EVENTS.SELF_UNADMITTED_GUEST, (payload) => {\n      if (payload) {\n        Trigger.trigger(\n          this,\n          {\n            file: 'meeting/index',\n            function: 'setUpLocusInfoSelfListener'\n          },\n          EVENT_TRIGGERS.MEETING_SELF_LOBBY_WAITING,\n          {\n            payload\n          }\n        );\n\n        Metrics.postEvent({\n          event: eventType.LOBBY_ENTERED,\n          meeting: this\n        });\n      }\n    });\n    this.locusInfo.on(LOCUSINFO.EVENTS.SELF_ADMITTED_GUEST, (payload) => {\n      if (payload) {\n        Trigger.trigger(\n          this,\n          {\n            file: 'meeting/index',\n            function: 'setUpLocusInfoSelfListener'\n          },\n          EVENT_TRIGGERS.MEETING_SELF_GUEST_ADMITTED,\n          {\n            payload\n          }\n        );\n\n        Metrics.postEvent({\n          event: eventType.LOBBY_EXITED,\n          meeting: this\n        });\n      }\n    });\n\n    this.locusInfo.on(LOCUSINFO.EVENTS.MEDIA_INACTIVITY, () => {\n      Metrics.sendBehavioralMetric(\n        BEHAVIORAL_METRICS.MEETING_MEDIA_INACTIVE,\n        {\n          correlation_id: this.correlationId,\n          locus_id: this.locusId\n        }\n      );\n      this.reconnect();\n    });\n\n    // There is two stats for mute one is the actual media being sent or received\n    // The second on is if the audio is muted, we need to tell the statsAnalyzer when\n    // the audio is muted or the user is not willing to send media\n    this.locusInfo.on(LOCUSINFO.EVENTS.MEDIA_STATUS_CHANGE, (status) => {\n      if (this.statsAnalyzer) {\n        this.statsAnalyzer.updateMediaStatus({\n          actual: status,\n          expected: {\n            // We need to check what should be the actual direction of media\n            sendAudio: this.mediaProperties.mediaDirection?.sendAudio && !this.audio?.isMuted(),\n            sendVideo: this.mediaProperties.mediaDirection?.sendVideo && !this.video?.isMuted(),\n            sendShare: this.mediaProperties.mediaDirection?.sendShare,\n            receiveAudio: this.mediaProperties.mediaDirection?.receiveAudio,\n            receiveVideo: this.mediaProperties.mediaDirection?.receiveVideo,\n            receiveShare: this.mediaProperties.mediaDirection?.receiveShare\n          }\n        });\n      }\n    });\n  }\n\n  /**\n   * Add LocusInfo nested object listeners (from child to parent)\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   */\n  setUpLocusInfoMeetingListener() {\n    this.locusInfo.on(EVENTS.REMOTE_RESPONSE, (payload) => {\n      this.meetingFiniteStateMachine.remote(payload);\n\n      if (payload.remoteDeclined) {\n        this.leave({reason: payload.reason}).then(() => {\n          LoggerProxy.logger.info('Meeting:index#setUpLocusInfoMeetingListener --> REMOTE_RESPONSE. Attempting to leave meeting.');\n        }).catch((error) => {\n          LoggerProxy.logger.error(`Meeting:index#setUpLocusInfoMeetingListener --> REMOTE_RESPONSE. Issue with leave for meeting, meeting still in collection: ${this.meeting}, error: ${error}`);\n        });\n      }\n    });\n    this.locusInfo.on(EVENTS.DESTROY_MEETING, (payload) => {\n      // if self state is NOT left\n\n      // TODO: Handle sharing and wireless sharing when meeting end\n      if (this.wirelessShare) {\n        if (this.mediaProperties.shareTrack) {\n          this.mediaProperties.shareTrack.onended = null;\n          this.mediaProperties.shareTrack.stop();\n        }\n      }\n      // when multiple WEB deviceType join with same user\n      // and some of the devices are joined and some are left\n      // when your own device is still connected you want to leave and destroy\n      // else you want to just destroy\n      // this looks odd because when it leaves it should destroy, but we get a\n      // leave response and we should destroy it on the next event loop\n      // the leave response gets parsed and we decide if we want to destroy the meeting\n      // the first time we just leave it, the second time it comes it destroys it from the collection\n      if (payload.shouldLeave) {\n        // TODO:  We should do cleaning of meeting object if the shouldLeave: false because there might be meeting object which we are not cleaning\n\n        this.leave({reason: payload.reason}).then(() => {\n          LoggerProxy.logger.warn('Meeting:index#setUpLocusInfoMeetingListener --> DESTROY_MEETING. The meeting has been left, but has not been destroyed, you should see a later event for leave.');\n        }).catch((error) => {\n          LoggerProxy.logger.error(`Meeting:index#setUpLocusInfoMeetingListener --> DESTROY_MEETING. Issue with leave for meeting, meeting still in collection: ${this.meeting}, error: ${error}`);\n        });\n      }\n      else {\n        LoggerProxy.logger.info('Meeting:index#setUpLocusInfoMeetingListener --> MEETING_REMOVED_REASON', payload.reason);\n\n        MeetingUtil.cleanUp(this);\n        Trigger.trigger(\n          this,\n          {\n            file: 'meeting/index',\n            function: 'setUpLocusInfoMeetingListener'\n          },\n          EVENTS.DESTROY_MEETING,\n          {\n            reason: payload.reason,\n            meetingId: this.id\n          }\n        );\n      }\n    });\n  }\n\n  /**\n   * Set meeting values rather than events\n   * @param {Object} object\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   * // TODO: is this function necessary?\n   */\n  updateMeetingObject(object) {\n    // Validate if these are valid meeting object property\n    // TODO: add a check to make sure the value passed in the constructor\n    // is not changed by any delta event\n    if (object && Object.keys(object).length) {\n      Object.keys(object).forEach((key) => {\n        this[key] = object[key];\n      });\n    }\n  }\n\n  /**\n   * Invite a guest to the call that isn't normally part of this call\n   * @param {Object} invitee\n   * @param {String} invitee.emailAddress\n   * @param {String} invitee.email\n   * @param {String} invitee.phoneNumber\n   * @param {Boolean} [alertIfActive]\n   * @returns {Promise} see #members.addMember\n   * @public\n   * @memberof Meeting\n   */\n  invite(invitee, alertIfActive = true) {\n    return this.members.addMember(invitee, alertIfActive);\n  }\n\n  /**\n   * Cancel an outgoing phone call invitation made during a meeting\n   * @param {Object} invitee\n   * @param {String} invitee.phoneNumber\n   * @returns {Promise} see #members.cancelPhoneInvite\n   * @public\n   * @memberof Meeting\n   */\n  cancelPhoneInvite(invitee) {\n    return this.members.cancelPhoneInvite(invitee);\n  }\n\n  /**\n   * Admit the guest(s) to the call once they are waiting\n   * @param {Array} memberIds\n   * @returns {Promise} see #members.admitMembers\n   * @public\n   * @memberof Meeting\n   */\n  admit(memberIds) {\n    return this.members.admitMembers(memberIds);\n  }\n\n  /**\n   * Remove the member from the meeting, boot them\n   * @param {String} memberId\n   * @returns {Promise} see #members.removeMember\n   * @public\n   * @memberof Meeting\n   */\n  remove(memberId) {\n    return this.members.removeMember(memberId);\n  }\n\n  /**\n   * Mute another member from the meeting\n   * @param {String} memberId\n   * @param {Boolean} mute\n   * @returns {Promise} see #members.muteMember\n   * @public\n   * @memberof Meeting\n   */\n  mute(memberId, mute = true) {\n    return this.members.muteMember(memberId, mute);\n  }\n\n  /**\n   * Transfer the moderator role to another eligible member\n   * @param {String} memberId\n   * @param {Boolean} moderator\n   * @returns {Promise} see #members.transferHostToMember\n   * @public\n   * @memberof Meeting\n   */\n  transfer(memberId, moderator = true) {\n    return this.members.transferHostToMember(memberId, moderator);\n  }\n\n  /**\n   * Reference to the Members object\n   * @returns {Members}\n   * @public\n   * @memberof Meeting\n   */\n  getMembers() {\n    return this.members;\n  }\n\n  /**\n   * If this gets turned off mid meeting after attaching media, it will shut down the MQA metrics and they will\n   * not restart unless the start function is called again\n   * @returns {undefined}\n   * @public\n   * @memberof Meeting\n   */\n  cleanMQAInterval() {\n    if (this.mqaInterval) {\n      clearInterval(this.mqaInterval);\n    }\n  }\n\n  /**\n   * Automatically publishes media metrics data and on a config interval\n   * uses the existing getStats data filter, so no new streams are created\n   * but it is separate than history, so history will not be available\n   * @returns {MediaMetrics}\n   * @public\n   * @memberof Meeting\n   */\n  startMediaQualityMetrics() {\n    const automaticMetrics = new StatsMetrics({config: this.config});\n\n    const stats = this.getStats(automaticMetrics.initialize(), true);\n\n    this.mediaQualityMetrics = automaticMetrics;\n\n    this.mediaQualityMetrics.setStats(stats);\n\n    this.mqaInterval = setInterval(() => this.processMQAData(), this.config.metrics.mqaMetricsInterval);\n\n    return automaticMetrics;\n  }\n\n  /**\n   * @private\n   * @returns {undefined}\n   * @memberof Meeting\n   */\n  processMQAData() {\n    if (!this.mqaProcessor) {\n      this.mqaProcessor = new MQAProcessor();\n    }\n\n    MQA_STATS.DATA_PLACEMENTS.forEach((key) => {\n      if (this.mediaQualityMetrics && this.mediaQualityMetrics.stats) {\n        let sendRecvData;\n\n        if (key.toLowerCase().endsWith(STATS.SENDER)) {\n          sendRecvData = this.mediaQualityMetrics.stats.getSender(key);\n        }\n        else if (key.toLowerCase().endsWith(STATS.RECEIVER)) {\n          sendRecvData = this.mediaQualityMetrics.stats.getReceiver(key);\n        }\n        let mqa;\n\n        if (sendRecvData) {\n          mqa = sendRecvData.getMQA();\n        }\n        if (mqa) {\n          const interval = mqa.getSlice(this.config.metrics.mqaMetricsInterval / 1000); // milliseconds -> second based intervals\n\n          this.mqaProcessor.process(key, interval);\n        }\n      }\n    });\n  }\n\n  /**\n   * Reference to the stats builder object\n   * @param {Object} options - see #createStats\n   * @param {Boolean} override - override the previous getStats\n   * @returns {WebRTCStats}\n   * @public\n   * @memberof Meeting\n   */\n  getStats(options, override) {\n    if (!this.stats) {\n      return this.createStats(options);\n    }\n    if (override) {\n      if (this.stats) {\n        LoggerProxy.logger.log('Meeting:index#getStats --> Overriding the previous stats object without destroying first can result in memory leaks.');\n      }\n\n      return this.createStats(options);\n    }\n\n    return this.stats;\n  }\n\n  /**\n   * write the stats builder object and assign to meeting property\n   * @param {Object} options\n   * @returns {WebRTCStats}\n   * @public\n   * @memberof Meeting\n   */\n  createStats(options = {}) {\n    StatsUtil.generateOptions(options, STATS.CONFIG, this);\n\n    options.config = STATS.CONFIG;\n\n    this.stats = new WebRTCStats(this.attrs, this.options, options);\n\n    return this.stats;\n  }\n\n  /**\n   * if you have started a stats instance, here's how you can stop it\n   * @returns {undefined}\n   * @public\n   * @memberof Meeting\n   */\n  stopStats() {\n    if (this.stats) {\n      this.stats.destroySenders();\n      this.stats.destroyReceivers();\n      this.stats = null;\n    }\n  }\n\n  /**\n   * Truthy when a meeting has an audio connection established\n   * @returns {Boolean}  true if meeting audio is connected otherwise false\n   * @public\n   * @memberof Meeting\n   */\n  isAudioConnected() {\n    return !!this.audio;\n  }\n\n  /**\n   * Convenience function to tell whether a meeting is muted\n   * @returns {Boolean} if meeting audio muted or not\n   * @public\n   * @memberof Meeting\n   */\n  isAudioMuted() {\n    return this.audio && this.audio.isMuted();\n  }\n\n  /**\n   * Convenience function to tell if the end user last changed the audio state\n   * @returns {Boolean} if audio was manipulated by the end user\n   * @public\n   * @memberof Meeting\n   */\n  isAudioSelf() {\n    return this.audio && this.audio.isSelf();\n  }\n\n  /**\n   * Truthy when a meeting has a video connection established\n   * @returns {Boolean} true if meeting video connected otherwise false\n   * @public\n   * @memberof Meeting\n   */\n  isVideoConnected() {\n    return !!this.video;\n  }\n\n  /**\n   * Convenience function to tell whether video is muted\n   * @returns {Boolean} if meeting video is muted or not\n   * @public\n   * @memberof Meeting\n   */\n  isVideoMuted() {\n    return this.video && this.video.isMuted();\n  }\n\n  /**\n   * Convenience function to tell whether the end user changed the video state\n   * @returns {Boolean} if meeting video is muted or not\n   * @public\n   * @memberof Meeting\n   */\n  isVideoSelf() {\n    return this.video && this.video.isSelf();\n  }\n\n  /**\n   * Sets the meeting info on the class instance\n   * @param {Object} meetingInfo\n   * @param {Object} meetingInfo.body\n   * @param {String} meetingInfo.body.conversationUrl\n   * @param {String} meetingInfo.body.locusUrl\n   * @param {String} meetingInfo.body.sipUri\n   * @param {Object} meetingInfo.body.owner\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   */\n  parseMeetingInfo(meetingInfo) {\n    const webexMeetingInfo = meetingInfo?.body;\n\n    // MeetingInfo will be undefined for 1:1 calls\n    if (webexMeetingInfo && !(meetingInfo.errors && meetingInfo.errors.length > 0)) {\n      this.conversationUrl = webexMeetingInfo.conversationUrl || this.conversationUrl;\n      this.locusUrl = webexMeetingInfo.locusUrl || this.locusUrl;\n      this.setSipUri(this.config.experimental.enableUnifiedMeetings ? webexMeetingInfo.sipUrl : webexMeetingInfo.sipMeetingUri || this.sipUri);\n      if (this.config.experimental.enableUnifiedMeetings) {\n        this.meetingNumber = webexMeetingInfo.meetingNumber;\n        this.meetingJoinUrl = webexMeetingInfo.meetingJoinUrl;\n      }\n      this.owner = webexMeetingInfo.owner || webexMeetingInfo.hostId || this.owner;\n      this.permissionToken = webexMeetingInfo.permissionToken;\n    }\n  }\n\n  /**\n   * Sets the first locus info on the class instance\n   * @param {Object} locus\n   * @param {String} locus.url\n   * @param {Array} locus.participants\n   * @param {Object} locus.self\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   */\n  parseLocus(locus) {\n    if (locus) {\n      this.locusUrl = locus.url;\n      // TODO: move this to parse participants module\n      this.setLocus(locus);\n\n      // check if we can extract this info from partner\n      // Parsing of locus object must be finished at this state\n      if (locus.participants && locus.self) {\n        this.partner = MeetingUtil.getLocusPartner(locus.participants, locus.self);\n      }\n\n      // For webex meeting the sipUrl gets updated in info parser\n      if (!this.sipUri && this.partner && this.type === _CALL_) {\n        this.setSipUri(this.partner.person.sipUrl || this.partner.person.id);\n      }\n    }\n  }\n\n  /**\n   * Sets the sip uri on the class instance\n   * uses meeting info as precedence\n   * @param {String} sipUri\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   */\n  setSipUri(sipUri) {\n    // This can be tel no, device id or a sip uri, user Id\n    this.sipUri = sipUri;\n  }\n\n  /**\n   * Set the roap seq on the class instance\n   * @param {Number} seq\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   */\n  setRoapSeq(seq) {\n    if (seq >= 0) {\n      this.roapSeq = seq;\n    }\n  }\n\n  /**\n   * Set the locus info the class instance\n   * @param {Object} locus\n   * @param {Array} locus.mediaConnections\n   * @param {String} locus.locusUrl\n   * @param {String} locus.locusId\n   * @param {String} locus.mediaId\n   * @param {Object} locus.host\n   * @todo change name to genertic parser\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   */\n  setLocus(locus) {\n    const mtgLocus = locus.locus || locus;\n\n    // LocusInfo object saves the locus object\n    // this.locus = mtgLocus;\n    this.mediaConnections = locus.mediaConnections;\n    this.locusUrl = locus.locusUrl || locus.url;\n    this.locusId = locus.locusId;\n    this.selfId = locus.selfId;\n    this.mediaId = locus.mediaId;\n    this.hostId = mtgLocus.host ? mtgLocus.host.id : this.hostId;\n    this.locusInfo.initialSetup(mtgLocus);\n  }\n\n  /**\n   * Sets the remote stream on the class instance and emits and\n   * event to developers\n   * @param {Object} pc The remote stream peer connection\n   * @returns {undefined}\n   * @public\n   * @memberof Meeting\n   */\n  setRemoteStream(pc) {\n    if (!pc) {\n      return;\n    }\n    // eslint-disable-next-line no-param-reassign\n    pc.ontrack = (event) => {\n      // eslint-disable-next-line no-warning-comments\n      // TODO: It's possible for media to not be present\n      // so we might need to either\n      // A) wait until we have media flowing\n      // B) trigger a second event when video is flowing\n      LoggerProxy.logger.log(`Meeting:index#setRemoteStream --> ontrack event received for peerConnection: ${event}`);\n\n      const MEDIA_ID = {\n        AUDIO_TRACK: '0',\n        VIDEO_TRACK: '1',\n        SHARE_TRACK: '2'\n      };\n      let eventType = null;\n      const mediaTrack = event.track;\n      let trackMediaID = null;\n\n\n      // In case of safari some time the transceiver is not present for specific os version\n      // sdk tries to determine the transceive using the track id present\n      if (event.transceiver && event.transceiver.mid) {\n        trackMediaID = event.transceiver.mid;\n      }\n      else {\n        const {audioTransceiver, videoTransceiver, shareTransceiver} = event.target;\n\n        // audio kind indicates its a audio stream\n        if (mediaTrack.id === audioTransceiver.receiver.track.id) {\n          trackMediaID = '0';\n        }\n        else\n        if (mediaTrack.id === videoTransceiver.receiver.track.id) {\n          trackMediaID = '1';\n        }\n        else\n        if (mediaTrack.id === shareTransceiver.receiver.track.id) {\n          trackMediaID = '2';\n        }\n        else {\n          trackMediaID = null;\n          Metrics.sendBehavioralMetric(\n            BEHAVIORAL_METRICS.MUTE_AUDIO_FAILURE,\n            {\n              correlation_id: this.correlationId,\n              locus_id: this.locusUrl.split('/').pop()\n            }\n          );\n        }\n      }\n\n\n      switch (trackMediaID) {\n        case MEDIA_ID.AUDIO_TRACK:\n          eventType = EVENT_TYPES.REMOTE_AUDIO;\n          this.mediaProperties.setRemoteAudioTrack(mediaTrack);\n          break;\n        case MEDIA_ID.VIDEO_TRACK:\n          eventType = EVENT_TYPES.REMOTE_VIDEO;\n          this.mediaProperties.setRemoteVideoTrack(mediaTrack);\n          break;\n        case MEDIA_ID.SHARE_TRACK:\n          if (event.track) {\n            eventType = EVENT_TYPES.REMOTE_SHARE;\n            this.mediaProperties.setRemoteShare(mediaTrack);\n          }\n          break;\n        default: {\n          LoggerProxy.logger.log('Meeting:index#setRemoteStream --> no matching media track id');\n        }\n      }\n\n      // start stats here the stats are coming null if you dont receive streams\n\n      this.statsAnalyzer.startAnalyzer(this.mediaProperties.peerConnection);\n\n      if (eventType && mediaTrack) {\n        Trigger.trigger(\n          this,\n          {\n            file: 'meeting/index',\n            function: 'setRemoteStream:pc.ontrack'\n          },\n          EVENT_TRIGGERS.MEDIA_READY,\n          {\n            type: eventType,\n            stream: MediaUtil.createMediaStream([mediaTrack])\n          }\n        );\n      }\n    };\n  }\n\n  /**\n   * Upload logs for the current meeting\n   * @param {object} options file name and function name\n   * @returns {undefined}\n   * @public\n   * @memberof Meeting\n   */\n  uploadLogs(options = {file: 'meeting/index', function: 'uploadLogs'}) {\n    Trigger.trigger(\n      this,\n      options,\n      EVENTS.REQUEST_UPLOAD_LOGS,\n      this\n    );\n  }\n\n\n  /**\n   * Removes remote audio and video stream on the class instance and triggers an event\n   * to developers\n   * @returns {undefined}\n   * @public\n   * @memberof Meeting\n   * @deprecated after v1.89.3\n   */\n  unsetRemoteStream() {\n    LoggerProxy.logger.warn('Meeting:index#unsetRemoteStream --> [DEPRECATION WARNING]: unsetRemoteStream has been deprecated after v1.89.3');\n    this.mediaProperties.unsetRemoteMedia();\n  }\n\n  /**\n   * Removes remote audio, video and share tracks from class instance's mediaProperties\n   * @returns {undefined}\n   */\n  unsetRemoteTracks() {\n    this.mediaProperties.unsetRemoteTracks();\n  }\n\n  /**\n   * Removes the remote stream on the class instance and triggers an event\n   * to developers\n   * @returns {undefined}\n   * @public\n   * @memberof Meeting\n   * @deprecated after v1.89.3\n   */\n  closeRemoteStream() {\n    LoggerProxy.logger.warn('Meeting:index#closeRemoteStream --> [DEPRECATION WARNING]: closeRemoteStream has been deprecated after v1.89.3');\n    this.closeRemoteTracks();\n  }\n\n  /**\n   * Removes the remote tracks on the class instance and triggers an event\n   * to developers\n   * @returns {undefined}\n   * @memberof Meeting\n   */\n  closeRemoteTracks() {\n    const {\n      remoteAudioTrack,\n      remoteVideoTrack,\n      remoteShare\n    } = this.mediaProperties;\n\n    /**\n     * Triggers an event to the developer\n     * @param {string} mediaType Type of media that was stopped\n     * @returns {void}\n     * @inner\n     */\n    const triggerMediaStoppedEvent = (mediaType) => {\n      Trigger.trigger(\n        this,\n        {\n          file: 'meeting/index',\n          function: 'closeRemoteTracks'\n        },\n        EVENT_TRIGGERS.MEDIA_STOPPED,\n        {\n          type: mediaType\n        }\n      );\n    };\n\n    /**\n     * Stops a media track and emits an event\n     * @param {MediaStreamTrack} track Media track to stop\n     * @param {string} type Media track type\n     * @returns {Promise}\n     * @inner\n     */\n    // eslint-disable-next-line arrow-body-style\n    const stopTrack = (track, type) => {\n      return Media.stopTracks(track)\n        .then(() => {\n          const isTrackStopped = track && track.readyState === ENDED;\n          const isWrongReadyState = track && !isTrackStopped;\n\n          if (isTrackStopped) {\n            triggerMediaStoppedEvent(type);\n          }\n          else if (isWrongReadyState) {\n            LoggerProxy.logger.warn(`Meeting:index#closeRemoteTracks --> Error: MediaStreamTrack.readyState is ${track.readyState} for ${type}`);\n          }\n        });\n    };\n\n    return Promise.all([\n      stopTrack(remoteAudioTrack, EVENT_TYPES.REMOTE_AUDIO),\n      stopTrack(remoteVideoTrack, EVENT_TYPES.REMOTE_VIDEO),\n      stopTrack(remoteShare, EVENT_TYPES.REMOTE_SHARE)\n    ]);\n  }\n\n  /**\n   * Emits the 'media:ready' event with a local stream that consists of 1 local audio and 1 local video track\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   */\n  sendLocalMediaReadyEvent() {\n    Trigger.trigger(\n      this,\n      {\n        file: 'meeting/index',\n        function: 'setLocalTracks'\n      },\n      EVENT_TRIGGERS.MEDIA_READY,\n      {\n        type: EVENT_TYPES.LOCAL,\n        stream: MediaUtil.createMediaStream([this.mediaProperties.audioTrack, this.mediaProperties.videoTrack])\n      }\n    );\n  }\n\n  /**\n   * Sets the local audio track on the class and emits an event to the developer\n   * @param {MediaStreamTrack} audioTrack\n   * @param {Boolean} emitEvent if true, a media ready event is emitted to the developer\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   */\n  setLocalAudioTrack(audioTrack, emitEvent = true) {\n    if (audioTrack) {\n      const settings = audioTrack.getSettings();\n\n      this.mediaProperties.setMediaSettings('audio', {\n        echoCancellation: settings.echoCancellation,\n        noiseSuppression: settings.noiseSuppression\n      });\n\n      LoggerProxy.logger.log('Meeting:index#setLocalAudioTrack --> Audio settings.', JSON.stringify(this.mediaProperties.mediaSettings.audio));\n      this.mediaProperties.setLocalAudioTrack(audioTrack);\n      if (this.audio) this.audio.applyClientStateLocally(this);\n    }\n\n    if (emitEvent) {\n      this.sendLocalMediaReadyEvent();\n    }\n  }\n\n  /**\n   * Sets the local video track on the class and emits an event to the developer\n   * @param {MediaStreamTrack} videoTrack\n   * @param {Boolean} emitEvent if true, a media ready event is emitted to the developer\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   */\n  setLocalVideoTrack(videoTrack, emitEvent = true) {\n    if (videoTrack) {\n      const {\n        aspectRatio, frameRate, height, width, deviceId\n      } = videoTrack.getSettings();\n\n      this.mediaProperties.setLocalVideoTrack(videoTrack);\n      if (this.video) this.video.applyClientStateLocally(this);\n\n      this.mediaProperties.setMediaSettings('video', {\n        aspectRatio, frameRate, height, width\n      });\n      // store and save the selected video input device\n      if (deviceId) {\n        this.mediaProperties.setVideoDeviceId(deviceId);\n      }\n      LoggerProxy.logger.log('Meeting:index#setLocalVideoTrack --> Video settings.', JSON.stringify(this.mediaProperties.mediaSettings.video));\n    }\n\n    if (emitEvent) {\n      this.sendLocalMediaReadyEvent();\n    }\n  }\n\n  /**\n   * Sets the local media stream on the class and emits an event to the developer\n   * @param {Stream} localStream the local media stream\n   * @returns {undefined}\n   * @public\n   * @memberof Meeting\n   */\n  setLocalTracks(localStream) {\n    if (localStream) {\n      const {audioTrack, videoTrack} = MeetingUtil.getTrack(localStream);\n\n      this.setLocalAudioTrack(audioTrack, false);\n      this.setLocalVideoTrack(videoTrack, false);\n\n      this.sendLocalMediaReadyEvent();\n    }\n  }\n\n  /**\n   * Sets the local media stream on the class and emits an event to the developer\n   * @param {Stream} localShare the local media stream\n   * @returns {undefined}\n   * @public\n   * @memberof Meeting\n   */\n  setLocalShareTrack(localShare) {\n    let settings = null;\n\n    if (localShare) {\n      this.mediaProperties.setLocalShareTrack(MeetingUtil.getTrack(localShare).videoTrack);\n      const contentTracks = this.mediaProperties.shareTrack;\n\n      if (contentTracks) {\n        settings = contentTracks.getSettings();\n        this.mediaProperties.setMediaSettings('screen', {\n          aspectRatio: settings.aspectRatio,\n          frameRate: settings.frameRate,\n          height: settings.height,\n          width: settings.width,\n          displaySurface: settings.displaySurface,\n          cursor: settings.cursor\n        });\n        LoggerProxy.logger.log('Meeting:index#setLocalShareTrack --> Screen settings.', JSON.stringify(this.mediaProperties.mediaSettings.screen));\n      }\n\n      contentTracks.onended = () => this.handleShareTrackEnded(localShare);\n\n      Trigger.trigger(\n        this,\n        {\n          file: 'meeting/index',\n          function: 'setLocalShareTrack'\n        },\n        EVENT_TRIGGERS.MEDIA_READY,\n        {\n          type: EVENT_TYPES.LOCAL_SHARE,\n          stream: localShare\n        }\n      );\n    }\n  }\n\n  /**\n   * Closes the local stream from the class and emits an event to the developer\n   * @returns {undefined}\n   * @event media:stopped\n   * @public\n   * @memberof Meeting\n   */\n  closeLocalStream() {\n    const {audioTrack, videoTrack} = this.mediaProperties;\n\n    return Media.stopTracks(audioTrack)\n      .then(() => Media.stopTracks(videoTrack))\n      .then(() => {\n        const audioStopped = audioTrack && audioTrack.readyState === ENDED;\n        const videoStopped = videoTrack && videoTrack.readyState === ENDED;\n\n        if (audioStopped && videoStopped) {\n          Trigger.trigger(\n            this,\n            {\n              file: 'meeting/index',\n              function: 'closeLocalStream'\n            },\n            EVENT_TRIGGERS.MEDIA_STOPPED, {\n              type: EVENT_TYPES.LOCAL\n            }\n          );\n        }\n        else if (audioTrack || videoTrack) {\n          LoggerProxy.logger.warn('Meeting:index#closeLocalStream --> Error: MediaStreamTrack.readyState is incorrect.');\n        }\n      });\n  }\n\n  /**\n   * Closes the local stream from the class and emits an event to the developer\n   * @returns {undefined}\n   * @event media:stopped\n   * @public\n   * @memberof Meeting\n   */\n  closeLocalShare() {\n    const track = this.mediaProperties.shareTrack;\n\n    return Media.stopTracks(track).then(() => {\n      if (track && track.readyState === ENDED) {\n        Trigger.trigger(\n          this,\n          {\n            file: 'meeting/index',\n            function: 'closeLocalShare'\n          },\n          EVENT_TRIGGERS.MEDIA_STOPPED, {\n            type: EVENT_TYPES.LOCAL_SHARE\n          }\n        );\n      }\n      else if (track) {\n        // Track exists but with wrong readyState\n        LoggerProxy.logger.warn(`Meeting:index#closeLocalShare --> Error: MediaStreamTrack.readyState is ${track.readyState} for localShare`);\n      }\n    });\n  }\n\n  /**\n   * Removes the local stream from the class and emits an event to the developer\n   * @returns {undefined}\n   * @public\n   * @memberof Meeting\n   */\n  unsetLocalVideoTrack() {\n    this.mediaProperties.unsetLocalVideoTrack();\n  }\n\n  /**\n   * Removes the local share from the class and emits an event to the developer\n   * @returns {undefined}\n   * @public\n   * @memberof Meeting\n   */\n  unsetLocalShareTrack() {\n    this.mediaProperties.unsetLocalShareTrack();\n  }\n\n  /**\n   * sets up listner for mercury event\n   * @returns {undefined}\n   * @public\n   * @memberof Meeting\n   */\n  setMercuryListener() {\n    // Client will have a socket manager and handle reconnecting to mercury, when we reconnect to mercury\n    // if the meeting has active peer connections, it should try to reconnect.\n    this.webex.internal.mercury.on(ONLINE, () => {\n      LoggerProxy.logger.info('Meeting:index#setMercuryListener --> Web socket online');\n\n      // Only send restore event when it was disconnected before and for connected later\n      if (!this.hasWebsocketConnected) {\n        Metrics.postEvent({\n          event: eventType.MERCURY_CONNECTION_RESTORED,\n          meeting: this\n        });\n        Metrics.sendBehavioralMetric(\n          BEHAVIORAL_METRICS.MERCURY_CONNECTION_RESTORED,\n          {\n            correlation_id: this.correlationId\n          }\n        );\n      }\n      this.hasWebsocketConnected = true;\n    });\n\n    this.webex.internal.mercury.on(OFFLINE, () => {\n      LoggerProxy.logger.error('Meeting:index#setMercuryListener --> Web socket offline');\n      Metrics.postEvent({\n        event: eventType.MERCURY_CONNECTION_LOST,\n        meeting: this\n      });\n      Metrics.sendBehavioralMetric(\n        BEHAVIORAL_METRICS.MERCURY_CONNECTION_FAILURE,\n        {\n          correlation_id: this.correlationId\n        }\n      );\n    });\n  }\n\n  /**\n   * Close the peer connections and remove them from the class. Triggers an event\n   * when each is closed.\n   * @returns {Promise} returns a resolved promise with an array of closed peer connections\n   * @public\n   * @memberof Meeting\n   */\n  closePeerConnections() {\n    return PeerConnectionManager.close(this.mediaProperties.peerConnection);\n  }\n\n  /**\n   * Unsets the peer connections on the class\n   * warning DO NOT CALL WITHOUT CLOSING PEER CONNECTIONS FIRST\n   * @param {PeerConnection} peerConnection\n   * @returns {undefined}\n   * @public\n   * @memberof Meeting\n   */\n  unsetPeerConnections() {\n    this.mediaProperties.unsetPeerConnection();\n    if (this.config.reconnection.detection) {\n      this.webex.internal.mercury.off(ONLINE);\n    }\n  }\n\n  /**\n   * Convenience method to set the correlation id for the Meeting\n   * @param {String} id correlation id to set on the class\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   */\n  setCorrelationId(id) {\n    this.correlationId = id;\n  }\n\n  /**\n   * Mute the audio for a meeting\n   * @returns {Promise} resolves the data from muting audio {mute, self} or rejects if there is no audio set\n   * @public\n   * @memberof Meeting\n   */\n  muteAudio() {\n    if (!MeetingUtil.isUserInJoinedState(this.locusInfo)) {\n      return Promise.reject(new UserNotJoinedError());\n    }\n\n    if (!this.mediaId) {\n      // Happens when addMedia and mute are triggered in succession\n      return Promise.reject(new NoMediaEstablishedYetError());\n    }\n\n    if (!this.audio) {\n      return Promise.reject(new ParameterError('no audio control associated to the meeting'));\n    }\n\n    const LOG_HEADER = 'Meeting:index#muteAudio -->';\n\n    // First, stop sending the local audio media\n    return logRequest(this.audio.handleClientRequest(this, true)\n      .then(() => {\n        MeetingUtil.handleAudioLogging(this.mediaProperties.audioTrack);\n        Metrics.postEvent({\n          event: eventType.MUTED,\n          meeting: this,\n          data: {trigger: trigger.USER_INTERACTION, mediaType: mediaType.AUDIO}\n        });\n      }).catch((error) => {\n        Metrics.sendBehavioralMetric(\n          BEHAVIORAL_METRICS.MUTE_AUDIO_FAILURE,\n          {\n            correlation_id: this.correlationId,\n            locus_id: this.locusUrl.split('/').pop(),\n            reason: error.message,\n            stack: error.stack\n          }\n        );\n\n        throw error;\n      }),\n    {\n      header: `${LOG_HEADER} muting audio`,\n      success: `${LOG_HEADER} muted audio successfully`,\n      failure: `${LOG_HEADER} muting audio failed, `\n    });\n  }\n\n  /**\n   * Unmute meeting audio\n   * @returns {Promise} resolves data from muting audio {mute, self} or rejects if there is no audio set\n   * @public\n   * @memberof Meeting\n   */\n  unmuteAudio() {\n    if (!MeetingUtil.isUserInJoinedState(this.locusInfo)) {\n      return Promise.reject(new UserNotJoinedError());\n    }\n\n    if (!this.mediaId) {\n      // Happens when addMedia and mute are triggered in succession\n      return Promise.reject(new NoMediaEstablishedYetError());\n    }\n\n    if (!this.audio) {\n      return Promise.reject(new ParameterError('no audio control associated to the meeting'));\n    }\n\n    const LOG_HEADER = 'Meeting:index#unmuteAudio -->';\n\n    // First, send the control to unmute the participant on the server\n    return logRequest(this.audio.handleClientRequest(this, false)\n      .then(() => {\n        MeetingUtil.handleAudioLogging(this.mediaProperties.audioTrack);\n        Metrics.postEvent({\n          event: eventType.UNMUTED,\n          meeting: this,\n          data: {trigger: trigger.USER_INTERACTION, mediaType: mediaType.AUDIO}\n        });\n      }).catch((error) => {\n        Metrics.sendBehavioralMetric(\n          BEHAVIORAL_METRICS.UNMUTE_AUDIO_FAILURE,\n          {\n            correlation_id: this.correlationId,\n            locus_id: this.locusUrl.split('/').pop(),\n            reason: error.message,\n            stack: error.stack\n          }\n        );\n\n        throw error;\n      }),\n    {\n      header: `${LOG_HEADER} unmuting audio`,\n      success: `${LOG_HEADER} unmuted audio successfully`,\n      failure: `${LOG_HEADER} unmuting audio failed, `\n    });\n  }\n\n  /**\n   * Mute the video for a meeting\n   * @returns {Promise} resolves data from muting video {mute, self} or rejects if there is no video set\n   * @public\n   * @memberof Meeting\n   */\n  muteVideo() {\n    if (!MeetingUtil.isUserInJoinedState(this.locusInfo)) {\n      return Promise.reject(new UserNotJoinedError());\n    }\n\n    if (!this.mediaId) {\n      // Happens when addMedia and mute are triggered in succession\n      return Promise.reject(new NoMediaEstablishedYetError());\n    }\n\n    if (!this.video) {\n      return Promise.reject(new ParameterError('no video control associated to the meeting'));\n    }\n\n    const LOG_HEADER = 'Meeting:index#muteVideo -->';\n\n    return logRequest(this.video.handleClientRequest(this, true)\n      .then(() => {\n        MeetingUtil.handleVideoLogging(this.mediaProperties.videoTrack);\n        Metrics.postEvent({\n          event: eventType.MUTED,\n          meeting: this,\n          data: {trigger: trigger.USER_INTERACTION, mediaType: mediaType.VIDEO}\n        });\n      }).catch((error) => {\n        Metrics.sendBehavioralMetric(\n          BEHAVIORAL_METRICS.MUTE_VIDEO_FAILURE,\n          {\n            correlation_id: this.correlationId,\n            locus_id: this.locusUrl.split('/').pop(),\n            reason: error.message,\n            stack: error.stack\n          }\n        );\n\n        throw error;\n      }),\n    {\n      header: `${LOG_HEADER} muting video`,\n      success: `${LOG_HEADER} muted video successfully`,\n      failure: `${LOG_HEADER} muting video failed, `\n    });\n  }\n\n  /**\n   * Unmute meeting video\n   * @returns {Promise} resolves data from muting video {mute, self} or rejects if there is no video set\n   * @public\n   * @memberof Meeting\n   */\n  unmuteVideo() {\n    if (!MeetingUtil.isUserInJoinedState(this.locusInfo)) {\n      return Promise.reject(new UserNotJoinedError());\n    }\n\n    if (!this.mediaId) {\n      // Happens when addMedia and mute are triggered in succession\n      return Promise.reject(new NoMediaEstablishedYetError());\n    }\n\n    if (!this.video) {\n      return Promise.reject(new ParameterError('no audio control associated to the meeting'));\n    }\n\n    const LOG_HEADER = 'Meeting:index#unmuteVideo -->';\n\n    return logRequest(this.video.handleClientRequest(this, false)\n      .then(() => {\n        MeetingUtil.handleVideoLogging(this.mediaProperties.videoTrack);\n        Metrics.postEvent({\n          event: eventType.UNMUTED,\n          meeting: this,\n          data: {trigger: trigger.USER_INTERACTION, mediaType: mediaType.VIDEO}\n        });\n      }).catch((error) => {\n        Metrics.sendBehavioralMetric(\n          BEHAVIORAL_METRICS.UNMUTE_VIDEO_FAILURE,\n          {\n            correlation_id: this.correlationId,\n            locus_id: this.locusUrl.split('/').pop(),\n            reason: error.message,\n            stack: error.stack\n          }\n        );\n\n        throw error;\n      }),\n    {\n      header: `${LOG_HEADER} unmuting video`,\n      success: `${LOG_HEADER} unmuted video successfully`,\n      failure: `${LOG_HEADER} unmuting video failed, `\n    });\n  }\n\n  /**\n   * Shorthand function to join AND set up media\n   * @param {Object} options - options to join with media\n   * @param {JoinOptions} [options.joinOptions] - see #join()\n   * @param {MediaDirection} options.mediaSettings - see #addMedia()\n   * @param {AudioVideo} [options.audioVideoOptions] - see #getMediaStreams()\n   * @returns {Promise} -- {join: see join(), media: see addMedia(), local: see getMediaStreams()}\n   * @public\n   * @memberof Meeting\n   * @example\n   * joinWithMedia({\n   *  joinOptions: {resourceId: 'resourceId' },\n   *  mediaSettings: {\n   *   sendAudio: true,\n   *   sendVideo: true,\n   *   sendShare: false,\n   *   receiveVideo:true,\n   *   receiveAudio: true,\n   *   receiveShare: true\n   * }\n   * audioVideoOptions: {\n   *   audio: 'audioDeviceId',\n   *   video: 'videoDeviceId'\n   * }})\n   */\n  joinWithMedia(options = {}) {\n    // TODO: add validations for parameters\n    const {mediaSettings, joinOptions, audioVideoOptions} = options;\n\n    return this.join(joinOptions)\n      .then((joinResponse) =>\n        this.getMediaStreams(mediaSettings, audioVideoOptions).then(([localStream, localShare]) =>\n          this.addMedia({\n            mediaSettings,\n            localShare,\n            localStream\n          }).then((mediaResponse) => ({\n            join: joinResponse,\n            media: mediaResponse,\n            local: [localStream, localShare]\n          }))))\n      .catch((error) => {\n        LoggerProxy.logger.error('Meeting:index#joinWithMedia --> ', error);\n\n        Metrics.sendBehavioralMetric(\n          BEHAVIORAL_METRICS.JOIN_WITH_MEDIA_FAILURE,\n          {\n            correlation_id: this.correlationId,\n            locus_id: this.locusUrl.split('/').pop(),\n            reason: error.message,\n            stack: error.stack\n          },\n          {\n            type: error.name\n          }\n        );\n\n        return Promise.reject(error);\n      });\n  }\n\n  /**\n   * Initiates the reconnection of the media in the meeting\n   *\n   * @param {object} options\n   * @returns {Promise} resolves with {reconnect} or errors with {error}\n   * @public\n   * @memberof Meeting\n   */\n  reconnect(options) {\n    LoggerProxy.logger.log(`Meeting:index#reconnect --> attempting to reconnect meeting ${this.id}`);\n\n    if (!this.reconnectionManager || !this.reconnectionManager.reconnect) {\n      return Promise.reject(new ParameterError('Cannot reconnect, ReconnectionManager must first be defined.'));\n    }\n\n    if (!MeetingUtil.isMediaEstablished(this.currentMediaStatus)) {\n      return Promise.reject(new ParameterError('Cannot reconnect, Media has not established to reconnect'));\n    }\n\n    try {\n      LoggerProxy.logger.info('Meeting:index#reconnect --> Validating reconnect ability.');\n      this.reconnectionManager.validate();\n    }\n    catch (error) {\n      // Unable to reconnect this call\n      if (error instanceof ReconnectInProgress) {\n        LoggerProxy.logger.info('Meeting:index#reconnect --> Unable to reconnect, reconnection in progress.');\n      }\n      else {\n        LoggerProxy.logger.log('Meeting:index#reconnect --> Unable to reconnect.', error);\n      }\n\n      return Promise.resolve();\n    }\n\n    Trigger.trigger(\n      this,\n      {\n        file: 'meeting/index',\n        function: 'reconnect'\n      },\n      EVENT_TRIGGERS.MEETING_RECONNECTION_STARTING\n    );\n\n\n    return this.reconnectionManager\n      .reconnect(options)\n      .then(() => {\n        Trigger.trigger(\n          this,\n          {\n            file: 'meeting/index',\n            function: 'reconnect'\n          },\n          EVENT_TRIGGERS.MEETING_RECONNECTION_SUCCESS\n        );\n        LoggerProxy.logger.log('Meeting:index#reconnect --> Meeting reconnect success');\n      })\n      .catch((error) => {\n        Trigger.trigger(\n          this,\n          {\n            file: 'meeting/index',\n            function: 'reconnect'\n          },\n          EVENT_TRIGGERS.MEETING_RECONNECTION_FAILURE,\n          {\n            error: new ReconnectionError('Reconnection failure event', error)\n          }\n        );\n\n        LoggerProxy.logger.error('Meeting:index#reconnect --> Meeting reconnect failed', error);\n\n        Metrics.sendBehavioralMetric(\n          BEHAVIORAL_METRICS.MEETING_RECONNECT_FAILURE,\n          {\n            correlation_id: this.correlationId,\n            locus_id: this.locusUrl.split('/').pop(),\n            reason: error.message,\n            stack: error.stack\n          }\n        );\n\n        this.uploadLogs({\n          file: 'meeting/index',\n          function: 'reconnect'\n        });\n\n        return Promise.reject(new ReconnectionError('Reconnection failure event', error));\n      })\n      .finally(() => {\n        this.reconnectionManager.reset();\n      });\n  }\n\n  /**\n   * Check if the meeting supports the Webex Assistant feature\n   * @returns {boolean}\n   * @throws TranscriptionNotSupportedError\n   */\n  isTranscriptionSupported() {\n    if (this.policy?.WEBEX_ASSISTANT_STATUS_ACTIVE) {\n      return true;\n    }\n\n    LoggerProxy.logger.error(\n      'Meeting:index#isTranscriptionSupported --> Webex Assistant is not supported'\n    );\n\n    return false;\n  }\n\n  /**\n   * Monitor the Low-Latency Mercury (LLM) web socket connection on `onError` and `onClose` states\n   * @private\n   * @returns {void}\n   */\n  monitorTranscriptionSocketConnection() {\n    this.transcription.onCloseSocket((event) => {\n      LoggerProxy.logger.info(\n        `Meeting:index#onCloseSocket -->\n        unable to continue receiving transcription;\n        low-latency mercury web socket connection is closed now.\n        ${event}`\n      );\n\n      this.triggerStopReceivingTranscriptionEvent();\n    });\n\n    this.transcription.onErrorSocket((event) => {\n      LoggerProxy.logger.error(\n        `Meeting:index#onErrorSocket -->\n         unable to continue receiving transcription;\n         low-latency mercury web socket connection error had occured.\n        ${event}`\n      );\n\n      this.triggerStopReceivingTranscriptionEvent();\n\n      Metrics.sendBehavioralMetric(\n        BEHAVIORAL_METRICS.RECEIVE_TRANSCRIPTION_FAILURE,\n        {\n          correlation_id: this.correlationId,\n          reason: 'unexpected error: transcription LLM web socket connection error had occured.',\n          event\n        }\n      );\n    });\n  }\n\n  /**\n   * Request for a WebSocket Url, open and monitor the WebSocket connection\n   * @private\n   * @returns {Promise<void>} a promise to open the WebSocket connection\n   */\n  async receiveTranscription() {\n    LoggerProxy.logger.info(\n      `Meeting:index#receiveTranscription -->\n      Attempting to generate a web socket url.`\n    );\n\n    try {\n      const {datachannelUrl} = this.locusInfo.info;\n      const {body: {webSocketUrl}} = await this.request({\n        method: HTTP_VERBS.POST,\n        uri: datachannelUrl,\n        body: {deviceUrl: this.deviceUrl}\n      });\n\n      LoggerProxy.logger.info(\n        `Meeting:index#receiveTranscription -->\n        Generated web socket url succesfully.`\n      );\n\n      this.transcription = new Transcription(\n        webSocketUrl,\n        this.webex.sessionId,\n        this.members,\n      );\n\n      LoggerProxy.logger.info(\n        `Meeting:index#receiveTranscription -->\n        opened LLM web socket connection successfully.`\n      );\n\n      // retrieve and pass the payload\n      this.transcription.subscribe((payload) => {\n        Trigger.trigger(\n          this,\n          {\n            file: 'meeting/index',\n            function: 'join'\n          },\n          EVENT_TRIGGERS.MEETING_STARTED_RECEIVING_TRANSCRIPTION,\n          payload\n        );\n      });\n\n      this.monitorTranscriptionSocketConnection();\n      this.transcription.connect(this.webex.credentials.supertoken.access_token);\n    }\n    catch (error) {\n      LoggerProxy.logger.error(`Meeting:index#receiveTranscription --> ${error}`);\n      Metrics.sendBehavioralMetric(\n        BEHAVIORAL_METRICS.RECEIVE_TRANSCRIPTION_FAILURE,\n        {\n          correlation_id: this.correlationId,\n          reason: error.message,\n          stack: error.stack\n        }\n      );\n    }\n  }\n\n  /**\n   * stop recieving Transcription by closing\n   * the web socket connection properly\n   * @returns {void}\n   */\n  stopReceivingTranscription() {\n    if (this.transcription) {\n      this.transcription.closeSocket();\n    }\n  }\n\n  /**\n   * triggers an event to notify that the user\n   * will not receive any more transcription\n   * @private\n   * @returns{void}\n   */\n  triggerStopReceivingTranscriptionEvent() {\n    LoggerProxy.logger.info(`\n      Meeting:index#stopReceivingTranscription -->\n      closed transcription LLM web socket connection successfully.`);\n\n\n    Trigger.trigger(\n      this,\n      {\n        file: 'meeting',\n        function: 'triggerStopReceivingTranscriptionEvent'\n      },\n      EVENT_TRIGGERS.MEETING_STOPPED_RECEIVING_TRANSCRIPTION\n    );\n  }\n\n  /**\n   * Specify joining via audio (option: pstn), video, screenshare\n   * @param {JoinOptions} options A configurable options object for joining a meeting\n   * @returns {Promise} the join response\n   * @public\n   * @memberof Meeting\n   * Scenario A: Joining own claimed personal meeting room\n   * Scenario B: Joining other's claimed personal meeting room, do pass pin (if desired to join as host, or nullify), do pass moderator\n   * Scenario C: Joining an unclaimed personal meeting room, -do not- pass pin or moderator on first try, -do- pass pin and moderator\n   *             if joining as host on second loop, pass pin and pass moderator if joining as guest on second loop\n   * Scenario D: Joining any other way (sip, pstn, conversationUrl, link just need to specify resourceId)\n   */\n  join(options = {}) {\n    // If a join request is being processed, refer to the deferred promise.\n    if (this.deferJoin) {\n      return this.deferJoin;\n    }\n\n    // Scope-up the resolve/reject methods for handling within join().\n    let joinFailed;\n    let joinSuccess;\n\n    // Create a deferred promise for a consistent resolve value from utils.\n    // This also prevents redundant API calls.\n    this.deferJoin = new Promise((resolve, reject) => {\n      joinFailed = reject;\n      joinSuccess = resolve;\n    });\n\n    if (!this.hasJoinedOnce) {\n      this.hasJoinedOnce = true;\n    }\n    else {\n      LoggerProxy.logger.log(`Meeting:index#join --> Generating a new correlation id for meeting ${this.id}`);\n      LoggerProxy.logger.log(`Meeting:index#join --> Previous correlation id ${this.correlationId}`);\n      this.setCorrelationId(uuid.v4());\n      LoggerProxy.logger.log(`Meeting:index#join --> New correlation id ${this.correlationId}`);\n    }\n\n    if (options.rejoin) {\n      this.meetingFiniteStateMachine.reset();\n    }\n\n    Metrics.postEvent({\n      event: eventType.CALL_INITIATED,\n      meeting: this,\n      data: {trigger: trigger.USER_INTERACTION}\n    });\n\n    LoggerProxy.logger.log('Meeting:index#join --> Joining a meeting');\n\n    if (this.meetingFiniteStateMachine.state === MEETING_STATE_MACHINE.STATES.ENDED) {\n      this.meetingFiniteStateMachine.reset();\n    }\n    if (this.meetingFiniteStateMachine.state !== MEETING_STATE_MACHINE.STATES.RINGING) {\n      this.meetingFiniteStateMachine.ring(_JOIN_);\n    }\n\n    // TODO: does this really need to be here?\n    if (options.resourceId && this.destination && options.resourceId === this.destination) {\n      this.wirelessShare = true;\n    }\n\n    if (options.meetingQuality) {\n      if (typeof options.meetingQuality === 'string') {\n        if (!QUALITY_LEVELS[options.meetingQuality]) {\n          const errorMessage = `Meeting:index#join --> ${options.meetingQuality} not defined`;\n          const error = new Error(errorMessage);\n\n          LoggerProxy.logger.error(errorMessage);\n\n          joinFailed(error);\n          this.deferJoin = undefined;\n\n          return Promise.reject(error);\n        }\n\n        this.mediaProperties.setLocalQualityLevel(options.meetingQuality);\n        this.mediaProperties.setRemoteQualityLevel(options.meetingQuality);\n      }\n\n      if (typeof options.meetingQuality === 'object') {\n        if (\n          !QUALITY_LEVELS[options.meetingQuality.local] &&\n          !QUALITY_LEVELS[options.meetingQuality.remote]\n        ) {\n          const errorMessage = `Meeting:index#join --> ${\n            options.meetingQuality.local || options.meetingQuality.remote\n          } not defined`;\n\n          LoggerProxy.logger.error(errorMessage);\n\n          const error = new Error(errorMessage);\n\n          joinFailed(error);\n          this.deferJoin = undefined;\n\n          return Promise.reject(new Error(errorMessage));\n        }\n\n        if (options.meetingQuality.local) {\n          this.mediaProperties.setLocalQualityLevel(options.meetingQuality.local);\n        }\n        if (options.meetingQuality.remote) {\n          this.mediaProperties.setRemoteQualityLevel(options.meetingQuality.remote);\n        }\n      }\n    }\n\n    return MeetingUtil.joinMeetingOptions(this, options)\n      .then((join) => {\n        this.meetingFiniteStateMachine.join();\n        LoggerProxy.logger.log('Meeting:index#join --> Success');\n\n        return join;\n      })\n      .then((join) => {\n        joinSuccess(join);\n        this.deferJoin = undefined;\n        Metrics.sendBehavioralMetric(\n          BEHAVIORAL_METRICS.JOIN_SUCCESS,\n          {\n            correlation_id: this.correlationId\n          }\n        );\n\n        return join;\n      }).then(async (join) => {\n        if (isBrowser) {\n          if (this.config.receiveTranscription || options.receiveTranscription) {\n            if (this.isTranscriptionSupported()) {\n              await this.receiveTranscription();\n              LoggerProxy.logger.info('Meeting:index#join --> enabled to recieve transcription!');\n            }\n          }\n        }\n        else {\n          LoggerProxy.logger.error('Meeting:index#join --> Receving transcription is not supported on this platform');\n        }\n\n\n        return join;\n      })\n      .catch((error) => {\n        this.meetingFiniteStateMachine.fail(error);\n        LoggerProxy.logger.error('Meeting:index#join --> Failed', error);\n\n        // TODO:  change this to error codes and pre defined dictionary\n        Metrics.sendBehavioralMetric(\n          BEHAVIORAL_METRICS.JOIN_FAILURE,\n          {\n            correlation_id: this.correlationId,\n            reason: error.error?.message,\n            stack: error.stack\n          }\n        );\n\n        // Upload logs on join Failure\n        Trigger.trigger(\n          this,\n          {\n            file: 'meeting/index',\n            function: 'join'\n          },\n          EVENTS.REQUEST_UPLOAD_LOGS,\n          this\n        );\n\n        joinFailed(error);\n        this.deferJoin = undefined;\n\n        return Promise.reject(error);\n      });\n  }\n\n  /**\n   * Use phone for meeting audio\n   * @param {String} phoneNumber If provided, it will dial-out using this number. If not provided, dial-in will be used\n   * @returns {Promise} Resolves once the dial-in or dial-out request has completed, or rejects if it failed\n   * @public\n   * @memberof Meeting\n   */\n  usePhoneAudio(phoneNumber) {\n    if (!phoneNumber) {\n      return this.dialInPstn();\n    }\n\n    return this.dialOutPstn(phoneNumber);\n  }\n\n  /**\n   * Determines if the given pstnStatus is in a state which implies the phone is provisioned\n   * @param {String} pstnStatus\n   * @returns {Boolean}\n   * @private\n   * @memberof Meeting\n   */\n  isPhoneProvisioned(pstnStatus) {\n    return [PSTN_STATUS.JOINED, PSTN_STATUS.CONNECTED, PSTN_STATUS.SUCCESS].includes(pstnStatus);\n  }\n\n  /**\n   * Enable dial-in for audio\n   * @returns {Promise} Resolves once the dial-in request has completed, or rejects if it failed\n   * @private\n   * @memberof Meeting\n   */\n  dialInPstn() {\n    if (this.isPhoneProvisioned(this.dialInDeviceStatus)) return Promise.resolve(); // prevent multiple dial in devices from being provisioned\n\n    const {correlationId, locusUrl} = this;\n\n    if (!this.dialInUrl) this.dialInUrl = `dialin:///${uuid.v4()}`;\n\n    return this.meetingRequest.dialIn({\n      correlationId,\n      dialInUrl: this.dialInUrl,\n      locusUrl,\n      clientUrl: this.deviceUrl\n    }).then((res) => {\n      this.locusInfo.onFullLocus(res.body.locus);\n    }).catch((error) => {\n      Metrics.sendBehavioralMetric(\n        BEHAVIORAL_METRICS.ADD_DIAL_IN_FAILURE,\n        {\n          correlation_id: this.correlationId,\n          dial_in_url: this.dialInUrl,\n          locus_id: locusUrl.split('/').pop(),\n          client_url: this.deviceUrl,\n          reason: error.error?.message,\n          stack: error.stack\n        }\n      );\n\n      return Promise.reject(error);\n    });\n  }\n\n  /**\n   * Enable dial-out for audio\n   * @param {String} phoneNumber Phone number to dial out to\n   * @returns {Promise} Resolves once the dial-out request has completed (it doesn't wait for the user to answer the phone), or rejects if it failed\n   * @private\n   * @memberof Meeting\n   */\n  dialOutPstn(phoneNumber) {\n    if (this.isPhoneProvisioned(this.dialOutDeviceStatus)) return Promise.resolve(); // prevent multiple dial out devices from being provisioned\n\n    const {correlationId, locusUrl} = this;\n\n    if (!this.dialOutUrl) this.dialOutUrl = `dialout:///${uuid.v4()}`;\n\n    return this.meetingRequest.dialOut({\n      correlationId,\n      dialOutUrl: this.dialOutUrl,\n      phoneNumber,\n      locusUrl,\n      clientUrl: this.deviceUrl\n    }).then((res) => {\n      this.locusInfo.onFullLocus(res.body.locus);\n    }).catch((error) => {\n      Metrics.sendBehavioralMetric(\n        BEHAVIORAL_METRICS.ADD_DIAL_OUT_FAILURE,\n        {\n          correlation_id: this.correlationId,\n          dial_out_url: this.dialOutUrl,\n          locus_id: locusUrl.split('/').pop(),\n          client_url: this.deviceUrl,\n          reason: error.error?.message,\n          stack: error.stack\n        }\n      );\n\n      return Promise.reject(error);\n    });\n  }\n\n  /**\n   * Disconnect meeting audio via phone.\n   * @returns {Promise} Resolves once the phone audio disconnection has completed\n   * @public\n   * @memberof Meeting\n   * @returns {Promise}\n   */\n  disconnectPhoneAudio() {\n    return Promise.all([\n      this.isPhoneProvisioned(this.dialInDeviceStatus) ?\n        MeetingUtil.disconnectPhoneAudio(this, this.dialInUrl) :\n        Promise.resolve(),\n      this.isPhoneProvisioned(this.dialOutDeviceStatus) ?\n        MeetingUtil.disconnectPhoneAudio(this, this.dialOutUrl) :\n        Promise.resolve()\n    ]);\n  }\n\n  /**\n   * Moves the call to the specified resourceId\n   * @param {String} resourceId\n   * @returns {Promise} once the move has been completed\n   * @public\n   * @memberof Meeting\n   */\n  moveTo(resourceId) {\n    if (!resourceId) {\n      throw new ParameterError('Cannot move call without a resourceId.');\n    }\n\n    Metrics.postEvent({\n      event: eventType.MEDIA_CAPABILITIES,\n      meeting: this,\n      data: {\n        mediaCapabilities: {\n          rx: {\n            audio: false,\n            share: false,\n            share_audio: false,\n            video: false,\n            whiteboard: false\n          },\n          tx: {\n            audio: false,\n            share: false,\n            share_audio: false,\n            video: false,\n            whiteboard: false\n          }\n        }\n      }\n    });\n\n    Metrics.postEvent({event: eventType.MOVE_MEDIA, meeting: this});\n\n    return MeetingUtil.joinMeetingOptions(this, {resourceId, moveToResource: true}).then(() => {\n      this.meetingFiniteStateMachine.join();\n\n      return this.updateMedia({\n        mediaSettings: {\n          sendVideo: false, receiveVideo: false, sendAudio: false, receiveAudio: false, sendShare: false, receiveShare: false\n        }\n      }).then(() => Promise.resolve(this));\n    }).catch((error) => {\n      this.meetingFiniteStateMachine.fail(error);\n\n      return Promise.reject(error);\n    });\n  }\n\n  /**\n   * Moves the call from the specified resourceId, back to computer\n   * @param {String} resourceId\n   * @returns {Promise} once the move has been completed\n   * @public\n   * @memberof Meeting\n   */\n  moveFrom(resourceId) {\n    if (!resourceId) {\n      throw new ParameterError('Cannot move call without a resourceId.');\n    }\n    const oldCorrelationId = this.correlationId;\n\n    this.id = uuid.v4();\n\n    this.webex.meetings.meetingCollection.set(this);\n\n    Metrics.postEvent({\n      event: eventType.MEDIA_CAPABILITIES,\n      meeting: this,\n      data: {\n        mediaCapabilities: {\n          rx: {\n            audio: true,\n            share: true,\n            share_audio: true,\n            video: true,\n            whiteboard: true\n          },\n          tx: {\n            audio: true,\n            share: true,\n            share_audio: true,\n            video: true,\n            whiteboard: true\n          }\n        }\n      }\n    });\n    Metrics.postEvent({event: eventType.MOVE_MEDIA, meeting: this});\n\n    return MeetingUtil.joinMeetingOptions(this).then((join) => this.getMediaStreams({sendAudio: true, sendVideo: true, sendShare: false})\n      .then(([localStream, localShare]) =>\n        this.updateMedia({\n          mediaSettings: {\n            sendAudio: true, receiveAudio: true, sendVideo: true, receiveVideo: true, sendShare: false, receiveShare: false\n          },\n          localStream,\n          localShare\n        })\n          .then(() => Promise.resolve(join)))\n      .then(() => MeetingUtil.leaveMeeting(this, {resourceId, correlationId: oldCorrelationId, moveMeeting: true})))\n      .then(() => {\n        this.webex.meetings.meetingCollection.delete(this.id);\n\n        return Promise.resolve();\n      });\n  }\n\n  /**\n   * Get local media streams based on options passed\n   * @param {MediaDirection} mediaDirection A configurable options object for joining a meeting\n   * @param {AudioVideo} [audioVideo] audio/video object to set audioinput and videoinput devices, see #Media.getUserMedia\n   * @param {SharePreferences} [sharePreferences] audio/video object to set audioinput and videoinput devices, see #Media.getUserMedia\n   * @returns {Promise} see #Media.getUserMedia\n   * @public\n   * @todo should be static, or moved so can be called outside of a meeting\n   * @memberof Meeting\n   */\n  getMediaStreams = (\n    mediaDirection,\n    // This return an OBJECT {video: {height, widght}}\n    audioVideo = VIDEO_RESOLUTIONS[this.mediaProperties.localQualityLevel],\n    sharePreferences\n  ) => {\n    if (\n      mediaDirection &&\n      (\n        mediaDirection.sendAudio ||\n        mediaDirection.sendVideo ||\n        mediaDirection.sendShare\n      )\n    ) {\n      if (mediaDirection &&\n        (\n          mediaDirection.sendAudio &&\n          mediaDirection.sendVideo &&\n          mediaDirection.sendShare\n        ) &&\n        isBrowser('safari')\n      ) {\n        LoggerProxy.logger.warn('Meeting:index#getMediaStreams --> Setting `sendShare` to FALSE, due to complications with Safari');\n\n        mediaDirection.sendShare = false;\n\n        LoggerProxy.logger.warn('Meeting:index#getMediaStreams --> Enabling `sendShare` along with `sendAudio` & `sendVideo`, on Safari, causes a failure while setting up a screen share at the same time as the camera+mic stream');\n        LoggerProxy.logger.warn('Meeting:index#getMediaStreams --> Please use `meeting.shareScreen()` to manually start the screen share after successfully joining the meeting');\n      }\n\n      // extract deviceId if exists otherwise default to null.\n      const {deviceId: preferredVideoDevice} = (audioVideo && audioVideo.video || {deviceId: null});\n      const lastVideoDeviceId = this.mediaProperties.getVideoDeviceId();\n\n      if (preferredVideoDevice) {\n        // Store new preferred video input device\n        this.mediaProperties.setVideoDeviceId(preferredVideoDevice);\n      }\n      else if (lastVideoDeviceId) {\n        // no new video preference specified so use last stored value,\n        // works with empty object {} or media constraint.\n        // eslint-disable-next-line no-param-reassign\n        audioVideo = {\n          ...audioVideo,\n          video: {\n            ...audioVideo.video,\n            deviceId: lastVideoDeviceId\n          }\n        };\n      }\n\n      return Media.getSupportedDevice({\n        sendAudio: mediaDirection.sendAudio,\n        sendVideo: mediaDirection.sendVideo\n      })\n        .catch((error) => Promise.reject(\n          new MediaError('Given constraints do not match permission set for either camera or microphone', error)\n        ))\n        .then((devicePermissions) =>\n          Media.getUserMedia(\n            {\n              ...mediaDirection,\n              sendAudio: devicePermissions.sendAudio,\n              sendVideo: devicePermissions.sendVideo,\n              isSharing: this.shareStatus === SHARE_STATUS.LOCAL_SHARE_ACTIVE\n            },\n            audioVideo,\n            sharePreferences,\n            this.config\n          )\n            .catch((error) => {\n              // Whenever there is a failure when trying to access a user's device\n              // report it as an Behavioral metric\n              // This gives visibility into common errors and can help\n              // with further troubleshooting\n              const metricName = BEHAVIORAL_METRICS.GET_USER_MEDIA_FAILURE;\n              const data = {\n                correlation_id: this.correlationId,\n                locus_id: this.locusUrl?.split('/').pop(),\n                reason: error.message,\n                stack: error.stack\n              };\n              const metadata = {\n                type: error.name\n              };\n\n              Metrics.sendBehavioralMetric(metricName, data, metadata);\n              throw new MediaError('Unable to retrieve media streams', error);\n            }));\n    }\n\n    return Promise.reject(\n      new MediaError('At least one of the mediaDirection value should be true')\n    );\n  };\n\n\n  /**\n   * Checks if the machine has at least one audio or video device\n   * @param {Object} options\n   * @param {Boolean} options.sendAudio\n   * @param {Boolean} options.sendVideo\n   * @returns {Object}\n   * @memberof Meetings\n   */\n  getSupportedDevices = ({sendAudio = true, sendVideo = true}) => Media.getSupportedDevice({sendAudio, sendVideo});\n\n  /**\n   * Get the devices from the Media module\n   * @returns {Promise} resolves to an array of DeviceInfo\n   * @memberof Meetings\n   */\n  getDevices = () => Media.getDevices();\n\n  /**\n   * Specify joining via audio (option: pstn), video, screenshare\n   * @param {Object} options A configurable options object for joining a meeting\n   * @param {Object} options.resourceId pass the deviceId\n   * @param {MediaDirection} options.mediaSettings pass media options\n   * @param {MediaStream} options.localStream\n   * @param {MediaStream} options.localShare\n   * @returns {Promise}\n   * @public\n   * @memberof Meeting\n   */\n  addMedia(options = {}) {\n    const LOG_HEADER = 'Meeting:index#addMedia -->';\n\n    if (this.meetingState !== FULL_STATE.ACTIVE) {\n      return Promise.reject(new MeetingNotActiveError());\n    }\n\n    if (MeetingUtil.isUserInLeftState(this.locusInfo)) {\n      return Promise.reject(new UserNotJoinedError());\n    }\n    // If the user is unjoined or guest waiting in lobby dont allow the user to addMedia\n    if (this.guest && MeetingUtil.isUserInIdleState(this.locusInfo) && !this.wirelessShare) {\n      return Promise.reject(new UserInLobbyError());\n    }\n\n    const {localStream, localShare, mediaSettings} = options;\n\n    LoggerProxy.logger.info(`${LOG_HEADER} Adding Media.`);\n\n    Metrics.postEvent({\n      event: eventType.MEDIA_CAPABILITIES,\n      meeting: this,\n      data: {\n        mediaCapabilities: {\n          rx: {\n            audio: false,\n            share: false,\n            share_audio: false,\n            video: false,\n            whiteboard: false\n          },\n          tx: {\n            audio: false,\n            share: false,\n            share_audio: false,\n            video: false,\n            whiteboard: false\n          }\n        }\n      }\n    });\n\n    return MeetingUtil.validateOptions(options)\n      .then(() => {\n        this.mediaProperties.setMediaPeerConnection(MediaUtil.createPeerConnection());\n        this.setMercuryListener();\n        PeerConnectionManager.setPeerConnectionEvents(this);\n\n        return this.preMedia(localStream, localShare, mediaSettings);\n      })\n      .then(() => Media.attachMedia(this.mediaProperties, {\n        meetingId: this.id,\n        remoteQualityLevel: this.mediaProperties.remoteQualityLevel,\n        enableRtx: this.config.enableRtx,\n        enableExtmap: this.config.enableExtmap,\n        setStartLocalSDPGenRemoteSDPRecvDelay: this.setStartLocalSDPGenRemoteSDPRecvDelay.bind(this)\n      })\n        .then((peerConnection) => this.getDevices().then((devices) => {\n          MeetingUtil.handleDeviceLogging(devices);\n\n          return peerConnection;\n        }))\n        .then((peerConnection) => {\n          this.handleMediaLogging(this.mediaProperties);\n          LoggerProxy.logger.info(`${LOG_HEADER} PeerConnection Received from attachMedia `);\n\n          this.setRemoteStream(peerConnection);\n          MeetingUtil.startInternalStats(this);\n\n          if (this.config.metrics.autoSendMQA) {\n            this.startMediaQualityMetrics();\n          }\n\n          if (this.config.stats.enableStatsAnalyzer) {\n            // TODO: ** Dont re create StatsAnalyzer on reconnect or rejoin\n            this.networkQualityMonitor = new NetworkQualityMonitor(this.config.stats);\n            this.statsAnalyzer = new StatsAnalyzer(this.config.stats, this.networkQualityMonitor);\n            this.statsAnalyzer.on(EVENT_TRIGGERS.MEDIA_QUALITY, (options) => {\n              // TODO:  might have to send the same event to the developer\n              // Add ip address info if geo hint is present\n              options.data.intervalMetadata.peerReflexiveIP = this.webex.meetings.geoHintInfo?.clientAddress || options.data.intervalMetadata.peerReflexiveIP || MQA_STATS.DEFAULT_IP;\n              Metrics.postEvent({event: eventType.MEDIA_QUALITY, meeting: this, data: {intervalData: options.data, networkType: options.networkType}});\n            });\n            this.networkQualityMonitor.on(EVENT_TRIGGERS.NETWORK_QUALITY, this.sendNetworkQualityEvent.bind(this));\n          }\n        })\n        .catch((error) => {\n          LoggerProxy.logger.error(`${LOG_HEADER} Error adding media , setting up peerconnection, `, error);\n\n          Metrics.sendBehavioralMetric(\n            BEHAVIORAL_METRICS.ADD_MEDIA_FAILURE,\n            {\n              correlation_id: this.correlationId,\n              locus_id: this.locusUrl.split('/').pop(),\n              reason: error.message,\n              stack: error.stack\n            }\n          );\n\n          throw error;\n        })\n        .then(() => new Promise((resolve, reject) => {\n          let timerCount = 0;\n\n          // eslint-disable-next-line func-names\n          // eslint-disable-next-line prefer-arrow-callback\n          if (this.type === _CALL_) {\n            resolve();\n          }\n          const joiningTimer = setInterval(() => {\n            timerCount += 1;\n            if (this.meetingState === FULL_STATE.ACTIVE) {\n              clearInterval(joiningTimer);\n              resolve();\n            }\n\n            if (timerCount === 4) {\n              clearInterval(joiningTimer);\n              reject(new Error('Meeting is still not active '));\n            }\n          }, 1000);\n        }))\n        .then(() =>\n          logRequest(this.roap\n            .sendRoapMediaRequest({\n              sdp: this.mediaProperties.peerConnection.sdp,\n              roapSeq: this.roapSeq,\n              meeting: this // or can pass meeting ID\n            }), {\n            header: `${LOG_HEADER} Send Roap Media Request.`,\n            success: `${LOG_HEADER} Successfully send roap media request`,\n            failure: `${LOG_HEADER} Error joining the call on send roap media request, `\n          }))\n        .then(() => {\n          const {peerConnection} = this.mediaProperties;\n\n          return new Promise((resolve, reject) => {\n            if (peerConnection.connectionState === CONNECTION_STATE.CONNECTED) {\n              LoggerProxy.logger.info(`${LOG_HEADER} PeerConnection CONNECTED`);\n\n              resolve(peerConnection);\n\n              return;\n            }\n            // Check if Peer Connection is STABLE (connected)\n            const stabilityTimeout = setTimeout(() => {\n              if (peerConnection.connectionState !== CONNECTION_STATE.CONNECTED) {\n                // TODO: Fix this after the error code pr goes in\n                reject(createMeetingsError(30202, 'Meeting connection failed'));\n              }\n              else {\n                LoggerProxy.logger.info(`${LOG_HEADER} PeerConnection CONNECTED`);\n                resolve(peerConnection);\n              }\n            }, PC_BAIL_TIMEOUT);\n\n            this.once(EVENT_TRIGGERS.MEDIA_READY, () => {\n              LoggerProxy.logger.info(`${LOG_HEADER} PeerConnection CONNECTED, clearing stability timer.`);\n              clearTimeout(stabilityTimeout);\n              resolve(peerConnection);\n            });\n          });\n        })\n        .then(() => {\n          if (mediaSettings && mediaSettings.sendShare && localShare) {\n            if (this.state === MEETING_STATE.STATES.JOINED) {\n              return this.share();\n            }\n\n            // When the self state changes to JOINED then request the floor\n            this.floorGrantPending = true;\n          }\n\n          Metrics.sendBehavioralMetric(\n            BEHAVIORAL_METRICS.ADD_MEDIA_SUCCESS,\n            {\n              correlation_id: this.correlationId,\n              locus_id: this.locusUrl.split('/').pop()\n            }\n          );\n\n          return Promise.resolve();\n        }))\n      .catch((error) => {\n        // Clean up stats analyzer, peer connection, and turn off listeners\n        if (this.statsAnalyzer) {\n          this.statsAnalyzer.stopAnalyzer();\n          this.statsAnalyzer = null;\n        }\n        if (this.mediaProperties.peerConnection) {\n          this.closePeerConnections();\n          this.unsetPeerConnections();\n        }\n\n        LoggerProxy.logger.error(`${LOG_HEADER} Error adding media failed to initiate PC and send request, `, error);\n\n        Metrics.sendBehavioralMetric(\n          BEHAVIORAL_METRICS.ADD_MEDIA_FAILURE,\n          {\n            correlation_id: this.correlationId,\n            locus_id: this.locusUrl.split('/').pop(),\n            reason: error.message,\n            stack: error.stack,\n            code: error.code\n          }\n        );\n\n        // Upload logs on error while adding media\n        Trigger.trigger(\n          this,\n          {\n            file: 'meeting/index',\n            function: 'addMedia'\n          },\n          EVENTS.REQUEST_UPLOAD_LOGS,\n          this\n        );\n\n        // If addMedia failes for not establishing connection then\n        // leave the meeting with reson connection failed as meeting anyways will end\n        // and cannot be connected unless network condition is checked for firewall\n        if (error.code === InvalidSdpError.CODE) {\n          this.leave({reason: MEETING_REMOVED_REASON.MEETING_CONNECTION_FAILED});\n        }\n\n        throw error;\n      });\n  }\n\n  /**\n   * Informs if the peer connection is in a state that can be updated with updateMedia (audio/video/share)\n   * @returns {Boolean}\n   */\n  canUpdateMedia() {\n    return this.mediaProperties.peerConnection.signalingState === SDP.STABLE && !RoapCollection.isBusy(this.correlationId);\n  }\n\n  /**\n   * Enqueues a media update operation.\n   * @param {String} mediaUpdateType one of MEDIA_UPDATE_TYPE values\n   * @param {Object} options\n   * @returns {Promise}\n   * @private\n   * @memberof Meeting\n   */\n  enqueueMediaUpdate(mediaUpdateType, options) {\n    return new Promise((resolve, reject) => {\n      const queueItem = {\n        pendingPromiseResolve: resolve, pendingPromiseReject: reject, mediaUpdateType, options\n      };\n\n      LoggerProxy.logger.log(`Meeting:index#enqueueMediaUpdate --> enqueuing media update type=${mediaUpdateType}`);\n      this.queuedMediaUpdates.push(queueItem);\n    });\n  }\n\n  /**\n   * emits event when the negotation is completed\n   * @returns {void}\n   * @private\n   * @memberof Meeting\n   */\n  mediaNegotiatedEvent = () => {\n    if (this.config.experimental.enableMediaNegotiatedEvent) {\n      LoggerProxy.logger.info('Meeting:mediaNegotiatedEvent --> Media server negotiated');\n      Trigger.trigger(\n        this,\n        {\n          file: 'meeting/index',\n          function: 'mediaNegotiatedEvent'\n        },\n        EVENT_TRIGGERS.MEDIA_NEGOTIATED,\n      );\n    }\n  }\n\n  /**\n   * Checks if there are any queued media updates and runs the first one from\n   * the queue if we are in a state that allows doing that.\n   * @returns {undefined}\n   * @public\n   * @memberof Meeting\n   */\n  processNextQueuedMediaUpdate = () => {\n    if (this.canUpdateMedia() && (this.queuedMediaUpdates.length > 0)) {\n      const {\n        pendingPromiseResolve, pendingPromiseReject, mediaUpdateType, options\n      } = this.queuedMediaUpdates.shift();\n\n      LoggerProxy.logger.log(`Meeting:index#processNextQueuedMediaUpdate --> performing delayed media update type=${mediaUpdateType}`);\n      switch (mediaUpdateType) {\n        case MEDIA_UPDATE_TYPE.ALL:\n          this.updateMedia(options).then(pendingPromiseResolve, pendingPromiseReject);\n          break;\n        case MEDIA_UPDATE_TYPE.AUDIO:\n          this.updateAudio(options).then(pendingPromiseResolve, pendingPromiseReject);\n          break;\n        case MEDIA_UPDATE_TYPE.VIDEO:\n          this.updateVideo(options).then(pendingPromiseResolve, pendingPromiseReject);\n          break;\n        case MEDIA_UPDATE_TYPE.SHARE:\n          this.updateShare(options).then(pendingPromiseResolve, pendingPromiseReject);\n          break;\n        default:\n          LoggerProxy.logger.error(`Peer-connection-manager:index#processNextQueuedMediaUpdate --> unsupported media update type ${mediaUpdateType} found in the queue`);\n          break;\n      }\n    }\n  };\n\n  /**\n   * A confluence of updateAudio, updateVideo, and updateShare\n   * this function re-establishes all of the media streams with new options\n   * @param {Object} options\n   * @param {MediaStream} options.localStream\n   * @param {MediaStream} options.localShare\n   * @param {MediaDirection} options.mediaSettings\n   * @returns {Promise}\n   * @todo fix setRemoteStream for updateMedia\n   * @public\n   * @memberof Meeting\n   */\n  updateMedia(options = {}) {\n    const LOG_HEADER = 'Meeting:index#updateMedia -->';\n\n    if (!this.canUpdateMedia()) {\n      return this.enqueueMediaUpdate(MEDIA_UPDATE_TYPE.ALL, options);\n    }\n    const {localStream, localShare, mediaSettings} = options;\n\n    const previousSendShareStatus = this.mediaProperties.mediaDirection.sendShare;\n\n    return MeetingUtil.validateOptions(options)\n      .then(() => this.preMedia(localStream, localShare, mediaSettings))\n      .then(() => Media.updateMedia(this.mediaProperties, {\n        meetingId: this.id,\n        remoteQualityLevel: this.mediaProperties.remoteQualityLevel,\n        enableRtx: this.config.enableRtx,\n        enableExtmap: this.config.enableExtmap\n      })\n        .then((peerConnection) => {\n          LoggerProxy.logger.info(`${LOG_HEADER} PeerConnection received from updateMedia, ${peerConnection}`);\n          this.setRemoteStream(peerConnection);\n          if (mediaSettings.receiveShare || localShare) {\n            PeerConnectionManager.setContentSlides(peerConnection);\n          }\n        })\n        .catch((error) => {\n          LoggerProxy.logger.error(`${LOG_HEADER} Error updatedMedia, `, error);\n\n          Metrics.sendBehavioralMetric(\n            BEHAVIORAL_METRICS.UPDATE_MEDIA_FAILURE,\n            {\n              correlation_id: this.correlationId,\n              locus_id: this.locusUrl.split('/').pop(),\n              reason: error.message,\n              stack: error.stack\n            }\n          );\n\n          throw error;\n        })\n        .then(() =>\n          logRequest(this.roap\n            .sendRoapMediaRequest({\n              sdp: this.mediaProperties.peerConnection.sdp,\n              roapSeq: this.roapSeq,\n              meeting: this // or can pass meeting ID\n            }),\n          {\n            header: `${LOG_HEADER} sendRoapMediaRequest being sent`,\n            success: `${LOG_HEADER} sendRoadMediaRequest successful`,\n            failure: `${LOG_HEADER} Error updateMedia on send roap media request, `\n          }))\n        .then(() => this.checkForStopShare(mediaSettings.sendShare, previousSendShareStatus))\n        .then((startShare) => {\n          // This is a special case if we do an /floor grant followed by /media\n          // we actually get a OFFER from the server and a GLAR condition happens\n          if (startShare) {\n            // We are assuming that the clients are connected when doing an update\n            return this.share();\n          }\n\n          return Promise.resolve();\n        }));\n  }\n\n  /**\n   * Update the main audio track with new parameters\n   * @param {Object} options\n   * @param {boolean} options.sendAudio\n   * @param {boolean} options.receiveAudio\n   * @param {MediaStream} options.stream Stream that contains the audio track to update\n   * @returns {Promise}\n   * @public\n   * @memberof Meeting\n   */\n  updateAudio(options) {\n    if (!this.canUpdateMedia()) {\n      return this.enqueueMediaUpdate(MEDIA_UPDATE_TYPE.AUDIO, options);\n    }\n    const {sendAudio, receiveAudio, stream} = options;\n    const {audioTransceiver} = this.mediaProperties.peerConnection;\n    const track = MeetingUtil.getTrack(stream).audioTrack;\n\n    if (typeof sendAudio !== 'boolean' || typeof receiveAudio !== 'boolean') {\n      return Promise.reject(new ParameterError('Pass sendAudio and receiveAudio parameter'));\n    }\n\n    return MeetingUtil.validateOptions({sendAudio, localStream: stream})\n      .then(() => {\n        let previousMediaDirection = {};\n\n        if (this.mediaProperties.mediaDirection) {\n          previousMediaDirection = {\n            sendTrack: this.mediaProperties.mediaDirection.sendAudio,\n            receiveTrack: this.mediaProperties.mediaDirection.receiveAudio\n          };\n        }\n        else {\n          this.mediaProperties.mediaDirection = {};\n        }\n\n        return MeetingUtil.updateTransceiver(\n          {\n            type: 'audio',\n            sendTrack: options.sendAudio,\n            receiveTrack: options.receiveAudio,\n            track,\n            transceiver: audioTransceiver,\n            peerConnection: this.mediaProperties.peerConnection,\n            previousMediaDirection\n          },\n          {\n            mediaProperties: this.mediaProperties,\n            meeting: this,\n            id: this.id\n          }\n        );\n      })\n      .then(() => {\n        this.setLocalAudioTrack(track);\n        this.mediaProperties.mediaDirection.sendAudio = sendAudio;\n        this.mediaProperties.mediaDirection.receiveAudio = receiveAudio;\n\n        // audio state could be undefined if you have not sent audio before\n        this.audio = this.audio || createMuteState(AUDIO, this, this.mediaProperties.mediaDirection);\n      });\n  }\n\n  /**\n   * Update the main video track with new parameters\n   * @param {Object} options\n   * @param {boolean} options.sendVideo\n   * @param {boolean} options.receiveVideo\n   * @param {MediaStream} options.stream Stream that contains the video track to update\n   * @returns {Promise}\n   * @public\n   * @memberof Meeting\n   */\n  updateVideo(options) {\n    if (!this.canUpdateMedia()) {\n      return this.enqueueMediaUpdate(MEDIA_UPDATE_TYPE.VIDEO, options);\n    }\n    const {sendVideo, receiveVideo, stream} = options;\n    const {videoTransceiver} = this.mediaProperties.peerConnection;\n    const track = MeetingUtil.getTrack(stream).videoTrack;\n\n    if (typeof sendVideo !== 'boolean' || typeof receiveVideo !== 'boolean') {\n      return Promise.reject(new ParameterError('Pass sendVideo and receiveVideo parameter'));\n    }\n\n    return MeetingUtil.validateOptions({sendVideo, localStream: stream})\n      .then(() => MeetingUtil.updateTransceiver({\n        type: 'video',\n        sendTrack: options.sendVideo,\n        receiveTrack: options.receiveVideo,\n        track,\n        transceiver: videoTransceiver,\n        peerConnection: this.mediaProperties.peerConnection,\n        previousMediaDirection: {\n          sendTrack: this.mediaProperties.mediaDirection.sendVideo,\n          receiveTrack: this.mediaProperties.mediaDirection.receiveVideo\n        }\n      },\n      {\n        mediaProperties: this.mediaProperties,\n        meeting: this,\n        id: this.id\n      }))\n      .then(() => {\n        this.setLocalVideoTrack(track);\n        this.mediaProperties.mediaDirection.sendVideo = sendVideo;\n        this.mediaProperties.mediaDirection.receiveVideo = receiveVideo;\n\n        // video state could be undefined if you have not sent video before\n        this.video = this.video || createMuteState(VIDEO, this, this.mediaProperties.mediaDirection);\n      });\n  }\n\n  /**\n   * Internal function when stopping a share stream, cleanup\n   * @param {boolean} sendShare\n   * @param {boolean} previousShareStatus\n   * @returns {Promise}\n   * @private\n   * @memberof Meeting\n   */\n  checkForStopShare(sendShare, previousShareStatus) {\n    if (sendShare && !previousShareStatus) {\n      // When user starts sharing\n      return Promise.resolve(true);\n    }\n\n    if (!sendShare && previousShareStatus) {\n      // When user stops sharing\n      return this.stopFloorRequest()\n        .then(() => Promise.resolve(false));\n    }\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Update the share streams, can be used to start sharing\n   * @param {Object} options\n   * @param {boolean} options.sendShare\n   * @param {boolean} options.receiveShare\n   * @returns {Promise}\n   * @public\n   * @memberof Meeting\n   */\n  updateShare(options) {\n    if (!options.skipSignalingCheck && !this.canUpdateMedia()) {\n      return this.enqueueMediaUpdate(MEDIA_UPDATE_TYPE.SHARE, options);\n    }\n    const {sendShare, receiveShare, stream} = options;\n    const {shareTransceiver} = this.mediaProperties.peerConnection;\n    const track = MeetingUtil.getTrack(stream).videoTrack;\n\n    if (typeof sendShare !== 'boolean' || typeof receiveShare !== 'boolean') {\n      return Promise.reject(new ParameterError('Pass sendShare and receiveShare parameter'));\n    }\n    const previousSendShareStatus = this.mediaProperties.mediaDirection.sendShare;\n\n    this.setLocalShareTrack(stream);\n\n    return MeetingUtil.validateOptions({sendShare, localShare: stream})\n      .then(() => this.checkForStopShare(sendShare, previousSendShareStatus))\n      .then((startShare) => MeetingUtil.updateTransceiver({\n        type: 'video',\n        sendTrack: sendShare,\n        receiveTrack: receiveShare,\n        track,\n        transceiver: shareTransceiver,\n        peerConnection: this.mediaProperties.peerConnection,\n        previousMediaDirection: {\n          sendTrack: this.mediaProperties.mediaDirection.sendShare,\n          receiveTrack: this.mediaProperties.mediaDirection.receiveShare\n        }\n      },\n      {\n        mediaProperties: this.mediaProperties,\n        meeting: this,\n        id: this.id\n      })\n        .then(() => {\n          if (startShare) {\n            return this.share();\n          }\n\n          return Promise.resolve();\n        }))\n      .then(() => {\n        this.mediaProperties.mediaDirection.sendShare = sendShare;\n        this.mediaProperties.mediaDirection.receiveShare = receiveShare;\n      })\n      .catch((error) => {\n        this.unsetLocalShareTrack(stream);\n        throw error;\n      })\n      .finally(() => {\n        const delay = 1e3;\n        // Check to see if share was stopped natively before onended was assigned.\n        const sharingModeIsActive = this.mediaProperties.peerConnection.shareTransceiver.direction === SENDRECV;\n        const isSharingOutOfSync = sharingModeIsActive && !this.isLocalShareLive;\n\n        if (isSharingOutOfSync) {\n          // Adding a delay to avoid a 409 from server\n          // which results in user still appearing as if sharing.\n          // Also delay give time for changes to peerConnection.\n          setTimeout(\n            () => this.handleShareTrackEnded(stream),\n            delay\n          );\n        }\n      });\n  }\n\n  /**\n   * Do all the attach media pre set up before executing the actual attach\n   * @param {MediaStream} localStream\n   * @param {MediaStream} localShare\n   * @param {MediaDirection} mediaSettings\n   * @returns {undefined}\n   * @private\n   * @memberof Meeting\n   */\n  preMedia(localStream, localShare, mediaSettings) {\n    // eslint-disable-next-line no-warning-comments\n    // TODO wire into default config. There's currently an issue with the stateless plugin or how we register\n    this.mediaProperties.setMediaDirection(Object.assign(this.config.mediaSettings, mediaSettings));\n    // add a setup a function move the create and setup media in future\n    // TODO: delete old audio and video if stale\n    this.audio = this.audio || createMuteState(AUDIO, this, this.mediaProperties.mediaDirection);\n    this.video = this.video || createMuteState(VIDEO, this, this.mediaProperties.mediaDirection);\n    // Validation is already done in addMedia so no need to check if the lenght is greater then 0\n    this.setLocalTracks(localStream);\n    this.setLocalShareTrack(localShare);\n  }\n\n  /**\n   * Acknowledge the meeting, outgoing or incoming\n   * @param {String} type\n   * @returns {Promise} resolve {message, ringing, response}\n   * @public\n   * @memberof Meeting\n   */\n  acknowledge(type) {\n    if (!type) {\n      return Promise.reject(new ParameterError('Type must be set to acknowledge the meeting.'));\n    }\n    if (type === _INCOMING_) {\n      return this.meetingRequest\n        .acknowledgeMeeting({\n          locusUrl: this.locusUrl,\n          deviceUrl: this.deviceUrl,\n          correlationId: this.correlationId\n        })\n        .then((response) => Promise.resolve(response))\n        .then((response) => {\n          this.meetingFiniteStateMachine.ring(type);\n          Metrics.postEvent({event: eventType.ALERT_DISPLAYED, meeting: this});\n\n          return Promise.resolve({\n            response\n          });\n        });\n    }\n\n    // TODO: outside of 1:1 incoming, and all outgoing calls\n    return Promise.resolve({\n      message: 'noop'\n    });\n  }\n\n  /**\n   * Decline this meeting\n   * @param {String} reason\n   * @returns {undefined}\n   * @public\n   * @memberof Meeting\n   */\n  decline(reason) {\n    return MeetingUtil.declineMeeting(this, reason).then((decline) => {\n      this.meetingFiniteStateMachine.decline();\n\n      return Promise.resolve(decline);\n    }).catch((error) => {\n      this.meetingFiniteStateMachine.fail(error);\n\n      return Promise.reject(error);\n    });\n  }\n\n  /**\n   * Leave the current meeting\n   * @param {Object} options leave options\n   * @param {String} options.resourceId the device with which to leave from, empty if just the computer\n   * @returns {Promise}\n   * @public\n   * @memberof Meeting\n   */\n  leave(options = {}) {\n    Metrics.postEvent({event: eventType.LEAVE, meeting: this, data: {trigger: trigger.USER_INTERACTION, canProceed: false}});\n    const leaveReason = options.reason || MEETING_REMOVED_REASON.CLIENT_LEAVE_REQUEST;\n\n    LoggerProxy.logger.log('Meeting:index#leave --> Leaving a meeting');\n\n    return MeetingUtil.leaveMeeting(this, options)\n      .then((leave) => {\n        this.meetingFiniteStateMachine.leave();\n        this.audio = null;\n        this.video = null;\n        this.isSharing = false;\n        if (this.shareStatus === SHARE_STATUS.LOCAL_SHARE_ACTIVE) {\n          this.shareStatus = SHARE_STATUS.NO_SHARE;\n        }\n        this.queuedMediaUpdates = [];\n\n        if (this.transcription) {\n          this.transcription.closeSocket();\n          this.triggerStopReceivingTranscriptionEvent();\n          this.transcription = undefined;\n        }\n\n        // upload logs on leave irrespective of meeting delete\n        Trigger.trigger(\n          this,\n          {\n            file: 'meeting/index',\n            function: 'leave'\n          },\n          EVENTS.REQUEST_UPLOAD_LOGS,\n          this\n        );\n\n        // TODO: more testing before we remove this code, we are not sure the scenarios for destroy here\n        if (this.wirelessShare || this.guest) {\n          // If screen sharing clean the meeting object\n          Trigger.trigger(\n            this,\n            {\n              file: 'meeting/index',\n              function: 'leave'\n            },\n            EVENTS.DESTROY_MEETING,\n            {\n              reason: options.reason,\n              meetingId: this.id\n            }\n          );\n        }\n        LoggerProxy.logger.log('Meeting:index#leave --> LEAVE REASON ', leaveReason);\n\n        return leave;\n      }).catch((error) => {\n        this.meetingFiniteStateMachine.fail(error);\n        LoggerProxy.logger.error('Meeting:index#leave --> Failed to leave ', error);\n        // upload logs on leave irrespective of meeting delete\n        Trigger.trigger(\n          this,\n          {\n            file: 'meeting/index',\n            function: 'leave'\n          },\n          EVENTS.REQUEST_UPLOAD_LOGS,\n          this\n        );\n        Metrics.sendBehavioralMetric(\n          BEHAVIORAL_METRICS.MEETING_LEAVE_FAILURE,\n          {\n            correlation_id: this.correlationId,\n            locus_id: this.locusUrl.split('/').pop(),\n            reason: error.message,\n            stack: error.stack,\n            code: error.code\n          }\n        );\n\n        return Promise.reject(error);\n      });\n  }\n\n  /**\n   * Start sharing whiteboard given channelUrl\n   * @param {string} channelUrl whiteboard url\n   * @param {String} resourceToken token created by authorize media injector\n   * @returns {Promise}\n   * @public\n   * @memberof Meeting\n   */\n  startWhiteboardShare(channelUrl, resourceToken) {\n    const whiteboard = this.locusInfo.mediaShares.find((element) => element.name === 'whiteboard');\n\n    if (!channelUrl) {\n      return Promise.reject(new ParameterError('Cannot share without channelUrl.'));\n    }\n\n    if (whiteboard) {\n      Metrics.postEvent({event: eventType.WHITEBOARD_SHARE_INITIATED, meeting: this});\n\n      const body = {\n        disposition: FLOOR_ACTION.GRANTED,\n        personUrl: this.locusInfo.self.url,\n        deviceUrl: this.deviceUrl,\n        uri: whiteboard.url,\n        resourceUrl: channelUrl\n      };\n\n      if (resourceToken) {\n        body.resourceToken = resourceToken;\n      }\n\n      return this.meetingRequest.changeMeetingFloor(body)\n        .then(() => {\n          this.isSharing = false;\n\n          return Promise.resolve();\n        })\n        .catch((error) => {\n          LoggerProxy.logger.error('Meeting:index#startWhiteboardShare --> Error ', error);\n\n          Metrics.sendBehavioralMetric(\n            BEHAVIORAL_METRICS.MEETING_START_WHITEBOARD_SHARE_FAILURE,\n            {\n              correlation_id: this.correlationId,\n              locus_id: this.locusUrl.split('/').pop(),\n              reason: error.message,\n              stack: error.stack,\n              board: {channelUrl}\n            }\n          );\n\n          return Promise.reject(error);\n        });\n    }\n\n    return Promise.reject(new ParameterError('Cannot share without whiteboard.'));\n  }\n\n  /**\n   * Stop sharing whiteboard given channelUrl\n   * @param {string} channelUrl whiteboard url\n   * @returns {Promise}\n   * @public\n   * @memberof Meeting\n   */\n  stopWhiteboardShare(channelUrl) {\n    const whiteboard = this.locusInfo.mediaShares.find((element) => element.name === 'whiteboard');\n\n    if (whiteboard) {\n      Metrics.postEvent({event: eventType.WHITEBOARD_SHARE_STOPPED, meeting: this});\n\n      return this.meetingRequest.changeMeetingFloor({\n        disposition: FLOOR_ACTION.RELEASED,\n        personUrl: this.locusInfo.self.url,\n        deviceUrl: this.deviceUrl,\n        uri: whiteboard.url\n      })\n        .catch((error) => {\n          LoggerProxy.logger.error('Meeting:index#stopWhiteboardShare --> Error ', error);\n\n          Metrics.sendBehavioralMetric(\n            BEHAVIORAL_METRICS.STOP_WHITEBOARD_SHARE_FAILURE,\n            {\n              correlation_id: this.correlationId,\n              locus_id: this.locusUrl.split('/').pop(),\n              reason: error.message,\n              stack: error.stack,\n              board: {channelUrl}\n            }\n          );\n\n          return Promise.reject(error);\n        })\n        .finally(() => {\n        });\n    }\n\n    return Promise.reject(new ParameterError('Cannot stop share without whiteboard.'));\n  }\n\n  /**\n   * Start sharing content with server\n   * @returns {Promise} see #meetingRequest.changeMeetingFloor\n   * @private\n   * @memberof Meeting\n   */\n  share() {\n    const content = this.locusInfo.mediaShares.find((element) => element.name === CONTENT);\n\n    if (content && (this.shareStatus !== SHARE_STATUS.LOCAL_SHARE_ACTIVE)) {\n      Metrics.postEvent({event: eventType.SHARE_INITIATED, meeting: this});\n\n      return this.meetingRequest.changeMeetingFloor({\n        disposition: FLOOR_ACTION.GRANTED,\n        personUrl: this.locusInfo.self.url,\n        deviceUrl: this.deviceUrl,\n        uri: content.url,\n        resourceUrl: this.resourceUrl\n      })\n        .then(() => {\n          this.isSharing = true;\n\n          return Promise.resolve();\n        })\n        .catch((error) => {\n          LoggerProxy.logger.error('Meeting:index#share --> Error ', error);\n\n          Metrics.sendBehavioralMetric(\n            BEHAVIORAL_METRICS.MEETING_SHARE_FAILURE,\n            {\n              correlation_id: this.correlationId,\n              locus_id: this.locusUrl.split('/').pop(),\n              reason: error.message,\n              stack: error.stack\n            }\n          );\n\n          return Promise.reject(error);\n        });\n    }\n\n    return Promise.reject(new ParameterError('Cannot share without content.'));\n  }\n\n  /**\n   * Stops the screen share\n   * @returns {Promise} see #updateShare\n   * @public\n   * @memberof Meeting\n   */\n  // Internal only, temporarily allows optional params\n  // eslint-disable-next-line valid-jsdoc\n  stopShare(options = {}) {\n    return this.updateShare({\n      sendShare: false,\n      receiveShare: this.mediaProperties.mediaDirection.receiveShare,\n      ...options\n    });\n  }\n\n  /**\n   * sends stops floor request\n   * @returns {Promise} see #meetingRequest.changeMeetingFloor\n   * @private\n   * @memberof Meeting\n   */\n  stopFloorRequest() {\n    const content = this.locusInfo.mediaShares.find((element) => element.name === CONTENT);\n\n    if (content && (this.mediaProperties.mediaDirection.sendShare)) {\n      Metrics.postEvent({event: eventType.SHARE_STOPPED, meeting: this});\n      Media.stopTracks(this.mediaProperties.shareTrack);\n\n      if (content.floor.beneficiary.id !== this.selfId) {\n        // remote participant started sharing and caused our sharing to stop, we don't want to send any floor action request in that case\n        this.isSharing = false;\n\n        return Promise.resolve();\n      }\n\n      return this.meetingRequest.changeMeetingFloor({\n        disposition: FLOOR_ACTION.RELEASED,\n        personUrl: this.locusInfo.self.url,\n        deviceUrl: this.deviceUrl,\n        uri: content.url,\n        resourceUrl: this.resourceUrl\n      })\n        .catch((error) => {\n          LoggerProxy.logger.error('Meeting:index#stopFloorRequest --> Error ', error);\n\n          Metrics.sendBehavioralMetric(\n            BEHAVIORAL_METRICS.STOP_FLOOR_REQUEST_FAILURE,\n            {\n              correlation_id: this.correlationId,\n              locus_id: this.locusUrl.split('/').pop(),\n              reason: error.message,\n              stack: error.stack\n            }\n          );\n\n          return Promise.reject(error);\n        })\n        .finally(() => {\n          this.isSharing = false;\n        });\n    }\n\n    return Promise.reject(new ParameterError('Cannot stop share without content'));\n  }\n\n  /**\n   * Intiate a recording of this meeting\n   * @returns {Promise}\n   * @public\n   * @memberof Meeting\n   */\n  startRecording() {\n    return MeetingUtil.startRecording(this.meetingRequest, this.locusUrl, this.locusInfo);\n  }\n\n  /**\n   * End the recording of this meeting\n   * @returns {Promise}\n   * @public\n   * @memberof Meeting\n   */\n  stopRecording() {\n    return MeetingUtil.stopRecording(this.meetingRequest, this.locusUrl, this.locusInfo);\n  }\n\n  /**\n   * Pauses the recording of this meeting\n   * @returns {Promise}\n   * @public\n   * @memberof Meeting\n   */\n  pauseRecording() {\n    return MeetingUtil.pauseRecording(this.meetingRequest, this.locusUrl, this.locusInfo);\n  }\n\n  /**\n   * Resumes the recording of this meeting\n   * @returns {Promise}\n   * @public\n   * @memberof Meeting\n   */\n  resumeRecording() {\n    return MeetingUtil.resumeRecording(this.meetingRequest, this.locusUrl, this.locusInfo);\n  }\n\n  /**\n   * Locks the current meeting if possible\n   * @returns {Promise}\n   * @public\n   * @memberof Meeting\n   */\n  lockMeeting() {\n    return MeetingUtil.lockMeeting(this.inMeetingActions, this.meetingRequest, this.locusUrl);\n  }\n\n  /**\n   * Unlocks the current meeting if possible\n   * @returns {Promise}\n   * @public\n   * @memberof Meeting\n   */\n  unlockMeeting() {\n    return MeetingUtil.unlockMeeting(this.inMeetingActions, this.meetingRequest, this.locusUrl);\n  }\n\n  /**\n   * Logs an error message and returns a rejected promise with same message\n   * @param {String} message\n   * @returns {Promise}\n   * @private\n   * @memberof Meeting\n   */\n  rejectWithErrorLog(message) {\n    LoggerProxy.logger.error(message);\n\n    return Promise.reject(new Error(message));\n  }\n\n  /**\n   * Sends DTMF tones to the current meeting\n   * @param {String} tones a string of one or more DTMF tones to send\n   * @returns {Promise}\n   * @public\n   * @memberof Meeting\n   */\n  sendDTMF(tones) {\n    if (this.locusInfo && this.locusInfo.self) {\n      if (this.locusInfo.self.enableDTMF) {\n        return this.meetingRequest\n          .sendDTMF({\n            locusUrl: this.locusInfo.self.url,\n            deviceUrl: this.deviceUrl,\n            tones\n          });\n      }\n\n      return this.rejectWithErrorLog('Meeting:index#sendDTMF --> cannot send DTMF, meeting does not have DTMF enabled');\n    }\n\n    return this.rejectWithErrorLog('Meeting:index#sendDTMF --> cannot send DTMF, meeting does not have a connection to the \"locus\" call control service. Have you joined?');\n  }\n\n  /**\n   * Sends request to change layout type for the current meeting for the specific participant/device only\n   * @param {String} layoutType a layout type that should be available in meeting constants LAYOUT_TYPES\n   * @param {Object} renderInfo preferred dimensions for the remote main and content streams (server can ignore it)\n   * @param {Object} renderInfo.main preferred dimensions for the remote main video stream\n   * @param {Number} renderInfo.main.width preferred width of main video stream\n   * @param {Number} renderInfo.main.height preferred height of main video stream\n   * @param {Object} renderInfo.content preferred dimensions for the remote content share stream\n   * @param {Number} renderInfo.content.width preferred width of content share stream\n   * @param {Number} renderInfo.content.height preferred height of content share stream\n   * @returns {Promise}\n   * @public\n   * @memberof Meeting\n   */\n  changeVideoLayout(layoutType, renderInfo = {}) {\n    const {main, content} = renderInfo;\n    const {mediaDirection, remoteShare, remoteVideoTrack} = this.mediaProperties;\n\n    const layoutInfo = cloneDeep(this.lastVideoLayoutInfo);\n\n    // TODO: We need a real time value for Audio, Video and Share send indicator\n    if (mediaDirection.receiveVideo !== true || !remoteVideoTrack) {\n      return this.rejectWithErrorLog('Meeting:index#changeVideoLayout --> cannot change video layout, you are not recieving any video/share stream');\n    }\n\n    if (LAYOUT_TYPES.includes(layoutType)) {\n      layoutInfo.layoutType = layoutType;\n    }\n    else {\n      return this.rejectWithErrorLog('Meeting:index#changeVideoLayout --> cannot change video layout, invalid layoutType recieved.');\n    }\n\n    if (main) {\n      const mainWidth = Math.round(main.width);\n      const mainHeight = Math.round(main.height);\n\n      // Stop any \"twitching\" caused by very slight size changes\n      if (\n        !this.lastVideoLayoutInfo.main ||\n        Math.abs(this.lastVideoLayoutInfo.main.height - mainHeight) > 2 ||\n        Math.abs(this.lastVideoLayoutInfo.main.width - mainWidth) > 2\n      ) {\n        layoutInfo.main = {width: mainWidth, height: mainHeight};\n      }\n    }\n\n    if (content) {\n      if (this.mediaProperties.mediaDirection.receiveShare && remoteShare) {\n        const contentWidth = Math.round(content.width);\n        const contentHeight = Math.round(content.height);\n\n        // Stop any \"twitching\" caused by very slight size changes\n        if (!this.lastVideoLayoutInfo.content ||\n          Math.abs(this.lastVideoLayoutInfo.content.height - contentHeight) > 2 ||\n          Math.abs(this.lastVideoLayoutInfo.content.width - contentWidth) > 2\n        ) {\n          layoutInfo.content = {width: contentWidth, height: contentHeight};\n        }\n      }\n      else {\n        return this.rejectWithErrorLog('Meeting:index#changeVideoLayout --> unable to send renderInfo for content, you are not receiving remote share');\n      }\n    }\n\n    if (isEqual(layoutInfo, this.lastVideoLayoutInfo)) {\n      // nothing changed, no need to send any request\n      return Promise.resolve();\n    }\n    this.lastVideoLayoutInfo = cloneDeep(layoutInfo);\n\n    return this.meetingRequest\n      .changeVideoLayoutDebounced({\n        locusUrl: this.locusInfo.self.url,\n        deviceUrl: this.deviceUrl,\n        layoutType,\n        main: layoutInfo.main,\n        content: layoutInfo.content\n      })\n      .then((response) => {\n        if (response && response.body && response.body.locus) {\n          this.locusInfo.onFullLocus(response.body.locus);\n        }\n      })\n      .catch((error) => {\n        LoggerProxy.logger.error('Meeting:index#changeVideoLayout --> Error ', error);\n\n        return Promise.reject(error);\n      });\n  }\n\n  /**\n   * Sets the quality of the local video stream\n   * @param {String} level {LOW|MEDIUM|HIGH}\n   * @returns {Promise}\n   */\n  setLocalVideoQuality(level) {\n    LoggerProxy.logger.log(`Meeting:index#setLocalVideoQuality --> Setting quality to ${level}`);\n\n    if (!VIDEO_RESOLUTIONS[level]) {\n      return this.rejectWithErrorLog(`Meeting:index#setLocalVideoQuality --> ${level} not defined`);\n    }\n\n    if (!this.mediaProperties.mediaDirection.sendVideo) {\n      return this.rejectWithErrorLog('Meeting:index#setLocalVideoQuality --> unable to change video quality, sendVideo is disabled');\n    }\n\n    // If level is already the same, don't do anything\n    if (level === this.mediaProperties.localQualityLevel) {\n      LoggerProxy.logger.warn(`Meeting:index#setLocalQualityLevel --> Quality already set to ${level}`);\n\n      return Promise.resolve();\n    }\n\n    // Set the quality level in properties\n    this.mediaProperties.setLocalQualityLevel(level);\n\n    const mediaDirection = {\n      sendAudio: this.mediaProperties.mediaDirection.sendAudio,\n      sendVideo: this.mediaProperties.mediaDirection.sendVideo,\n      sendShare: this.mediaProperties.mediaDirection.sendShare\n    };\n\n    return this.getMediaStreams(mediaDirection, VIDEO_RESOLUTIONS[level])\n      .then(([localStream]) =>\n        this.updateVideo({\n          sendVideo: true,\n          receiveVideo: true,\n          stream: localStream\n        }));\n  }\n\n  /**\n   * Sets the quality level of the remote incoming media\n   * @param {String} level {LOW|MEDIUM|HIGH}\n   * @returns {Promise}\n   */\n  setRemoteQualityLevel(level) {\n    LoggerProxy.logger.log(`Meeting:index#setRemoteQualityLevel --> Setting quality to ${level}`);\n\n    if (!QUALITY_LEVELS[level]) {\n      return this.rejectWithErrorLog(`Meeting:index#setRemoteQualityLevel --> ${level} not defined`);\n    }\n\n    if (!this.mediaProperties.mediaDirection.receiveAudio && !this.mediaProperties.mediaDirection.receiveVideo) {\n      return this.rejectWithErrorLog('Meeting:index#setRemoteQualityLevel --> unable to change remote quality, receiveVideo and receiveAudio is disabled');\n    }\n\n    // If level is already the same, don't do anything\n    if (level === this.mediaProperties.remoteQualityLevel) {\n      LoggerProxy.logger.warn(`Meeting:index#setRemoteQualityLevel --> Quality already set to ${level}`);\n\n      return Promise.resolve();\n    }\n\n    // Set the quality level in properties\n    this.mediaProperties.setRemoteQualityLevel(level);\n\n    return this.updateMedia({mediaSettings: this.mediaProperties.mediaDirection});\n  }\n\n  /**\n   * Sets the quality level of all meeting media (incoming/outgoing)\n   * @param {String} level {LOW|MEDIUM|HIGH}\n   * @returns {Promise}\n   */\n  setMeetingQuality(level) {\n    LoggerProxy.logger.log(`Meeting:index#setMeetingQuality --> Setting quality to ${level}`);\n\n    if (!QUALITY_LEVELS[level]) {\n      return this.rejectWithErrorLog(`Meeting:index#setMeetingQuality --> ${level} not defined`);\n    }\n\n    const previousLevel = {\n      local: this.mediaProperties.localQualityLevel,\n      remote: this.mediaProperties.remoteQualityLevel\n    };\n\n    // If level is already the same, don't do anything\n    if (\n      level === this.mediaProperties.localQualityLevel &&\n      level === this.mediaProperties.remoteQualityLevel\n    ) {\n      LoggerProxy.logger.warn(`Meeting:index#setMeetingQuality --> Quality already set to ${level}`);\n\n      return Promise.resolve();\n    }\n\n    // Determine the direction of our current media\n    const {receiveAudio, receiveVideo, sendVideo} = this.mediaProperties.mediaDirection;\n\n    return (sendVideo ? this.setLocalVideoQuality(level) : Promise.resolve())\n      .then(() =>\n        ((receiveAudio || receiveVideo) ?\n          this.setRemoteQualityLevel(level) :\n          Promise.resolve()))\n      .catch((error) => {\n        // From troubleshooting it seems that the stream itself doesn't change the max-fs if the peer connection isn't stable\n        this.mediaProperties.setLocalQualityLevel(previousLevel.local);\n        this.mediaProperties.setRemoteQualityLevel(previousLevel.remote);\n\n        LoggerProxy.logger.error(`Meeting:index#setMeetingQuality --> ${error.message}`);\n\n        Metrics.sendBehavioralMetric(\n          BEHAVIORAL_METRICS.SET_MEETING_QUALITY_FAILURE,\n          {\n            correlation_id: this.correlationId,\n            locus_id: this.locusUrl.split('/').pop(),\n            reason: error.message,\n            stack: error.stack\n          },\n          {\n            type: error.name\n          }\n        );\n\n        return Promise.reject(error);\n      });\n  }\n\n  /**\n  * @param {Object} options parameter\n  * @param {Boolean} options.sendAudio send audio from the display share\n  * @param {Boolean} options.sendShare send video from the display share\n  * @param {Object} options.sharePreferences\n  * @param {MediaTrackConstraints} options.sharePreferences.shareConstraints constraints to apply to video\n  *   @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints}\n  * @param {Boolean} options.sharePreferences.highFrameRate if shareConstraints isn't provided, set default values based off of this boolean\n  * @returns {Promise}\n  */\n  shareScreen(options = {}) {\n    LoggerProxy.logger.log('Meeting:index#shareScreen --> Getting local share');\n\n    const shareConstraints = {\n      sendShare: true,\n      sendAudio: false,\n      ...options\n    };\n\n    return Media.getDisplayMedia(shareConstraints, this.config)\n      .then((shareStream) => this.updateShare({\n        sendShare: true,\n        receiveShare: this.mediaProperties.mediaDirection.receiveShare,\n        stream: shareStream\n      }))\n      .catch((error) => {\n        // Whenever there is a failure when trying to access a user's display\n        // report it as an Behavioral metric\n        // This gives visibility into common errors and can help\n        // with further troubleshooting\n\n        // This metrics will get erros for getDisplayMedia and share errors for now\n        // TODO: The getDisplayMedia errors need to be moved inside `media.getDisplayMedia`\n        const metricName = BEHAVIORAL_METRICS.GET_DISPLAY_MEDIA_FAILURE;\n        const data = {\n          correlation_id: this.correlationId,\n          locus_id: this.locusUrl.split('/').pop(),\n          reason: error.message,\n          stack: error.stack\n        };\n        const metadata = {\n          type: error.name\n        };\n\n        Metrics.sendBehavioralMetric(metricName, data, metadata);\n        throw new MediaError('Unable to retrieve display media stream', error);\n      });\n  }\n\n  /**\n   * Functionality for when a share is ended.\n   * @private\n   * @memberof Meeting\n   * @param {MediaStream} localShare\n   * @returns {undefined}\n   */\n  handleShareTrackEnded(localShare) {\n    if (this.wirelessShare) {\n      this.leave({reason: MEETING_REMOVED_REASON.USER_ENDED_SHARE_STREAMS});\n    }\n    else {\n      // Skip checking for a stable peerConnection\n      // to allow immediately stopping screenshare\n      this.stopShare({\n        skipSignalingCheck: true\n      })\n        .catch((error) => {\n          LoggerProxy.logger.log('Meeting:index#handleShareTrackEnded --> Error stopping share: ', error);\n        });\n    }\n\n    Trigger.trigger(\n      this,\n      {\n        file: 'meeting/index',\n        function: 'handleShareTrackEnded'\n      },\n      EVENT_TRIGGERS.MEETING_STOPPED_SHARING_LOCAL,\n      {\n        type: EVENT_TYPES.LOCAL_SHARE,\n        stream: localShare\n      }\n    );\n  }\n\n  /**\n   * Emits the 'network:quality' event\n   * 1 indicates an acceptable uplink network.\n   * 0 indicates an unacceptable uplink network based on a predefined threshold\n   * @returns {undefined}\n   * @param {Object} res - payload of emitNetworkQuality\n   * @property {string} mediaType {video|audio}\n   * @property {number} networkQualityScore - {1|0}\n   * @private\n   * @memberof Meeting\n   */\n  sendNetworkQualityEvent(res) {\n    Trigger.trigger(\n      this,\n      {\n        file: 'meeting/index',\n        function: 'addMedia'\n      },\n      EVENT_TRIGGERS.NETWORK_QUALITY,\n      {\n        networkQualityScore: res.networkQualityScore,\n        mediaType: res.mediaType\n      }\n    );\n  }\n\n  /**\n   * Handle logging the media\n   * @param {Object} audioTrack The audio track\n   * @param {Object} videoTrack The video track\n   * @private\n   * @returns {undefined}\n   */\n  handleMediaLogging({audioTrack, videoTrack}) {\n    MeetingUtil.handleVideoLogging(videoTrack);\n    MeetingUtil.handleAudioLogging(audioTrack);\n  }\n\n  /**\n   * @param {string} typeMedia 'audio' or 'video'\n   * @returns {undefined}\n   */\n  setStartSetupDelay(typeMedia) {\n    this[`startSetupDelay${typeMedia}`] = performance.now();\n    this[`endSetupDelay${typeMedia}`] = undefined;\n  }\n\n  /**\n   * @param {string} typeMedia 'audio' or 'video'\n   * @returns {undefined}\n   */\n  setEndSetupDelay(typeMedia) {\n    this[`endSetupDelay${typeMedia}`] = performance.now();\n  }\n\n  /**\n   * @param {string} typeMedia 'audio' or 'video'\n   * @returns {string} duration between start and end of setup\n   */\n  getSetupDelayDuration(typeMedia) {\n    const start = this[`startSetupDelay${typeMedia}`];\n    const end = this[`endSetupDelay${typeMedia}`];\n\n    return (start && end) ? end - start : undefined;\n  }\n\n  /**\n   * @param {string} typeMedia 'audio' or 'video'\n   * @returns {undefined}\n   */\n  setStartSendingMediaDelay(typeMedia) {\n    this[`startSendingMediaDelay${typeMedia}`] = performance.now();\n    this[`endSendingMediaDelay${typeMedia}`] = undefined;\n  }\n\n  /**\n   * @param {string} typeMedia 'audio' or 'video'\n   * @returns {undefined}\n   */\n  setEndSendingMediaDelay(typeMedia) {\n    this[`endSendingMediaDelay${typeMedia}`] = performance.now();\n  }\n\n  /**\n   * @param {string} typeMedia 'audio' or 'video'\n   * @returns {string} duration between join response and first media tx\n   */\n  getSendingMediaDelayDuration(typeMedia) {\n    const start = this[`startSendingMediaDelay${typeMedia}`];\n    const end = this[`endSendingMediaDelay${typeMedia}`];\n\n    return (start && end) ? end - start : undefined;\n  }\n\n  /**\n   *\n   * @returns {undefined}\n   */\n  setStartLocalSDPGenRemoteSDPRecvDelay() {\n    if (!this.startLocalSDPGenRemoteSDPRecvDelay) {\n      this.startLocalSDPGenRemoteSDPRecvDelay = performance.now();\n      this.endLocalSDPGenRemoteSDPRecvDelay = undefined;\n    }\n  }\n\n  /**\n   *\n   * @returns {undefined}\n   */\n  setEndLocalSDPGenRemoteSDPRecvDelay() {\n    if (!this.endLocalSDPGenRemoteSDPRecvDelay) {\n      this.endLocalSDPGenRemoteSDPRecvDelay = performance.now();\n    }\n  }\n\n  /**\n   *\n   * @returns {string} duration between local SDP generation and remote SDP reception\n   */\n  getLocalSDPGenRemoteSDPRecvDelay() {\n    const start = this.startLocalSDPGenRemoteSDPRecvDelay;\n    const end = this.endLocalSDPGenRemoteSDPRecvDelay;\n\n    if (start && end) {\n      const calculatedDelay = end - start;\n\n      return calculatedDelay > METRICS_JOIN_TIMES_MAX_DURATION ?\n        undefined :\n        calculatedDelay;\n    }\n\n    return undefined;\n  }\n\n  /**\n   *\n   * @returns {undefined}\n   */\n  setStartCallInitiateJoinReq() {\n    this.startCallInitiateJoinReq = performance.now();\n    this.endCallInitiateJoinReq = undefined;\n  }\n\n  /**\n   *\n   * @returns {undefined}\n   */\n  setEndCallInitiateJoinReq() {\n    this.endCallInitiateJoinReq = performance.now();\n  }\n\n  /**\n   *\n   * @returns {string} duration between call initiate and sending join request to locus\n   */\n  getCallInitiateJoinReq() {\n    const start = this.startCallInitiateJoinReq;\n    const end = this.endCallInitiateJoinReq;\n\n    if (start && end) {\n      const calculatedDelay = end - start;\n\n      return calculatedDelay > METRICS_JOIN_TIMES_MAX_DURATION ?\n        undefined :\n        calculatedDelay;\n    }\n\n    return undefined;\n  }\n\n  /**\n   *\n   * @returns {undefined}\n   */\n  setStartJoinReqResp() {\n    this.startJoinReqResp = performance.now();\n    this.endJoinReqResp = undefined;\n  }\n\n  /**\n   *\n   * @returns {undefined}\n   */\n  setEndJoinReqResp() {\n    this.endJoinReqResp = performance.now();\n  }\n\n  /**\n   *\n   * @returns {string} duration between sending locus join request and receiving join response\n   */\n  getJoinReqResp() {\n    const start = this.startJoinReqResp;\n    const end = this.endJoinReqResp;\n\n    if (start && end) {\n      const calculatedDelay = end - start;\n\n      return calculatedDelay > METRICS_JOIN_TIMES_MAX_DURATION ?\n        undefined :\n        calculatedDelay;\n    }\n\n    return undefined;\n  }\n\n  /**\n   *\n   * @returns {string} duration between call initiate and successful locus join (even if it is in lobby)\n   */\n  getTotalJmt() {\n    const start = this.startCallInitiateJoinReq;\n    const end = this.endJoinReqResp;\n\n    return (start && end) ? end - start : undefined;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}