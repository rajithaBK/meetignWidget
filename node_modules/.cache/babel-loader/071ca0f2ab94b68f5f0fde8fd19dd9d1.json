{"ast":null,"code":"\"use strict\";\n\nvar _Reflect$construct = require(\"@babel/runtime-corejs2/core-js/reflect/construct\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/createClass\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/getPrototypeOf\"));\n\nvar _webexCore = require(\"@webex/webex-core\");\n\nvar _loggerProxy = _interopRequireDefault(require(\"../common/logs/logger-proxy\"));\n\nvar _constants = require(\"../constants\");\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2.default)(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;\n      result = _Reflect$construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0, _possibleConstructorReturn2.default)(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false;\n  if (_Reflect$construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * @class MeetingRequest\n */\n\n\nvar MeetingRequest = /*#__PURE__*/function (_StatelessWebexPlugin) {\n  (0, _inherits2.default)(MeetingRequest, _StatelessWebexPlugin);\n\n  var _super = _createSuper(MeetingRequest);\n\n  function MeetingRequest() {\n    (0, _classCallCheck2.default)(this, MeetingRequest);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(MeetingRequest, [{\n    key: \"getActiveMeetings\",\n    value:\n    /**\n       *  get all the active meetings for the user\n       * @returns {Array} return locus array\n      */\n    function getActiveMeetings() {\n      var _this = this;\n\n      return this.request({\n        api: _constants.API.LOCUS,\n        resource: _constants.RESOURCE.LOCI\n      }).then(function (res) {\n        return _this.determineRedirections(res.body);\n      }).catch(function (error) {\n        _loggerProxy.default.logger.error(\"Meetings:request#getActiveMeetings --> failed to get locus details, \".concat(error));\n      });\n    }\n    /**\n       *  fetch geoHit for the user\n       * @returns {Promise<object>} geoHintInfo\n      */\n\n  }, {\n    key: \"fetchGeoHint\",\n    value: function fetchGeoHint() {\n      return this.webex.internal.services.fetchClientRegionInfo();\n    } // locus federation, determines and populate locus if the responseBody has remote URLs to fetch locus details\n\n    /**\n     *  Fetches indivdual locus rather then getting all at once\n     * @param {object} responseBody determine the locus and fetch them if a remoteUrl is given\n     * @returns {Promise}  returns locusObject array\n     */\n\n  }, {\n    key: \"determineRedirections\",\n    value: function determineRedirections(responseBody) {\n      var _this2 = this;\n\n      if (responseBody.remoteLocusClusterUrls && responseBody.remoteLocusClusterUrls.length) {\n        return _promise.default.all(responseBody.remoteLocusClusterUrls.map(function (url) {\n          return _this2.request({\n            method: _constants.HTTP_VERBS.GET,\n            url: url,\n            runWhitelistedDomains: true // allows auth token for whitelisted domain\n\n          }).then(function (res) {\n            responseBody.loci = responseBody.loci.concat(res.body.loci);\n            responseBody.locusUrls = responseBody.locusUrls.concat(res.body.locusUrls);\n            return _promise.default.resolve(responseBody);\n          }).catch(function (error) {\n            _loggerProxy.default.logger.error(\"Meetings:request#determineRedirections --> failed to get locus details from url: \".concat(url, \", reason: \").concat(error));\n          });\n        })).then(function () {\n          return _promise.default.resolve(responseBody);\n        });\n      }\n\n      return _promise.default.resolve(responseBody);\n    }\n  }]);\n  return MeetingRequest;\n}(_webexCore.StatelessWebexPlugin);\n\nexports.default = MeetingRequest;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAEA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AACA;AACA;;;IACqBA,c;;;;;;;;;;;;;AACnB;AACF;AACA;AACA;AACE,iCAAoB;AAAA;;AAClB,aAAO,KAAKC,OAAL,CAAa;AAClBC,WAAG,EAAEC,eAAIC,KADS;AAElBC,gBAAQ,EAAEC,oBAASC;AAFD,OAAb,EAIJC,IAJI,CAIC,UAACC,GAAD;AAAA,eAASC,KAAI,CAACC,qBAAL,CAA2BF,GAAG,CAACG,IAA/B,CAAT;AAJD,SAKJC,KALI,CAKE,UAACC,KAAD,EAAW;AAChBC,6BAAYC,MAAZD,CAAmBD,KAAnBC,+EAAgGD,KAAhG;AANG,QAAP;AAQD;AAED;AACF;AACA;AACA;;;;WACE,wBAAe;AACb,aAAO,KAAKG,KAAL,CAAWC,QAAX,CAAoBC,QAApB,CAA6BC,qBAA7B,EAAP;MAGF;;AAEA;AACF;AACA;AACA;AACA;;;;WACE,+BAAsBC,YAAtB,EAAoC;AAAA;;AAClC,UAAIA,YAAY,CAACC,sBAAbD,IAAuCA,YAAY,CAACC,sBAAbD,CAAoCE,MAA/E,EAAuF;AACrF,eAAOC,iBAAQC,GAAR,CAAYJ,YAAY,CAACC,sBAAbD,CAAoCK,GAApCL,CAAwC,UAACM,GAAD;AAAA,iBAASC,MAAI,CAAC3B,OAAL,CAAa;AAC/E4B,kBAAM,EAAEC,sBAAWC,GAD4D;AAE/EJ,eAAG,EAAHA,GAF+E;AAG/EK,iCAAqB,EAAE,IAHwD,CAGnD;;AAHmD,WAAb,EAKjExB,IALiE,CAK5D,UAACC,GAAD,EAAS;AACbY,wBAAY,CAACY,IAAbZ,GAAoBA,YAAY,CAACY,IAAbZ,CAAkBa,MAAlBb,CAAyBZ,GAAG,CAACG,IAAJH,CAASwB,IAAlCZ,CAApBA;AACAA,wBAAY,CAACc,SAAbd,GAAyBA,YAAY,CAACc,SAAbd,CAAuBa,MAAvBb,CAA8BZ,GAAG,CAACG,IAAJH,CAAS0B,SAAvCd,CAAzBA;AAEA,mBAAOG,iBAAQY,OAAR,CAAgBf,YAAhB,CAAP;AATgE,aAWjER,KAXiE,CAW3D,UAACC,KAAD,EAAW;AAChBC,iCAAYC,MAAZD,CAAmBD,KAAnBC,4FAA6GY,GAA7G,uBAA6Hb,KAA7H;AAZgE,YAAT;AAAxC,UAAZ,EAcJN,IAdI,CAcC;AAAA,iBAAMgB,iBAAQY,OAAR,CAAgBf,YAAhB,CAAN;AAdD,UAAP;AAeD;;AAED,aAAOG,iBAAQY,OAAR,CAAgBf,YAAhB,CAAP;AACD;;;EAnDyCgB,+B","names":["MeetingRequest","request","api","API","LOCUS","resource","RESOURCE","LOCI","then","res","_this","determineRedirections","body","catch","error","LoggerProxy","logger","webex","internal","services","fetchClientRegionInfo","responseBody","remoteLocusClusterUrls","length","_promise","all","map","url","_this2","method","HTTP_VERBS","GET","runWhitelistedDomains","loci","concat","locusUrls","resolve","StatelessWebexPlugin"],"sources":["request.js"],"sourcesContent":["import {StatelessWebexPlugin} from '@webex/webex-core';\n\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport {\n  HTTP_VERBS,\n  API,\n  RESOURCE\n} from '../constants';\n\n/**\n * @class MeetingRequest\n */\nexport default class MeetingRequest extends StatelessWebexPlugin {\n  /**\n     *  get all the active meetings for the user\n     * @returns {Array} return locus array\n    */\n  getActiveMeetings() {\n    return this.request({\n      api: API.LOCUS,\n      resource: RESOURCE.LOCI\n    })\n      .then((res) => this.determineRedirections(res.body))\n      .catch((error) => {\n        LoggerProxy.logger.error(`Meetings:request#getActiveMeetings --> failed to get locus details, ${error}`);\n      });\n  }\n\n  /**\n     *  fetch geoHit for the user\n     * @returns {Promise<object>} geoHintInfo\n    */\n  fetchGeoHint() {\n    return this.webex.internal.services.fetchClientRegionInfo();\n  }\n\n  // locus federation, determines and populate locus if the responseBody has remote URLs to fetch locus details\n\n  /**\n   *  Fetches indivdual locus rather then getting all at once\n   * @param {object} responseBody determine the locus and fetch them if a remoteUrl is given\n   * @returns {Promise}  returns locusObject array\n   */\n  determineRedirections(responseBody) {\n    if (responseBody.remoteLocusClusterUrls && responseBody.remoteLocusClusterUrls.length) {\n      return Promise.all(responseBody.remoteLocusClusterUrls.map((url) => this.request({\n        method: HTTP_VERBS.GET,\n        url,\n        runWhitelistedDomains: true // allows auth token for whitelisted domain\n      })\n        .then((res) => {\n          responseBody.loci = responseBody.loci.concat(res.body.loci);\n          responseBody.locusUrls = responseBody.locusUrls.concat(res.body.locusUrls);\n\n          return Promise.resolve(responseBody);\n        })\n        .catch((error) => {\n          LoggerProxy.logger.error(`Meetings:request#determineRedirections --> failed to get locus details from url: ${url}, reason: ${error}`);\n        })))\n        .then(() => Promise.resolve(responseBody));\n    }\n\n    return Promise.resolve(responseBody);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}