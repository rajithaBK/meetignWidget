import { throwError, combineLatest, Observable, ReplaySubject, defer, from, fromEvent, concat, Subject, BehaviorSubject, of, merge } from 'rxjs';
import { startWith, map, tap, catchError, filter, flatMap, finalize, publishReplay, refCount, distinctUntilChanged, concatMap, takeWhile, mergeMap } from 'rxjs/operators';
import { format, transports, createLogger } from 'winston';
import { deconstructHydraId, SDK_EVENT, constructHydraId } from '@webex/common';

// dummy implementation of getTracks() for non-supporting browsers,
// to avoid checking for its existence before calling it
if (!MediaStream.prototype.getTracks) {
  MediaStream.prototype.getTracks = () => [];
}

class t {
  constructor(e) {
    this.datasource = e;
  }

  connect() {
    return Promise.reject(new Error("connect() must be defined in WebexAdapter"));
  }

  disconnect() {
    return Promise.reject(new Error("disconnect() must be defined in WebexAdapter"));
  }

}

class r extends t {
  getActivity(t) {
    return throwError(new Error("getActivity(ID) must be defined in ActivitiesAdapter"));
  }

}

const i = {
  ACTIVE: "active",
  INACTIVE: "inactive",
  DISABLED: "disabled"
},
      s = {
  NOT_JOINED: "NOT_JOINED",
  LOBBY: "LOBBY",
  JOINED: "JOINED",
  LEFT: "LEFT"
};

class d extends t {
  constructor(e) {
    super(e), this.meetingControls = {};
  }

  createMeeting(t) {
    return throwError(new Error("createMeeting(destination) must be defined in MeetingsAdapter"));
  }

  incomingMeeting(t) {
    return throwError(new Error("incomingMeeting(destination) must be defined in MeetingsAdapter"));
  }

  getMeeting(t) {
    return throwError(new Error("getMeeting(ID) must be defined in MeetingsAdapter"));
  }

  joinMeeting(e) {
    throw new Error("joinMeeting(ID) must be defined in MeetingsAdapter");
  }

  leaveMeeting(e) {
    throw new Error("leaveMeeting(ID) must be defined in MeetingsAdapter");
  }

  supportedControls() {
    return throwError(new Error("supportedControls() must be defined in MeetingsAdapter"));
  }

  clearPasswordRequiredFlag(e) {
    throw new Error("clearPasswordRequiredFlag(ID) must be defined in MeetingsAdapter");
  }

  clearInvalidPasswordFlag(e) {
    throw new Error("clearInvalidPasswordFlag(ID) must be defined in MeetingsAdapter");
  }

}

const a = {
  ROOM: "room",
  MEETING: "meeting"
};

class E extends t {
  getMembersFromDestination(t, r) {
    return throwError(new Error("getMembersFromDestination(destinationID, destinationType) must be defined in MembershipsAdapter"));
  }

}

class g extends t {
  getOrg(t) {
    return throwError(new Error("getOrg(ID) must be defined in OrganizationsAdapter"));
  }

}

const c = {
  ACTIVE: "active",
  BOT: "bot",
  CALL: "call",
  DO_NOT_DISTURB: "dnd",
  INACTIVE: "inactive",
  MEETING: "meeting",
  OUT_OF_OFFICE: "ooo",
  PRESENTING: "presenting",
  SELF: "self",
  TYPING: "typing"
};

class I extends t {
  getMe() {
    return throwError(new Error("getMe() must be defined in PeopleAdapter"));
  }

  getPerson(t) {
    return throwError(new Error("getPerson(ID) must be defined in PeopleAdapter"));
  }

}

class u extends t {
  getRoom(t) {
    return throwError(new Error("getRoom(ID) must be defined in RoomsAdapter"));
  }

  getRoomActivities(t) {
    return throwError(new Error("getRoomActivities(ID) must be defined in RoomsAdapter"));
  }

  getPreviousRoomActivities(t) {
    return throwError(new Error("getPreviousRoomActivities(ID) must be defined in RoomsAdapter"));
  }

  hasMoreActivities(e) {
    throw new Error("hasMoreActivities(ID) must be defined in RoomsAdapter");
  }

}

var global$3 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};

if (typeof global$3.setTimeout === 'function') ;

if (typeof global$3.clearTimeout === 'function') ;

var performance = global$3.performance || {};

performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function () {
  return new Date().getTime();
}; // generate timestamp or delta

/**
 * Custom rxjs operator for chaining dependent observables.
 * Usage:
 ```js
  obs.pipe(
    chainWith((lastMessage) => createDependentObservable(lastMessage),
  );
  ```
 *
 * @param {function(lastMessage): Observable} createDependentObservable  Function that is passed the last message emitted by the source observable and returns a new observable
 * @returns {Observable} observable
 */

function chainWith(createDependentObservable) {
  return source => new Observable(subscriber => {
    let lastValue;
    let subscription;
    subscription = source.subscribe(value => {
      subscriber.next(value);
      lastValue = value;
    }, error => subscriber.error(error), () => {
      subscription = createDependentObservable(lastValue).subscribe(value => subscriber.next(value), error => subscriber.error(error), () => subscriber.complete());
    });
    return () => {
      if (subscription) {
        subscription.unsubscribe();
      }
    };
  });
}
/**
 * Custom rxjs operator that works like combineLatest, but emits even if some of the source observables haven't emitted yet.
 * Usage:
 ```js
  combineLatestImmediate(obs1, obs2, ...);
  ```
 *
 * @param {ObservableInput} [observables] An array of input Observables to combine with each other.
 * @returns {Observable} Observable that emits arrays containing the last emitted value from each of the observables defined above.
 */

function combineLatestImmediate() {
  for (var _len = arguments.length, observables = new Array(_len), _key = 0; _key < _len; _key++) {
    observables[_key] = arguments[_key];
  }

  return combineLatest(observables.map(obs => obs.pipe(startWith(undefined))));
}
/**
 * Helper function for deep merge on objects.
 *
 * @param {object} dest - The destination object.
 * @param {object} src - The source object.
 */

function deepMerge(dest, src) {
  const result = dest;

  for (const [key, val] of Object.entries(src || {})) {
    if (val && val.constructor === Object) {
      deepMerge(result[key], val);
    } else {
      result[key] = val;
    }
  }
}
/**
 * Safe JSON stringifier that:
 * - replaces circular references with the text [circular-reference]
 * - catches any JSON.stringify error and returns [error-stringifying:<ERROR-MESSAGE>]
 *
 * @param {any} data  Data to be stringified
 * @param {function} [replacer]  JSON.stringify() replacer parameter
 * @param {string|number} [space]  JSON.stringify() space parameter
 * @returns {string} The string result
 */

function safeJsonStringify(data, replacer, space) {
  const seen = new WeakSet();
  let str;

  try {
    str = JSON.stringify(data, (key, value) => {
      let replaced = replacer ? replacer(key, value) : value;

      if (typeof replaced === 'object' && replaced !== null) {
        if (seen.has(replaced)) {
          replaced = '[circular-reference]';
        } else {
          seen.add(replaced);
        }
      }

      return replaced;
    }, space);
  } catch (error) {
    str = `[error-stringifying:${error.message}]`;
  }

  return str;
}

const isSpeakerSupported = !!document.createElement('audio').setSinkId;

const logFormat = format.printf(_ref => {
  let {
    timestamp,
    level,
    resourceType,
    resourceID,
    action,
    message,
    error
  } = _ref;
  let msgString = message;

  if (Array.isArray(message)) {
    msgString = message.map(item => typeof item === 'string' && item || safeJsonStringify(item, (key, value) => value instanceof MediaStream && `MediaStream([${value.getTracks().map(track => track.kind)}])` || value, 2)).join(' ');
  }

  return `${timestamp} ${level} ${resourceType} ${resourceID} ${action} ${msgString} ${error ? ` ${error.stack || error}` : ''}`;
});
const activeTransports = [];

{
  activeTransports.push(new transports.Console({
    format: format.combine(format.timestamp({
      format: 'YYYY-MM-DD HH:mm:ss'
    }), format.colorize(), format.simple(), logFormat)
  }));
}

const winstonLogger = createLogger({
  level: 'error',
  transports: activeTransports
}); // create a custom logger and export it

const logger = {
  setLevel: level => {
    winstonLogger.level = level;
  }
};

for (const level of ['info', 'warn', 'error', 'debug']) {
  logger[level] = (resourceType, resourceID, action, message, error) => winstonLogger[level]({
    resourceType,
    resourceID,
    action,
    message,
    error
  });
}

if (typeof window !== 'undefined') {
  window.webexSDKAdapterSetLogLevel = level => logger.setLevel(level);
}

/**
 * An activity a person performs in Webex.
 *
 * @external Activity
 * @see {@link https://github.com/webex/component-adapter-interfaces/blob/master/src/ActivitiesAdapter.js#L6}
 */

/**
 * The `ActivitiesSDKAdapter` is an implementation of the `ActivitiesAdapter` interface.
 * This implementation utilizes the Webex JS SDK as its source of activity data.
 *
 * @see {@link ActivitiesJSON}
 * @implements {ActivitiesAdapter}
 */

/* eslint-disable no-useless-constructor */

class ActivitiesSDKAdapter extends r {
  constructor(datasource) {
    super(datasource);
    this.activityObservables = {};
  }
  /**
   * Loads activity data from Webex and returns a promise that resolves to an Activity object
   *
   * @param {string} activityID  Id of the activity for which to fetch data
   * @returns {Promise.<Activity>} Information about the activity of the given ID
   *
   * @private
   */


  fetchActivity(activityID) {
    logger.debug('ACTIVITY', activityID, 'fetchActivity()', ['called with', {
      activityID
    }]);
    return this.datasource.messages.get(activityID);
  }
  /**
   * Returns an observable that emits activity data of the given ID.
   *
   * @param {string} ID  Id of activity to get
   * @returns {external:Observable.<Activity>} Observable stream that emits activity data
   */


  getActivity(ID) {
    logger.debug('ACTIVITY', ID, 'getActivity()', ['called with', {
      ID
    }]);

    if (!(ID in this.activityObservables)) {
      // use ReplaySubject cause we don't need to set an initial value
      this.activityObservables[ID] = new ReplaySubject(1);
      defer(() => this.fetchActivity(ID)).pipe(map(_ref => {
        let {
          id,
          roomId,
          text,
          personId,
          attachments,
          created
        } = _ref;
        return {
          ID: id,
          roomID: roomId,
          text,
          personID: personId,
          attachments,
          card: attachments && attachments[0] && attachments[0].contentType === 'application/vnd.microsoft.card.adaptive' ? attachments[0].content : undefined,
          created
        };
      })).subscribe(activity => {
        logger.debug('ACTIVITY', ID, 'getActivity()', ['emitting activity object', activity]);
        this.activityObservables[ID].next(activity);
      }, error => {
        logger.error('ACTIVITY', ID, 'getActivity()', 'Error fetching activity', error);
        this.activityObservables[ID].error(new Error(`Could not find activity with ID "${ID}"`));
      });
    }

    return this.activityObservables[ID];
  }
  /**
   * Posts an attachment action, returns an observable that emits the created action
   *
   * @param {string} activityID  ID of the activity corresponding to this submit action
   * @param {object} inputs  The message content
   * @returns {Observable.<object>} Observable stream that emits data of the newly created action
   */


  postAction(activityID, inputs) {
    logger.debug('ATTACHMENT-ACTION', undefined, 'postAction()', ['called with', {
      activityID,
      inputs
    }]);
    const action$ = from(this.datasource.attachmentActions.create({
      type: 'submit',
      messageId: activityID,
      inputs
    })).pipe(map(action => ({
      actionID: action.id,
      activityID: action.messageId,
      inputs: action.inputs,
      roomID: action.roomId,
      personID: action.personId,
      type: action.type,
      created: action.created
    })), tap(action => {
      logger.debug('ATTACHMENT-ACTION', action.actionID, 'postAction()', ['emitting posted attachment action', action]);
    }), catchError(err => {
      logger.error('ATTACHMENT-ACTION', undefined, 'postAction()', `Unable to create an attachment for activity with id "${activityID}"`, err);
      throw err;
    }));
    return action$;
  }
  /**
   * Posts an activity and returns an observable to the new activity data
   *
   * @param {object} activity  The activity to post
   * @returns {Observable.<Activity>} Observable that emits the posted activity (including id)
   */


  postActivity(activity) {
    const activity$ = from(this.datasource.messages.create({
      roomId: activity.roomID,
      text: activity.text,
      attachments: activity.card ? [{
        contentType: 'application/vnd.microsoft.card.adaptive',
        content: activity.card
      }] : activity.attachments
    })).pipe(map(_ref2 => {
      let {
        id,
        roomId,
        text,
        personId,
        attachments,
        created
      } = _ref2;
      return {
        ID: id,
        roomID: roomId,
        text,
        personID: personId,
        attachments,
        created
      };
    }), catchError(err => {
      logger.error('ACTIVITY', undefined, 'postActivity()', ['Unable to post activity', activity], err);
      throw err;
    }));
    return activity$;
  }

}

/**
 * A virtual space where people can collaborate in Webex.
 *
 * @external Room
 * @see {@link https://github.com/webex/component-adapter-interfaces/blob/master/src/RoomsAdapter.js#L7}
 */

const ROOM_UPDATED_EVENT = 'updated';

const sortByPublished = arr => arr.sort((a, b) => new Date(b.published) - new Date(a.published)); // TODO: Need to remove this once we figure out why we need to pre-cache conversations


let FETCHED_CONVERSATIONS = false;
/**
 * The `RoomsSDKAdapter` is an implementation of the `RoomsAdapter` interface.
 * This adapter utilizes the Webex JS SDK to fetch data about a room.
 *
 * @implements {RoomsAdapter}
 */

class RoomsSDKAdapter extends u {
  constructor(datasource) {
    super(datasource);
    this.getRoomObservables = {};
    this.getRoomActivitiesCache = {};
    this.listenerCount = 0;
    this.activityLimit = 50;
    this.activitiesObservableCache = new Map();
    this.roomActivities = new Map();
  }
  /**
   * Fetches the room data from the sdk and returns in the shape required by adapter.
   *
   * @private
   * @param {string} ID ID of the room for which to fetch data
   * @returns {Room} Information about the room of the given ID
   */


  async fetchRoom(ID) {
    const {
      id,
      title,
      type,
      lastActivity
    } = await this.datasource.rooms.get(ID);
    return {
      ID: id,
      title,
      type,
      lastActivity
    };
  }
  /**
   * Tells the SDK to start listening to room events and tracks the amount of calls.
   *
   * Note: Since the SDK listens to ALL room events, this function only
   * calls the SDK's `rooms.listen` function on the first room to listen.
   * Repeated calls to `rooms.listen` are not needed afterwards.
   *
   * @private
   */


  startListeningToRoomUpdates() {
    if (this.listenerCount === 0) {
      // Tell the sdk to start listening to room changes
      this.datasource.rooms.listen();
    }

    this.listenerCount += 1;
  }
  /**
   * Tells the SDK to stop listening to room events.
   *
   * Note: Since the SDK listens to ALL room events, this function only
   * calls the SDK's `rooms.stopListening` function once all of the listeners are done.
   * If `rooms.stopListening` is called early, existing subscribers won't get any updates.
   *
   * @private
   */


  stopListeningToRoomUpdates() {
    this.listenerCount -= 1;

    if (this.listenerCount <= 0) {
      // Once all listeners are done, stop listening
      this.datasource.rooms.stopListening();
    }
  }
  /**
   * Returns an observable that emits room data of the given ID.
   *
   * @param {string} ID ID of room to get
   * @returns {external:Observable.<Room>} Observable stream that emits room data of the given ID
   */


  getRoom(ID) {
    logger.debug('ROOM', ID, 'getRoom()', ['called with', {
      ID
    }]);

    if (!(ID in this.getRoomObservables)) {
      this.startListeningToRoomUpdates();
      const room$ = from(this.fetchRoom(ID)); // subscribes to room update events emitted via websocket and emits the updated room object.

      const roomUpdate$ = fromEvent(this.datasource.rooms, ROOM_UPDATED_EVENT).pipe( // Is the room change event for our subscribed room?
      filter(event => event.data.id === ID), // Event data doesn't have the room data in it, so we need to fetch manually
      flatMap(() => from(this.fetchRoom(ID)))); // The observable flow for fetching room data, then listening for websocket events about room changes.

      const getRoom$ = concat( // Fetch Our Room Data
      room$, roomUpdate$).pipe(tap(room => logger.debug('ROOM', ID, 'getRoom()', ['emitting room object', room])), finalize(() => {
        // Called once all subscriptions to `ID` are done.
        this.stopListeningToRoomUpdates();
        delete this.getRoomObservables[ID];
      })); // Convert to a multicast observable

      this.getRoomObservables[ID] = getRoom$.pipe(publishReplay(1), refCount());
    }

    return this.getRoomObservables[ID];
  }
  /**
   * Returns an array of IDs of the most recent activities in a conversation up to the specified limit.
   *
   * @param {string} ID ID for the room
   * @param {string} earliestActivityDate  Get all child activities before this date
   * @returns {Promise} Resolves with array of activities
   * @private
   */


  async fetchActivities(ID, earliestActivityDate) {
    const {
      activityLimit
    } = this;
    const conversationId = deconstructHydraId(ID).id;
    logger.debug('ROOM', ID, 'fetchActivities()', ['called with', {
      earliestActivityDate,
      activityLimit
    }]);

    if (!FETCHED_CONVERSATIONS) {
      await this.datasource.internal.conversation.list();
      FETCHED_CONVERSATIONS = true;
    }

    return this.datasource.internal.conversation.listActivities({
      conversationId,
      limit: activityLimit + 1,
      // Fetch one extra activity to determine if there are more activities to fetch later
      lastActivityFirst: true,
      maxDate: earliestActivityDate === null ? undefined : earliestActivityDate
    });
  }
  /**
   * Returns `true` if there are more activities to load from the room of the given ID.
   * Otherwise, it returns `false`.
   *
   * @param {string} ID ID of the room for which to verify activities.
   * @returns {boolean} `true` if room has more activities to load, `false` otherwise
   */


  hasMoreActivities(ID) {
    const pastActivities$Cache = this.activitiesObservableCache.get(ID);
    const {
      hasMore = true
    } = this.roomActivities.get(ID);

    if (!hasMore) {
      pastActivities$Cache.complete();
    } else {
      this.fetchPastActivities(ID);
    }

    return hasMore;
  }
  /**
   * Fetches past activities and returns array of (id, published) objects. Performs side effects
   *
   * @param {string} ID The id of the room
   * @returns null
   */


  fetchPastActivities(ID) {
    const roomActivity = this.roomActivities.get(ID);
    const {
      earliestActivityDate
    } = roomActivity;
    const room$ = this.activitiesObservableCache.get(ID);
    logger.debug('ROOM', ID, 'fetchPastActivities()', ['called with', {
      earliestActivityDate
    }]);

    if (!ID) {
      logger.error('ROOM', ID, 'fetchPastActivities()', ['Must provide room ID']);
      room$.error(new Error('fetchPastActivities - Must provide room ID'));
    }

    from(this.fetchActivities(ID, earliestActivityDate)).subscribe(data => {
      if (!data) {
        return room$.complete();
      }

      roomActivity.hasMore = data.length >= this.activityLimit + 1;
      const {
        published
      } = data.shift();
      const activityIds = sortByPublished(data).map(activity => {
        const {
          id
        } = activity;
        roomActivity.activities.set(id, activity);
        return [id, activity.published];
      });
      roomActivity.earliestActivityDate = published;
      roomActivity.activityIds.set(published, activityIds.length);
      this.roomActivities.set(ID, roomActivity);
      return room$.next(activityIds);
    });
  }
  /**
   * Returns an observable that emits an array of the next chunk of previous
   * activity data of the given roomID. If `hasMoreActivities` returns false,
   * the observable will complete.
   * **Previous activity data must be sorted newest-to-oldest.**
   *
   * @param {string} ID  ID of the room for which to get activities.
   * @param {number} activityLimit The maximum number of activities to return
   * @returns {external:Observable.<Room>} Observable stream that emits activity data
   */


  getPreviousActivities(ID) {
    let activityLimit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;
    this.activityLimit = activityLimit;
    const pastActivities$Cache = this.activitiesObservableCache.get(ID) || new Subject();

    if (!ID) {
      logger.error('ROOM', ID, 'getPreviousActivities()', ['Must provide room ID']);
      return throwError(new Error('getPreviousActivities - Must provide room ID'));
    }

    if (!this.roomActivities.has(ID)) {
      this.roomActivities.set(ID, {
        earliestActivityDate: null,
        activities: new Map(),
        activityIds: new Map()
      });
    }

    this.activitiesObservableCache.set(ID, pastActivities$Cache);
    return pastActivities$Cache;
  }
  /**
   * Returns an observable that emits current and future activities from the specified room.
   *
   * @param {string} ID ID of room to get
   * @returns {Observable.<Activity>} Observable stream that emits current and future activities from the specified room
   */


  getRoomActivities(ID) {
    logger.debug('ROOM', ID, 'getRoomActivities()', ['called with', {
      ID
    }]);

    if (!(ID in this.getRoomActivitiesCache)) {
      const getRoomActivities$ = new BehaviorSubject({});
      this.datasource.internal.mercury.on('event:conversation.activity', sdkActivity => {
        const {
          id: UUID
        } = deconstructHydraId(ID);

        if (sdkActivity.target && sdkActivity.target.id === UUID) {
          logger.debug('ROOM', ID, 'getRoomActivities()', ['received "event:conversation.activity" event', {
            sdkActivity
          }]);
          const activity = {
            ID: sdkActivity.id,
            roomID: sdkActivity.target.id,
            content: sdkActivity.object,
            contentType: sdkActivity.object.objectType,
            personID: sdkActivity.actor.id,
            displayAuthor: false,
            created: sdkActivity.published
          };
          getRoomActivities$.next(activity);
          logger.info('ROOM', ID, 'getRoomActivities()', ['emitting activity object', {
            activity
          }]);
        }
      });
      this.getRoomActivitiesCache[ID] = getRoomActivities$;
    }

    return this.getRoomActivitiesCache[ID];
  }

}

/**
 * A Webex user.
 *
 * @external Person
 * @see {@link https://github.com/webex/component-adapter-interfaces/blob/master/src/PeopleAdapter.js#L6}
 */

const USER_PRESENCE_UPDATE_EVENT = 'event:apheleia.subscription_update';
/**
 * Returns a PersonStatus enum key from the given value.
 * If status does not match an enum key, it returns null.
 *
 * @private
 * @param {string} status Person status from Apheleia service.
 * @returns {string} PersonStatus
 */

function getStatus(status) {
  const personStatus = Object.keys(c).find(key => c[key] === status);
  return personStatus === undefined ? null : personStatus;
}
/**
 * The `PeopleSDKAdapter` is an implementation of the `PeopleAdapter` interface.
 * This adapter utilizes the Webex JS SDK to fetch data about a person.
 *
 * @implements {PeopleAdapter}
 */


class PeopleSDKAdapter extends I {
  constructor(datasource) {
    super(datasource);
    this.getPersonObservables = {};
  }
  /**
   * Fetches the person data from the sdk and returns in the shape required by adapter.
   *
   * @private
   * @param {string} ID ID of the person for which to fetch data
   * @returns {Person} Info about the person of the given ID
   */


  async fetchPerson(ID) {
    const {
      id,
      emails,
      displayName,
      firstName,
      lastName,
      avatar,
      orgId
    } = await this.datasource.people.get(ID);
    logger.debug('PEOPLE', ID, 'fetchPerson()', ['called with', {
      ID
    }]);
    return {
      ID: id,
      emails,
      displayName,
      firstName,
      lastName,
      avatar,
      orgID: orgId
    };
  }
  /**
   * Returns an observable that emits person data of the access token bearer.
   * The observable will emit once and then complete.
   *
   * @returns {external:Observable.<Person>} Observable stream that emits person data of the current user
   */


  getMe() {
    logger.debug('PEOPLE', undefined, 'getMe()', 'called'); // Get person data of the current access token bearer

    return defer(() => this.fetchPerson('me')).pipe( // Get person status information from presence plug-in
    flatMap(person => defer(() => this.datasource.internal.presence.get([person.id])).pipe( // When SDK throws error, don't set a status
    catchError(() => of({
      status: null
    })), // Combine person data and presence data to send back
    map(_ref => {
      let {
        status
      } = _ref;
      return { ...person,
        status: getStatus(status)
      };
    }))));
  }
  /**
   * Returns an observable that emits person data of the given ID.
   *
   * @param {string} ID ID of person to get
   * @returns {external:Observable.<Person>} Observable stream that emits person data of the given ID
   */


  getPerson(ID) {
    logger.debug('PEOPLE', ID, 'getPerson()', ['called with', {
      ID
    }]);

    if (!(ID in this.getPersonObservables)) {
      const personUUID = deconstructHydraId(ID).id;
      const person$ = defer(() => this.fetchPerson(ID)); // Subscribe to 'Apheleia' internal service to listen for status changes
      // Update the Person object with status response from the subscription

      const personWithStatus$ = defer(() => this.datasource.internal.presence.subscribe(personUUID)).pipe(map(data => data.responses[0].status.status), // This returns only the status data from subscription
      catchError(() => of(null)), // If subscription fails, don't set a status
      flatMap(status => person$.pipe(map(person => ({ ...person,
        status: getStatus(status)
      }))))); // Listen for status changes for the given person ID after subscription to service

      const statusUpdate$ = fromEvent(this.datasource.internal.mercury, USER_PRESENCE_UPDATE_EVENT).pipe(tap(() => {
        logger.debug('PEOPLE', ID, 'getPerson', ['received', USER_PRESENCE_UPDATE_EVENT, 'event']);
      }), filter(event => event.data.subject === personUUID), map(event => getStatus(event.data.status))); // Update the person status after each change emitted from the event

      const personUpdate$ = person$.pipe(flatMap(person => statusUpdate$.pipe(map(status => ({ ...person,
        status
      })))), tap(person => {
        logger.debug('PEOPLE', ID, 'getPerson()', ['person update', {
          person
        }]);
      })); // Emit initial person data on the first run and send updates after each status change

      const getPerson$ = concat(personWithStatus$, personUpdate$).pipe(tap(person => {
        logger.debug('PEOPLE', ID, 'getPerson()', ['emit initial person', {
          person
        }]);
      }), finalize(async () => {
        try {
          logger.debug('PEOPLE', ID, 'getPerson()', ['unsubscribing from internal service', {
            personUUID
          }]); // Unsubscribe from `Apheleia` internal service when there are no more subscriptions

          await this.datasource.internal.presence.unsubscribe(personUUID);
        } catch (error) {
          // Don't do anything when unsubscribing fails
          // Trying to remove a subscription fails when the user has presence turned off
          logger.warn('Unsubscribing failed, user has presence turned off');
        }

        delete this.getPersonObservables[ID];
      })); // Store observable for future subscriptions

      this.getPersonObservables[ID] = getPerson$.pipe(publishReplay(1), refCount());
    }

    return this.getPersonObservables[ID];
  }

}

class MeetingControl {
  /**
   * Creates a new instance of the MeetingControl.
   *
   * @param {object} adapter  Meeting adapter object
   * @param {string} controlID  The id of the control
   */
  constructor(adapter, controlID) {
    this.adapter = adapter;
    this.ID = controlID;
  }

}

/**
 * Display options of a meeting control.
 *
 * @external MeetingControlDisplay
 * @see {@link https://github.com/webex/component-adapter-interfaces/blob/master/src/MeetingsAdapter.js#L58}
 */

class AudioControl extends MeetingControl {
  /**
   * Calls the adapter handleLocalAudio() method
   *
   * @private
   * @param {string} meetingID  ID of the meeting to mute audio
   */
  action(meetingID) {
    logger.debug('MEETING', meetingID, 'AudioControl::action()', ['called with', {
      meetingID
    }]);
    return this.adapter.handleLocalAudio(meetingID);
  }
  /**
   * Returns an observable that emits the display data of a mute meeting audio control.
   *
   * @private
   * @param {string} meetingID  ID of the meeting to mute audio
   * @returns {Observable.<MeetingControlDisplay>} Observable stream that emits display data of the audio control
   */


  display(meetingID) {
    logger.debug('MEETING', meetingID, 'AudioControl::display()', ['called with', {
      meetingID
    }]);
    const common = {
      ID: this.ID,
      type: 'BUTTON'
    };
    const STATES = {
      muted: {
        icon: 'microphone-muted',
        tooltip: 'Unmute audio',
        state: i.ACTIVE,
        text: 'Unmute'
      },
      unmuted: {
        icon: 'microphone',
        tooltip: 'Mute audio',
        state: i.INACTIVE,
        text: 'Mute'
      },
      muting: {
        icon: 'microphone',
        tooltip: 'Muting audio',
        state: i.DISABLED,
        text: 'Muting...'
      },
      unmuting: {
        icon: 'microphone-muted',
        tooltip: 'Unmuting audio',
        state: i.DISABLED,
        text: 'Unmuting...'
      },
      noMicrophone: {
        icon: 'microphone-muted',
        tooltip: 'No microphone available',
        state: i.DISABLED,
        text: 'No microphone'
      }
    };
    return this.adapter.getMeeting(meetingID).pipe(map(_ref => {
      let {
        localAudio: {
          stream,
          muting
        },
        disabledLocalAudio
      } = _ref;
      return muting === true && STATES.muting || muting === false && STATES.unmuting || stream && STATES.unmuted || disabledLocalAudio && STATES.muted || STATES.noMicrophone;
    }), distinctUntilChanged(), map(state => ({ ...common,
      ...state
    })), tap(display => logger.debug('MEETING', meetingID, 'AudioControl::display()', ['emitting', display])));
  }

}

/**
 * Display options of a meeting control.
 *
 * @external MeetingControlDisplay
 * @see {@link https://github.com/webex/component-adapter-interfaces/blob/master/src/MeetingsAdapter.js#L58}
 */

class ExitControl extends MeetingControl {
  /**
   * Calls the adapter leaveMeeting method.
   *
   * @param {string} meetingID  Id of the meeting to leave from
   */
  async action(meetingID) {
    logger.debug('MEETING', meetingID, 'ExitControl::action()', ['called with', {
      meetingID
    }]);
    await this.adapter.leaveMeeting(meetingID);
  }
  /**
   * Returns and observable that emits the display data of the control.
   *
   * @param meetingID
   * @returns {Observable.<MeetingControlDisplay>} Observable that emits display of the exit control
   */
  // eslint-disable-next-line class-methods-use-this


  display(meetingID) {
    logger.debug('MEETING', meetingID, 'ExitControl::display()', 'called');
    return of({
      ID: this.ID,
      type: 'CANCEL',
      icon: 'cancel',
      tooltip: 'Leave meeting'
    }).pipe(tap(display => logger.debug('MEETING', meetingID, 'ExitControl::display()', ['emitting', display])));
  }

}

/**
 * Display options of a meeting control.
 *
 * @external MeetingControlDisplay
 * @see {@link https://github.com/webex/component-adapter-interfaces/blob/master/src/MeetingsAdapter.js#L58}
 */

class JoinControl extends MeetingControl {
  /**
   * Calls the adapter joinMeeting method.
   *
   * @param {string} meetingID  Id of the meeting to join
   */
  async action(meetingID) {
    logger.debug('MEETING', meetingID, 'JoinControl::action()', ['called with', {
      meetingID
    }]);
    await this.adapter.joinMeeting(meetingID);
  }
  /**
   * Returns an observable that emits the display data of the control.
   *
   * @returns {Observable.<MeetingControlDisplay>} Observable that emits display of the join control
   */
  // eslint-disable-next-line class-methods-use-this


  display(meetingID) {
    logger.debug('MEETING', meetingID, 'JoinControl::display()', ['called with', {
      meetingID
    }]);
    return this.adapter.getMeeting(meetingID).pipe(map(meeting => {
      const hint = (meeting.localAudio.stream ? 'Unmuted, ' : 'Muted, ') + (meeting.localVideo.stream ? 'video on' : 'video off');
      const state = meeting.state === 'NOT_JOINED' ? i.ACTIVE : i.DISABLED;
      return {
        hint,
        state
      };
    }), distinctUntilChanged((prev, curr) => prev.hint === curr.hint && prev.state === curr.state), map(_ref => {
      let {
        hint,
        state
      } = _ref;
      return {
        ID: this.ID,
        type: 'JOIN',
        text: 'Join meeting',
        tooltip: 'Join meeting',
        hint,
        state
      };
    }), tap(display => logger.debug('MEETING', meetingID, 'JoinControl::display()', ['emitting', display])));
  }

}

/**
 * Display options of a meeting control.
 *
 * @external MeetingControlDisplay
 * @see {@link https://github.com/webex/component-adapter-interfaces/blob/master/src/MeetingsAdapter.js#L58}
 */

class RosterControl extends MeetingControl {
  /**
   * Attempts to toggle roster to the given meeting ID.
   * A roster toggle event is dispatched.
   *
   * @param {string} meetingID  Id of the meeting to toggle roster
   */
  async action(meetingID) {
    logger.debug('MEETING', meetingID, 'RosterControl::action()', ['called with', {
      meetingID
    }]);
    await this.adapter.toggleRoster(meetingID);
  }
  /**
   * Returns an observable that emits the display data of a roster control.
   *
   * @param {string} meetingID  Id of the meeting to toggle roster
   * @returns {Observable.<MeetingControlDisplay>} Observable stream that emits display data of the roster control
   */


  display(meetingID) {
    logger.debug('MEETING', meetingID, 'RosterControl::display()', ['called with', {
      meetingID
    }]);
    const active = {
      ID: this.ID,
      type: 'TOGGLE',
      state: i.ACTIVE,
      icon: 'participant-list',
      text: 'Hide participants',
      tooltip: 'Hide participants panel'
    };
    const inactive = {
      ID: this.ID,
      type: 'TOGGLE',
      state: i.INACTIVE,
      icon: 'participant-list',
      text: 'Show participants',
      tooltip: 'Show participants panel'
    };
    return this.adapter.getMeeting(meetingID).pipe(map(_ref => {
      let {
        showRoster
      } = _ref;
      return showRoster ? active : inactive;
    }), distinctUntilChanged(), tap(display => logger.debug('MEETING', meetingID, 'RosterControl::display()', ['emitting', display])));
  }

}

/**
 * Display options of a meeting control.
 *
 * @external MeetingControlDisplay
 * @see {@link https://github.com/webex/component-adapter-interfaces/blob/master/src/MeetingsAdapter.js#L58}
 */

class SettingsControl extends MeetingControl {
  /**
   * Toggles the showSettings flag of the given meeting ID.
   * A settings toggle event is dispatched.
   *
   * @param {string} meetingID  Meeting ID
   */
  action(meetingID) {
    logger.debug('Meeting', meetingID, 'SettingsControl::action()', ['called with', {
      meetingID
    }]);
    this.adapter.toggleSettings(meetingID);
  }
  /**
   * Returns an observable that emits the display data of a settings control.
   *
   * @param {string} meetingID  Meeting id
   * @returns {Observable.<MeetingControlDisplay>} Observable stream that emits display data of the settings control
   */


  display(meetingID) {
    logger.debug('MEETING', meetingID, 'SettingsControl::display()', ['called with', {
      meetingID
    }]);
    const active = {
      ID: this.ID,
      type: 'BUTTON',
      state: i.ACTIVE,
      icon: 'settings',
      text: 'Settings',
      tooltip: 'Meeting settings'
    };
    const inactive = {
      ID: this.ID,
      type: 'BUTTON',
      state: i.INACTIVE,
      icon: 'settings',
      text: 'Settings',
      tooltip: 'Meeting settings'
    };
    return this.adapter.getMeeting(meetingID).pipe(map(_ref => {
      let {
        showSettings
      } = _ref;
      return showSettings ? active : inactive;
    }), distinctUntilChanged(), tap(display => logger.debug('Meeting', meetingID, 'SettingsControl::display()', ['emitting', display])));
  }

}

/**
 * Display options of a meeting control.
 *
 * @external MeetingControlDisplay
 * @see {@link https://github.com/webex/component-adapter-interfaces/blob/master/src/MeetingsAdapter.js#L58}
 */

class ShareControl extends MeetingControl {
  /**
   * Calls the adapter handleLocalShare() method
   *
   * @param {string} meetingID  ID of the meeting to share screen
   */
  async action(meetingID) {
    logger.debug('MEETING', meetingID, 'ShareControl::action()', ['called with', {
      meetingID
    }]);
    await this.adapter.handleLocalShare(meetingID);
  }
  /**
   * Returns an observable that emits the display data of a share control.
   *
   * @param {string} meetingID  ID of the meeting to start/stop screen share
   * @returns {Observable.<MeetingControlDisplay>} Observable stream that emits display data of the screen share control
   */


  display(meetingID) {
    logger.debug('MEETING', meetingID, 'ShareControl::display()', ['called with', {
      meetingID
    }]);
    const inactive = {
      ID: this.ID,
      type: 'TOGGLE',
      state: i.INACTIVE,
      icon: 'share-screen-presence-stroke',
      text: 'Start sharing',
      tooltip: 'Start sharing content'
    };
    const active = {
      ID: this.ID,
      type: 'TOGGLE',
      state: i.ACTIVE,
      icon: 'share-screen-presence-stroke',
      text: 'Stop sharing',
      tooltip: 'Stop sharing content'
    };
    return this.adapter.getMeeting(meetingID).pipe(map(_ref => {
      let {
        localShare: {
          stream
        }
      } = _ref;
      return stream ? active : inactive;
    }), distinctUntilChanged(), tap(display => logger.debug('MEETING', meetingID, 'ShareControl::display()', ['emitting', display])));
  }

}

/**
 * Display options of a meeting control.
 *
 * @external MeetingControlDisplay
 * @see {@link https://github.com/webex/component-adapter-interfaces/blob/master/src/MeetingsAdapter.js#L58}
 */

class SwitchCameraControl extends MeetingControl {
  /**
   * Calls the action of the switch camera control.
   *
   * @param {string} meetingID  Meeting ID
   * @param {string} cameraID  Id of the camera to switch to
   */
  async action(meetingID, cameraID) {
    logger.debug('MEETING', meetingID, 'SwitchCameraControl::action()', ['called with', {
      meetingID
    }]);
    await this.adapter.switchCamera(meetingID, cameraID);
  }
  /**
   * Returns an observable that emits the display data of the switch camera control.
   *
   * @param {string} meetingID  Meeting ID
   * @returns {Observable.<MeetingControlDisplay>} Observable that emits control display data of the switch camera control
   */


  display(meetingID) {
    logger.debug('MEETING', meetingID, 'SwitchCameraControl::display()', ['called with', {
      meetingID
    }]);
    const cameraID$ = this.adapter.getMeeting(meetingID).pipe(map(meeting => meeting.cameraID), distinctUntilChanged());
    const options$ = this.adapter.getAvailableDevices(meetingID, 'videoinput').pipe(map(availableCameras => availableCameras.map(camera => ({
      value: camera.deviceId,
      label: camera.label
    }))));
    return combineLatestImmediate(cameraID$, options$).pipe(map(_ref => {
      let [cameraID, options] = _ref;
      return {
        ID: this.ID,
        type: 'MULTISELECT',
        tooltip: 'Video Devices',
        noOptionsMessage: 'No available cameras',
        options: options || null,
        selected: cameraID || null,
        hint: 'Use arrow keys to navigate between camera options and hit "Enter" to select.'
      };
    }), tap(display => logger.debug('MEETING', meetingID, 'SwitchCameraControl::display()', ['emitting', display])));
  }

}

/**
 * Display options of a meeting control.
 *
 * @external MeetingControlDisplay
 * @see {@link https://github.com/webex/component-adapter-interfaces/blob/master/src/MeetingsAdapter.js#L58}
 */

class SwitchMicrophoneControl extends MeetingControl {
  /**
   * Switches the microphone control.
   *
   * @param {string} meetingID  Meeting ID
   * @param {string} microphoneID  Id of the microphone to switch to
   */
  async action(meetingID, microphoneID) {
    logger.debug('MEETING', meetingID, 'SwitchMicrophoneControl::action()', ['called with', {
      meetingID
    }]);
    await this.adapter.switchMicrophone(meetingID, microphoneID);
  }
  /**
   * Returns an observable that emits the display data of the switch microphone control.
   *
   * @param {string} meetingID  Meeting ID
   * @returns {Observable.<MeetingControlDisplay>} Observable that emits control display data of the switch microphone control
   */


  display(meetingID) {
    logger.debug('MEETING', meetingID, 'SwitchMicrophoneControl::display()', ['called with', {
      meetingID
    }]);
    const microphoneID$ = this.adapter.getMeeting(meetingID).pipe(map(meeting => meeting.microphoneID), distinctUntilChanged());
    const options$ = this.adapter.getAvailableDevices(meetingID, 'audioinput').pipe(map(availableMicrophones => availableMicrophones.map(microphone => ({
      value: microphone.deviceId,
      label: microphone.label
    }))));
    return combineLatestImmediate(microphoneID$, options$).pipe(map(_ref => {
      let [microphoneID, options] = _ref;
      return {
        ID: this.ID,
        type: 'MULTISELECT',
        tooltip: 'Audio Devices',
        noOptionsMessage: 'No available microphones',
        options: options || null,
        selected: microphoneID || null,
        hint: 'Use arrow keys to navigate between microphone options and hit "Enter" to select.'
      };
    }), tap(display => logger.debug('MEETING', meetingID, 'SwitchMicrophoneControl::display()', ['emitting', display])));
  }

}

/**
 * Display options of a meeting control.
 *
 * @external MeetingControlDisplay
 * @see {@link https://github.com/webex/component-adapter-interfaces/blob/master/src/MeetingsAdapter.js#L58}
 */

class SwitchSpeakerControl extends MeetingControl {
  /**
   * Calls the the action of the switch speaker control.
   *
   * @param {string} meetingID  Meeting ID
   * @param {string} speakerID  ID of the speaker device to switch to
   */
  async action(meetingID, speakerID) {
    logger.debug('MEETING', meetingID, 'SwitchSpeakerControl::action()', ['called with', {
      meetingID
    }]);
    await this.adapter.switchSpeaker(meetingID, speakerID);
  }
  /**
   * Returns and observable that emits the display data of the control.
   *
   * @param {string} meetingID  Meeting ID
   * @returns {Observable.<MeetingControlDisplay>} Observable that emits control display of the control
   */


  display(meetingID) {
    logger.debug('MEETING', meetingID, 'SwitchSpeakerControl::display()', ['called with', {
      meetingID
    }]);
    const speakerID$ = this.adapter.getMeeting(meetingID).pipe(map(meeting => meeting.speakerID), distinctUntilChanged());
    const options$ = this.adapter.getAvailableDevices(meetingID, 'audiooutput').pipe(map(availableSpeakers => availableSpeakers.map(speaker => ({
      value: speaker.deviceId,
      label: speaker.label
    }))), map(options => [{
      value: '',
      label: 'Browser Default'
    }, ...options]));
    return combineLatestImmediate(speakerID$, options$).pipe(map(_ref => {
      let [speakerID, options] = _ref;
      return {
        ID: this.ID,
        type: 'MULTISELECT',
        // The browser api setSinkId() does not work properly on Firefox and Safari browsers so we need to treat them separately by displaying a message inside a tooltip in both cases.
        // https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId
        tooltip: isSpeakerSupported ? 'Speaker Devices' : 'The current browser does not support changing speakers',
        noOptionsMessage: 'No available speakers',
        options: options || null,
        selected: speakerID || null,
        hint: 'Use arrow keys to navigate between speaker options and hit "Enter" to select.'
      };
    }), tap(display => logger.debug('MEETING', meetingID, 'SwitchSpeakerControl::display()', ['emitting', display])));
  }

}

/**
 * Display options of a meeting control.
 *
 * @external MeetingControlDisplay
 * @see {@link https://github.com/webex/component-adapter-interfaces/blob/master/src/MeetingsAdapter.js#L58}
 */

class VideoControl extends MeetingControl {
  /**
   * Calls the adapter handleLocalVideo() method
   *
   * @param {string} meetingID  Meeting id
   */
  action(meetingID) {
    logger.debug('MEETING', meetingID, 'VideoControl::action()', ['called with', {
      meetingID
    }]);
    return this.adapter.handleLocalVideo(meetingID);
  }
  /**
   * Returns an observable that emits the display data of a mute meeting video control.
   *
   * @param {string} meetingID  Meeting id
   * @returns {Observable.<MeetingControlDisplay>} Observable stream that emits display data of the video control
   */


  display(meetingID) {
    logger.debug('MEETING', meetingID, 'VideoControl::display()', ['called with', {
      meetingID
    }]);
    const common = {
      ID: this.ID,
      type: 'BUTTON'
    };
    const STATES = {
      muted: {
        icon: 'camera-muted',
        tooltip: 'Start video',
        state: i.ACTIVE,
        text: 'Start video'
      },
      unmuted: {
        icon: 'camera',
        tooltip: 'Stop video',
        state: i.INACTIVE,
        text: 'Stop video'
      },
      muting: {
        icon: 'camera',
        tooltip: 'Stopping video',
        state: i.DISABLED,
        text: 'Stopping...'
      },
      unmuting: {
        icon: 'camera-muted',
        tooltip: 'Starting video',
        state: i.DISABLED,
        text: 'Starting...'
      },
      noCamera: {
        icon: 'camera-muted',
        tooltip: 'No camera available',
        state: i.DISABLED,
        text: 'No camera'
      }
    };
    return this.adapter.getMeeting(meetingID).pipe(map(_ref => {
      let {
        localVideo: {
          stream,
          muting
        },
        disabledLocalVideo
      } = _ref;
      return muting === true && STATES.muting || muting === false && STATES.unmuting || stream && STATES.unmuted || disabledLocalVideo && STATES.muted || STATES.noCamera;
    }), distinctUntilChanged(), map(state => ({ ...common,
      ...state
    })), tap(display => logger.debug('MEETING', meetingID, 'VideoControl::display()', ['emitting', display])));
  }

}

/**
 * A video conference in Webex over WebRTC.
 *
 * @external Meeting
 * @see {@link https://github.com/webex/component-adapter-interfaces/blob/master/src/MeetingsAdapter.js#L20}
 * @see {@link https://webrtc.org}
 */
// TODO: Figure out how to import JS Doc definitions and remove duplication.

/**
 * Display options of a meeting control.
 *
 * @external MeetingControlDisplay
 * @see {@link https://github.com/webex/component-adapter-interfaces/blob/master/src/MeetingsAdapter.js#L58}
 */
// JS SDK Events

const EVENT_MEDIA_READY = 'media:ready';
const EVENT_MEDIA_STOPPED = 'media:stopped';
const EVENT_MEMBERS_UPDATE = 'members:update';
const EVENT_LOCAL_SHARE_STOP = 'meeting:stoppedSharingLocal';
const EVENT_LOCAL_SHARE_START = 'meeting:startedSharingLocal';
const EVENT_REMOTE_SHARE_START = 'meeting:startedSharingRemote';
const EVENT_REMOTE_SHARE_STOP = 'meeting:stoppedSharingRemote'; // Adapter Events

const EVENT_MEETING_UPDATED = 'adapter:meeting:updated';
const EVENT_CAMERA_SWITCH = 'adapter:camera:switch';
const EVENT_MICROPHONE_SWITCH = 'adapter:microphone:switch'; // Meeting controls

const JOIN_CONTROL = 'join-meeting';
const EXIT_CONTROL = 'leave-meeting';
const AUDIO_CONTROL = 'mute-audio';
const VIDEO_CONTROL = 'mute-video';
const SHARE_CONTROL = 'share-screen';
const ROSTER_CONTROL = 'member-roster';
const SETTINGS_CONTROL = 'settings';
const SWITCH_CAMERA_CONTROL = 'switch-camera';
const SWITCH_MICROPHONE_CONTROL = 'switch-microphone';
const SWITCH_SPEAKER_CONTROL = 'switch-speaker'; // Media stream types

const MEDIA_TYPE_LOCAL = 'local';
const MEDIA_TYPE_LOCAL_SHARE = 'localShare';
const MEDIA_TYPE_REMOTE_AUDIO = 'remoteAudio';
const MEDIA_TYPE_REMOTE_VIDEO = 'remoteVideo';
const MEDIA_TYPE_REMOTE_SHARE = 'remoteShare';
const MEDIA_EVENT_TYPES = [MEDIA_TYPE_LOCAL, MEDIA_TYPE_LOCAL_SHARE, MEDIA_TYPE_REMOTE_AUDIO, MEDIA_TYPE_REMOTE_VIDEO, MEDIA_TYPE_REMOTE_SHARE];
const mediaSettings = {
  receiveVideo: true,
  receiveAudio: true,
  receiveShare: true,
  sendVideo: true,
  sendAudio: true,
  sendShare: false
};
const HYDRA_ID_TYPE_PEOPLE = 'PEOPLE';
const HYDRA_ID_TYPE_ROOM = 'ROOM';
const LAYOUT_TYPES_MAP = {
  Overlay: 'ActivePresence',
  Grid: 'Equal',
  Stack: 'Prominent',
  Prominent: 'OnePlusN',
  Focus: 'Single'
};
const SDK_MEMBER_STATUS_TO_ADAPTER_MEETING_STATE = {
  IN_LOBBY: s.LOBBY,
  IN_MEETING: s.JOINED,
  NOT_IN_MEETING: s.LEFT
};
/**
 * The `MeetingsSDKAdapter` is an implementation of the `MeetingsAdapter` interface.
 * This adapter utilizes the Webex JS SDK to create and join Webex meetings.
 *
 * @implements {MeetingsAdapter}
 */

class MeetingsSDKAdapter extends d {
  constructor(datasource) {
    super(datasource);
    this.getMeetingObservables = {};
    this.meetings = {};
    this.meetingControls = {
      [JOIN_CONTROL]: new JoinControl(this, JOIN_CONTROL),
      [AUDIO_CONTROL]: new AudioControl(this, AUDIO_CONTROL),
      [VIDEO_CONTROL]: new VideoControl(this, VIDEO_CONTROL),
      [SHARE_CONTROL]: new ShareControl(this, SHARE_CONTROL),
      [EXIT_CONTROL]: new ExitControl(this, EXIT_CONTROL),
      [ROSTER_CONTROL]: new RosterControl(this, ROSTER_CONTROL),
      [SETTINGS_CONTROL]: new SettingsControl(this, SETTINGS_CONTROL),
      [SWITCH_CAMERA_CONTROL]: new SwitchCameraControl(this, SWITCH_CAMERA_CONTROL),
      [SWITCH_SPEAKER_CONTROL]: new SwitchSpeakerControl(this, SWITCH_SPEAKER_CONTROL),
      [SWITCH_MICROPHONE_CONTROL]: new SwitchMicrophoneControl(this, SWITCH_MICROPHONE_CONTROL)
    };
  }
  /**
   * Register the SDK meeting plugin to the device
   * and sync the meeting collection from the server.
   */


  async connect() {
    await this.datasource.meetings.register();
    await this.datasource.meetings.syncMeetings();
  }
  /**
   * Unregister the SDK meeting plugin from the device.
   */


  async disconnect() {
    await this.datasource.meetings.unregister();
  }
  /**
   * Returns an observable that emits local device media streams and their user permission status
   *
   * @private
   * @param {string} ID ID to retrieve the SDK meeting object to add the local media to
   * @returns {Observable} Observable that emits local media streams and their user permission status
   */


  getLocalMedia(ID) {
    logger.debug('MEETING', ID, 'getLocalMedia()', ['called with', {
      ID
    }]);
    const {
      sendAudio,
      sendVideo
    } = mediaSettings;
    return this.getStreamWithPermission(sendAudio, ID, {
      sendAudio: true
    }).pipe(map(_ref => {
      let {
        permission,
        stream,
        ignore,
        deviceId
      } = _ref;
      return {
        localAudio: {
          stream,
          permission,
          ignoreMediaAccessPrompt: ignore
        },
        localVideo: {
          stream: null,
          permission: null
        },
        microphoneID: deviceId
      };
    }), chainWith(audio => this.getStreamWithPermission(sendVideo, ID, {
      sendVideo: true
    }).pipe(map(_ref2 => {
      let {
        permission,
        stream,
        ignore,
        deviceId
      } = _ref2;
      return { ...audio,
        localVideo: {
          stream,
          permission,
          ignoreMediaAccessPrompt: ignore
        },
        cameraID: deviceId
      };
    }))));
  }
  /**
   * Returns an observable that emits local device media streams and their user permission status based on the given constraints.
   *
   * @see {@link MediaStream|https://developer.mozilla.org/en-US/docs/Web/API/MediaStream}.
   *
   * @private
   * @param {string} ID ID of the meeting for which to fetch streams
   * @param {object} mediaDirection A configurable options object for joining a meetings
   * @param {object} audioVideo audio/video object to set audioinput and videoinput devices
   * @returns {Observable} Observable that emits local media streams and their user permission status
   */


  getStream(ID, mediaDirection, audioVideo) {
    logger.debug('MEETING', ID, 'getStream()', ['called with', {
      ID,
      mediaDirection,
      audioVideo
    }]);
    return new Observable(async subscriber => {
      let ignored = false;
      let isAsking;

      try {
        const sdkMeeting = this.fetchMeeting(ID);

        const ignore = () => {
          ignored = true;
          subscriber.next({
            permission: 'IGNORED',
            stream: null
          });
          subscriber.complete();
        }; // wait a bit for the prompt to appear before emitting ASKING


        isAsking = true;
        setTimeout(() => {
          if (isAsking) {
            // media access promise was neither fulfilled nor rejected, so the browser prompt is probably showing
            subscriber.next({
              permission: 'ASKING',
              stream: null,
              ignore
            });
          }
        }, 2000);
        const [localStream] = await sdkMeeting.getMediaStreams(mediaDirection, audioVideo);
        const availableDevices = await navigator.mediaDevices.enumerateDevices();
        const [{
          label: deviceLabel
        }] = localStream.getTracks();
        const mediaDevice = availableDevices.find(device => device.label === deviceLabel);
        const deviceId = mediaDevice && mediaDevice.deviceId;
        isAsking = false;

        for (const track of localStream.getTracks()) {
          if (track.kind === 'video' && !mediaDirection.sendVideo) {
            localStream.removeTrack(track);
          }

          if (track.kind === 'audio' && !mediaDirection.sendAudio) {
            localStream.removeTrack(track);
          }
        }

        if (!ignored) {
          subscriber.next({
            permission: 'ALLOWED',
            stream: localStream,
            deviceId
          });
          subscriber.complete();
        }
      } catch (error) {
        isAsking = false;

        if (!ignored) {
          let perm;
          const ee = error.error;
          logger.error('MEETING', ID, 'getStream()', 'Unable to retrieve local media stream', ee || error);

          if (ee instanceof DOMException) {
            if (ee.name === 'NotAllowedError') {
              if (ee.message === 'Permission dismissed') {
                perm = 'DISMISSED';
              } else if (ee.message === 'Permission denied by system') {
                perm = 'DISABLED';
              } else {
                perm = 'DENIED';
              }
            } else if (ee.name === 'NotReadableError') {
              perm = 'DISABLED';
            } else {
              perm = 'ERROR';
            }
          } else {
            perm = 'ERROR';
          }

          subscriber.next({
            permission: perm,
            stream: null
          });
          subscriber.complete();
        }
      }
    });
  }
  /**
   * Returns an observable that emits local device media streams and their user permission status
   *
   * @private
   * @param {boolean} condition Meeting mediaSettings propery condition for sending streams
   * @param {string} ID Meeting ID
   * @param {object} mediaDirection A configurable options object for joining a meetings
   * @param {object} audioVideo audio/video object to set audioinput and videoinput devices
   * @returns {Observable} Observable that emits local media streams and their user permission status
   */


  getStreamWithPermission(condition, ID, mediaDirection, audioVideo) {
    logger.debug('MEETING', ID, 'getStreamWithPermission()', ['called with these params', {
      condition,
      ID,
      mediaDirection,
      audioVideo
    }]);
    return condition ? this.getStream(ID, mediaDirection, audioVideo) : of({
      permission: null,
      stream: null
    });
  }
  /**
   * Emits available media devices.
   * If the user did no grant access to media (browser and OS), the returned observable
   * will emit an empty array.
   *
   * @param {string} ID  Id of the meeting
   * @param {'videoinput'|'audioinput'|'audiooutput'} type  String specifying the device type.
   * See {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo/kind|MDN}
   * @returns {Observable<MediaDeviceInfo[]>} Observable that emits arrays containing media devices.
   * @private
   */


  getAvailableDevices(ID, type) {
    logger.debug('MEETING', ID, 'getAvailableDevices()', ['called with', {
      ID,
      type
    }]);

    const getDevices = async () => {
      let devices = [];

      try {
        devices = await this.fetchMeeting(ID).getDevices();
        devices = devices.filter(device => !type || device.kind === type && device.deviceId);
      } catch (error) {
        logger.error('MEETING', ID, 'getAvailableDevices()', 'Unable to retrieve devices', error);
      }

      return devices;
    };

    return this.getMeeting(ID).pipe(map(meeting => type !== 'videoinput' && type !== 'audioinput' || type === 'videoinput' && meeting.localVideo.permission === 'ALLOWED' || type === 'audioinput' && meeting.localAudio.permission === 'ALLOWED'), distinctUntilChanged(), concatMap(allowed => from(allowed ? getDevices() : [[]])), tap(devices => logger.debug('MEETING', ID, 'getAvailabelDevices()', ['emitting', devices])));
  }
  /**
   * Update the meeting object with media attached based on a given event type.
   *
   * @private
   * @param {string} ID ID of the meeting to update
   * @param {object} media Media stream to attach to the meeting object based on a given event type
   * @param {string} media.type Type of event associated with the media change
   * @param {MediaStream} media.stream Media stream to attach to meeting
   */


  attachMedia(ID, _ref3) {
    let {
      type,
      stream
    } = _ref3;
    logger.debug('MEETING', ID, 'attachMedia()', ['called with', {
      ID,
      type,
      stream
    }]);
    const meeting = { ...this.meetings[ID]
    };
    const audioTracks = stream instanceof MediaStream && stream.getAudioTracks() || [];
    const videoTracks = stream instanceof MediaStream && stream.getVideoTracks() || [];

    switch (type) {
      case MEDIA_TYPE_LOCAL:
        this.meetings[ID] = { ...meeting,
          // Attach the media streams only if the streams are unmuted
          // `disableLocalAudio/Video` change inside handle media stream methods
          localAudio: { ...meeting.localAudio,
            stream: meeting.disabledLocalAudio || audioTracks.length === 0 ? null : new MediaStream(audioTracks)
          },
          localVideo: { ...meeting.localVideo,
            stream: meeting.disabledLocalVideo || videoTracks.length === 0 ? null : new MediaStream(videoTracks)
          }
        };
        break;

      case MEDIA_TYPE_REMOTE_AUDIO:
        this.meetings[ID] = { ...meeting,
          remoteAudio: stream
        };
        break;

      case MEDIA_TYPE_REMOTE_VIDEO:
        this.meetings[ID] = { ...meeting,
          remoteVideo: stream
        };
        break;

      case MEDIA_TYPE_LOCAL_SHARE:
        this.meetings[ID] = { ...meeting,
          localShare: {
            stream
          }
        };
        break;

      case MEDIA_TYPE_REMOTE_SHARE:
        this.meetings[ID] = { ...meeting,
          remoteShareStream: stream,
          remoteShare: meeting.remoteSharing ? stream : null
        };
        break;

      case EVENT_REMOTE_SHARE_START:
        // Only activate the remote stream when get get the start notification
        this.meetings[ID] = { ...meeting,
          remoteShare: meeting.remoteShareStream || null,
          remoteSharing: true
        };
        break;

      case EVENT_REMOTE_SHARE_STOP:
        // Remove remote share on stop event
        this.meetings[ID] = { ...meeting,
          remoteShare: null,
          remoteSharing: false
        };
        break;
    }
  }
  /**
   * Stops the tracks of the given media stream.
   *
   * @see {@link MediaStream|https://developer.mozilla.org/en-US/docs/Web/API/MediaStream}.
   *
   * @private
   * @static
   * @param {MediaStream} stream Media stream for which to stop tracks
   */
  // eslint-disable-next-line class-methods-use-this


  stopStream(stream) {
    logger.debug('MEETING', undefined, 'stopStream()', 'called');

    if (stream && stream.getTracks) {
      const tracks = stream.getTracks();
      tracks.forEach(track => track.stop());
    }
  }
  /**
   * Update the meeting object by removing all media.
   *
   * @private
   * @param {string} ID ID of the meeting to update
   */


  removeMedia(ID) {
    logger.debug('MEETING', ID, 'removeMedia()', ['called with', {
      ID
    }]);

    if (this.meetings && this.meetings[ID]) {
      this.stopStream(this.meetings[ID].localAudio.stream);
      this.stopStream(this.meetings[ID].localVideo.stream);
      this.stopStream(this.meetings[ID].localShare.stream);
      this.stopStream(this.meetings[ID].disabledLocalAudio);
      this.stopStream(this.meetings[ID].disabledLocalVideo);
    }

    this.meetings[ID] = { ...this.meetings[ID],
      localAudio: {
        stream: null,
        permission: null
      },
      localVideo: {
        stream: null,
        permission: null
      },
      localShare: {
        stream: null
      },
      remoteAudio: null,
      remoteVideo: null,
      remoteShare: null,
      cameraID: null,
      microphoneID: null,
      speakerID: null,
      settings: {
        visible: false,
        preview: {
          video: null,
          audio: null
        }
      }
    };
  }
  /**
   * Returns a promise of a meeting title for a given destination.
   * Supported destinations are person ID, room ID and SIP URI.
   *
   * @private
   * @param {string} destination Virtual meeting destination
   * @returns {Promise.<string>} Promise to the tile of the meeting at the destination
   */


  async fetchMeetingTitle(destination) {
    const {
      id,
      type
    } = deconstructHydraId(destination);
    let meetingTitle = destination;

    if (type === HYDRA_ID_TYPE_PEOPLE) {
      const {
        displayName
      } = await this.datasource.people.get(id);
      meetingTitle = displayName;
    } else if (type === HYDRA_ID_TYPE_ROOM) {
      // One must use a Hydra ID when calling `get` on rooms.
      // It has both the convo ID and cluster name in it.
      const {
        title
      } = await this.datasource.rooms.get(destination);
      meetingTitle = title;
    } else {
      try {
        const people = await this.datasource.people.list({
          email: destination
        });

        if (people.items) {
          const {
            displayName
          } = people.items[0];
          meetingTitle = displayName;
        } // eslint-disable-next-line no-empty

      } catch (error) {}
    }

    return meetingTitle;
  }
  /**
   * Creates meeting and returns an observable to the new meeting data.
   *
   * @param {string} destination Destination where to start the meeting at
   * @returns {Observable.<Meeting>} Observable stream that emits data of the newly created meeting
   */


  createMeeting(destination) {
    const newMeeting$ = from(this.datasource.meetings.create(destination)).pipe(map(_ref4 => {
      let {
        id,
        meetingInfo: {
          meetingName
        }
      } = _ref4;
      return {
        ID: id,
        title: meetingName,
        localAudio: {
          stream: null,
          permission: null
        },
        localVideo: {
          stream: null,
          permission: null
        },
        localShare: {
          stream: null
        },
        remoteAudio: null,
        remoteVideo: null,
        remoteShare: null,
        showRoster: null,
        settings: {
          visible: false,
          preview: {
            audio: null,
            video: null
          }
        },
        state: s.NOT_JOINED,
        cameraID: null,
        microphoneID: null,
        speakerID: ''
      };
    }), // if not provided by the sdk, compute a meeting title
    concatMap(meeting => meeting.title ? of(meeting) : from(this.fetchMeetingTitle(destination)).pipe(map(title => ({ ...meeting,
      title
    })))));
    return newMeeting$.pipe(chainWith(meeting => this.getLocalMedia(meeting.ID).pipe(map(localMedia => ({ ...meeting,
      ...localMedia
    })))), tap(meeting => {
      const sdkMeeting = this.fetchMeeting(meeting.ID);
      this.meetings[meeting.ID] = meeting;
      sdkMeeting.emit(EVENT_MEETING_UPDATED, meeting);
    }), catchError(err => {
      logger.error('MEETING', destination, 'createMeeting()', `Unable to create a meeting with "${destination}"`, err);
      throw err;
    }));
  }
  /**
   * Returns a SDK meeting object retrieved from the collection.
   *
   * @private
   * @param {string} ID ID of the meeting to fetch.
   * @returns {object} The SDK meeting object from the meetings collection.
   */


  fetchMeeting(ID) {
    logger.debug('MEETING', ID, 'fetchMeeting()', ['called with', {
      ID
    }]);
    return this.datasource.meetings.getMeetingByType('id', ID);
  }
  /**
   * Attempts to join the meeting of the given meeting ID.
   * If the meeting is successfully joined, a ready event is dispatched.
   *
   * @param {string} ID  ID of the meeting to join
   * @param {object} [options]  Options for joining
   * @param {string} [options.name]  Username for meeting
   * @param {string} [options.password]  Meeting guest password
   * @param {string} [options.hostKey]  Meeting host key
   */


  async joinMeeting(ID) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    logger.debug('MEETING', ID, 'joinMeeting()', ['called with', {
      ID,
      options
    }]);

    try {
      const sdkMeeting = this.fetchMeeting(ID);
      sdkMeeting.meetingFiniteStateMachine.reset();
      logger.debug('MEETING', ID, 'joinMeeting()', ['calling sdkMeeting.join() with', {
        pin: options.password,
        moderator: false,
        name: options.name
      }]);
      await sdkMeeting.join({
        pin: options.hostKey || options.password,
        moderator: !!options.hostKey,
        name: options.name
      });
      logger.info('MEETING', ID, 'JOIN', 'Joining meeting');
    } catch (error) {
      if (error.joinIntentRequired) {
        logger.info('MEETING', ID, 'joinMeeting()', 'Meeting requires authentication');
        this.updateMeeting(ID, () => ({
          passwordRequired: true,
          invalidPassword: !!options.password,
          invalidHostKey: !!options.hostKey
        }));
      } else {
        logger.error('MEETING', ID, 'joinMeeting()', 'Unable to join', error);
      }
    }
  }
  /**
   * Attempts to leave the meeting of the given meeting ID.
   * If the user had left the meeting successfully, a stopped event is dispatched.
   *
   * @param {string} ID ID of the meeting to leave from
   */


  async leaveMeeting(ID) {
    logger.debug('MEETING', ID, 'leaveMeeting()', ['called with', {
      ID
    }]);

    try {
      const sdkMeeting = this.fetchMeeting(ID);
      this.removeMedia(ID);
      logger.debug('MEETING', ID, 'leaveMeeting()', 'calling sdkMeeting.leave()');
      await sdkMeeting.leave();
      logger.info('MEETING', ID, 'LEAVE', 'Leaving meeting');
    } catch (error) {
      logger.error('MEETING', ID, 'leaveMeeting()', 'Unable to leave', error);
    }
  }
  /**
   * Returns the status of the specified local media (audio or video) in the form of an object
   * with the following mutually exclusive boolean properties:
   * - `unmuted` - the media is unmuted
   * - `muted` - the media is muted
   * - `muting` - the media is currently being muted
   * - `unmuting` - the media is currently being unmuted
   * - `disabled` - the media is disabled (there is no available media device)
   *
   * @param {object} localMedia  The local media object from the meeting
   * @param {MediaStream|null} disabledLocalMedia  The disabled media stream
   * @returns {{muting: boolean}|{unmuting: boolean}|{unmuted: boolean}|{muted: boolean}|{disabled: boolean}} The local media state
   */
  // eslint-disable-next-line class-methods-use-this


  getLocalMediaState(localMedia, disabledLocalMedia) {
    return localMedia.muting === true && {
      muting: true
    } || localMedia.muting === false && {
      unmuting: true
    } || localMedia.stream && {
      unmuted: true
    } || disabledLocalMedia && {
      muted: true
    } || {
      disabled: true
    };
  }
  /**
   * Attempts to mute the microphone of the given meeting ID.
   * If the microphone is successfully muted, an audio mute event is dispatched.
   *
   * @private
   * @param {string} ID ID of the meeting to mute audio
   */


  async handleLocalAudio(ID) {
    logger.debug('MEETING', ID, 'handleLocalAudio()', ['called with', {
      ID
    }]);
    let state; // local audio state
    // sanity checks and "(un)muting in-progress" state

    await this.updateMeeting(ID, meeting => {
      let updates;
      state = this.getLocalMediaState(meeting.localAudio, meeting.disabledLocalAudio);

      if (state.disabled) {
        throw new Error('Can\'t mute/unmute disabled audio');
      } else if (state.muting) {
        throw new Error('Already muting audio');
      } else if (state.unmuting) {
        throw new Error('Already unmuting audio');
      } else if (state.unmuted) {
        updates = {
          localAudio: {
            muting: true
          }
        };
      } else if (state.muted) {
        updates = {
          localAudio: {
            muting: false
          }
        };
      }

      return updates;
    });

    try {
      await this.updateMeeting(ID, async (meeting, sdkMeeting) => {
        const isInSession = !!meeting.remoteAudio;
        let updates;

        if (state.unmuted) {
          // Mute the audio only if there is an active meeting
          if (isInSession) {
            logger.debug('MEETING', ID, 'handleLocalAudio()', 'calling sdkMeeting.muteAudio()');
            await sdkMeeting.muteAudio();
            logger.info('MEETING', ID, 'MUTE', 'Audio muted');
          } // Store the current local audio stream to avoid an extra request call


          updates = {
            disabledLocalAudio: meeting.localAudio.stream,
            localAudio: {
              stream: null,
              muting: undefined
            }
          };
        } else if (state.muted) {
          // Unmute the audio only if there is an active meeting
          if (isInSession) {
            logger.debug('MEETING', ID, 'handleLocalAudio()', 'calling sdkMeeting.unmuteAudio()');
            await sdkMeeting.unmuteAudio();
            logger.info('MEETING', ID, 'UNMUTE', 'Unmute audio');
          } // Retrieve the stored local audio stream


          updates = {
            disabledLocalAudio: null,
            localAudio: {
              stream: meeting.disabledLocalAudio,
              muting: undefined
            }
          };
        }

        logger.debug('MEETING', ID, 'handleLocalAudio()', ['meeting updated with localAudio', {
          updates
        }]);
        return updates;
      });
    } catch (error) {
      logger.error('MEETING', ID, 'handleLocalAudio()', 'Unable to update local audio settings', error);
      this.updateMeeting(ID, () => ({
        localAudio: {
          muting: undefined
        }
      }));
    }
  }
  /**
   * Attempts to mute the camera of the given meeting ID.
   * If the camera is successfully muted, a video mute event is dispatched.
   *
   * @private
   * @param {string} ID ID of the meeting to mute video
   */


  async handleLocalVideo(ID) {
    logger.debug('MEETING', ID, 'handleLocalVideo()', ['called with', {
      ID
    }]);
    let state; // local video state
    // sanity checks and "(un)muting in-progress" state

    await this.updateMeeting(ID, meeting => {
      let updates;
      state = this.getLocalMediaState(meeting.localVideo, meeting.disabledLocalVideo);

      if (state.disabled) {
        throw new Error('Can\'t mute/unmute disabled video');
      } else if (state.muting) {
        throw new Error('Already muting video');
      } else if (state.unmuting) {
        throw new Error('Already unmuting video');
      } else if (state.unmuted) {
        updates = {
          localVideo: {
            muting: true
          }
        };
      } else if (state.muted) {
        updates = {
          localVideo: {
            muting: false
          }
        };
      }

      return updates;
    });

    try {
      await this.updateMeeting(ID, async (meeting, sdkMeeting) => {
        const isInSession = !!meeting.remoteVideo;
        let updates;

        if (state.unmuted) {
          // Mute the video only if there is an active meeting
          if (isInSession) {
            logger.debug('MEETING', ID, 'handleLocalVideo()', 'calling sdkMeeting.muteVideo()');
            await sdkMeeting.muteVideo();
            logger.info('MEETING', ID, 'MUTE', 'Video muted');
          } // Store the current local video stream to avoid an extra request call


          updates = {
            disabledLocalVideo: meeting.localVideo.stream,
            localVideo: {
              stream: null,
              muting: undefined
            }
          };
        } else if (state.muted) {
          // Unmute the video only if there is an active meeting
          if (isInSession) {
            logger.debug('MEETING', ID, 'handleLocalVideo()', 'calling sdkMeeting.unmuteVideo()');
            await sdkMeeting.unmuteVideo();
            logger.info('MEETING', ID, 'UNMUTE', 'Unmute video');
          } // Retrieve the stored local video stream


          updates = {
            disabledLocalVideo: null,
            localVideo: {
              stream: meeting.disabledLocalVideo,
              muting: undefined
            }
          };
        }

        logger.debug('MEETING', ID, 'handleLocalVideo()', ['meeting updated with localVideo', {
          updates
        }]);
        return updates;
      });
    } catch (error) {
      logger.error('MEETING', ID, 'handleLocalVideo()', 'Unable to update local video settings', error);
      this.updateMeeting(ID, () => ({
        localVideo: {
          muting: undefined
        }
      }));
    }
  }
  /**
   * Attempts to start/stop screen sharing to the given meeting ID.
   * If successful, a sharing start/stop event is dispatched.
   *
   * @private
   * @param {string} ID ID of the meeting to start/stop sharing
   */


  async handleLocalShare(ID) {
    logger.debug('MEETING', ID, 'handleLocalShare()', ['called with', {
      ID
    }]);
    await this.updateMeeting(ID, async (meeting, sdkMeeting) => {
      let updates;

      const handleSdkError = error => {
        logger.warn('MEETING', ID, 'handleLocalShare()', 'Unable to update local share stream', error);
        this.stopStream(meeting.localShare.stream);
        updates = {
          localShare: {
            stream: null
          }
        };
        this.updateMeeting(ID, async () => ({
          localShare: {
            stream: null
          }
        }));
      }; //
      // Workflow:
      // To enable or to disable the local sharing stream based on toggle state.
      // Will stop sharing stream and reset UI state when error happens
      //


      if (!sdkMeeting.canUpdateMedia()) {
        logger.error('MEETING', ID, 'handleLocalShare()', 'Unable to update screen share due to unstable connection.');
      } else if (meeting.localShare.stream) {
        this.stopStream(meeting.localShare.stream);
        sdkMeeting.updateShare({
          sendShare: false,
          receiveShare: true
        }).catch(handleSdkError);
        logger.info('MEETING', ID, 'UNSHARE', 'Stopping sharing');
        updates = {
          localShare: {
            stream: null
          }
        };
      } else {
        const [, localShare] = await sdkMeeting.getMediaStreams({
          sendShare: true
        });
        sdkMeeting.updateShare({
          stream: localShare,
          sendShare: true,
          receiveShare: true
        }).catch(handleSdkError);
        logger.info('MEETING', ID, 'SHARE', 'Starting sharing');
        updates = {
          localShare: {
            stream: localShare
          }
        };
      }

      logger.debug('MEETING', ID, 'handleLocalShare()', ['meeting updated with localShare', {
        updates
      }]);
      return updates;
    });
  }
  /**
   * Attempts to toggle roster to the given meeting ID.
   * A roster toggle event is dispatched.
   *
   * @param {string} ID ID of the meeting to toggle roster
   */


  toggleRoster(ID) {
    logger.debug('MEETING', ID, 'toggleRoster()', ['called with', {
      ID
    }]);
    logger.info('MEETING', ID, 'TOOGLE ROSTER', 'Opening meeting participants panel');
    return this.updateMeeting(ID, _ref5 => {
      let {
        showRoster
      } = _ref5;
      return {
        showRoster: !showRoster
      };
    });
  }
  /**
   * Toggles the settings.visible flag of the given meeting ID.
   * A settings toggle event is dispatched.
   *
   * @param {string} ID  Meeting ID
   */


  async toggleSettings(ID) {
    logger.debug('MEETING', ID, 'toggleSettings()', ['called with', {
      ID
    }]);
    await this.updateMeeting(ID, async (meeting, sdkMeeting) => {
      let updates;
      const openingSettings = !meeting.settings.visible;

      if (openingSettings) {
        logger.info('MEETING', ID, 'TOOGLE SETTINGS', 'Opening settings modal'); // Populate the preview streams with clones of the meeting streams
        // so that switching cameras/microphones in preview doesn't stop the meeting streams.
        // If the camera or microphone are muted, start them for the preview.

        const videoStream = meeting.localVideo.stream || meeting.disabledLocalVideo;
        const audioStream = meeting.localAudio.stream || meeting.disabledLocalAudio;
        updates = {
          settings: {
            visible: true,
            preview: {
              video: videoStream && videoStream.clone(),
              audio: audioStream && audioStream.clone()
            }
          }
        };
      } else {
        logger.info('MEETING', ID, 'TOOGLE SETTINGS', 'Closing settings modal'); // When closing settings, stop the existing meeting streams
        // and replace them with the last preview streams.

        this.stopStream(meeting.localVideo.stream);
        this.stopStream(meeting.localAudio.stream);
        updates = {
          settings: {
            visible: false
          },
          localVideo: {
            stream: meeting.localVideo.stream && meeting.settings.preview.video
          },
          disabledLocalVideo: meeting.disabledLocalVideo && meeting.settings.preview.video,
          localAudio: {
            stream: meeting.localAudio.stream && meeting.settings.preview.audio
          },
          disabledLocalAudio: meeting.disabledLocalAudio && meeting.settings.preview.audio
        };

        if (meeting.state === s.JOINED) {
          if (meeting.settings.preview.video) {
            await sdkMeeting.updateVideo({
              stream: meeting.settings.preview.video,
              receiveVideo: mediaSettings.receiveVideo,
              sendVideo: mediaSettings.sendVideo
            });
          }

          if (meeting.settings.preview.audio) {
            await sdkMeeting.updateAudio({
              stream: meeting.settings.preview.audio,
              receiveAudio: mediaSettings.receiveAudio,
              sendAudio: mediaSettings.sendAudio
            });
          }
        }
      }

      logger.debug('MEETING', ID, 'toggleSettings()', ['meeting updated with toggleSettings', {
        updates
      }]);
      return updates;
    });
  }
  /**
   * Switches the camera control.
   *
   * @param {string} ID Meeting ID
   * @param {string} cameraID ID of the camera to switch to
   */


  async switchCamera(ID, cameraID) {
    logger.debug('MEETING', ID, 'switchCamera()', ['called with', {
      ID,
      cameraID
    }]);
    logger.info('MEETING', ID, 'SWITCH CAMERA', `Switching current camera to camera with id "${cameraID}"`);
    await this.updateMeeting(ID, async meeting => {
      let updates;
      this.stopStream(meeting.settings.preview.video);
      const {
        stream,
        permission,
        deviceId
      } = await this.getStream(ID, {
        sendVideo: true
      }, {
        video: {
          deviceId: cameraID
        }
      }).toPromise();

      if (stream) {
        updates = {
          settings: {
            preview: {
              video: stream
            }
          },
          cameraID: deviceId
        };
      } else {
        throw new Error(`Could not change camera, permission not granted: ${permission}`);
      }

      logger.debug('MEETING', ID, 'switchCamera()', ['meeting update with switchCamera', {
        updates
      }]);
      return updates;
    });
  }
  /**
   * Switches the microphone control.
   *
   * @param {string} ID Meeting ID
   * @param {string} microphoneID ID of the microphone to switch to
   */


  async switchMicrophone(ID, microphoneID) {
    logger.debug('MEETING', ID, 'switchMicrophone()', ['called with', {
      ID,
      microphoneID
    }]);
    logger.info('MEETING', ID, 'SWITCH MICROPHONE', `Switching current microphone to microphone with id "${microphoneID}"`);
    await this.updateMeeting(ID, async meeting => {
      let updates;
      this.stopStream(meeting.settings.preview.audio);
      const {
        stream,
        permission,
        deviceId
      } = await this.getStream(ID, {
        sendAudio: true
      }, {
        audio: {
          deviceId: microphoneID
        }
      }).toPromise();

      if (stream) {
        updates = {
          settings: {
            preview: {
              audio: stream
            }
          },
          microphoneID: deviceId
        };
      } else {
        throw new Error(`Could not change microphone, permission not granted: ${permission}`);
      }

      logger.debug('MEETING', ID, 'switchMicrophone()', ['meeting update with switchMicrophone', {
        updates
      }]);
      return updates;
    });
  }
  /**
   * Switches the layout control.
   *
   * @async
   * @param {string} ID  Meeting ID
   * @param {string} layoutType  Type of layout
   * @returns {Promise}  Resolves when the layout has been changed
   */


  async changeLayout(ID, layoutType) {
    const sdkMeeting = this.fetchMeeting(ID);
    await sdkMeeting.changeVideoLayout(LAYOUT_TYPES_MAP[layoutType]);
  }
  /**
   * Switches the speaker control.
   *
   * @param {string} ID  Meeting ID
   * @param {string} speakerID  ID of the speaker device to switch to
   * @private
   */


  async switchSpeaker(ID, speakerID) {
    logger.debug('MEETING', ID, 'switchSpeaker()', ['called with', {
      ID,
      speakerID
    }]);
    logger.info('MEETING', ID, 'SWITCH SPEAKER', `Switching current speaker to speaker with id "${speakerID}"`);
    return this.updateMeeting(ID, () => ({
      speakerID
    }));
  }
  /**
   * Allows user to join meeting without allowing camera access
   *
   * @param {string}  ID Meeting ID
   */


  ignoreVideoAccessPrompt(ID) {
    logger.debug('MEETING', ID, 'ignoreVideoAccessPrompt()', ['called with', {
      ID
    }]);
    const meeting = this.meetings[ID];

    if (meeting.localVideo.ignoreMediaAccessPrompt) {
      logger.info('MEETING', ID, 'PROCEED WITHOUT CAMERA', 'Allow to join the meeting without camera access');
      meeting.localVideo.ignoreMediaAccessPrompt();
    } else {
      logger.error('MEETING', ID, 'ignoreVideoAccessPrompt()', `Can not ignore video prompt in current state: "${meeting.localVideo.permission}"`);
    }
  }
  /**
   * Allows user to join meeting without allowing microphone access
   *
   * @param {string} ID  Meeting ID
   */


  ignoreAudioAccessPrompt(ID) {
    logger.debug('MEETING', ID, 'ignoreAudioAccessPrompt()', ['called with', {
      ID
    }]);
    const meeting = this.meetings[ID];

    if (meeting.localAudio.ignoreMediaAccessPrompt) {
      logger.info('MEETING', ID, 'PROCEED WITHOUT MICROPHONE', 'Allow to join the meeting without microphone access');
      meeting.localAudio.ignoreMediaAccessPrompt();
    } else {
      logger.error('MEETING', ID, 'ignoreAudioAccessPrompt()', `Can not ignore audio prompt in current state: "${meeting.localAudio.permission}"`);
    }
  }
  /**
   * Sends the local media streams to the SDK
   *
   * @async
   * @private
   * @param {string} ID  Meeting id
   * @returns {Promise} Resolves when the local media streams have been successfully sent to the SDK.
   */


  async addMedia(ID) {
    logger.debug('MEETING', ID, 'addMedia()', ['called with', {
      ID
    }]);
    const sdkMeeting = this.fetchMeeting(ID);
    const localStream = new MediaStream();
    const localAudio = this.meetings[ID].localAudio.stream || this.meetings[ID].disabledLocalAudio;
    const localVideo = this.meetings[ID].localVideo.stream || this.meetings[ID].disabledLocalVideo;

    if (localAudio) {
      localAudio.getAudioTracks().forEach(track => localStream.addTrack(track));
    }

    if (localVideo) {
      localVideo.getVideoTracks().forEach(track => localStream.addTrack(track));
    }

    logger.debug('MEETING', ID, 'addMedia()', ['calling sdkMeeting.addMedia()', {
      localStream,
      mediaSettings
    }]);
    await sdkMeeting.addMedia({
      localStream,
      mediaSettings
    });

    if (!this.meetings[ID].localAudio.stream) {
      logger.debug('MEETING', ID, 'addMedia()', 'calling sdkMeeting.muteAudio()');
      await sdkMeeting.muteAudio();
    }

    if (!this.meetings[ID].localVideo.stream) {
      logger.debug('MEETING', ID, 'addMedia()', 'calling sdkMeeting.muteVideo()');
      await sdkMeeting.muteVideo();
    }
  }
  /**
   * Returns an observable that emits meeting data of the given ID.
   *
   * @param {string} ID ID of meeting to get
   * @returns {Observable.<Meeting>} Observable stream that emits meeting data of the given ID
   */


  getMeeting(ID) {
    logger.debug('MEETING', ID, 'getMeeting()', ['called with', {
      ID
    }]);

    if (!(ID in this.getMeetingObservables)) {
      const sdkMeeting = this.fetchMeeting(ID);
      const getMeeting$ = Observable.create(observer => {
        if (sdkMeeting && this.meetings[ID]) {
          logger.debug('MEETING', ID, 'getMeeting()', ['initial meeting object', this.meetings[ID]]);
          observer.next(this.meetings[ID]);
          observer.complete();
        } else {
          logger.error('MEETING', ID, 'getMeeting()', `Could not find meeting with ID "${ID}"`);
          observer.error(new Error(`Could not find meeting with ID "${ID}"`));
        }
      });
      const meetingUpdateEvent$ = fromEvent(sdkMeeting, EVENT_MEETING_UPDATED).pipe(tap(() => logger.debug('MEETING', ID, 'getMeeting()', ['received', EVENT_MEETING_UPDATED, 'event'])), tap(meeting => {
        this.meetings[ID] = meeting;
      }));
      const meetingWithMediaReadyEvent$ = fromEvent(sdkMeeting, EVENT_MEDIA_READY).pipe(tap(() => {
        logger.debug('MEETING', ID, 'getMeeting()', ['received', EVENT_MEDIA_READY, 'event']);
      }), filter(event => MEDIA_EVENT_TYPES.includes(event.type)), map(event => this.attachMedia(ID, event)));
      const meetingWithMediaStoppedEvent$ = fromEvent(sdkMeeting, EVENT_MEDIA_STOPPED).pipe(tap(() => {
        logger.debug('MEETING', ID, 'getMeeting()', ['received', EVENT_MEDIA_STOPPED, 'event']);
        this.removeMedia(ID);
      }));
      const meetingWithMediaShareEvent$ = fromEvent(sdkMeeting, EVENT_REMOTE_SHARE_START).pipe(tap(() => {
        logger.debug('MEETING', ID, 'getMeeting()', ['received', EVENT_REMOTE_SHARE_START, 'event']);
        this.attachMedia(ID, {
          type: EVENT_REMOTE_SHARE_START
        });
      }));
      const meetingWithMediaStoppedShareEvent$ = fromEvent(sdkMeeting, EVENT_REMOTE_SHARE_STOP).pipe(tap(() => {
        logger.debug('MEETING', ID, 'getMeeting()', ['received', EVENT_REMOTE_SHARE_STOP, 'event']);
        this.attachMedia(ID, {
          type: EVENT_REMOTE_SHARE_STOP
        });
      }));
      const meetingWithLocalShareStoppedEvent$ = fromEvent(sdkMeeting, EVENT_LOCAL_SHARE_STOP).pipe(tap(() => {
        logger.debug('MEETING', ID, 'getMeeting()', ['received', EVENT_LOCAL_SHARE_STOP, 'event']);
        this.stopStream(this.meetings[ID].localShare.stream);
        this.meetings[ID].localShare.stream = null;
      }));
      const meetingWithLocalShareStartedEvent$ = fromEvent(sdkMeeting, EVENT_LOCAL_SHARE_START).pipe(tap(() => {
        logger.debug('MEETING', ID, 'getMeeting()', ['received', EVENT_LOCAL_SHARE_START, 'event']);
      }));
      const meetingWithSwitchCameraEvent$ = fromEvent(sdkMeeting, EVENT_CAMERA_SWITCH).pipe(tap(() => {
        logger.debug('MEETING', ID, 'getMeeting()', ['received', EVENT_CAMERA_SWITCH, 'event']);
      }));
      const meetingWithSwitchMicrophoneEvent$ = fromEvent(sdkMeeting, EVENT_MICROPHONE_SWITCH).pipe(tap(() => {
        logger.debug('MEETING', ID, 'getMeeting()', ['received', EVENT_MICROPHONE_SWITCH, 'event']);
      }));
      const meetingStateChange$ = fromEvent(sdkMeeting && sdkMeeting.members, EVENT_MEMBERS_UPDATE).pipe(map(event => {
        logger.debug('MEETING', ID, 'getMeeting()', ['received', EVENT_MEMBERS_UPDATE, 'event']);
        const self = Object.values(event.full).find(m => m.isSelf);
        return SDK_MEMBER_STATUS_TO_ADAPTER_MEETING_STATE[self && self.status] || s.NOT_JOINED;
      }), distinctUntilChanged(), tap(state => {
        logger.debug('MEETING', ID, 'getMeeting()', ['changing meeting state to', state]);
        this.meetings[ID] = { ...this.meetings[ID],
          state
        };

        if (state === s.JOINED) {
          // do not await on this, otherwise the emitted message won't contain an updated state
          this.addMedia(ID).catch(error => {
            logger.error('MEETING', ID, 'getMeeting()', 'Unable to add media', error);
          });
        }
      }));
      const meetingsWithEvents$ = merge(meetingUpdateEvent$, meetingWithMediaReadyEvent$, meetingWithMediaStoppedEvent$, meetingWithLocalShareStoppedEvent$, meetingWithMediaShareEvent$, meetingWithMediaStoppedShareEvent$, meetingStateChange$, meetingWithSwitchCameraEvent$, meetingWithSwitchMicrophoneEvent$, meetingWithLocalShareStartedEvent$).pipe(map(() => this.meetings[ID])); // Return a meeting object from event

      const getMeetingWithEvents$ = concat(getMeeting$, meetingsWithEvents$); // Convert to a multicast observable

      this.getMeetingObservables[ID] = getMeetingWithEvents$.pipe(publishReplay(1), refCount(), takeWhile(meeting => meeting.state && meeting.state !== s.LEFT, true), tap(() => {
        logger.debug('MEETING', ID, 'getMeeting()', ['emitting', this.meetings[ID]]);
      }));
    }

    return this.getMeetingObservables[ID];
  }
  /**
   * A callback that returns an updated meeting
   *
   * @callback UpdateMeetingCallback
   * @param {Meeting} meeting  Original meeting object
   * @returns {Promise<Meeting>} Updated meeting object
   */

  /**
   * Updates a meeting and notifies listeners
   *
   * @private
   * @async
   * @param {string} ID  Id of the meeting to update.
   * @param {UpdateMeetingCallback} updater  Function to update the meeting
   */


  async updateMeeting(ID, updater) {
    logger.debug('MEETING', ID, 'updateMeeting()', ['called with', {
      ID,
      updater
    }]);
    const sdkMeeting = this.fetchMeeting(ID);
    const meeting = this.meetings[ID];

    if (!sdkMeeting || !meeting) {
      throw new Error(`Could not find meeting with ID "${ID}"`);
    }

    const updates = await updater(meeting, sdkMeeting);
    deepMerge(meeting, updates);
    logger.debug('MEETING', ID, 'updateMeeting()', ['meeting updated with', EVENT_MEETING_UPDATED, 'event', 'meeting object', {
      meeting
    }]);
    sdkMeeting.emit(EVENT_MEETING_UPDATED, meeting);
  }
  /**
   * Displays the names of the available controls.
   *
   * @returns {string[]} Array containing the control names supported.
   */


  supportedControls() {
    return Object.keys(this.meetingControls);
  }
  /**
   * Displays the available layout types.
   *
   * @returns {string[]} Array containing the layout types.
   */
  // eslint-disable-next-line class-methods-use-this


  getLayoutTypes() {
    return Object.keys(LAYOUT_TYPES_MAP);
  }
  /**
   * Clears the password required flag.
   *
   * @async
   * @param {string} ID  Id of the meeting
   */


  async clearPasswordRequiredFlag(ID) {
    logger.debug('MEETING', ID, 'clearPasswordRequiredFlag()', ['called with', {
      ID
    }]);
    await this.updateMeeting(ID, async () => ({
      passwordRequired: false
    }));
  }
  /**
   * Sets the invalidPassword flag to false.
   *
   * @async
   * @param {string} ID  Id of the meeting
   */


  async clearInvalidPasswordFlag(ID) {
    logger.debug('MEETING', ID, 'clearInvalidPasswordFlag()', ['called with', {
      ID
    }]);
    await this.updateMeeting(ID, async () => ({
      invalidPassword: false
    }));
  }
  /**
   * Sets the invalidHostKey flag to false.
   *
   * @async
   * @param {string} ID  Id of the meeting
   */


  async clearInvalidHostKeyFlag(ID) {
    await this.updateMeeting(ID, async () => ({
      invalidHostKey: false
    }));
  }

}

var constants = {};

var _global = {exports: {}};

var global$2 = _global.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
: Function('return this')();
if (typeof __g == 'number') __g = global$2; // eslint-disable-line no-undef

var _core = {exports: {}};

var core$1 = _core.exports = {
  version: '2.6.12'
};
if (typeof __e == 'number') __e = core$1; // eslint-disable-line no-undef

var _aFunction = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

var aFunction = _aFunction;

var _ctx = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function
    /* ...args */
  () {
    return fn.apply(that, arguments);
  };
};

var _objectDp = {};

var _isObject = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

var isObject$2 = _isObject;

var _anObject = function (it) {
  if (!isObject$2(it)) throw TypeError(it + ' is not an object!');
  return it;
};

var _fails = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

var _descriptors = !_fails(function () {
  return Object.defineProperty({}, 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

var isObject$1 = _isObject;
var document$1 = _global.exports.document; // typeof document.createElement is 'object' in old IE

var is = isObject$1(document$1) && isObject$1(document$1.createElement);

var _domCreate = function (it) {
  return is ? document$1.createElement(it) : {};
};

var _ie8DomDefine = !_descriptors && !_fails(function () {
  return Object.defineProperty(_domCreate('div'), 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

var isObject = _isObject; // instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string

var _toPrimitive = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var anObject = _anObject;
var IE8_DOM_DEFINE = _ie8DomDefine;
var toPrimitive = _toPrimitive;
var dP$1 = Object.defineProperty;
_objectDp.f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP$1(O, P, Attributes);
  } catch (e) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var _propertyDesc = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var dP = _objectDp;
var createDesc = _propertyDesc;

var _hide = _descriptors ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var hasOwnProperty = {}.hasOwnProperty;

var _has = function (it, key) {
  return hasOwnProperty.call(it, key);
};

var global$1 = _global.exports;
var core = _core.exports;
var ctx = _ctx;
var hide = _hide;
var has = _has;
var PROTOTYPE = 'prototype';

var $export$1 = function (type, name, source) {
  var IS_FORCED = type & $export$1.F;
  var IS_GLOBAL = type & $export$1.G;
  var IS_STATIC = type & $export$1.S;
  var IS_PROTO = type & $export$1.P;
  var IS_BIND = type & $export$1.B;
  var IS_WRAP = type & $export$1.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global$1 : IS_STATIC ? global$1[name] : (global$1[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;

  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue; // export native or passed

    out = own ? target[key] : source[key]; // prevent global pollution for namespaces

    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global$1) // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0:
              return new C();

            case 1:
              return new C(a);

            case 2:
              return new C(a, b);
          }

          return new C(a, b, c);
        }

        return C.apply(this, arguments);
      };

      F[PROTOTYPE] = C[PROTOTYPE];
      return F; // make static versions for prototype methods
    }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%

    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out; // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%

      if (type & $export$1.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
}; // type bitmap


$export$1.F = 1; // forced

$export$1.G = 2; // global

$export$1.S = 4; // static

$export$1.P = 8; // proto

$export$1.B = 16; // bind

$export$1.W = 32; // wrap

$export$1.U = 64; // safe

$export$1.R = 128; // real proto method for `library`

var _export = $export$1;

var $export = _export; // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)

$export($export.S + $export.F * !_descriptors, 'Object', {
  defineProperty: _objectDp.f
});

var $Object = _core.exports.Object;

var defineProperty$1 = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};

var defineProperty = defineProperty$1;

(function (exports) {

  var _Object$defineProperty = defineProperty;

  _Object$defineProperty(exports, "__esModule", {
    value: true
  });

  exports.INTERNAL_US_INTEGRATION_CLUSTER_NAME = exports.INTERNAL_US_CLUSTER_NAME = exports.deviceType = exports.hydraTypes = exports.SDK_EVENT = void 0;
  var SDK_EVENT = {
    INTERNAL: {
      WEBEX_ACTIVITY: 'event:conversation.activity',
      ACTIVITY_FIELD: {
        ACTOR: 'actor',
        OBJECT: 'object',
        TARGET: 'target'
      },
      ACTIVITY_VERB: {
        ACKNOWLEDGE: 'acknowledge',
        CARD_ACTION: 'cardAction',
        CREATE: 'create',
        POST: 'post',
        SHARE: 'share',
        DELETE: 'delete',
        ADD: 'add',
        LEAVE: 'leave',
        ADD_MODERATOR: 'assignModerator',
        REMOVE_MODERATOR: 'unassignModerator',
        LOCK: 'lock',
        UNLOCK: 'unlock',
        HIDE: 'hide',
        UPDATE: 'update'
      },
      ACTIVITY_TAG: {
        HIDDEN: 'HIDDEN',
        ONE_ON_ONE: 'ONE_ON_ONE',
        LOCKED: 'LOCKED'
      }
    },
    EXTERNAL: {
      EVENT_TYPE: {
        CREATED: 'created',
        DELETED: 'deleted',
        UPDATED: 'updated',
        SEEN: 'seen'
      },
      OWNER: {
        CREATOR: 'creator',
        ORG: 'org'
      },
      STATUS: {
        ACTIVE: 'active',
        DISABLED: 'disabled'
      },
      SPACE_TYPE: {
        DIRECT: 'direct',
        GROUP: 'group'
      },
      RESOURCE: {
        ATTACHMENT_ACTIONS: 'attachmentActions',
        MEMBERSHIPS: 'memberships',
        MESSAGES: 'messages',
        ROOMS: 'rooms'
      },
      ATTACHMENTS: {
        CARD_CONTENT_TYPE: 'application/vnd.microsoft.card.adaptive'
      }
    }
  };
  exports.SDK_EVENT = SDK_EVENT;
  var hydraTypes = {
    ATTACHMENT_ACTION: 'ATTACHMENT_ACTION',
    CONTENT: 'CONTENT',
    MEMBERSHIP: 'MEMBERSHIP',
    MESSAGE: 'MESSAGE',
    ORGANIZATION: 'ORGANIZATION',
    PEOPLE: 'PEOPLE',
    ROOM: 'ROOM',
    TEAM: 'TEAM'
  };
  exports.hydraTypes = hydraTypes;
  var deviceType = {
    PROVISIONAL: 'PROVISIONAL',
    WEB: 'WEB'
  };
  exports.deviceType = deviceType;
  var INTERNAL_US_CLUSTER_NAME = 'urn:TEAM:us-east-2_a';
  exports.INTERNAL_US_CLUSTER_NAME = INTERNAL_US_CLUSTER_NAME;
  var INTERNAL_US_INTEGRATION_CLUSTER_NAME = 'urn:TEAM:us-east-1_int13';
  exports.INTERNAL_US_INTEGRATION_CLUSTER_NAME = INTERNAL_US_INTEGRATION_CLUSTER_NAME;
})(constants);

var name = "@webex/sdk-component-adapter";
var version = "1.101.0";

const LOG_ARGS$1 = ['SDK-MEMBERSHIPS', `${name}-${version}`]; // max parameter value must be greater than 0 and less than or equal to 1000

const MAX_MEMBERSHIPS = 1000; // TODO: Figure out how to import JS Doc definitions and remove duplication.

/**
 * A Member object that is part of a membership
 *
 * @external Member
 * @see {@link https://github.com/webex/component-adapter-interfaces/blob/master/src/MembershipsAdapter.js#L6}
 */

/**
 * Sort the members alphabetically, with the current user first
 *
 * @param {Array} members List of sdk meeting members
 * @returns {Array} Sorted list of sdk meeting members
 */

function sortMeetingMembers(members) {
  logger.debug(...LOG_ARGS$1, 'sortMeetingMembers()', ['called with', {
    members
  }]);
  return members.sort((member1, member2) =>
  /* eslint-disable no-nested-ternary, indent */
  member1.isSelf ? -1 // current user comes first
  : member2.isSelf ? +1 : !member1.name ? +1 // empty names come last
  : !member2.name ? -1 : member1.name.localeCompare(member2.name)); // alphabetical order

  /* eslint-enable no-nested-ternary, indent */
}
/**
 * A Webex user.
 *
 * @external Person
 * @see {@link https://github.com/webex/component-adapter-interfaces/blob/master/src/PeopleAdapter.js#L6}
 */

/**
 * Sort a memberships list alphabetically, with the current user first
 *
 * @param {Array} memberships List of sdk memberships
 * @param {string} myID Id of the current user
 * @returns {Array} Sorted list of sdk memberships
 */


function sortRoomMembers(memberships, myID) {
  logger.debug(...LOG_ARGS$1, 'sortRoomMembers()', ['called with', {
    memberships,
    myID
  }]);
  return memberships.sort((m1, m2) =>
  /* eslint-disable no-nested-ternary, indent */
  m1.personId === myID ? -1 // current user comes first
  : m2.personId === myID ? 1 : !m2.personDisplayName ? -1 // empty names come last
  : !m1.personDisplayName ? 1 : m1.personDisplayName.localeCompare(m2.personDisplayName)); // alphabetical order

  /* eslint-enable no-nested-ternary, indent */
}
/**
 * Maps SDK members to adapter members
 *
 * @private
 * @param {object} sdkMembers  Members object from sdk meeting, keyed by ID
 * @param {object} meeting  Sdk meeting object
 * @returns {Array.<Member>} List of meeting members
 */


function getMembers(sdkMembers, meeting) {
  logger.debug(...LOG_ARGS$1, 'getMembers()', ['called with', {
    sdkMembers,
    meeting
  }]);
  let members = Object.values(sdkMembers || {});
  members = sortMeetingMembers(members);
  return members.map(member => ({
    ID: member.participant && member.participant.person && constructHydraId(constants.hydraTypes.PEOPLE, member.participant.person.id),
    orgID: member.participant && member.participant.person && member.participant.person.orgId && constructHydraId(constants.hydraTypes.ORGANIZATION, member.participant.person.orgId),
    inMeeting: member.isInMeeting,
    muted: member.isAudioMuted,
    sharing: member.isContentSharing,
    host: !!meeting.meetingInfo.isWebexScheduled && member.isModerator,
    guest: member.isGuest
  }));
}
/**
 * The `MembershipsSDKAdapter` is an implementation of the `MembershipsAdapter` interface.
 * This adapter utilizes the Webex JS SDK to fetch data about a memberships.
 *
 * @implements {MembershipsAdapter}
 */


class MembershipsSDKAdapter extends E {
  constructor(datasource) {
    super(datasource);
    logger.debug(...LOG_ARGS$1, 'constructor()', 'instantiating membership sdk adapter');
    this.members$ = {}; // cache membership observables based on membership id

    this.listenerCount = 0;
  }
  /**
   * Tells the SDK to start listening to memberships events and tracks the amount of calls.
   *
   * Note: Since the SDK listens to ALL memberships events, this function only
   * calls the SDK's `memberships.listen` function on the first membership to listen.
   * Repeated calls to `memberships.listen` are not needed afterwards.
   *
   * @private
   */


  startListeningToMembershipsUpdates() {
    logger.debug(...LOG_ARGS$1, 'startListeningToMembershipsUpdates()', 'called');

    if (this.listenerCount === 0) {
      // Tell the sdk to start listening to membership changes
      this.datasource.memberships.listen();
    }

    this.listenerCount += 1;
  }
  /**
   * Tells the SDK to stop listening to memberships events.
   *
   * Note: Since the SDK listens to ALL memberships events, this function only
   * calls the SDK's `memberships.stopListening` function once all of the listeners are done.
   * If `memberships.stopListening` is called early, existing subscribers won't get any updates.
   *
   * @private
   */


  stopListeningToMembershipsUpdates() {
    logger.debug(...LOG_ARGS$1, 'stopListeningToMembershipsUpdates()', 'called');
    this.listenerCount -= 1;

    if (this.listenerCount <= 0) {
      // Once all listeners are done, stop listening
      this.datasource.memberships.stopListening();
    }
  }
  /**
   * Returns an observable that emits room members list of the given roomID.
   *
   * @private
   * @param {string} roomID ID of the room
   * @returns {external:Observable.<Array.<Member>>} Observable stream that emits a list of current members in a room
   */


  getRoomMembers(roomID) {
    logger.debug('MEMBERSHIP', `room-${roomID}`, 'getRoomMembers()', ['called with', {
      roomID
    }]);
    this.startListeningToMembershipsUpdates();

    const membershipToMember = membership => ({
      ID: deconstructHydraId(membership.personId).id,
      orgID: deconstructHydraId(membership.personOrgId).id,
      muted: null,
      sharing: null,
      inMeeting: null,
      host: null,
      guest: null
    });

    const me$ = from(this.datasource.people.get('me'));
    const memberships$ = defer(() => this.datasource.memberships.list({
      roomId: roomID,
      max: MAX_MEMBERSHIPS
    })).pipe(map(page => page.items));
    const members$ = combineLatest([me$, memberships$]).pipe(map(_ref => {
      let [me, memberships] = _ref;
      return sortRoomMembers(memberships, me.id).map(membershipToMember);
    }));
    const createdEvent$ = fromEvent(this.datasource.memberships, SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED).pipe(tap(() => {
      logger.debug('MEMBERSHIP', `room-${roomID}`, 'getRoomMembers()', ['received', SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED, 'event']);
    }));
    const deletedEvent$ = fromEvent(this.datasource.memberships, SDK_EVENT.EXTERNAL.EVENT_TYPE.DELETED);
    const event$ = merge(createdEvent$, deletedEvent$).pipe(filter(event => event.data.roomId === roomID), mergeMap(() => members$));
    return concat(members$, event$).pipe(publishReplay(1), refCount(), tap(members => {
      logger.debug('MEMBERSHIP', `room-${roomID}`, 'getRoomMembers()', ['emitting membership object', members]);
    }), finalize(() => {
      this.stopListeningToMembershipsUpdates();
    }));
  }
  /**
   * Returns an observable that emits meeting members list of the given meetingID.
   *
   * @private
   * @param {string} meetingID ID of the meeting
   * @returns {external:Observable.<Array.<Member>>} Observable stream that emits a list of current members in a meeting
   */


  getMeetingMembers(meetingID) {
    logger.debug('MEMBERSHIP', `meeting-${meetingID}`, 'getMeetingMembers()', ['called with', {
      meetingID
    }]);
    const meeting = this.datasource.meetings.getMeetingByType('id', meetingID);
    let members$;

    if (!meeting) {
      members$ = throwError(new Error(`Meeting ${meetingID} not found.`));
    } else {
      const members = meeting.members && meeting.members.membersCollection && meeting.members.membersCollection.members; // Behavior subject will keep the last emitted object for new subscribers
      // https://rxjs.dev/guide/subject#behaviorsubject

      members$ = new BehaviorSubject(getMembers(members, meeting)); // Emit on membership updates

      meeting.members.on('members:update', payload => {
        logger.debug(...LOG_ARGS$1, 'getMeetingMembers()', ['received "members:update" event', {
          payload
        }]);

        if (payload && payload.full) {
          members$.next(getMembers(payload.full, meeting));
        }
      });
    }

    return members$.pipe(tap(members => {
      logger.debug('MEMBERSHIP', `meeting-${meetingID}`, 'getMeetingMembers()', ['emitting membership object', members]);
    }));
  }
  /**
   * Returns an observable that emits a list of Member objects.
   * Whenever there is an update to the membership, the observable
   * will emit a new updated Member list, if datasource permits.
   *
   * @param {string} destinationID  ID of the destination for which to get members
   * @param {DestinationType} destinationType Type of the membership destination
   * @returns {external:Observable.<Array.<Member>>} Observable stream that emits member lists
   */


  getMembersFromDestination(destinationID, destinationType) {
    logger.debug('MEMBERSHIP', `${destinationType}-${destinationID}`, 'getMembersFromDestination()', ['called with', {
      destinationID,
      destinationType
    }]);
    const membershipID = `${destinationType}-${destinationID}`;
    let members$ = this.members$[membershipID];

    if (!members$) {
      switch (destinationType) {
        case a.ROOM:
          members$ = this.getRoomMembers(destinationID);
          break;

        case a.MEETING:
          members$ = this.getMeetingMembers(destinationID);
          break;

        default:
          members$ = throwError(new Error(`getMembersFromDestination for ${destinationType} is not currently supported.`));
      } // save for future calls


      this.members$[membershipID] = members$;
    }

    return members$;
  }

}

/**
 * A set of people in Webex.
 *
 * @external Organization
 * @see {@link https://github.com/webex/component-adapter-interfaces/blob/master/src/OrganizationsAdapter.js#L6}
 */

/**
 * The `OrganizationsSDKAdapter` is an implementation of the `OrganizationsAdapter` interface.
 * This adapter utilizes the Webex JS SDK to fetch data about an organization.
 *
 * @implements {OrganizationsAdapter}
 */

class OrganizationsSDKAdapter extends g {
  constructor(datasource) {
    super(datasource);
    this.organizationObservables = {};
  }
  /**
   * Returns a promise to organization data from Webex.
   *
   * @param {string} orgID ID of the organization for which to fetch data
   * @returns {Promise.<Organization>} Information about the organization of the given ID
   *
   * @private
   */


  fetchOrganization(orgID) {
    logger.debug('ORGANIZATION', orgID, 'fetchOrganization()', ['called with', {
      orgID
    }]);
    return this.datasource.request({
      service: 'hydra',
      resource: `organizations/${orgID}`
    }).then(res => res.body);
  }
  /**
   * Returns an observable that emits organization data of the given ID.
   *
   * @param {string} ID ID of organization to get
   * @returns {external:Observable.<Organization>} Observable stream that emits organization data
   */


  getOrg(ID) {
    logger.debug('ORGANIZATION', ID, 'getOrg()', ['called with', {
      ID
    }]);

    if (!(ID in this.organizationObservables)) {
      // use ReplaySubject cause we don't need to set an initial value
      this.organizationObservables[ID] = new ReplaySubject(1);
      defer(() => this.fetchOrganization(ID)).pipe(map(response => ({
        ID: response.id,
        name: response.displayName
      }))).subscribe(organization => {
        logger.debug('ORGANIZATION', ID, 'getOrg()', ['emitting organization object', organization]);
        this.organizationObservables[ID].next(organization);
      }, error => {
        logger.error('ORGANIZATION', ID, 'getOrg()', 'Error fetching organization', error);
        this.organizationObservables[ID].error(new Error(`Could't find organization with ID "${ID}"`));
      });
    }

    return this.organizationObservables[ID];
  }

}

const LOG_ARGS = ['SDK', `${name}-${version}`];
class WebexSDKAdapter extends t {
  /**
   * Creates a new instance of the WebexSDKAdapter.
   * The data source for this adapter comes from an authenticated instance of the SDK.
   * More information about the Webex JS SDK: https://github.com/webex/webex-js-sdk
   *
   * @param {object} sdk The primary sdk the adapter will be using.
   */
  constructor(sdk) {
    super(sdk);
    logger.debug(...LOG_ARGS, 'constructor()', 'instantiating sdk component adapter');
    this.activitiesAdapter = new ActivitiesSDKAdapter(sdk);
    this.peopleAdapter = new PeopleSDKAdapter(sdk);
    this.roomsAdapter = new RoomsSDKAdapter(sdk);
    this.meetingsAdapter = new MeetingsSDKAdapter(sdk);
    this.membershipsAdapter = new MembershipsSDKAdapter(sdk);
    this.organizationsAdapter = new OrganizationsSDKAdapter(sdk);
    this.sdk = sdk;
  }
  /**
   * Connect to Webex services so SDK can listen for data updates.
   */


  async connect() {
    logger.debug(...LOG_ARGS, 'connect()', 'called');
    logger.debug(...LOG_ARGS, 'connect()', 'calling sdk.internal.mercury.connect()');
    await this.sdk.internal.device.register();
    logger.debug(...LOG_ARGS, 'connect()', 'calling sdk.internal.mercury.connect()');
    await this.sdk.internal.mercury.connect();
    logger.debug(...LOG_ARGS, 'connect()', 'calling meetingsAdapter.connect()');
    await this.meetingsAdapter.connect();
  }
  /**
   * Disconnect from Webex services, closing any connections SDK may have opened.
   */


  async disconnect() {
    logger.debug(...LOG_ARGS, 'disconnect()', 'called');
    logger.debug(...LOG_ARGS, 'disconnect()', 'calling meetingsAdapter.disconnect()');
    await this.meetingsAdapter.disconnect();
    logger.debug(...LOG_ARGS, 'disconnect()', 'calling sdk.internal.mercury.disconnect()');
    await this.sdk.internal.mercury.disconnect();
    logger.debug(...LOG_ARGS, 'disconnect()', 'calling meetingsAdapter.unregister()');
    await this.sdk.internal.device.unregister();
  }

}

export { WebexSDKAdapter as default };
//# sourceMappingURL=webexSDKComponentAdapter.esm.js.map
