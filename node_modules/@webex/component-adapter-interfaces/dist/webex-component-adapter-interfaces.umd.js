(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs')) :
  typeof define === 'function' && define.amd ? define(['exports', 'rxjs'], factory) :
  (global = global || self, factory(global.WebexComponentAdapterInterfaces = {}, global.rxjs));
}(this, (function (exports, rxjs) { 'use strict';

  /**
   * An observable represents a continuous stream of data.
   * The observables in the Webex Component System are based on RxJS.
   *
   * @external Observable
   * @see {@link https://rxjs-dev.firebaseapp.com/guide/observable}
   */

  /**
   * This is a base class that defines the interface that other adapter interfaces extend.
   */
  class WebexAdapter {
    /**
     * Creates a new instance of the WebexAdapter.
     *
     * @param {object} datasource The primary datasource the adapter will be using
     */
    constructor(datasource) {
      this.datasource = datasource;
    }

    /**
     * Connects the adapter to its datasource.
     *
     * @returns {Promise} A promise that resolves when the adapter finishes connecting
     */
    connect() {
      return Promise.reject(
        new Error('connect() must be defined in WebexAdapter'),
      );
    }

    /**
     * Disconnects the adapter from its datasource.
     *
     * @returns {Promise} A promise that resolves when the adapter finishes disconnecting
     */
    disconnect() {
      return Promise.reject(
        new Error('disconnect() must be defined in WebexAdapter'),
      );
    }
  }

  /**
   * An activity a person performs in Webex.
   *
   * @typedef  {object} Activity
   * @property {string}  ID             The activity identifier
   * @property {string}  roomID         ID of the room where the activity happens
   * @property {string}  text           Any text the activity may contain
   * @property {string}  personID       ID of the person performing the activity
   * @property {Date}    created        Timestamp of the time when the activity happened
   * @property {boolean} displayAuthor  Whether to display author information or not
   */

  /**
   * This is a base class that defines the interface that maps activity data.
   * Developers that want to extend `ActivitiesAdapter` must implement all of its methods,
   * adhering to the exact parameters and structure of the returned objects.
   *
   * @interface
   */
  class ActivitiesAdapter extends WebexAdapter {
    /**
     * Returns an observable that emits activity data of the given ID.
     *
     * @param {string} ID  ID of the activity to get
     * @returns {external:Observable.<Activity>} Observable stream that emits activity data
     * @memberof ActivityAdapter
     */
    getActivity(ID) {
      return rxjs.throwError(new Error('getActivity(ID) must be defined in ActivitiesAdapter'));
    }
  }

  /**
   * MediaStream is a Web API standard that represents a stream of media content, e,g, video, audio.
   *
   * @external  MediaStream
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaStream}
   */

  /**
   * An object that represents a media stream and its permission with respect to a meeting.
   *
   * @typedef {object}  MeetingStream
   * @property {MediaStream}      stream      The local media stream
   * @property {MediaPermissions} permission  The state of the user permission on local media @see {@link MediaPermissions} enum
   */

  /**
   * A meeting object that allows users to have a WebRTC meeting.
   *
   * @typedef {object}  Meeting
   * @property {string}        ID               The meeting identifier
   * @property {string}        title            The title of the meeting
   * @property {MeetingStream} localVideo       The local video information
   * @property {MeetingStream} localAudio       The local audio information
   * @property {MeetingStream} localShare       The local share information
   * @property {MediaStream}   remoteVideo      The remote video stream
   * @property {MediaStream}   remoteAudio      The remote audio stream
   * @property {MediaStream}   remoteShare      The remote media share stream
   * @property {MeetingState}  state            The state of the meeting
   * @property {string}        cameraID         The ID of the camera in use
   * @property {string}        microphoneID     The ID of the microphone in use
   * @property {string}        speakerID        The ID of the speaker in use
   * @property {boolean}       passwordRequired If the meeting requires a password
   * @property {boolean}       invalidPassword  If the password received from the user is invalid
   */

  /**
   * A control/action that may modify a meeting or meeting state.
   *
   * @typedef {object}  MeetingControl
   * @property {string}                         ID       The meeting control ID or name
   * @property {MeetingControlAction}           action   A function that performs the control action. Must not return a value, as it must perform side-effects only
   * @property {MeetingControlDisplayFunction}  display  A function that returns an observable that emits MeetingControlDisplay objects
   */

  /**
   * Action a meeting control performs. It must perform a side-effect only.
   *
   * @typedef {Function}  MeetingControlAction
   * @param {string}  meetingID  ID of the meeting object for which to perform side-effect
   * @returns {void}
   */

  /**
   * Function that returns an observable that emits a meeting control display values.
   *
   * @typedef {Function}  MeetingControlDisplayFunction
   * @returns {external:Observable.<MeetingControlDisplay>}
   */

  /**
   * Enum for meeting control types
   *
   * @readonly
   * @enum {string}
   */
  const MeetingControlType = {
    JOIN: 'JOIN',
    CANCEL: 'CANCEL',
    CLOSE: 'CLOSE',
    TOGGLE: 'TOGGLE',
    MULTISELECT: 'MULTISELECT',
  };

  /**
   * Display options of a meeting control.
   *
   * @typedef {object}  MeetingControlDisplay
   * @property {MeetingControlState}  state    Current state of the meeting control
   * @property {string}               tooltip  The text to display when user hovers over control
   * @property {string}               icon     Momentum-ui icon name to display for the meeting control
   * @property {string}               text     Text to display on the meeting control. If there is an icon and text, text takes precedence
   * @property {MeetingControlType}   type     Type of the meeting control
   */

  /**
   * Enum for meeting control states.
   *
   * @readonly
   * @enum {string}
   */
  const MeetingControlState = {
    ACTIVE: 'active',
    INACTIVE: 'inactive',
    DISABLED: 'disabled',
  };

  /**
   * Enum for meeting states.
   * A falsy value for the state (missing/undefined/null) means that the meeting has not been created yet.
   *
   * @readonly
   * @enum {string}
   */
  const MeetingState = {
    NOT_JOINED: 'NOT_JOINED', // the meeting has been created (has an id), but the user has not yet started / joined
    LOBBY: 'LOBBY', // the user is waiting to be admitted into the meeting
    JOINED: 'JOINED', // the user has started / joined the meeting
    LEFT: 'LEFT', // the user has left the meeting
  };

  /**
   * Enum for media permissions states.
   * A falsy value for the media permission means that it is unknown (eg: the meeting was just created).
   *
   * @readonly
   * @enum {string}
   */
  const MediaPermissions = {
    ASKING: 'ASKING', // set while requesting the user for permission to access media device
    ALLOWED: 'ALLOWED', // set when the user has allowed permission to access media device
    DENIED: 'DENIED', // set when the user has denied access to media device
    DISMISSED: 'DISMISSED', // set when the user has dismissed the media device access prompt without allowing or denying access
    ERROR: 'ERROR', // set when there is an error while requesting access to media device
    IGNORED: 'IGNORED', // set when the user has chosen to not interact with the device access
  };

  /**
   * This is a base class that defines the interface that maps meetings data.
   * Developers that want to extend `MeetingsAdapter` must implement all of its methods,
   * adhering to the exact parameters and structure of the returned objects.
   *
   * @interface
   */
  class MeetingsAdapter extends WebexAdapter {
    /**
     * Creates a new instance of the MeetingsAdapter.
     *
     * @param {object} datasource The primary datasource the adapter will be using
     */
    constructor(datasource) {
      super(datasource);

      this.meetingControls = {};
    }

    /**
     * Creates a meeting for the given destination. Returns an observable
     * that emits a Meeting object with the data from the newly created meeting.
     * Observable should complete after emitting data.
     * If there is an issue creating the meeting, the observable will error.
     *
     * @param {string} destination  Virtual location where the meeting will take place
     * @returns {external:Observable.<Meeting>} Observable stream that emits meeting data
     * @memberof MeetingsAdapter
     */
    createMeeting(destination) {
      return rxjs.throwError(new Error('createMeeting(destination) must be defined in MeetingsAdapter'));
    }

    /**
     * Listens for incoming meetings at the given destination.
     * Returns an observable that emits a Meeting object with the data from the incoming meeting.
     * `incomingMeeting` is mostly used for 1:1 meetings where a user tries to reach another user directly.
     * This method only notifies that someone is trying to start a meeting, but it has to be used in
     * conjunction with `joinMeeting` to actually join the meeting.
     *
     * @param {string} destination  Virtual location where meeting will take place
     * @returns {external:Observable.<Meeting>} Observable stream that emits meeting data
     * @memberof MeetingsAdapter
     */
    incomingMeeting(destination) {
      return rxjs.throwError(new Error('incomingMeeting(destination) must be defined in MeetingsAdapter'));
    }

    /**
     * Returns an observable that emits a Meeting object.
     * Whenever there is an update to the meeting, the observable
     * will emit a new updated Meeting object, if datasource permits.
     * Observable must complete when the meeting is left
     * (e.g. @see {@link leaveMeeting} triggers an event).
     *
     * @param {string} ID  ID of the meeting to get
     * @returns {external:Observable.<Meeting>} Observable stream that emits meeting data
     * @memberof MeetingsAdapter
     */
    getMeeting(ID) {
      return rxjs.throwError(new Error('getMeeting(ID) must be defined in MeetingsAdapter'));
    }

    /**
     * Joins the meeting of the given ID.
     * Joining a meeting is performed as a side-effect and this method does not
     * return a value. Instead, joining a meeting should trigger getMeeting to
     * emit a new updated Meeting object.
     *
     * @param {string} ID  ID of the meeting to join
     * @memberof MeetingsAdapter
     */
    joinMeeting(ID) {
      throw new Error('joinMeeting(ID) must be defined in MeetingsAdapter');
    }

    /**
     * Leaves from the meeting of the given ID.
     * Leaving from a meeting is performed as a side-effect and this method does not
     * return a value. Instead, leaving from a meeting should trigger getMeeting to
     * emit a new updated Meeting object.
     * Leaving a meeting should trigger @see {@link getMeeting} to be complete.
     *
     * @param {string} ID  ID of the meeting to leave from
     * @memberof MeetingsAdapter
     */
    leaveMeeting(ID) {
      throw new Error('leaveMeeting(ID) must be defined in MeetingsAdapter');
    }

    /**
     * Displays the names of the available controls.
     *
     * @returns {string[]} Array containing the control names supported.
     */
    supportedControls() {
      return rxjs.throwError(new Error('supportedControls() must be defined in MeetingsAdapter'));
    }

    /**
     * Sets the passwordRequired flag to false.
     *
     * @param {string} ID  Id of the meeting
     * @returns {Promise|undefined}
     */
    clearPasswordRequiredFlag(ID) {
      throw new Error('clearPasswordRequiredFlag(ID) must be defined in MeetingsAdapter');
    }

    /**
     * Sets the invalidPassword flag to false.
     *
     * @param {string} ID  Id of the meeting
     * @returns {Promise|undefined}
     */
    clearInvalidPasswordFlag(ID) {
      throw new Error('clearInvalidPasswordFlag(ID) must be defined in MeetingsAdapter');
    }
  }

  /**
   * A person that is part of a membership.
   *
   * @typedef {object} Member
   * @property {string}   ID          The member identifier
   * @property {string}   orgID       The organization identifier
   * @property {boolean}  muted       If the member's audio is currently muted
   * @property {boolean}  sharing     If the member is currently sharing their screen
   * @property {boolean}  inMeeting   If the member is currently in meeting
   * @property {boolean}  host        If the member is the host of a meeting
   * @property {boolean}  guest       If the member is guest in meeting
   */

  /**
   * A relationship between a destination and people that belong to such destination.
   *
   * @typedef {object} Membership
   * @property {string}          ID               The membership identifier
   * @property {string}          destinationID    ID of the destination for which to get members
   * @property {string}          destinationType  type of the membership destination
   * @property {Array.<Member>}  members          An array of members information
   */

  /**
   * Enum for types of destinations.
   *
   * @readonly
   * @enum {string}
   */
  const DestinationType = {
    ROOM: 'room',
    MEETING: 'meeting',
  };

  /**
   * This is a base class that defines the interface that maps membership data.
   * Developers that want to extend `MembershipsAdapter` must implement all of its methods,
   * adhering to the exact parameters and structure of the returned objects.
   *
   * @interface
   */
  class MembershipsAdapter extends WebexAdapter {
    /**
     * Returns an observable that emits an array of members.
     * Whenever there is an update to this array, the observable
     * will emit a new updated array of members, if datasource permits.
     *
     * @param {string} destinationID  ID of the destination for which to get members
     * @param {DestinationType} destinationType  type of the membership destination
     * @returns {external:Observable.<Array.<Member>>} Observable stream that emits an array of members
     * @memberof MembershipAdapter
     */
    getMembersFromDestination(destinationID, destinationType) {
      return rxjs.throwError(
        new Error('getMembersFromDestination(destinationID, destinationType) must be defined in MembershipsAdapter'),
      );
    }
  }

  /**
   * A set of people in Webex.
   *
   * @typedef {object} Organization
   * @property {string} ID    The organization identifier
   * @property {string} name  The display name of the organization
   */

  /**
   * This is a base class that defines the interface that maps organization data.
   * Developers that want to extend `OrganizationsAdapter` must implement all of its methods,
   * adhering to the exact parameters and structure of the returned objects.
   *
   * @interface
   */
  class OrganizationsAdapter extends WebexAdapter {
    /**
     * Returns an observable that emits organization data of the given ID.
     *
     * @param {string} ID ID of organization to get
     * @returns {external:Observable.<Organization>} Observable stream that emits organization data
     * @memberof OrganizationsAdapter
     */
    getOrg(ID) {
      return rxjs.throwError(new Error('getOrg(ID) must be defined in OrganizationsAdapter'));
    }
  }

  /**
   * A user in Webex.
   *
   * @typedef {object} Person
   * @property {string}             ID          The person identifier
   * @property {Array.<string>}     emails      An array of emails for the person
   * @property {string}             displayName The name to be displayed for the person
   * @property {string}             firstName   The first name of the person
   * @property {string}             lastName    The last name of the person
   * @property {string}             nickName    The short name for the person
   * @property {string}             avatar      The full url to the person's avatar
   * @property {string}             orgID       The ID of the organization the person belongs to
   * @property {null|PersonStatus}  status      The presence status of the user. @see {@link PersonStatus} enum
   */

  /**
   * All potential statuses of a person.
   *
   * @readonly
   * @enum {string}
   */
  const PersonStatus = {
    ACTIVE: 'active',
    BOT: 'bot',
    CALL: 'call',
    DO_NOT_DISTURB: 'dnd',
    INACTIVE: 'inactive',
    MEETING: 'meeting',
    OUT_OF_OFFICE: 'ooo',
    PRESENTING: 'presenting',
    SELF: 'self',
    TYPING: 'typing',
  };

  /**
   * This is a base class that defines the interface that maps people data.
   * Developers that want to extend `PeopleAdapter` must implement all of its methods,
   * adhering to the exact parameters and structure of the returned objects.
   *
   * @interface
   */
  class PeopleAdapter extends WebexAdapter {
    /**
     * Returns an observable that emits person data of the current user.
     *
     * Current user is be defined by the implementation. For instance,
     * to instantiate the SDK, an access token must be given, "me" in that case
     * is the owner of the access token for that SDK instance.
     *
     * @returns {external:Observable.<Person>} Observable stream that emits person data
     * @memberof PeopleAdapter
     */
    getMe() {
      return rxjs.throwError(new Error('getMe() must be defined in PeopleAdapter'));
    }

    /**
     * Returns an observable that emits person data of the given ID.
     *
     * @param {string} ID ID of person to get
     * @returns {external:Observable.<Person>} Observable stream that emits person data
     * @memberof PeopleAdapter
     */
    getPerson(ID) {
      return rxjs.throwError(new Error('getPerson(ID) must be defined in PeopleAdapter'));
    }
  }

  /* eslint-disable valid-jsdoc */

  /**
   * A virtual room where people can collaborate.
   *
   * @typedef {object}  Room
   * @property {string}    ID     The room identifier
   * @property {string}    title  The room title
   * @property {RoomType}  type   The type of the room. @see {@link RoomType} enum
   */

  /**
   * @typedef {object}  ActivityDate
   * @property {string}  date  Date that will render on a time ruler. Must be a valid date-time string
   * @see [Date-time string format]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse#Date_Time_String_Format}
   */

  /**
   * All potential types of rooms.
   *
   * @readonly
   * @enum {string}
   */
  const RoomType = {
    GROUP: 'group',
    DIRECT: 'direct',
  };

  /**
   * This is a base class that defines the interface that maps room data.
   * Developers that want to extend `RoomsAdapter` must implement all of its methods,
   * adhering to the exact parameters and structure of the returned objects.
   *
   * `RoomsAdapter` handles data of a room such as details about that room but also
   * activities that happened/will happen within that room. Activities are expected
   * to be lazy loaded, and therefore, chunked.
   *
   * @interface
   */
  class RoomsAdapter extends WebexAdapter {
    /**
     * Returns an observable that emits room data of the given ID.
     *
     * @param {string} ID  ID of the room to get.
     * @returns {external:Observable.<Room>} Observable stream that emits room data
     * @memberof RoomsAdapter
     */
    getRoom(ID) {
      return rxjs.throwError(new Error('getRoom(ID) must be defined in RoomsAdapter'));
    }

    /**
     * Returns an observable that emits an array of current and future activities of the given roomID.
     *
     * @param {string} ID  ID of the room for which to get activities.
     * @returns {external:Observable.<Array.<string|ActivityDate>>} Observable stream that emits arrays of activity IDs
     * @memberof RoomsAdapter
     */
    getRoomActivities(ID) {
      return rxjs.throwError(new Error('getRoomActivities(ID) must be defined in RoomsAdapter'));
    }

    /**
     * Returns an observable that emits an array of the next chunk of previous
     * activity data of the given roomID. If `hasMoreActivities` returns false,
     * the observable will complete.
     * **Previous activity data must be sorted newest-to-oldest.**
     *
     * @param {string} ID  ID of the room for which to get activities.
     * @returns {external:Observable.<Array.<string|ActivityDate>>} Observable stream that emits arrays of activity IDs
     * @memberof RoomsAdapter
     */
    getPreviousRoomActivities(ID) {
      return rxjs.throwError(new Error('getPreviousRoomActivities(ID) must be defined in RoomsAdapter'));
    }

    /**
     * Returns `true` if there are more activities to load from the room of the given ID.
     * Otherwise, it returns `false`.
     *
     * @param {string} ID ID of the room for which to verify activities.
     * @returns {boolean} `true` if room has more activities to load, `false` otherwise
     * @memberof RoomsAdapter
     */
    hasMoreActivities(ID) {
      throw new Error('hasMoreActivities(ID) must be defined in RoomsAdapter');
    }
  }

  exports.ActivitiesAdapter = ActivitiesAdapter;
  exports.DestinationType = DestinationType;
  exports.MediaPermissions = MediaPermissions;
  exports.MeetingControlState = MeetingControlState;
  exports.MeetingControlType = MeetingControlType;
  exports.MeetingState = MeetingState;
  exports.MeetingsAdapter = MeetingsAdapter;
  exports.MembershipsAdapter = MembershipsAdapter;
  exports.OrganizationsAdapter = OrganizationsAdapter;
  exports.PeopleAdapter = PeopleAdapter;
  exports.PersonStatus = PersonStatus;
  exports.RoomType = RoomType;
  exports.RoomsAdapter = RoomsAdapter;
  exports.WebexAdapter = WebexAdapter;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=webex-component-adapter-interfaces.umd.js.map
