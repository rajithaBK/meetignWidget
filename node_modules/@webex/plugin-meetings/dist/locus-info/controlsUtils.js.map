{"version":3,"sources":["controlsUtils.js"],"names":["ControlsUtils","parse","controls","parsedControls","record","modifiedBy","getId","paused","recording","lastModified","meta","getControls","oldControls","newControls","previous","current","updates","hasRecordingPausedChanged","hasRecordingChanged"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAMA,aAAa,GAAG,EAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACAA,aAAa,CAACC,KAAd,GAAsB,UAACC,QAAD,EAAc;AAClC,MAAMC,cAAc,qBAAOD,QAAP,CAApB;;AAEA,MAAIA,QAAQ,IAAIA,QAAQ,CAACE,MAAzB,EAAiC;AAC/BD,IAAAA,cAAc,CAACC,MAAf,GAAwB;AACtBC,MAAAA,UAAU,EAAEL,aAAa,CAACM,KAAd,CAAoBJ,QAApB,CADU;AAEtBK,MAAAA,MAAM,EAAEL,QAAQ,CAACE,MAAT,CAAgBG,MAAhB,GAAyBL,QAAQ,CAACE,MAAT,CAAgBG,MAAzC,GAAkD,KAFpC;AAGtBC,MAAAA,SAAS,EAAEN,QAAQ,CAACE,MAAT,CAAgBI,SAHL;AAItBC,MAAAA,YAAY,EAAEP,QAAQ,CAACE,MAAT,CAAgBM,IAAhB,CAAqBD;AAJb,KAAxB;AAMD;;AAED,SAAON,cAAP;AACD,CAbD;AAeA;AACA;AACA;AACA;AACA;AACA;;;AACAH,aAAa,CAACW,WAAd,GAA4B,UAACC,WAAD,EAAcC,WAAd,EAA8B;AAAA;;AACxD,MAAMC,QAAQ,GAAGd,aAAa,CAACC,KAAd,CAAoBW,WAApB,CAAjB;AACA,MAAMG,OAAO,GAAGf,aAAa,CAACC,KAAd,CAAoBY,WAApB,CAAhB;AAEA,SAAO;AACLC,IAAAA,QAAQ,EAARA,QADK;AAELC,IAAAA,OAAO,EAAPA,OAFK;AAGLC,IAAAA,OAAO,EAAE;AACPC,MAAAA,yBAAyB,EAAE,CAAAF,OAAO,SAAP,IAAAA,OAAO,WAAP,YAAAA,OAAO,CAAEX,MAAT,KAC3B,CAAC,uBAAQU,QAAR,aAAQA,QAAR,2CAAQA,QAAQ,CAAEV,MAAlB,qDAAQ,iBAAkBG,MAA1B,EAAkCQ,OAAO,CAACX,MAAR,CAAeG,MAAjD,CAD0B,KAE1B,CAAAO,QAAQ,SAAR,IAAAA,QAAQ,WAAR,iCAAAA,QAAQ,CAAEV,MAAV,wEAAkBI,SAAlB,MAA+BO,OAA/B,aAA+BA,OAA/B,0CAA+BA,OAAO,CAAEX,MAAxC,oDAA+B,gBAAiBI,SAAhD,CAF0B,CADpB;AAGsD;AAE7DU,MAAAA,mBAAmB,EAAE,CAAAH,OAAO,SAAP,IAAAA,OAAO,WAAP,YAAAA,OAAO,CAAEX,MAAT,KACrB,CAAC,uBAAQU,QAAR,aAAQA,QAAR,4CAAQA,QAAQ,CAAEV,MAAlB,sDAAQ,kBAAkBI,SAA1B,EAAqCO,OAArC,aAAqCA,OAArC,2CAAqCA,OAAO,CAAEX,MAA9C,qDAAqC,iBAAiBI,SAAtD,CADoB,KAEpB,CAAAM,QAAQ,SAAR,IAAAA,QAAQ,WAAR,iCAAAA,QAAQ,CAAEV,MAAV,wEAAkBI,SAAlB,MAA+BO,OAA/B,aAA+BA,OAA/B,2CAA+BA,OAAO,CAAEX,MAAxC,qDAA+B,iBAAiBI,SAAhD,CAFoB,CALd,CAOqD;;AAPrD;AAHJ,GAAP;AAaD,CAjBD;AAmBA;AACA;AACA;AACA;AACA;;;AACAR,aAAa,CAACM,KAAd,GAAsB,UAACJ,QAAD,EAAc;AAClC,MAAIA,QAAQ,CAACE,MAAT,CAAgBM,IAApB,EAA0B;AACxB,WAAOR,QAAQ,CAACE,MAAT,CAAgBM,IAAhB,CAAqBL,UAA5B;AACD;;AAED,SAAO,IAAP;AACD,CAND;;eAQeL,a","sourcesContent":["import {isEqual} from 'lodash';\n\nconst ControlsUtils = {};\n\n/**\n * Controls\n * @typedef {Object} LocusControls\n * @property {Object} record\n * @property {Boolean} record.recording\n * @property {Object} record.meta\n * @property {String} record.meta.modifiedBy\n */\n\n/**\n * parse the relevant host values that we care about: id\n * @param {LocusControls} controls\n * @returns {Object} parsedObject - parsed host or null if host was undefined\n * @returns {String} parsedObject.recordingId\n */\nControlsUtils.parse = (controls) => {\n  const parsedControls = {...controls};\n\n  if (controls && controls.record) {\n    parsedControls.record = {\n      modifiedBy: ControlsUtils.getId(controls),\n      paused: controls.record.paused ? controls.record.paused : false,\n      recording: controls.record.recording,\n      lastModified: controls.record.meta.lastModified\n    };\n  }\n\n  return parsedControls;\n};\n\n/**\n * parses and returns previous state vs current state and triggers the changes.\n * @param {LocusControl} oldControls previous state\n * @param {LocusControl} newControls current state\n * @returns {Object} combination of state plus the changes\n */\nControlsUtils.getControls = (oldControls, newControls) => {\n  const previous = ControlsUtils.parse(oldControls);\n  const current = ControlsUtils.parse(newControls);\n\n  return {\n    previous,\n    current,\n    updates: {\n      hasRecordingPausedChanged: current?.record &&\n      !isEqual(previous?.record?.paused, current.record.paused) &&\n      (previous?.record?.recording || current?.record?.recording), // see comments directly below\n\n      hasRecordingChanged: current?.record &&\n      !isEqual(previous?.record?.recording, current?.record?.recording) && // upon first join, previous?.record?.recording = undefined; thus, never going to be equal and will always return true\n      (previous?.record?.recording || current?.record?.recording) // therefore, condition added to prevent false firings of #meeting:recording:stopped upon first joining a meeting\n    }\n  };\n};\n\n/**\n * Extract the id from the record controls object\n * @param {LocusControls} controls\n * @returns {String|null}\n */\nControlsUtils.getId = (controls) => {\n  if (controls.record.meta) {\n    return controls.record.meta.modifiedBy;\n  }\n\n  return null;\n};\n\nexport default ControlsUtils;\n"]}