{"version":3,"sources":["utilv2.js"],"names":["MeetingInfoUtil","getParsedUrl","link","parsedUrl","url","parse","protocol","HTTPS_PROTOCOL","error","LoggerProxy","logger","warn","isMeetingLink","value","hostNameBool","hostname","includes","WEBEX_DOT_COM","pathNameBool","pathname","MEET","MEET_M","JOIN","isConversationUrl","webex","clusterId","internal","services","getClusterId","endsWith","CONVERSATION_SERVICE","isSipUri","sipString","sipUri","DIALER_REGEX","SIP_ADDRESS","exec","isPhoneNumber","phoneNumber","isValidNumber","PHONE_NUMBER","test","getHydraId","destination","type","id","cluster","UUID_REG","_ROOM_","room","_PEOPLE_","people","getSipUriFromHydraPersonId","get","then","res","emails","length","ParameterError","catch","err","getDestinationType","from","_PERSONAL_ROOM_","userId","device","orgId","options","VALID_EMAIL_ADDRESS","email","list","items","hydraId","_MEETING_LINK_","_SIP_URI_","_CONVERSATION_URL_","wasHydraPerson","resolve","waitForCatalog","conversationUrl","conversation","getUrlFromClusterId","getRequestBody","password","captchaInfo","body","supportHostKey","sipUrl","_MEETING_ID_","meetingKey","_LOCUS_ID_","info","webExMeetingId","meetingUrl","_MEETING_UUID_","meetingUUID","captchaID","captchaVerifyCode","code"],"mappings":"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","sourcesContent":["import url from 'url';\n\nimport {\n  deconstructHydraId\n} from '@webex/common';\n\nimport {\n  _SIP_URI_,\n  _PERSONAL_ROOM_,\n  _MEETING_ID_,\n  _CONVERSATION_URL_,\n  _LOCUS_ID_,\n  _MEETING_LINK_,\n  _PEOPLE_,\n  _ROOM_,\n  _MEETING_UUID_,\n  DIALER_REGEX,\n  WEBEX_DOT_COM,\n  CONVERSATION_SERVICE,\n  JOIN,\n  MEET,\n  MEET_M,\n  HTTPS_PROTOCOL,\n  UUID_REG,\n  VALID_EMAIL_ADDRESS\n} from '../constants';\nimport ParameterError from '../common/errors/parameter';\nimport LoggerProxy from '../common/logs/logger-proxy';\n\nconst MeetingInfoUtil = {};\n\nMeetingInfoUtil.getParsedUrl = (link) => {\n  try {\n    let parsedUrl = url.parse(link);\n\n    if (!parsedUrl) {\n      return false;\n    }\n    // hack for links such as <company>.webex.com/meet/<user> without a protocol\n    if (!parsedUrl.protocol) {\n      parsedUrl = url.parse(`${HTTPS_PROTOCOL}${link}`);\n    }\n\n    return parsedUrl;\n  }\n  catch (error) {\n    LoggerProxy.logger.warn(`Meeting-info:util#getParsedUrl --> unable to parse the URL, error: ${error}`);\n\n    return null;\n  }\n};\n\n/**\n * Helper function to check if a string matches a known meeting link pattern\n * @param {String} value  string to parse and see if it matches a meeting link\n * @returns {Boolean}\n */\nMeetingInfoUtil.isMeetingLink = (value) => {\n  const parsedUrl = MeetingInfoUtil.getParsedUrl(value);\n  const hostNameBool = parsedUrl.hostname && parsedUrl.hostname.includes(WEBEX_DOT_COM);\n  const pathNameBool = parsedUrl.pathname && (parsedUrl.pathname.includes(`/${MEET}`) || parsedUrl.pathname.includes(`/${MEET_M}`) || parsedUrl.pathname.includes(`/${JOIN}`));\n\n  return hostNameBool && pathNameBool;\n};\n\nMeetingInfoUtil.isConversationUrl = (value, webex) => {\n  const clusterId = webex.internal.services.getClusterId(value);\n\n  if (clusterId) {\n    return clusterId.endsWith(CONVERSATION_SERVICE);\n  }\n\n  return false;\n};\n\n\nMeetingInfoUtil.isSipUri = (sipString) => {\n  // TODO: lets remove regex from this equation and user URI matchers and such\n  // have not found a great sip uri parser library as of now\n  const sipUri = DIALER_REGEX.SIP_ADDRESS.exec(sipString);\n\n  return sipUri;\n};\n\nMeetingInfoUtil.isPhoneNumber = (phoneNumber) => {\n  const isValidNumber = DIALER_REGEX.PHONE_NUMBER.test(phoneNumber);\n\n  return isValidNumber;\n};\n\nMeetingInfoUtil.getHydraId = (destination) => {\n  const {type, id, cluster} = deconstructHydraId(destination);\n\n  if (id && UUID_REG.test(id)) {\n    if (type === _ROOM_) {\n      return {room: true, destination: id, cluster};\n    }\n    if (type === _PEOPLE_) {\n      return {people: true, destination: id, cluster};\n    }\n\n    return {};\n  }\n\n  return {};\n};\n\nMeetingInfoUtil.getSipUriFromHydraPersonId = (destination, webex) => webex.people.get(destination).then((res) => {\n  if (res.emails && res.emails.length) {\n    return res.emails[0];\n  }\n  throw new ParameterError('Hydra Id Lookup was an invalid hydra person id.');\n}).catch((err) => {\n  LoggerProxy.logger.error(`Meeting-info:util#MeetingInfoUtil.getSipUriFromHydraPersonId --> getSipUriFromHydraPersonId ${err} `);\n  throw err;\n});\n\n\nMeetingInfoUtil.getDestinationType = async (from) => {\n  const {type, webex} = from;\n  let {destination} = from;\n\n  if (type === _PERSONAL_ROOM_) { // this case checks if your type is personal room\n    if (!destination) { // if we are not getting anything in desination we fetch org and user ids from webex instance\n      destination = {\n        userId: webex.internal.device.userId,\n        orgId: webex.internal.device.orgId\n      };\n    }\n    else {\n      const options = VALID_EMAIL_ADDRESS.test(destination) ? {email: destination} : {id: destination};// we are assuming userId as default\n      const res = await webex.people.list(options);\n\n      let {orgId, id: userId} = res.items[0];\n\n      userId = deconstructHydraId(userId).id;\n      orgId = deconstructHydraId(orgId).id;\n      destination = {userId, orgId};\n    }\n  }\n  if (type) {\n    return {\n      destination,\n      type\n    };\n  }\n  const options = {};\n  const hydraId = MeetingInfoUtil.getHydraId(destination);\n\n  if (MeetingInfoUtil.isMeetingLink(destination)) {\n    LoggerProxy.logger.warn('Meeting-info:util#generateOptions --> WARN, use of Meeting Link is deprecated, please use a SIP URI instead');\n\n    options.type = _MEETING_LINK_;\n    options.destination = destination;\n  }\n  else if (MeetingInfoUtil.isSipUri(destination)) {\n    options.type = _SIP_URI_;\n    options.destination = destination;\n  }\n  else if (MeetingInfoUtil.isPhoneNumber(destination)) {\n    options.type = _SIP_URI_;\n    options.destination = destination;\n  }\n  else if (MeetingInfoUtil.isConversationUrl(destination, webex)) {\n    options.type = _CONVERSATION_URL_;\n    options.destination = destination;\n  }\n  else if (hydraId.people) {\n    options.type = _SIP_URI_;\n\n    return MeetingInfoUtil.getSipUriFromHydraPersonId(hydraId.destination, webex).then((res) => {\n      options.destination = res;\n\n      // Since hydra person ids require a unique case in which they are\n      // entirely converted to a SIP URI, we need to set a flag for detecting\n      // this type of destination.\n      options.wasHydraPerson = true;\n\n      return Promise.resolve(options);\n    });\n  }\n  else if (hydraId.room) {\n    options.type = _CONVERSATION_URL_;\n    try {\n      await webex.internal.services.waitForCatalog('postauth');\n\n      const conversationUrl = webex.internal.conversation.getUrlFromClusterId({\n        cluster: hydraId.cluster,\n        id: hydraId.destination\n      });\n\n      options.destination = conversationUrl;\n    }\n    catch (e) {\n      LoggerProxy.logger.error(`Meeting-info:util#getDestinationType --> ${e}`);\n      throw (e);\n    }\n  }\n  else {\n    LoggerProxy.logger.warn('Meeting-info:util#getDestinationType --> (\\'MeetingInfo is fetched with meeting link, sip uri, phone number, hydra room id, hydra people id, or a conversation url.');\n    throw new ParameterError('MeetingInfo is fetched with meeting link, sip uri, phone number, hydra room id, hydra people id, or a conversation url.');\n  }\n\n  return Promise.resolve(options);\n};\n\n/**\n * Helper function to build up a correct locus url depending on the value passed\n * @param {Object} options type and value to fetch meeting info\n * @param {String} options.type One of [SIP_URI, PERSONAL_ROOM, MEETING_ID, CONVERSATION_URL, LOCUS_ID, MEETING_LINK]\n * @param {Object} options.destination ?? value.value\n * @returns {Object} returns an object with {resource, method}\n */\nMeetingInfoUtil.getRequestBody = (options) => {\n  const {\n    type, destination, password, captchaInfo\n  } = options;\n  const body = {\n    supportHostKey: true\n  };\n\n  switch (type) {\n    case _SIP_URI_:\n      body.sipUrl = destination;\n      break;\n    case _PERSONAL_ROOM_:\n      body.userId = destination.userId;\n      body.orgId = destination.orgId;\n      break;\n    case _MEETING_ID_:\n      body.meetingKey = destination;\n      break;\n    case _CONVERSATION_URL_:\n      body.conversationUrl = destination;\n      break;\n    case _LOCUS_ID_:\n      // use meetingID for the completer meeting info for the already started meeting\n      if (destination.info?.webExMeetingId) {\n        body.meetingKey = destination.info.webExMeetingId;\n      }\n      else if (destination.info?.sipUri) {\n        body.sipUrl = destination.info.sipUri;\n      }\n      break;\n    case _MEETING_LINK_:\n      body.meetingUrl = destination;\n      break;\n    case _MEETING_UUID_: {\n      body.meetingUUID = destination;\n      break;\n    }\n    default:\n  }\n\n  if (password) {\n    body.password = password;\n  }\n\n  if (captchaInfo) {\n    body.captchaID = captchaInfo.id;\n    body.captchaVerifyCode = captchaInfo.code;\n  }\n\n  return body;\n};\n\nexport default MeetingInfoUtil;\n"]}