{"version":3,"sources":["index.js"],"names":["Transcription","webSocketUrl","sessionId","members","sessionID","memberCSIs","params","webSocket","WebSocket","token","onopen","send","id","type","data","trackingId","toString","callback","onclose","event","onerror","csis","csi","member","membersCollection","find","participant","status","selfIsSpeaking","includes","speaker","transcription","onmessage","JSON","parse","voiceaPayload","getSpeaker","messageID","transcript_id","personID","timestamp","close"],"mappings":"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","sourcesContent":["import {v4 as uuidv4} from 'uuid';\n\n/**\n * @description Meeting Webex assistance transcription feature.\n * @exports\n * @class Transcription\n */\nexport default class Transcription {\n  /**\n   * @param {string} webSocketUrl\n   * @param {sessionID} sessionId\n   * @param {object} members\n   * @constructor\n   * @memberof Transcription\n   */\n  constructor(webSocketUrl, sessionId, members) {\n    this.webSocketUrl = webSocketUrl;\n    this.sessionID = sessionId;\n    this.members = members;\n    this.memberCSIs = {};\n\n    const params = '?outboundWireFormat=text&bufferStates=true&aliasHttpStatus=true';\n\n    this.webSocket = new WebSocket(`${this.webSocketUrl}${params}`);\n  }\n\n  /**\n   * open the Low Latency Mercury connection\n   * An event parameter will be send to the callback.\n   *\n   * @param {string} token\n   * @param {string} sessionID\n   * @returns {void}\n   */\n  connect(token) {\n    this.webSocket.onopen = () => {\n      this.webSocket.send(JSON.stringify({\n        id: uuidv4(),\n        type: 'authorization',\n        data: {token: `Bearer ${token}`},\n        trackingId: `webex-js-sdk_${this.sessionID}${Date.now.toString()}`\n      }));\n    };\n  }\n\n  /**\n   * Sets callback to invoke when the web socket connection is closed.\n   *\n   * @param {function} callback\n   * @returns {void}\n   */\n  onCloseSocket(callback) {\n    if (callback) {\n      this.webSocket.onclose = (event) => {\n        callback(event);\n      };\n    }\n  }\n\n  /**\n   * Sets callback to invoke when a web socket connection error occurs.\n   * An event parameter will be send to the callback.\n   *\n   * @param {function} callback\n   * @returns {void}\n   */\n  onErrorSocket(callback) {\n    if (callback) {\n      this.webSocket.onerror = (event) => {\n        callback(event);\n      };\n    }\n  }\n\n  /**\n   * Get current speaker from the given csis payload and update the global csis map\n   *\n   * @private\n   * @param {object} csis\n   * @returns {object}\n   */\n  getSpeaker(csis) {\n    for (const csi of csis) {\n      const member = this.memberCSIs[csi];\n\n      if (member) {\n        return member;\n      }\n    }\n\n    return Object.values(this.members.membersCollection.members)\n      .find((member) => {\n        const memberCSIs = member.participant.status.csis;\n        let selfIsSpeaking = false;\n\n        for (const csi of csis) {\n          if (memberCSIs.includes(csi)) {\n            this.memberCSIs[csi] = member;\n            selfIsSpeaking = true;\n            break;\n          }\n        }\n\n        return selfIsSpeaking;\n      });\n  }\n\n  /**\n   * Sends transcription data to given callback as it arrives.\n   *\n   * @param {function} callback\n   * @returns {void}\n   */\n  subscribe(callback) {\n    let data, csis, speaker, transcription;\n\n    this.webSocket.onmessage = (event) => {\n      data = JSON.parse(event.data);\n      csis = data.data?.voiceaPayload?.csis || [];\n      speaker = this.getSpeaker(csis);\n      transcription = data.data?.voiceaPayload?.data || '';\n\n      this.webSocket.send(JSON.stringify({messageID: data.id, type: 'ack'}));\n\n      if (transcription) {\n        callback(\n          {\n            id: data.data?.voiceaPayload?.transcript_id,\n            personID: speaker?.id,\n            transcription,\n            timestamp: data.timestamp,\n            type: data?.data?.voiceaPayload?.type\n          }\n        );\n      }\n    };\n  }\n\n  /**\n   * Close the LLM web socket connection\n   * @returns {void}\n   */\n  closeSocket() {\n    this.webSocket.close();\n  }\n}\n\n"]}